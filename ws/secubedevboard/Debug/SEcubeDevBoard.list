
SEcubeDevBoard.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001b64c  080001b0  080001b0  000101b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002a4c  0801b800  0801b800  0002b800  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0801e24c  0801e24c  0002e24c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0801e250  0801e250  0002e250  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000464  20000000  0801e254  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00030464  2**0
                  CONTENTS
  7 .bss          0000d5f8  20000468  20000468  00030468  2**3
                  ALLOC
  8 ._user_heap_stack 00000600  2000da60  2000da60  00030468  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00030464  2**0
                  CONTENTS, READONLY
 10 .debug_line   00038117  00000000  00000000  00030494  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   000568fb  00000000  00000000  000685ab  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000addb  00000000  00000000  000beea6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00002920  00000000  00000000  000c9c88  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a6da0  00000000  00000000  000cc5a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002430  00000000  00000000  00173348  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00025dc6  00000000  00000000  00175778  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007b  00000000  00000000  0019b53e  2**0
                  CONTENTS, READONLY
 18 .debug_frame  0000a7a8  00000000  00000000  0019b5bc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001b0 <__do_global_dtors_aux>:
 80001b0:	b510      	push	{r4, lr}
 80001b2:	4c05      	ldr	r4, [pc, #20]	; (80001c8 <__do_global_dtors_aux+0x18>)
 80001b4:	7823      	ldrb	r3, [r4, #0]
 80001b6:	b933      	cbnz	r3, 80001c6 <__do_global_dtors_aux+0x16>
 80001b8:	4b04      	ldr	r3, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x1c>)
 80001ba:	b113      	cbz	r3, 80001c2 <__do_global_dtors_aux+0x12>
 80001bc:	4804      	ldr	r0, [pc, #16]	; (80001d0 <__do_global_dtors_aux+0x20>)
 80001be:	f3af 8000 	nop.w
 80001c2:	2301      	movs	r3, #1
 80001c4:	7023      	strb	r3, [r4, #0]
 80001c6:	bd10      	pop	{r4, pc}
 80001c8:	20000468 	.word	0x20000468
 80001cc:	00000000 	.word	0x00000000
 80001d0:	0801b7e4 	.word	0x0801b7e4

080001d4 <frame_dummy>:
 80001d4:	b508      	push	{r3, lr}
 80001d6:	4b03      	ldr	r3, [pc, #12]	; (80001e4 <frame_dummy+0x10>)
 80001d8:	b11b      	cbz	r3, 80001e2 <frame_dummy+0xe>
 80001da:	4903      	ldr	r1, [pc, #12]	; (80001e8 <frame_dummy+0x14>)
 80001dc:	4803      	ldr	r0, [pc, #12]	; (80001ec <frame_dummy+0x18>)
 80001de:	f3af 8000 	nop.w
 80001e2:	bd08      	pop	{r3, pc}
 80001e4:	00000000 	.word	0x00000000
 80001e8:	2000046c 	.word	0x2000046c
 80001ec:	0801b7e4 	.word	0x0801b7e4

080001f0 <strlen>:
 80001f0:	4603      	mov	r3, r0
 80001f2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001f6:	2a00      	cmp	r2, #0
 80001f8:	d1fb      	bne.n	80001f2 <strlen+0x2>
 80001fa:	1a18      	subs	r0, r3, r0
 80001fc:	3801      	subs	r0, #1
 80001fe:	4770      	bx	lr

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 80002a0:	f8df d034 	ldr.w	sp, [pc, #52]	; 80002d8 <LoopFillZerobss+0x14>
 
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80002a4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80002a6:	e003      	b.n	80002b0 <LoopCopyDataInit>

080002a8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80002a8:	4b0c      	ldr	r3, [pc, #48]	; (80002dc <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80002aa:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80002ac:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80002ae:	3104      	adds	r1, #4

080002b0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80002b0:	480b      	ldr	r0, [pc, #44]	; (80002e0 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80002b2:	4b0c      	ldr	r3, [pc, #48]	; (80002e4 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80002b4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80002b6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80002b8:	d3f6      	bcc.n	80002a8 <CopyDataInit>
  ldr  r2, =_sbss
 80002ba:	4a0b      	ldr	r2, [pc, #44]	; (80002e8 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80002bc:	e002      	b.n	80002c4 <LoopFillZerobss>

080002be <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80002be:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80002c0:	f842 3b04 	str.w	r3, [r2], #4

080002c4 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80002c4:	4b09      	ldr	r3, [pc, #36]	; (80002ec <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80002c6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80002c8:	d3f9      	bcc.n	80002be <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80002ca:	f011 f8ab 	bl	8011424 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80002ce:	f01a fe27 	bl	801af20 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80002d2:	f00f ffc7 	bl	8010264 <main>
  bx  lr    
 80002d6:	4770      	bx	lr
  ldr   sp, =_estack       /* set stack pointer */
 80002d8:	20030000 	.word	0x20030000
  ldr  r3, =_sidata
 80002dc:	0801e254 	.word	0x0801e254
  ldr  r0, =_sdata
 80002e0:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80002e4:	20000464 	.word	0x20000464
  ldr  r2, =_sbss
 80002e8:	20000468 	.word	0x20000468
  ldr  r3, = _ebss
 80002ec:	2000da60 	.word	0x2000da60

080002f0 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80002f0:	e7fe      	b.n	80002f0 <ADC_IRQHandler>

080002f2 <B5_AES256_GETUINT32>:
 * @brief Convert a 4 bytes array into a 32 bit word.
 * @param pt Byte array to be converted.
 * @return 32-bit word extracted from input array.
 */
uint32_t B5_AES256_GETUINT32 (const uint8_t *pt)
{
 80002f2:	b480      	push	{r7}
 80002f4:	b085      	sub	sp, #20
 80002f6:	af00      	add	r7, sp, #0
 80002f8:	6078      	str	r0, [r7, #4]
    uint16_t ph,pl;
    uint32_t p;

    ph = ((uint16_t) pt[0]) << 8;
 80002fa:	687b      	ldr	r3, [r7, #4]
 80002fc:	781b      	ldrb	r3, [r3, #0]
 80002fe:	b29b      	uxth	r3, r3
 8000300:	021b      	lsls	r3, r3, #8
 8000302:	81fb      	strh	r3, [r7, #14]
    ph ^= ((uint16_t) pt[1]) & 0x00ff;
 8000304:	687b      	ldr	r3, [r7, #4]
 8000306:	3301      	adds	r3, #1
 8000308:	781b      	ldrb	r3, [r3, #0]
 800030a:	b29a      	uxth	r2, r3
 800030c:	89fb      	ldrh	r3, [r7, #14]
 800030e:	4053      	eors	r3, r2
 8000310:	81fb      	strh	r3, [r7, #14]
    pl = ((uint16_t) pt[2]) << 8;
 8000312:	687b      	ldr	r3, [r7, #4]
 8000314:	3302      	adds	r3, #2
 8000316:	781b      	ldrb	r3, [r3, #0]
 8000318:	b29b      	uxth	r3, r3
 800031a:	021b      	lsls	r3, r3, #8
 800031c:	81bb      	strh	r3, [r7, #12]
    pl ^= ((uint16_t) pt[3]) & 0x00ff;
 800031e:	687b      	ldr	r3, [r7, #4]
 8000320:	3303      	adds	r3, #3
 8000322:	781b      	ldrb	r3, [r3, #0]
 8000324:	b29a      	uxth	r2, r3
 8000326:	89bb      	ldrh	r3, [r7, #12]
 8000328:	4053      	eors	r3, r2
 800032a:	81bb      	strh	r3, [r7, #12]
    p = (((uint32_t) ph) << 16) ^ pl;
 800032c:	89fb      	ldrh	r3, [r7, #14]
 800032e:	041a      	lsls	r2, r3, #16
 8000330:	89bb      	ldrh	r3, [r7, #12]
 8000332:	4053      	eors	r3, r2
 8000334:	60bb      	str	r3, [r7, #8]
    return p;
 8000336:	68bb      	ldr	r3, [r7, #8]
}
 8000338:	4618      	mov	r0, r3
 800033a:	3714      	adds	r7, #20
 800033c:	46bd      	mov	sp, r7
 800033e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000342:	4770      	bx	lr

08000344 <B5_AES256_PUTUINT32>:
 * @brief Convert a 32 bit word into a 4 bytes array.
 * @param ct Pointer to converted array.
 * @param st 32-bit word to be converted.
 */
void B5_AES256_PUTUINT32 (uint8_t *ct, const uint32_t st)
{
 8000344:	b480      	push	{r7}
 8000346:	b083      	sub	sp, #12
 8000348:	af00      	add	r7, sp, #0
 800034a:	6078      	str	r0, [r7, #4]
 800034c:	6039      	str	r1, [r7, #0]
    ct[0] = (uint8_t)((st) >> 24);
 800034e:	683b      	ldr	r3, [r7, #0]
 8000350:	0e1b      	lsrs	r3, r3, #24
 8000352:	b2da      	uxtb	r2, r3
 8000354:	687b      	ldr	r3, [r7, #4]
 8000356:	701a      	strb	r2, [r3, #0]
    ct[1] = (uint8_t)((st) >> 16);
 8000358:	683b      	ldr	r3, [r7, #0]
 800035a:	0c1a      	lsrs	r2, r3, #16
 800035c:	687b      	ldr	r3, [r7, #4]
 800035e:	3301      	adds	r3, #1
 8000360:	b2d2      	uxtb	r2, r2
 8000362:	701a      	strb	r2, [r3, #0]
    ct[2] = (uint8_t)((st) >>  8);
 8000364:	683b      	ldr	r3, [r7, #0]
 8000366:	0a1a      	lsrs	r2, r3, #8
 8000368:	687b      	ldr	r3, [r7, #4]
 800036a:	3302      	adds	r3, #2
 800036c:	b2d2      	uxtb	r2, r2
 800036e:	701a      	strb	r2, [r3, #0]
    ct[3] = (uint8_t)(st);
 8000370:	687b      	ldr	r3, [r7, #4]
 8000372:	3303      	adds	r3, #3
 8000374:	683a      	ldr	r2, [r7, #0]
 8000376:	b2d2      	uxtb	r2, r2
 8000378:	701a      	strb	r2, [r3, #0]
}
 800037a:	bf00      	nop
 800037c:	370c      	adds	r7, #12
 800037e:	46bd      	mov	sp, r7
 8000380:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000384:	4770      	bx	lr

08000386 <B5_AES256_PUTUINT64>:
/**
 * @brief Convert a 64 bit word into a 4 bytes array.
 * @param ct Pointer to converted array.
 * @param st 64-bit word to be converted.
 */
void B5_AES256_PUTUINT64(uint8_t *a, uint64_t val){
 8000386:	b490      	push	{r4, r7}
 8000388:	b084      	sub	sp, #16
 800038a:	af00      	add	r7, sp, #0
 800038c:	60f8      	str	r0, [r7, #12]
 800038e:	e9c7 2300 	strd	r2, r3, [r7]
	a[0] = val >> 56;
 8000392:	e9d7 1200 	ldrd	r1, r2, [r7]
 8000396:	f04f 0300 	mov.w	r3, #0
 800039a:	f04f 0400 	mov.w	r4, #0
 800039e:	0e13      	lsrs	r3, r2, #24
 80003a0:	2400      	movs	r4, #0
 80003a2:	b2da      	uxtb	r2, r3
 80003a4:	68fb      	ldr	r3, [r7, #12]
 80003a6:	701a      	strb	r2, [r3, #0]
	a[1] = val >> 48;
 80003a8:	e9d7 1200 	ldrd	r1, r2, [r7]
 80003ac:	f04f 0300 	mov.w	r3, #0
 80003b0:	f04f 0400 	mov.w	r4, #0
 80003b4:	0c13      	lsrs	r3, r2, #16
 80003b6:	2400      	movs	r4, #0
 80003b8:	68fa      	ldr	r2, [r7, #12]
 80003ba:	3201      	adds	r2, #1
 80003bc:	b2db      	uxtb	r3, r3
 80003be:	7013      	strb	r3, [r2, #0]
	a[2] = val >> 40;
 80003c0:	e9d7 1200 	ldrd	r1, r2, [r7]
 80003c4:	f04f 0300 	mov.w	r3, #0
 80003c8:	f04f 0400 	mov.w	r4, #0
 80003cc:	0a13      	lsrs	r3, r2, #8
 80003ce:	2400      	movs	r4, #0
 80003d0:	68fa      	ldr	r2, [r7, #12]
 80003d2:	3202      	adds	r2, #2
 80003d4:	b2db      	uxtb	r3, r3
 80003d6:	7013      	strb	r3, [r2, #0]
	a[3] = val >> 32;
 80003d8:	e9d7 1200 	ldrd	r1, r2, [r7]
 80003dc:	f04f 0300 	mov.w	r3, #0
 80003e0:	f04f 0400 	mov.w	r4, #0
 80003e4:	0013      	movs	r3, r2
 80003e6:	2400      	movs	r4, #0
 80003e8:	68fa      	ldr	r2, [r7, #12]
 80003ea:	3203      	adds	r2, #3
 80003ec:	b2db      	uxtb	r3, r3
 80003ee:	7013      	strb	r3, [r2, #0]
	a[4] = val >> 24;
 80003f0:	e9d7 1200 	ldrd	r1, r2, [r7]
 80003f4:	f04f 0300 	mov.w	r3, #0
 80003f8:	f04f 0400 	mov.w	r4, #0
 80003fc:	0e0b      	lsrs	r3, r1, #24
 80003fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000402:	0e14      	lsrs	r4, r2, #24
 8000404:	68fa      	ldr	r2, [r7, #12]
 8000406:	3204      	adds	r2, #4
 8000408:	b2db      	uxtb	r3, r3
 800040a:	7013      	strb	r3, [r2, #0]
	a[5] = val >> 16;
 800040c:	e9d7 1200 	ldrd	r1, r2, [r7]
 8000410:	f04f 0300 	mov.w	r3, #0
 8000414:	f04f 0400 	mov.w	r4, #0
 8000418:	0c0b      	lsrs	r3, r1, #16
 800041a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800041e:	0c14      	lsrs	r4, r2, #16
 8000420:	68fa      	ldr	r2, [r7, #12]
 8000422:	3205      	adds	r2, #5
 8000424:	b2db      	uxtb	r3, r3
 8000426:	7013      	strb	r3, [r2, #0]
	a[6] = val >> 8;
 8000428:	e9d7 1200 	ldrd	r1, r2, [r7]
 800042c:	f04f 0300 	mov.w	r3, #0
 8000430:	f04f 0400 	mov.w	r4, #0
 8000434:	0a0b      	lsrs	r3, r1, #8
 8000436:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800043a:	0a14      	lsrs	r4, r2, #8
 800043c:	68fa      	ldr	r2, [r7, #12]
 800043e:	3206      	adds	r2, #6
 8000440:	b2db      	uxtb	r3, r3
 8000442:	7013      	strb	r3, [r2, #0]
	a[7] = val & 0xff;
 8000444:	68fb      	ldr	r3, [r7, #12]
 8000446:	3307      	adds	r3, #7
 8000448:	783a      	ldrb	r2, [r7, #0]
 800044a:	701a      	strb	r2, [r3, #0]
}
 800044c:	bf00      	nop
 800044e:	3710      	adds	r7, #16
 8000450:	46bd      	mov	sp, r7
 8000452:	bc90      	pop	{r4, r7}
 8000454:	4770      	bx	lr
	...

08000458 <B5_rijndaelKeySetupEnc>:
 * @param cipherKey Key to be expanded.
 * @param keyBits Key length. Key length. See \ref aesKeys for supported sizes.
 * @return Number of rounds for the given cipher key size (10, 12, 14).
 */
static uint8_t B5_rijndaelKeySetupEnc (B5_tAesCtx *ctx, uint32_t *rk, const uint8_t *cipherKey, int16_t keyBits) 
{
 8000458:	b590      	push	{r4, r7, lr}
 800045a:	b08d      	sub	sp, #52	; 0x34
 800045c:	af00      	add	r7, sp, #0
 800045e:	60f8      	str	r0, [r7, #12]
 8000460:	60b9      	str	r1, [r7, #8]
 8000462:	607a      	str	r2, [r7, #4]
 8000464:	807b      	strh	r3, [r7, #2]
    int16_t i;
    uint32_t temp;
    uint32_t ut0, ut1, ut2, ut3, ut4;
    
    i = 0;
 8000466:	2300      	movs	r3, #0
 8000468:	85fb      	strh	r3, [r7, #46]	; 0x2e
    rk[0] = B5_AES256_GETUINT32(cipherKey     );
 800046a:	6878      	ldr	r0, [r7, #4]
 800046c:	f7ff ff41 	bl	80002f2 <B5_AES256_GETUINT32>
 8000470:	4602      	mov	r2, r0
 8000472:	68bb      	ldr	r3, [r7, #8]
 8000474:	601a      	str	r2, [r3, #0]
    rk[1] = B5_AES256_GETUINT32(cipherKey +  4);
 8000476:	687b      	ldr	r3, [r7, #4]
 8000478:	1d1a      	adds	r2, r3, #4
 800047a:	68bb      	ldr	r3, [r7, #8]
 800047c:	1d1c      	adds	r4, r3, #4
 800047e:	4610      	mov	r0, r2
 8000480:	f7ff ff37 	bl	80002f2 <B5_AES256_GETUINT32>
 8000484:	4603      	mov	r3, r0
 8000486:	6023      	str	r3, [r4, #0]
    rk[2] = B5_AES256_GETUINT32(cipherKey +  8);
 8000488:	687b      	ldr	r3, [r7, #4]
 800048a:	f103 0208 	add.w	r2, r3, #8
 800048e:	68bb      	ldr	r3, [r7, #8]
 8000490:	f103 0408 	add.w	r4, r3, #8
 8000494:	4610      	mov	r0, r2
 8000496:	f7ff ff2c 	bl	80002f2 <B5_AES256_GETUINT32>
 800049a:	4603      	mov	r3, r0
 800049c:	6023      	str	r3, [r4, #0]
    rk[3] = B5_AES256_GETUINT32(cipherKey + 12);
 800049e:	687b      	ldr	r3, [r7, #4]
 80004a0:	f103 020c 	add.w	r2, r3, #12
 80004a4:	68bb      	ldr	r3, [r7, #8]
 80004a6:	f103 040c 	add.w	r4, r3, #12
 80004aa:	4610      	mov	r0, r2
 80004ac:	f7ff ff21 	bl	80002f2 <B5_AES256_GETUINT32>
 80004b0:	4603      	mov	r3, r0
 80004b2:	6023      	str	r3, [r4, #0]
    
    if (keyBits == 128) 
 80004b4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80004b8:	2b80      	cmp	r3, #128	; 0x80
 80004ba:	d172      	bne.n	80005a2 <B5_rijndaelKeySetupEnc+0x14a>
    {
        for (;;) 
        {
            temp  = rk[3];
 80004bc:	68bb      	ldr	r3, [r7, #8]
 80004be:	68db      	ldr	r3, [r3, #12]
 80004c0:	62bb      	str	r3, [r7, #40]	; 0x28
            memcpy(&ut0, &ctx->Te4[(temp >> 16) & 0xff], sizeof(uint32_t));
 80004c2:	68fb      	ldr	r3, [r7, #12]
 80004c4:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80004c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80004ca:	0c1b      	lsrs	r3, r3, #16
 80004cc:	b2db      	uxtb	r3, r3
 80004ce:	009b      	lsls	r3, r3, #2
 80004d0:	4413      	add	r3, r2
 80004d2:	681b      	ldr	r3, [r3, #0]
 80004d4:	627b      	str	r3, [r7, #36]	; 0x24
            memcpy(&ut1, &ctx->Te4[(temp >>  8) & 0xff], sizeof(uint32_t));
 80004d6:	68fb      	ldr	r3, [r7, #12]
 80004d8:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80004dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80004de:	0a1b      	lsrs	r3, r3, #8
 80004e0:	b2db      	uxtb	r3, r3
 80004e2:	009b      	lsls	r3, r3, #2
 80004e4:	4413      	add	r3, r2
 80004e6:	681b      	ldr	r3, [r3, #0]
 80004e8:	623b      	str	r3, [r7, #32]
            memcpy(&ut2, &ctx->Te4[(temp      ) & 0xff], sizeof(uint32_t));
 80004ea:	68fb      	ldr	r3, [r7, #12]
 80004ec:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80004f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80004f2:	b2db      	uxtb	r3, r3
 80004f4:	009b      	lsls	r3, r3, #2
 80004f6:	4413      	add	r3, r2
 80004f8:	681b      	ldr	r3, [r3, #0]
 80004fa:	61fb      	str	r3, [r7, #28]
            memcpy(&ut3, &ctx->Te4[(temp >> 24)       ], sizeof(uint32_t));
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000502:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000504:	0e1b      	lsrs	r3, r3, #24
 8000506:	009b      	lsls	r3, r3, #2
 8000508:	4413      	add	r3, r2
 800050a:	681b      	ldr	r3, [r3, #0]
 800050c:	61bb      	str	r3, [r7, #24]
            memcpy(&ut4, &B5_rcon[i], sizeof(uint32_t));
 800050e:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8000512:	009b      	lsls	r3, r3, #2
 8000514:	4a74      	ldr	r2, [pc, #464]	; (80006e8 <B5_rijndaelKeySetupEnc+0x290>)
 8000516:	4413      	add	r3, r2
 8000518:	681b      	ldr	r3, [r3, #0]
 800051a:	617b      	str	r3, [r7, #20]
            
            rk[4] = rk[0] ^
 800051c:	68bb      	ldr	r3, [r7, #8]
 800051e:	681a      	ldr	r2, [r3, #0]
                    (ut0 & 0xff000000) ^
 8000520:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000522:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
            rk[4] = rk[0] ^
 8000526:	405a      	eors	r2, r3
                    (ut1 & 0x00ff0000) ^
 8000528:	6a3b      	ldr	r3, [r7, #32]
 800052a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                    (ut0 & 0xff000000) ^
 800052e:	405a      	eors	r2, r3
                    (ut2 & 0x0000ff00) ^
 8000530:	69fb      	ldr	r3, [r7, #28]
 8000532:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
                    (ut1 & 0x00ff0000) ^
 8000536:	405a      	eors	r2, r3
                    (ut3 & 0x000000ff) ^
 8000538:	69bb      	ldr	r3, [r7, #24]
 800053a:	b2db      	uxtb	r3, r3
                    (ut2 & 0x0000ff00) ^
 800053c:	ea82 0103 	eor.w	r1, r2, r3
                    (ut3 & 0x000000ff) ^
 8000540:	697a      	ldr	r2, [r7, #20]
            rk[4] = rk[0] ^
 8000542:	68bb      	ldr	r3, [r7, #8]
 8000544:	3310      	adds	r3, #16
                    (ut3 & 0x000000ff) ^
 8000546:	404a      	eors	r2, r1
            rk[4] = rk[0] ^
 8000548:	601a      	str	r2, [r3, #0]
                    ut4;
            
            rk[5] = rk[1] ^ rk[4];
 800054a:	68bb      	ldr	r3, [r7, #8]
 800054c:	3304      	adds	r3, #4
 800054e:	6819      	ldr	r1, [r3, #0]
 8000550:	68bb      	ldr	r3, [r7, #8]
 8000552:	3310      	adds	r3, #16
 8000554:	681a      	ldr	r2, [r3, #0]
 8000556:	68bb      	ldr	r3, [r7, #8]
 8000558:	3314      	adds	r3, #20
 800055a:	404a      	eors	r2, r1
 800055c:	601a      	str	r2, [r3, #0]
            rk[6] = rk[2] ^ rk[5];
 800055e:	68bb      	ldr	r3, [r7, #8]
 8000560:	3308      	adds	r3, #8
 8000562:	6819      	ldr	r1, [r3, #0]
 8000564:	68bb      	ldr	r3, [r7, #8]
 8000566:	3314      	adds	r3, #20
 8000568:	681a      	ldr	r2, [r3, #0]
 800056a:	68bb      	ldr	r3, [r7, #8]
 800056c:	3318      	adds	r3, #24
 800056e:	404a      	eors	r2, r1
 8000570:	601a      	str	r2, [r3, #0]
            rk[7] = rk[3] ^ rk[6];
 8000572:	68bb      	ldr	r3, [r7, #8]
 8000574:	330c      	adds	r3, #12
 8000576:	6819      	ldr	r1, [r3, #0]
 8000578:	68bb      	ldr	r3, [r7, #8]
 800057a:	3318      	adds	r3, #24
 800057c:	681a      	ldr	r2, [r3, #0]
 800057e:	68bb      	ldr	r3, [r7, #8]
 8000580:	331c      	adds	r3, #28
 8000582:	404a      	eors	r2, r1
 8000584:	601a      	str	r2, [r3, #0]
            
            if (++i == 10) return 10;
 8000586:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8000588:	3301      	adds	r3, #1
 800058a:	b29b      	uxth	r3, r3
 800058c:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800058e:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8000592:	2b0a      	cmp	r3, #10
 8000594:	d101      	bne.n	800059a <B5_rijndaelKeySetupEnc+0x142>
 8000596:	230a      	movs	r3, #10
 8000598:	e195      	b.n	80008c6 <B5_rijndaelKeySetupEnc+0x46e>
            rk += 4;
 800059a:	68bb      	ldr	r3, [r7, #8]
 800059c:	3310      	adds	r3, #16
 800059e:	60bb      	str	r3, [r7, #8]
            temp  = rk[3];
 80005a0:	e78c      	b.n	80004bc <B5_rijndaelKeySetupEnc+0x64>
        }
    }
    
    rk[4] = B5_AES256_GETUINT32(cipherKey + 16);
 80005a2:	687b      	ldr	r3, [r7, #4]
 80005a4:	f103 0210 	add.w	r2, r3, #16
 80005a8:	68bb      	ldr	r3, [r7, #8]
 80005aa:	f103 0410 	add.w	r4, r3, #16
 80005ae:	4610      	mov	r0, r2
 80005b0:	f7ff fe9f 	bl	80002f2 <B5_AES256_GETUINT32>
 80005b4:	4603      	mov	r3, r0
 80005b6:	6023      	str	r3, [r4, #0]
    rk[5] = B5_AES256_GETUINT32(cipherKey + 20);
 80005b8:	687b      	ldr	r3, [r7, #4]
 80005ba:	f103 0214 	add.w	r2, r3, #20
 80005be:	68bb      	ldr	r3, [r7, #8]
 80005c0:	f103 0414 	add.w	r4, r3, #20
 80005c4:	4610      	mov	r0, r2
 80005c6:	f7ff fe94 	bl	80002f2 <B5_AES256_GETUINT32>
 80005ca:	4603      	mov	r3, r0
 80005cc:	6023      	str	r3, [r4, #0]
    
    if (keyBits == 192) 
 80005ce:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80005d2:	2bc0      	cmp	r3, #192	; 0xc0
 80005d4:	f040 808a 	bne.w	80006ec <B5_rijndaelKeySetupEnc+0x294>
    {
        for (;;) 
        {
            temp = rk[5];
 80005d8:	68bb      	ldr	r3, [r7, #8]
 80005da:	695b      	ldr	r3, [r3, #20]
 80005dc:	62bb      	str	r3, [r7, #40]	; 0x28
            memcpy(&ut0, &ctx->Te4[(temp >> 16) & 0xff], sizeof(uint32_t));
 80005de:	68fb      	ldr	r3, [r7, #12]
 80005e0:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80005e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80005e6:	0c1b      	lsrs	r3, r3, #16
 80005e8:	b2db      	uxtb	r3, r3
 80005ea:	009b      	lsls	r3, r3, #2
 80005ec:	4413      	add	r3, r2
 80005ee:	681b      	ldr	r3, [r3, #0]
 80005f0:	627b      	str	r3, [r7, #36]	; 0x24
            memcpy(&ut1, &ctx->Te4[(temp >>  8) & 0xff], sizeof(uint32_t));
 80005f2:	68fb      	ldr	r3, [r7, #12]
 80005f4:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 80005f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80005fa:	0a1b      	lsrs	r3, r3, #8
 80005fc:	b2db      	uxtb	r3, r3
 80005fe:	009b      	lsls	r3, r3, #2
 8000600:	4413      	add	r3, r2
 8000602:	681b      	ldr	r3, [r3, #0]
 8000604:	623b      	str	r3, [r7, #32]
            memcpy(&ut2, &ctx->Te4[(temp      ) & 0xff], sizeof(uint32_t));
 8000606:	68fb      	ldr	r3, [r7, #12]
 8000608:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800060c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800060e:	b2db      	uxtb	r3, r3
 8000610:	009b      	lsls	r3, r3, #2
 8000612:	4413      	add	r3, r2
 8000614:	681b      	ldr	r3, [r3, #0]
 8000616:	61fb      	str	r3, [r7, #28]
            memcpy(&ut3, &ctx->Te4[(temp >> 24)       ], sizeof(uint32_t));
 8000618:	68fb      	ldr	r3, [r7, #12]
 800061a:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800061e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000620:	0e1b      	lsrs	r3, r3, #24
 8000622:	009b      	lsls	r3, r3, #2
 8000624:	4413      	add	r3, r2
 8000626:	681b      	ldr	r3, [r3, #0]
 8000628:	61bb      	str	r3, [r7, #24]
            memcpy(&ut4, &B5_rcon[i], sizeof(uint32_t));
 800062a:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 800062e:	009b      	lsls	r3, r3, #2
 8000630:	4a2d      	ldr	r2, [pc, #180]	; (80006e8 <B5_rijndaelKeySetupEnc+0x290>)
 8000632:	4413      	add	r3, r2
 8000634:	681b      	ldr	r3, [r3, #0]
 8000636:	617b      	str	r3, [r7, #20]
            
            rk[ 6] = rk[ 0] ^
 8000638:	68bb      	ldr	r3, [r7, #8]
 800063a:	681a      	ldr	r2, [r3, #0]
                    (ut0 & 0xff000000) ^
 800063c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800063e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
            rk[ 6] = rk[ 0] ^
 8000642:	405a      	eors	r2, r3
                    (ut1 & 0x00ff0000) ^
 8000644:	6a3b      	ldr	r3, [r7, #32]
 8000646:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                    (ut0 & 0xff000000) ^
 800064a:	405a      	eors	r2, r3
                    (ut2 & 0x0000ff00) ^
 800064c:	69fb      	ldr	r3, [r7, #28]
 800064e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
                    (ut1 & 0x00ff0000) ^
 8000652:	405a      	eors	r2, r3
                    (ut3 & 0x000000ff) ^
 8000654:	69bb      	ldr	r3, [r7, #24]
 8000656:	b2db      	uxtb	r3, r3
                    (ut2 & 0x0000ff00) ^
 8000658:	ea82 0103 	eor.w	r1, r2, r3
                    (ut3 & 0x000000ff) ^
 800065c:	697a      	ldr	r2, [r7, #20]
            rk[ 6] = rk[ 0] ^
 800065e:	68bb      	ldr	r3, [r7, #8]
 8000660:	3318      	adds	r3, #24
                    (ut3 & 0x000000ff) ^
 8000662:	404a      	eors	r2, r1
            rk[ 6] = rk[ 0] ^
 8000664:	601a      	str	r2, [r3, #0]
                    ut4;
            
            rk[ 7] = rk[ 1] ^ rk[ 6];
 8000666:	68bb      	ldr	r3, [r7, #8]
 8000668:	3304      	adds	r3, #4
 800066a:	6819      	ldr	r1, [r3, #0]
 800066c:	68bb      	ldr	r3, [r7, #8]
 800066e:	3318      	adds	r3, #24
 8000670:	681a      	ldr	r2, [r3, #0]
 8000672:	68bb      	ldr	r3, [r7, #8]
 8000674:	331c      	adds	r3, #28
 8000676:	404a      	eors	r2, r1
 8000678:	601a      	str	r2, [r3, #0]
            rk[ 8] = rk[ 2] ^ rk[ 7];
 800067a:	68bb      	ldr	r3, [r7, #8]
 800067c:	3308      	adds	r3, #8
 800067e:	6819      	ldr	r1, [r3, #0]
 8000680:	68bb      	ldr	r3, [r7, #8]
 8000682:	331c      	adds	r3, #28
 8000684:	681a      	ldr	r2, [r3, #0]
 8000686:	68bb      	ldr	r3, [r7, #8]
 8000688:	3320      	adds	r3, #32
 800068a:	404a      	eors	r2, r1
 800068c:	601a      	str	r2, [r3, #0]
            rk[ 9] = rk[ 3] ^ rk[ 8];
 800068e:	68bb      	ldr	r3, [r7, #8]
 8000690:	330c      	adds	r3, #12
 8000692:	6819      	ldr	r1, [r3, #0]
 8000694:	68bb      	ldr	r3, [r7, #8]
 8000696:	3320      	adds	r3, #32
 8000698:	681a      	ldr	r2, [r3, #0]
 800069a:	68bb      	ldr	r3, [r7, #8]
 800069c:	3324      	adds	r3, #36	; 0x24
 800069e:	404a      	eors	r2, r1
 80006a0:	601a      	str	r2, [r3, #0]
            
            if (++i == 8) return 12;
 80006a2:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80006a4:	3301      	adds	r3, #1
 80006a6:	b29b      	uxth	r3, r3
 80006a8:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80006aa:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80006ae:	2b08      	cmp	r3, #8
 80006b0:	d101      	bne.n	80006b6 <B5_rijndaelKeySetupEnc+0x25e>
 80006b2:	230c      	movs	r3, #12
 80006b4:	e107      	b.n	80008c6 <B5_rijndaelKeySetupEnc+0x46e>
            rk[10] = rk[ 4] ^ rk[ 9];
 80006b6:	68bb      	ldr	r3, [r7, #8]
 80006b8:	3310      	adds	r3, #16
 80006ba:	6819      	ldr	r1, [r3, #0]
 80006bc:	68bb      	ldr	r3, [r7, #8]
 80006be:	3324      	adds	r3, #36	; 0x24
 80006c0:	681a      	ldr	r2, [r3, #0]
 80006c2:	68bb      	ldr	r3, [r7, #8]
 80006c4:	3328      	adds	r3, #40	; 0x28
 80006c6:	404a      	eors	r2, r1
 80006c8:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 5] ^ rk[10];
 80006ca:	68bb      	ldr	r3, [r7, #8]
 80006cc:	3314      	adds	r3, #20
 80006ce:	6819      	ldr	r1, [r3, #0]
 80006d0:	68bb      	ldr	r3, [r7, #8]
 80006d2:	3328      	adds	r3, #40	; 0x28
 80006d4:	681a      	ldr	r2, [r3, #0]
 80006d6:	68bb      	ldr	r3, [r7, #8]
 80006d8:	332c      	adds	r3, #44	; 0x2c
 80006da:	404a      	eors	r2, r1
 80006dc:	601a      	str	r2, [r3, #0]
            rk += 6;
 80006de:	68bb      	ldr	r3, [r7, #8]
 80006e0:	3318      	adds	r3, #24
 80006e2:	60bb      	str	r3, [r7, #8]
            temp = rk[5];
 80006e4:	e778      	b.n	80005d8 <B5_rijndaelKeySetupEnc+0x180>
 80006e6:	bf00      	nop
 80006e8:	0801e000 	.word	0x0801e000
        }
    }
    
    rk[6] = B5_AES256_GETUINT32(cipherKey + 24);
 80006ec:	687b      	ldr	r3, [r7, #4]
 80006ee:	f103 0218 	add.w	r2, r3, #24
 80006f2:	68bb      	ldr	r3, [r7, #8]
 80006f4:	f103 0418 	add.w	r4, r3, #24
 80006f8:	4610      	mov	r0, r2
 80006fa:	f7ff fdfa 	bl	80002f2 <B5_AES256_GETUINT32>
 80006fe:	4603      	mov	r3, r0
 8000700:	6023      	str	r3, [r4, #0]
    rk[7] = B5_AES256_GETUINT32(cipherKey + 28);
 8000702:	687b      	ldr	r3, [r7, #4]
 8000704:	f103 021c 	add.w	r2, r3, #28
 8000708:	68bb      	ldr	r3, [r7, #8]
 800070a:	f103 041c 	add.w	r4, r3, #28
 800070e:	4610      	mov	r0, r2
 8000710:	f7ff fdef 	bl	80002f2 <B5_AES256_GETUINT32>
 8000714:	4603      	mov	r3, r0
 8000716:	6023      	str	r3, [r4, #0]
    
    if (keyBits == 256) 
 8000718:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800071c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000720:	f040 80d0 	bne.w	80008c4 <B5_rijndaelKeySetupEnc+0x46c>
    {
        for (;;) 
        {
            temp = rk[ 7];
 8000724:	68bb      	ldr	r3, [r7, #8]
 8000726:	69db      	ldr	r3, [r3, #28]
 8000728:	62bb      	str	r3, [r7, #40]	; 0x28
            memcpy(&ut0, &ctx->Te4[(temp >> 16) & 0xff], sizeof(uint32_t));
 800072a:	68fb      	ldr	r3, [r7, #12]
 800072c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000730:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000732:	0c1b      	lsrs	r3, r3, #16
 8000734:	b2db      	uxtb	r3, r3
 8000736:	009b      	lsls	r3, r3, #2
 8000738:	4413      	add	r3, r2
 800073a:	681b      	ldr	r3, [r3, #0]
 800073c:	627b      	str	r3, [r7, #36]	; 0x24
            memcpy(&ut1, &ctx->Te4[(temp >>  8) & 0xff], sizeof(uint32_t));
 800073e:	68fb      	ldr	r3, [r7, #12]
 8000740:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000744:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000746:	0a1b      	lsrs	r3, r3, #8
 8000748:	b2db      	uxtb	r3, r3
 800074a:	009b      	lsls	r3, r3, #2
 800074c:	4413      	add	r3, r2
 800074e:	681b      	ldr	r3, [r3, #0]
 8000750:	623b      	str	r3, [r7, #32]
            memcpy(&ut2, &ctx->Te4[(temp      ) & 0xff], sizeof(uint32_t));
 8000752:	68fb      	ldr	r3, [r7, #12]
 8000754:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000758:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800075a:	b2db      	uxtb	r3, r3
 800075c:	009b      	lsls	r3, r3, #2
 800075e:	4413      	add	r3, r2
 8000760:	681b      	ldr	r3, [r3, #0]
 8000762:	61fb      	str	r3, [r7, #28]
            memcpy(&ut3, &ctx->Te4[(temp >> 24)       ], sizeof(uint32_t));
 8000764:	68fb      	ldr	r3, [r7, #12]
 8000766:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800076a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800076c:	0e1b      	lsrs	r3, r3, #24
 800076e:	009b      	lsls	r3, r3, #2
 8000770:	4413      	add	r3, r2
 8000772:	681b      	ldr	r3, [r3, #0]
 8000774:	61bb      	str	r3, [r7, #24]
            memcpy(&ut4, &B5_rcon[i], sizeof(uint32_t));
 8000776:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 800077a:	009b      	lsls	r3, r3, #2
 800077c:	4a54      	ldr	r2, [pc, #336]	; (80008d0 <B5_rijndaelKeySetupEnc+0x478>)
 800077e:	4413      	add	r3, r2
 8000780:	681b      	ldr	r3, [r3, #0]
 8000782:	617b      	str	r3, [r7, #20]
            
            rk[ 8] = rk[ 0] ^
 8000784:	68bb      	ldr	r3, [r7, #8]
 8000786:	681a      	ldr	r2, [r3, #0]
                    (ut0 & 0xff000000) ^
 8000788:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800078a:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
            rk[ 8] = rk[ 0] ^
 800078e:	405a      	eors	r2, r3
                    (ut1 & 0x00ff0000) ^
 8000790:	6a3b      	ldr	r3, [r7, #32]
 8000792:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                    (ut0 & 0xff000000) ^
 8000796:	405a      	eors	r2, r3
                    (ut2 & 0x0000ff00) ^
 8000798:	69fb      	ldr	r3, [r7, #28]
 800079a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
                    (ut1 & 0x00ff0000) ^
 800079e:	405a      	eors	r2, r3
                    (ut3 & 0x000000ff) ^
 80007a0:	69bb      	ldr	r3, [r7, #24]
 80007a2:	b2db      	uxtb	r3, r3
                    (ut2 & 0x0000ff00) ^
 80007a4:	ea82 0103 	eor.w	r1, r2, r3
                    (ut3 & 0x000000ff) ^
 80007a8:	697a      	ldr	r2, [r7, #20]
            rk[ 8] = rk[ 0] ^
 80007aa:	68bb      	ldr	r3, [r7, #8]
 80007ac:	3320      	adds	r3, #32
                    (ut3 & 0x000000ff) ^
 80007ae:	404a      	eors	r2, r1
            rk[ 8] = rk[ 0] ^
 80007b0:	601a      	str	r2, [r3, #0]
                    ut4;
            
            rk[ 9] = rk[ 1] ^ rk[ 8];
 80007b2:	68bb      	ldr	r3, [r7, #8]
 80007b4:	3304      	adds	r3, #4
 80007b6:	6819      	ldr	r1, [r3, #0]
 80007b8:	68bb      	ldr	r3, [r7, #8]
 80007ba:	3320      	adds	r3, #32
 80007bc:	681a      	ldr	r2, [r3, #0]
 80007be:	68bb      	ldr	r3, [r7, #8]
 80007c0:	3324      	adds	r3, #36	; 0x24
 80007c2:	404a      	eors	r2, r1
 80007c4:	601a      	str	r2, [r3, #0]
            rk[10] = rk[ 2] ^ rk[ 9];
 80007c6:	68bb      	ldr	r3, [r7, #8]
 80007c8:	3308      	adds	r3, #8
 80007ca:	6819      	ldr	r1, [r3, #0]
 80007cc:	68bb      	ldr	r3, [r7, #8]
 80007ce:	3324      	adds	r3, #36	; 0x24
 80007d0:	681a      	ldr	r2, [r3, #0]
 80007d2:	68bb      	ldr	r3, [r7, #8]
 80007d4:	3328      	adds	r3, #40	; 0x28
 80007d6:	404a      	eors	r2, r1
 80007d8:	601a      	str	r2, [r3, #0]
            rk[11] = rk[ 3] ^ rk[10];
 80007da:	68bb      	ldr	r3, [r7, #8]
 80007dc:	330c      	adds	r3, #12
 80007de:	6819      	ldr	r1, [r3, #0]
 80007e0:	68bb      	ldr	r3, [r7, #8]
 80007e2:	3328      	adds	r3, #40	; 0x28
 80007e4:	681a      	ldr	r2, [r3, #0]
 80007e6:	68bb      	ldr	r3, [r7, #8]
 80007e8:	332c      	adds	r3, #44	; 0x2c
 80007ea:	404a      	eors	r2, r1
 80007ec:	601a      	str	r2, [r3, #0]
            
            if (++i == 7) return 14;
 80007ee:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 80007f0:	3301      	adds	r3, #1
 80007f2:	b29b      	uxth	r3, r3
 80007f4:	85fb      	strh	r3, [r7, #46]	; 0x2e
 80007f6:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80007fa:	2b07      	cmp	r3, #7
 80007fc:	d101      	bne.n	8000802 <B5_rijndaelKeySetupEnc+0x3aa>
 80007fe:	230e      	movs	r3, #14
 8000800:	e061      	b.n	80008c6 <B5_rijndaelKeySetupEnc+0x46e>
            temp = rk[11];
 8000802:	68bb      	ldr	r3, [r7, #8]
 8000804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000806:	62bb      	str	r3, [r7, #40]	; 0x28
            memcpy(&ut0, &ctx->Te4[(temp >> 24)       ], sizeof(uint32_t));
 8000808:	68fb      	ldr	r3, [r7, #12]
 800080a:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 800080e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000810:	0e1b      	lsrs	r3, r3, #24
 8000812:	009b      	lsls	r3, r3, #2
 8000814:	4413      	add	r3, r2
 8000816:	681b      	ldr	r3, [r3, #0]
 8000818:	627b      	str	r3, [r7, #36]	; 0x24
            memcpy(&ut1, &ctx->Te4[(temp >> 16) & 0xff], sizeof(uint32_t));
 800081a:	68fb      	ldr	r3, [r7, #12]
 800081c:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000820:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000822:	0c1b      	lsrs	r3, r3, #16
 8000824:	b2db      	uxtb	r3, r3
 8000826:	009b      	lsls	r3, r3, #2
 8000828:	4413      	add	r3, r2
 800082a:	681b      	ldr	r3, [r3, #0]
 800082c:	623b      	str	r3, [r7, #32]
            memcpy(&ut2, &ctx->Te4[(temp >>  8) & 0xff], sizeof(uint32_t));
 800082e:	68fb      	ldr	r3, [r7, #12]
 8000830:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000834:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000836:	0a1b      	lsrs	r3, r3, #8
 8000838:	b2db      	uxtb	r3, r3
 800083a:	009b      	lsls	r3, r3, #2
 800083c:	4413      	add	r3, r2
 800083e:	681b      	ldr	r3, [r3, #0]
 8000840:	61fb      	str	r3, [r7, #28]
            memcpy(&ut3, &ctx->Te4[(temp      ) & 0xff], sizeof(uint32_t));
 8000842:	68fb      	ldr	r3, [r7, #12]
 8000844:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8000848:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800084a:	b2db      	uxtb	r3, r3
 800084c:	009b      	lsls	r3, r3, #2
 800084e:	4413      	add	r3, r2
 8000850:	681b      	ldr	r3, [r3, #0]
 8000852:	61bb      	str	r3, [r7, #24]
            
            rk[ 12] = rk[ 4] ^
 8000854:	68bb      	ldr	r3, [r7, #8]
 8000856:	3310      	adds	r3, #16
 8000858:	681a      	ldr	r2, [r3, #0]
                    (ut0 & 0xff000000) ^
 800085a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800085c:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
            rk[ 12] = rk[ 4] ^
 8000860:	405a      	eors	r2, r3
                    (ut1 & 0x00ff0000) ^
 8000862:	6a3b      	ldr	r3, [r7, #32]
 8000864:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
                    (ut0 & 0xff000000) ^
 8000868:	405a      	eors	r2, r3
                    (ut2 & 0x0000ff00) ^
 800086a:	69fb      	ldr	r3, [r7, #28]
 800086c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
                    (ut1 & 0x00ff0000) ^
 8000870:	ea82 0103 	eor.w	r1, r2, r3
                    (ut3 & 0x000000ff);
 8000874:	69bb      	ldr	r3, [r7, #24]
 8000876:	b2da      	uxtb	r2, r3
            rk[ 12] = rk[ 4] ^
 8000878:	68bb      	ldr	r3, [r7, #8]
 800087a:	3330      	adds	r3, #48	; 0x30
                    (ut2 & 0x0000ff00) ^
 800087c:	404a      	eors	r2, r1
            rk[ 12] = rk[ 4] ^
 800087e:	601a      	str	r2, [r3, #0]
            
            rk[13] = rk[ 5] ^ rk[12];
 8000880:	68bb      	ldr	r3, [r7, #8]
 8000882:	3314      	adds	r3, #20
 8000884:	6819      	ldr	r1, [r3, #0]
 8000886:	68bb      	ldr	r3, [r7, #8]
 8000888:	3330      	adds	r3, #48	; 0x30
 800088a:	681a      	ldr	r2, [r3, #0]
 800088c:	68bb      	ldr	r3, [r7, #8]
 800088e:	3334      	adds	r3, #52	; 0x34
 8000890:	404a      	eors	r2, r1
 8000892:	601a      	str	r2, [r3, #0]
            rk[14] = rk[ 6] ^ rk[13];
 8000894:	68bb      	ldr	r3, [r7, #8]
 8000896:	3318      	adds	r3, #24
 8000898:	6819      	ldr	r1, [r3, #0]
 800089a:	68bb      	ldr	r3, [r7, #8]
 800089c:	3334      	adds	r3, #52	; 0x34
 800089e:	681a      	ldr	r2, [r3, #0]
 80008a0:	68bb      	ldr	r3, [r7, #8]
 80008a2:	3338      	adds	r3, #56	; 0x38
 80008a4:	404a      	eors	r2, r1
 80008a6:	601a      	str	r2, [r3, #0]
            rk[15] = rk[ 7] ^ rk[14];
 80008a8:	68bb      	ldr	r3, [r7, #8]
 80008aa:	331c      	adds	r3, #28
 80008ac:	6819      	ldr	r1, [r3, #0]
 80008ae:	68bb      	ldr	r3, [r7, #8]
 80008b0:	3338      	adds	r3, #56	; 0x38
 80008b2:	681a      	ldr	r2, [r3, #0]
 80008b4:	68bb      	ldr	r3, [r7, #8]
 80008b6:	333c      	adds	r3, #60	; 0x3c
 80008b8:	404a      	eors	r2, r1
 80008ba:	601a      	str	r2, [r3, #0]
            
            rk += 8;
 80008bc:	68bb      	ldr	r3, [r7, #8]
 80008be:	3320      	adds	r3, #32
 80008c0:	60bb      	str	r3, [r7, #8]
            temp = rk[ 7];
 80008c2:	e72f      	b.n	8000724 <B5_rijndaelKeySetupEnc+0x2cc>
        }
    }
    return 0;
 80008c4:	2300      	movs	r3, #0
}
 80008c6:	4618      	mov	r0, r3
 80008c8:	3734      	adds	r7, #52	; 0x34
 80008ca:	46bd      	mov	sp, r7
 80008cc:	bd90      	pop	{r4, r7, pc}
 80008ce:	bf00      	nop
 80008d0:	0801e000 	.word	0x0801e000

080008d4 <B5_rijndaelKeySetupDec>:
 * @param cipherKey Key to be expanded.
 * @param keyBits Key length. See \ref aesKeys for supported sizes.
 * @return Number of rounds for the given cipher key size (10, 12, 14).
 */
static uint8_t B5_rijndaelKeySetupDec (B5_tAesCtx *ctx, uint32_t *rk, const uint8_t *cipherKey, int16_t keyBits)
{ 
 80008d4:	b580      	push	{r7, lr}
 80008d6:	b088      	sub	sp, #32
 80008d8:	af00      	add	r7, sp, #0
 80008da:	60f8      	str	r0, [r7, #12]
 80008dc:	60b9      	str	r1, [r7, #8]
 80008de:	607a      	str	r2, [r7, #4]
 80008e0:	807b      	strh	r3, [r7, #2]
    int Nr, i, j;
    uint32_t temp;
    
    /* expand the cipher key: */
    Nr = B5_rijndaelKeySetupEnc(ctx, rk, cipherKey, keyBits);
 80008e2:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80008e6:	687a      	ldr	r2, [r7, #4]
 80008e8:	68b9      	ldr	r1, [r7, #8]
 80008ea:	68f8      	ldr	r0, [r7, #12]
 80008ec:	f7ff fdb4 	bl	8000458 <B5_rijndaelKeySetupEnc>
 80008f0:	4603      	mov	r3, r0
 80008f2:	617b      	str	r3, [r7, #20]
    /* invert the order of the round keys: */
    for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {
 80008f4:	2300      	movs	r3, #0
 80008f6:	61fb      	str	r3, [r7, #28]
 80008f8:	697b      	ldr	r3, [r7, #20]
 80008fa:	009b      	lsls	r3, r3, #2
 80008fc:	61bb      	str	r3, [r7, #24]
 80008fe:	e069      	b.n	80009d4 <B5_rijndaelKeySetupDec+0x100>
        temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
 8000900:	69fb      	ldr	r3, [r7, #28]
 8000902:	009b      	lsls	r3, r3, #2
 8000904:	68ba      	ldr	r2, [r7, #8]
 8000906:	4413      	add	r3, r2
 8000908:	681b      	ldr	r3, [r3, #0]
 800090a:	613b      	str	r3, [r7, #16]
 800090c:	69bb      	ldr	r3, [r7, #24]
 800090e:	009b      	lsls	r3, r3, #2
 8000910:	68ba      	ldr	r2, [r7, #8]
 8000912:	441a      	add	r2, r3
 8000914:	69fb      	ldr	r3, [r7, #28]
 8000916:	009b      	lsls	r3, r3, #2
 8000918:	68b9      	ldr	r1, [r7, #8]
 800091a:	440b      	add	r3, r1
 800091c:	6812      	ldr	r2, [r2, #0]
 800091e:	601a      	str	r2, [r3, #0]
 8000920:	69bb      	ldr	r3, [r7, #24]
 8000922:	009b      	lsls	r3, r3, #2
 8000924:	68ba      	ldr	r2, [r7, #8]
 8000926:	4413      	add	r3, r2
 8000928:	693a      	ldr	r2, [r7, #16]
 800092a:	601a      	str	r2, [r3, #0]
        temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
 800092c:	69fb      	ldr	r3, [r7, #28]
 800092e:	3301      	adds	r3, #1
 8000930:	009b      	lsls	r3, r3, #2
 8000932:	68ba      	ldr	r2, [r7, #8]
 8000934:	4413      	add	r3, r2
 8000936:	681b      	ldr	r3, [r3, #0]
 8000938:	613b      	str	r3, [r7, #16]
 800093a:	69bb      	ldr	r3, [r7, #24]
 800093c:	3301      	adds	r3, #1
 800093e:	009b      	lsls	r3, r3, #2
 8000940:	68ba      	ldr	r2, [r7, #8]
 8000942:	441a      	add	r2, r3
 8000944:	69fb      	ldr	r3, [r7, #28]
 8000946:	3301      	adds	r3, #1
 8000948:	009b      	lsls	r3, r3, #2
 800094a:	68b9      	ldr	r1, [r7, #8]
 800094c:	440b      	add	r3, r1
 800094e:	6812      	ldr	r2, [r2, #0]
 8000950:	601a      	str	r2, [r3, #0]
 8000952:	69bb      	ldr	r3, [r7, #24]
 8000954:	3301      	adds	r3, #1
 8000956:	009b      	lsls	r3, r3, #2
 8000958:	68ba      	ldr	r2, [r7, #8]
 800095a:	4413      	add	r3, r2
 800095c:	693a      	ldr	r2, [r7, #16]
 800095e:	601a      	str	r2, [r3, #0]
        temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
 8000960:	69fb      	ldr	r3, [r7, #28]
 8000962:	3302      	adds	r3, #2
 8000964:	009b      	lsls	r3, r3, #2
 8000966:	68ba      	ldr	r2, [r7, #8]
 8000968:	4413      	add	r3, r2
 800096a:	681b      	ldr	r3, [r3, #0]
 800096c:	613b      	str	r3, [r7, #16]
 800096e:	69bb      	ldr	r3, [r7, #24]
 8000970:	3302      	adds	r3, #2
 8000972:	009b      	lsls	r3, r3, #2
 8000974:	68ba      	ldr	r2, [r7, #8]
 8000976:	441a      	add	r2, r3
 8000978:	69fb      	ldr	r3, [r7, #28]
 800097a:	3302      	adds	r3, #2
 800097c:	009b      	lsls	r3, r3, #2
 800097e:	68b9      	ldr	r1, [r7, #8]
 8000980:	440b      	add	r3, r1
 8000982:	6812      	ldr	r2, [r2, #0]
 8000984:	601a      	str	r2, [r3, #0]
 8000986:	69bb      	ldr	r3, [r7, #24]
 8000988:	3302      	adds	r3, #2
 800098a:	009b      	lsls	r3, r3, #2
 800098c:	68ba      	ldr	r2, [r7, #8]
 800098e:	4413      	add	r3, r2
 8000990:	693a      	ldr	r2, [r7, #16]
 8000992:	601a      	str	r2, [r3, #0]
        temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 8000994:	69fb      	ldr	r3, [r7, #28]
 8000996:	3303      	adds	r3, #3
 8000998:	009b      	lsls	r3, r3, #2
 800099a:	68ba      	ldr	r2, [r7, #8]
 800099c:	4413      	add	r3, r2
 800099e:	681b      	ldr	r3, [r3, #0]
 80009a0:	613b      	str	r3, [r7, #16]
 80009a2:	69bb      	ldr	r3, [r7, #24]
 80009a4:	3303      	adds	r3, #3
 80009a6:	009b      	lsls	r3, r3, #2
 80009a8:	68ba      	ldr	r2, [r7, #8]
 80009aa:	441a      	add	r2, r3
 80009ac:	69fb      	ldr	r3, [r7, #28]
 80009ae:	3303      	adds	r3, #3
 80009b0:	009b      	lsls	r3, r3, #2
 80009b2:	68b9      	ldr	r1, [r7, #8]
 80009b4:	440b      	add	r3, r1
 80009b6:	6812      	ldr	r2, [r2, #0]
 80009b8:	601a      	str	r2, [r3, #0]
 80009ba:	69bb      	ldr	r3, [r7, #24]
 80009bc:	3303      	adds	r3, #3
 80009be:	009b      	lsls	r3, r3, #2
 80009c0:	68ba      	ldr	r2, [r7, #8]
 80009c2:	4413      	add	r3, r2
 80009c4:	693a      	ldr	r2, [r7, #16]
 80009c6:	601a      	str	r2, [r3, #0]
    for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {
 80009c8:	69fb      	ldr	r3, [r7, #28]
 80009ca:	3304      	adds	r3, #4
 80009cc:	61fb      	str	r3, [r7, #28]
 80009ce:	69bb      	ldr	r3, [r7, #24]
 80009d0:	3b04      	subs	r3, #4
 80009d2:	61bb      	str	r3, [r7, #24]
 80009d4:	69fa      	ldr	r2, [r7, #28]
 80009d6:	69bb      	ldr	r3, [r7, #24]
 80009d8:	429a      	cmp	r2, r3
 80009da:	db91      	blt.n	8000900 <B5_rijndaelKeySetupDec+0x2c>
    }
    /* apply the inverse MixColumn transform to all round keys but the first and the last: */
    for (i = 1; i < Nr; i++) {
 80009dc:	2301      	movs	r3, #1
 80009de:	61fb      	str	r3, [r7, #28]
 80009e0:	e133      	b.n	8000c4a <B5_rijndaelKeySetupDec+0x376>
        rk += 4;
 80009e2:	68bb      	ldr	r3, [r7, #8]
 80009e4:	3310      	adds	r3, #16
 80009e6:	60bb      	str	r3, [r7, #8]
        rk[0] =
                ctx->Td0[ctx->Te4[(rk[0] >> 24)       ] & 0xff] ^
 80009e8:	68fb      	ldr	r3, [r7, #12]
 80009ea:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80009ee:	68fb      	ldr	r3, [r7, #12]
 80009f0:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 80009f4:	68bb      	ldr	r3, [r7, #8]
 80009f6:	681b      	ldr	r3, [r3, #0]
 80009f8:	0e1b      	lsrs	r3, r3, #24
 80009fa:	009b      	lsls	r3, r3, #2
 80009fc:	440b      	add	r3, r1
 80009fe:	681b      	ldr	r3, [r3, #0]
 8000a00:	b2db      	uxtb	r3, r3
 8000a02:	009b      	lsls	r3, r3, #2
 8000a04:	4413      	add	r3, r2
 8000a06:	681a      	ldr	r2, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
 8000a08:	68fb      	ldr	r3, [r7, #12]
 8000a0a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8000a0e:	68fb      	ldr	r3, [r7, #12]
 8000a10:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000a14:	68bb      	ldr	r3, [r7, #8]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	0c1b      	lsrs	r3, r3, #16
 8000a1a:	b2db      	uxtb	r3, r3
 8000a1c:	009b      	lsls	r3, r3, #2
 8000a1e:	4403      	add	r3, r0
 8000a20:	681b      	ldr	r3, [r3, #0]
 8000a22:	b2db      	uxtb	r3, r3
 8000a24:	009b      	lsls	r3, r3, #2
 8000a26:	440b      	add	r3, r1
 8000a28:	681b      	ldr	r3, [r3, #0]
                ctx->Td0[ctx->Te4[(rk[0] >> 24)       ] & 0xff] ^
 8000a2a:	405a      	eors	r2, r3
                ctx->Td2[ctx->Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
 8000a2c:	68fb      	ldr	r3, [r7, #12]
 8000a2e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8000a32:	68fb      	ldr	r3, [r7, #12]
 8000a34:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000a38:	68bb      	ldr	r3, [r7, #8]
 8000a3a:	681b      	ldr	r3, [r3, #0]
 8000a3c:	0a1b      	lsrs	r3, r3, #8
 8000a3e:	b2db      	uxtb	r3, r3
 8000a40:	009b      	lsls	r3, r3, #2
 8000a42:	4403      	add	r3, r0
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	b2db      	uxtb	r3, r3
 8000a48:	009b      	lsls	r3, r3, #2
 8000a4a:	440b      	add	r3, r1
 8000a4c:	681b      	ldr	r3, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
 8000a4e:	405a      	eors	r2, r3
                ctx->Td3[ctx->Te4[(rk[0]      ) & 0xff] & 0xff];
 8000a50:	68fb      	ldr	r3, [r7, #12]
 8000a52:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8000a56:	68fb      	ldr	r3, [r7, #12]
 8000a58:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000a5c:	68bb      	ldr	r3, [r7, #8]
 8000a5e:	681b      	ldr	r3, [r3, #0]
 8000a60:	b2db      	uxtb	r3, r3
 8000a62:	009b      	lsls	r3, r3, #2
 8000a64:	4403      	add	r3, r0
 8000a66:	681b      	ldr	r3, [r3, #0]
 8000a68:	b2db      	uxtb	r3, r3
 8000a6a:	009b      	lsls	r3, r3, #2
 8000a6c:	440b      	add	r3, r1
 8000a6e:	681b      	ldr	r3, [r3, #0]
                ctx->Td2[ctx->Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
 8000a70:	405a      	eors	r2, r3
        rk[0] =
 8000a72:	68bb      	ldr	r3, [r7, #8]
 8000a74:	601a      	str	r2, [r3, #0]
        rk[1] =
                ctx->Td0[ctx->Te4[(rk[1] >> 24)       ] & 0xff] ^
 8000a76:	68fb      	ldr	r3, [r7, #12]
 8000a78:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8000a7c:	68fb      	ldr	r3, [r7, #12]
 8000a7e:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8000a82:	68bb      	ldr	r3, [r7, #8]
 8000a84:	3304      	adds	r3, #4
 8000a86:	681b      	ldr	r3, [r3, #0]
 8000a88:	0e1b      	lsrs	r3, r3, #24
 8000a8a:	009b      	lsls	r3, r3, #2
 8000a8c:	440b      	add	r3, r1
 8000a8e:	681b      	ldr	r3, [r3, #0]
 8000a90:	b2db      	uxtb	r3, r3
 8000a92:	009b      	lsls	r3, r3, #2
 8000a94:	4413      	add	r3, r2
 8000a96:	681a      	ldr	r2, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
 8000a98:	68fb      	ldr	r3, [r7, #12]
 8000a9a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8000a9e:	68fb      	ldr	r3, [r7, #12]
 8000aa0:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000aa4:	68bb      	ldr	r3, [r7, #8]
 8000aa6:	3304      	adds	r3, #4
 8000aa8:	681b      	ldr	r3, [r3, #0]
 8000aaa:	0c1b      	lsrs	r3, r3, #16
 8000aac:	b2db      	uxtb	r3, r3
 8000aae:	009b      	lsls	r3, r3, #2
 8000ab0:	4403      	add	r3, r0
 8000ab2:	681b      	ldr	r3, [r3, #0]
 8000ab4:	b2db      	uxtb	r3, r3
 8000ab6:	009b      	lsls	r3, r3, #2
 8000ab8:	440b      	add	r3, r1
 8000aba:	681b      	ldr	r3, [r3, #0]
                ctx->Td0[ctx->Te4[(rk[1] >> 24)       ] & 0xff] ^
 8000abc:	405a      	eors	r2, r3
                ctx->Td2[ctx->Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
 8000abe:	68fb      	ldr	r3, [r7, #12]
 8000ac0:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8000ac4:	68fb      	ldr	r3, [r7, #12]
 8000ac6:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000aca:	68bb      	ldr	r3, [r7, #8]
 8000acc:	3304      	adds	r3, #4
 8000ace:	681b      	ldr	r3, [r3, #0]
 8000ad0:	0a1b      	lsrs	r3, r3, #8
 8000ad2:	b2db      	uxtb	r3, r3
 8000ad4:	009b      	lsls	r3, r3, #2
 8000ad6:	4403      	add	r3, r0
 8000ad8:	681b      	ldr	r3, [r3, #0]
 8000ada:	b2db      	uxtb	r3, r3
 8000adc:	009b      	lsls	r3, r3, #2
 8000ade:	440b      	add	r3, r1
 8000ae0:	681b      	ldr	r3, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
 8000ae2:	ea82 0103 	eor.w	r1, r2, r3
                ctx->Td3[ctx->Te4[(rk[1]      ) & 0xff] & 0xff];
 8000ae6:	68fb      	ldr	r3, [r7, #12]
 8000ae8:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
 8000aec:	68fb      	ldr	r3, [r7, #12]
 8000aee:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000af2:	68bb      	ldr	r3, [r7, #8]
 8000af4:	3304      	adds	r3, #4
 8000af6:	681b      	ldr	r3, [r3, #0]
 8000af8:	b2db      	uxtb	r3, r3
 8000afa:	009b      	lsls	r3, r3, #2
 8000afc:	4403      	add	r3, r0
 8000afe:	681b      	ldr	r3, [r3, #0]
 8000b00:	b2db      	uxtb	r3, r3
 8000b02:	009b      	lsls	r3, r3, #2
 8000b04:	4413      	add	r3, r2
 8000b06:	681a      	ldr	r2, [r3, #0]
        rk[1] =
 8000b08:	68bb      	ldr	r3, [r7, #8]
 8000b0a:	3304      	adds	r3, #4
                ctx->Td2[ctx->Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
 8000b0c:	404a      	eors	r2, r1
        rk[1] =
 8000b0e:	601a      	str	r2, [r3, #0]
        rk[2] =
                ctx->Td0[ctx->Te4[(rk[2] >> 24)       ] & 0xff] ^
 8000b10:	68fb      	ldr	r3, [r7, #12]
 8000b12:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8000b16:	68fb      	ldr	r3, [r7, #12]
 8000b18:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8000b1c:	68bb      	ldr	r3, [r7, #8]
 8000b1e:	3308      	adds	r3, #8
 8000b20:	681b      	ldr	r3, [r3, #0]
 8000b22:	0e1b      	lsrs	r3, r3, #24
 8000b24:	009b      	lsls	r3, r3, #2
 8000b26:	440b      	add	r3, r1
 8000b28:	681b      	ldr	r3, [r3, #0]
 8000b2a:	b2db      	uxtb	r3, r3
 8000b2c:	009b      	lsls	r3, r3, #2
 8000b2e:	4413      	add	r3, r2
 8000b30:	681a      	ldr	r2, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
 8000b32:	68fb      	ldr	r3, [r7, #12]
 8000b34:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8000b38:	68fb      	ldr	r3, [r7, #12]
 8000b3a:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000b3e:	68bb      	ldr	r3, [r7, #8]
 8000b40:	3308      	adds	r3, #8
 8000b42:	681b      	ldr	r3, [r3, #0]
 8000b44:	0c1b      	lsrs	r3, r3, #16
 8000b46:	b2db      	uxtb	r3, r3
 8000b48:	009b      	lsls	r3, r3, #2
 8000b4a:	4403      	add	r3, r0
 8000b4c:	681b      	ldr	r3, [r3, #0]
 8000b4e:	b2db      	uxtb	r3, r3
 8000b50:	009b      	lsls	r3, r3, #2
 8000b52:	440b      	add	r3, r1
 8000b54:	681b      	ldr	r3, [r3, #0]
                ctx->Td0[ctx->Te4[(rk[2] >> 24)       ] & 0xff] ^
 8000b56:	405a      	eors	r2, r3
                ctx->Td2[ctx->Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
 8000b58:	68fb      	ldr	r3, [r7, #12]
 8000b5a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8000b5e:	68fb      	ldr	r3, [r7, #12]
 8000b60:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000b64:	68bb      	ldr	r3, [r7, #8]
 8000b66:	3308      	adds	r3, #8
 8000b68:	681b      	ldr	r3, [r3, #0]
 8000b6a:	0a1b      	lsrs	r3, r3, #8
 8000b6c:	b2db      	uxtb	r3, r3
 8000b6e:	009b      	lsls	r3, r3, #2
 8000b70:	4403      	add	r3, r0
 8000b72:	681b      	ldr	r3, [r3, #0]
 8000b74:	b2db      	uxtb	r3, r3
 8000b76:	009b      	lsls	r3, r3, #2
 8000b78:	440b      	add	r3, r1
 8000b7a:	681b      	ldr	r3, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
 8000b7c:	ea82 0103 	eor.w	r1, r2, r3
                ctx->Td3[ctx->Te4[(rk[2]      ) & 0xff] & 0xff];
 8000b80:	68fb      	ldr	r3, [r7, #12]
 8000b82:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
 8000b86:	68fb      	ldr	r3, [r7, #12]
 8000b88:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000b8c:	68bb      	ldr	r3, [r7, #8]
 8000b8e:	3308      	adds	r3, #8
 8000b90:	681b      	ldr	r3, [r3, #0]
 8000b92:	b2db      	uxtb	r3, r3
 8000b94:	009b      	lsls	r3, r3, #2
 8000b96:	4403      	add	r3, r0
 8000b98:	681b      	ldr	r3, [r3, #0]
 8000b9a:	b2db      	uxtb	r3, r3
 8000b9c:	009b      	lsls	r3, r3, #2
 8000b9e:	4413      	add	r3, r2
 8000ba0:	681a      	ldr	r2, [r3, #0]
        rk[2] =
 8000ba2:	68bb      	ldr	r3, [r7, #8]
 8000ba4:	3308      	adds	r3, #8
                ctx->Td2[ctx->Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
 8000ba6:	404a      	eors	r2, r1
        rk[2] =
 8000ba8:	601a      	str	r2, [r3, #0]
        rk[3] =
                ctx->Td0[ctx->Te4[(rk[3] >> 24)       ] & 0xff] ^
 8000baa:	68fb      	ldr	r3, [r7, #12]
 8000bac:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8000bb0:	68fb      	ldr	r3, [r7, #12]
 8000bb2:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8000bb6:	68bb      	ldr	r3, [r7, #8]
 8000bb8:	330c      	adds	r3, #12
 8000bba:	681b      	ldr	r3, [r3, #0]
 8000bbc:	0e1b      	lsrs	r3, r3, #24
 8000bbe:	009b      	lsls	r3, r3, #2
 8000bc0:	440b      	add	r3, r1
 8000bc2:	681b      	ldr	r3, [r3, #0]
 8000bc4:	b2db      	uxtb	r3, r3
 8000bc6:	009b      	lsls	r3, r3, #2
 8000bc8:	4413      	add	r3, r2
 8000bca:	681a      	ldr	r2, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
 8000bcc:	68fb      	ldr	r3, [r7, #12]
 8000bce:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8000bd2:	68fb      	ldr	r3, [r7, #12]
 8000bd4:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000bd8:	68bb      	ldr	r3, [r7, #8]
 8000bda:	330c      	adds	r3, #12
 8000bdc:	681b      	ldr	r3, [r3, #0]
 8000bde:	0c1b      	lsrs	r3, r3, #16
 8000be0:	b2db      	uxtb	r3, r3
 8000be2:	009b      	lsls	r3, r3, #2
 8000be4:	4403      	add	r3, r0
 8000be6:	681b      	ldr	r3, [r3, #0]
 8000be8:	b2db      	uxtb	r3, r3
 8000bea:	009b      	lsls	r3, r3, #2
 8000bec:	440b      	add	r3, r1
 8000bee:	681b      	ldr	r3, [r3, #0]
                ctx->Td0[ctx->Te4[(rk[3] >> 24)       ] & 0xff] ^
 8000bf0:	405a      	eors	r2, r3
                ctx->Td2[ctx->Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
 8000bf2:	68fb      	ldr	r3, [r7, #12]
 8000bf4:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8000bf8:	68fb      	ldr	r3, [r7, #12]
 8000bfa:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000bfe:	68bb      	ldr	r3, [r7, #8]
 8000c00:	330c      	adds	r3, #12
 8000c02:	681b      	ldr	r3, [r3, #0]
 8000c04:	0a1b      	lsrs	r3, r3, #8
 8000c06:	b2db      	uxtb	r3, r3
 8000c08:	009b      	lsls	r3, r3, #2
 8000c0a:	4403      	add	r3, r0
 8000c0c:	681b      	ldr	r3, [r3, #0]
 8000c0e:	b2db      	uxtb	r3, r3
 8000c10:	009b      	lsls	r3, r3, #2
 8000c12:	440b      	add	r3, r1
 8000c14:	681b      	ldr	r3, [r3, #0]
                ctx->Td1[ctx->Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
 8000c16:	ea82 0103 	eor.w	r1, r2, r3
                ctx->Td3[ctx->Te4[(rk[3]      ) & 0xff] & 0xff];
 8000c1a:	68fb      	ldr	r3, [r7, #12]
 8000c1c:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
 8000c20:	68fb      	ldr	r3, [r7, #12]
 8000c22:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
 8000c26:	68bb      	ldr	r3, [r7, #8]
 8000c28:	330c      	adds	r3, #12
 8000c2a:	681b      	ldr	r3, [r3, #0]
 8000c2c:	b2db      	uxtb	r3, r3
 8000c2e:	009b      	lsls	r3, r3, #2
 8000c30:	4403      	add	r3, r0
 8000c32:	681b      	ldr	r3, [r3, #0]
 8000c34:	b2db      	uxtb	r3, r3
 8000c36:	009b      	lsls	r3, r3, #2
 8000c38:	4413      	add	r3, r2
 8000c3a:	681a      	ldr	r2, [r3, #0]
        rk[3] =
 8000c3c:	68bb      	ldr	r3, [r7, #8]
 8000c3e:	330c      	adds	r3, #12
                ctx->Td2[ctx->Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
 8000c40:	404a      	eors	r2, r1
        rk[3] =
 8000c42:	601a      	str	r2, [r3, #0]
    for (i = 1; i < Nr; i++) {
 8000c44:	69fb      	ldr	r3, [r7, #28]
 8000c46:	3301      	adds	r3, #1
 8000c48:	61fb      	str	r3, [r7, #28]
 8000c4a:	69fa      	ldr	r2, [r7, #28]
 8000c4c:	697b      	ldr	r3, [r7, #20]
 8000c4e:	429a      	cmp	r2, r3
 8000c50:	f6ff aec7 	blt.w	80009e2 <B5_rijndaelKeySetupDec+0x10e>
    }
    return (uint8_t) Nr;
 8000c54:	697b      	ldr	r3, [r7, #20]
 8000c56:	b2db      	uxtb	r3, r3
}
 8000c58:	4618      	mov	r0, r3
 8000c5a:	3720      	adds	r7, #32
 8000c5c:	46bd      	mov	sp, r7
 8000c5e:	bd80      	pop	{r7, pc}

08000c60 <B5_rijndaelEncrypt>:
 * @param Nr number of rounds (depends on the original key length)
 * @param pt input block
 * @param ct output block
 */
static void B5_rijndaelEncrypt (B5_tAesCtx *ctx, uint32_t *rk, int16_t Nr, const uint8_t *pt, uint8_t *ct)
{
 8000c60:	b580      	push	{r7, lr}
 8000c62:	b08c      	sub	sp, #48	; 0x30
 8000c64:	af00      	add	r7, sp, #0
 8000c66:	60f8      	str	r0, [r7, #12]
 8000c68:	60b9      	str	r1, [r7, #8]
 8000c6a:	603b      	str	r3, [r7, #0]
 8000c6c:	4613      	mov	r3, r2
 8000c6e:	80fb      	strh	r3, [r7, #6]
    uint32_t s0, s1, s2, s3, t0, t1, t2, t3;
    /*
     * map byte array block to cipher state
     * and add initial round key:
     */
    s0 = B5_AES256_GETUINT32(pt     ) ^ rk[0];
 8000c70:	6838      	ldr	r0, [r7, #0]
 8000c72:	f7ff fb3e 	bl	80002f2 <B5_AES256_GETUINT32>
 8000c76:	4602      	mov	r2, r0
 8000c78:	68bb      	ldr	r3, [r7, #8]
 8000c7a:	681b      	ldr	r3, [r3, #0]
 8000c7c:	4053      	eors	r3, r2
 8000c7e:	61fb      	str	r3, [r7, #28]
    s1 = B5_AES256_GETUINT32(pt +  4) ^ rk[1];
 8000c80:	683b      	ldr	r3, [r7, #0]
 8000c82:	3304      	adds	r3, #4
 8000c84:	4618      	mov	r0, r3
 8000c86:	f7ff fb34 	bl	80002f2 <B5_AES256_GETUINT32>
 8000c8a:	4602      	mov	r2, r0
 8000c8c:	68bb      	ldr	r3, [r7, #8]
 8000c8e:	3304      	adds	r3, #4
 8000c90:	681b      	ldr	r3, [r3, #0]
 8000c92:	4053      	eors	r3, r2
 8000c94:	61bb      	str	r3, [r7, #24]
    s2 = B5_AES256_GETUINT32(pt +  8) ^ rk[2];
 8000c96:	683b      	ldr	r3, [r7, #0]
 8000c98:	3308      	adds	r3, #8
 8000c9a:	4618      	mov	r0, r3
 8000c9c:	f7ff fb29 	bl	80002f2 <B5_AES256_GETUINT32>
 8000ca0:	4602      	mov	r2, r0
 8000ca2:	68bb      	ldr	r3, [r7, #8]
 8000ca4:	3308      	adds	r3, #8
 8000ca6:	681b      	ldr	r3, [r3, #0]
 8000ca8:	4053      	eors	r3, r2
 8000caa:	617b      	str	r3, [r7, #20]
    s3 = B5_AES256_GETUINT32(pt + 12) ^ rk[3];
 8000cac:	683b      	ldr	r3, [r7, #0]
 8000cae:	330c      	adds	r3, #12
 8000cb0:	4618      	mov	r0, r3
 8000cb2:	f7ff fb1e 	bl	80002f2 <B5_AES256_GETUINT32>
 8000cb6:	4602      	mov	r2, r0
 8000cb8:	68bb      	ldr	r3, [r7, #8]
 8000cba:	330c      	adds	r3, #12
 8000cbc:	681b      	ldr	r3, [r3, #0]
 8000cbe:	4053      	eors	r3, r2
 8000cc0:	613b      	str	r3, [r7, #16]
    
    
    /* round 1: */
    t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[ 4];
 8000cc2:	68fb      	ldr	r3, [r7, #12]
 8000cc4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000cc8:	69fb      	ldr	r3, [r7, #28]
 8000cca:	0e1b      	lsrs	r3, r3, #24
 8000ccc:	009b      	lsls	r3, r3, #2
 8000cce:	4413      	add	r3, r2
 8000cd0:	681a      	ldr	r2, [r3, #0]
 8000cd2:	68fb      	ldr	r3, [r7, #12]
 8000cd4:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000cd8:	69bb      	ldr	r3, [r7, #24]
 8000cda:	0c1b      	lsrs	r3, r3, #16
 8000cdc:	b2db      	uxtb	r3, r3
 8000cde:	009b      	lsls	r3, r3, #2
 8000ce0:	440b      	add	r3, r1
 8000ce2:	681b      	ldr	r3, [r3, #0]
 8000ce4:	405a      	eors	r2, r3
 8000ce6:	68fb      	ldr	r3, [r7, #12]
 8000ce8:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000cec:	697b      	ldr	r3, [r7, #20]
 8000cee:	0a1b      	lsrs	r3, r3, #8
 8000cf0:	b2db      	uxtb	r3, r3
 8000cf2:	009b      	lsls	r3, r3, #2
 8000cf4:	440b      	add	r3, r1
 8000cf6:	681b      	ldr	r3, [r3, #0]
 8000cf8:	405a      	eors	r2, r3
 8000cfa:	68fb      	ldr	r3, [r7, #12]
 8000cfc:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000d00:	693b      	ldr	r3, [r7, #16]
 8000d02:	b2db      	uxtb	r3, r3
 8000d04:	009b      	lsls	r3, r3, #2
 8000d06:	440b      	add	r3, r1
 8000d08:	681b      	ldr	r3, [r3, #0]
 8000d0a:	405a      	eors	r2, r3
 8000d0c:	68bb      	ldr	r3, [r7, #8]
 8000d0e:	3310      	adds	r3, #16
 8000d10:	681b      	ldr	r3, [r3, #0]
 8000d12:	4053      	eors	r3, r2
 8000d14:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[ 5];
 8000d16:	68fb      	ldr	r3, [r7, #12]
 8000d18:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000d1c:	69bb      	ldr	r3, [r7, #24]
 8000d1e:	0e1b      	lsrs	r3, r3, #24
 8000d20:	009b      	lsls	r3, r3, #2
 8000d22:	4413      	add	r3, r2
 8000d24:	681a      	ldr	r2, [r3, #0]
 8000d26:	68fb      	ldr	r3, [r7, #12]
 8000d28:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000d2c:	697b      	ldr	r3, [r7, #20]
 8000d2e:	0c1b      	lsrs	r3, r3, #16
 8000d30:	b2db      	uxtb	r3, r3
 8000d32:	009b      	lsls	r3, r3, #2
 8000d34:	440b      	add	r3, r1
 8000d36:	681b      	ldr	r3, [r3, #0]
 8000d38:	405a      	eors	r2, r3
 8000d3a:	68fb      	ldr	r3, [r7, #12]
 8000d3c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000d40:	693b      	ldr	r3, [r7, #16]
 8000d42:	0a1b      	lsrs	r3, r3, #8
 8000d44:	b2db      	uxtb	r3, r3
 8000d46:	009b      	lsls	r3, r3, #2
 8000d48:	440b      	add	r3, r1
 8000d4a:	681b      	ldr	r3, [r3, #0]
 8000d4c:	405a      	eors	r2, r3
 8000d4e:	68fb      	ldr	r3, [r7, #12]
 8000d50:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000d54:	69fb      	ldr	r3, [r7, #28]
 8000d56:	b2db      	uxtb	r3, r3
 8000d58:	009b      	lsls	r3, r3, #2
 8000d5a:	440b      	add	r3, r1
 8000d5c:	681b      	ldr	r3, [r3, #0]
 8000d5e:	405a      	eors	r2, r3
 8000d60:	68bb      	ldr	r3, [r7, #8]
 8000d62:	3314      	adds	r3, #20
 8000d64:	681b      	ldr	r3, [r3, #0]
 8000d66:	4053      	eors	r3, r2
 8000d68:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[ 6];
 8000d6a:	68fb      	ldr	r3, [r7, #12]
 8000d6c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000d70:	697b      	ldr	r3, [r7, #20]
 8000d72:	0e1b      	lsrs	r3, r3, #24
 8000d74:	009b      	lsls	r3, r3, #2
 8000d76:	4413      	add	r3, r2
 8000d78:	681a      	ldr	r2, [r3, #0]
 8000d7a:	68fb      	ldr	r3, [r7, #12]
 8000d7c:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000d80:	693b      	ldr	r3, [r7, #16]
 8000d82:	0c1b      	lsrs	r3, r3, #16
 8000d84:	b2db      	uxtb	r3, r3
 8000d86:	009b      	lsls	r3, r3, #2
 8000d88:	440b      	add	r3, r1
 8000d8a:	681b      	ldr	r3, [r3, #0]
 8000d8c:	405a      	eors	r2, r3
 8000d8e:	68fb      	ldr	r3, [r7, #12]
 8000d90:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000d94:	69fb      	ldr	r3, [r7, #28]
 8000d96:	0a1b      	lsrs	r3, r3, #8
 8000d98:	b2db      	uxtb	r3, r3
 8000d9a:	009b      	lsls	r3, r3, #2
 8000d9c:	440b      	add	r3, r1
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	405a      	eors	r2, r3
 8000da2:	68fb      	ldr	r3, [r7, #12]
 8000da4:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000da8:	69bb      	ldr	r3, [r7, #24]
 8000daa:	b2db      	uxtb	r3, r3
 8000dac:	009b      	lsls	r3, r3, #2
 8000dae:	440b      	add	r3, r1
 8000db0:	681b      	ldr	r3, [r3, #0]
 8000db2:	405a      	eors	r2, r3
 8000db4:	68bb      	ldr	r3, [r7, #8]
 8000db6:	3318      	adds	r3, #24
 8000db8:	681b      	ldr	r3, [r3, #0]
 8000dba:	4053      	eors	r3, r2
 8000dbc:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[ 7];
 8000dbe:	68fb      	ldr	r3, [r7, #12]
 8000dc0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000dc4:	693b      	ldr	r3, [r7, #16]
 8000dc6:	0e1b      	lsrs	r3, r3, #24
 8000dc8:	009b      	lsls	r3, r3, #2
 8000dca:	4413      	add	r3, r2
 8000dcc:	681a      	ldr	r2, [r3, #0]
 8000dce:	68fb      	ldr	r3, [r7, #12]
 8000dd0:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000dd4:	69fb      	ldr	r3, [r7, #28]
 8000dd6:	0c1b      	lsrs	r3, r3, #16
 8000dd8:	b2db      	uxtb	r3, r3
 8000dda:	009b      	lsls	r3, r3, #2
 8000ddc:	440b      	add	r3, r1
 8000dde:	681b      	ldr	r3, [r3, #0]
 8000de0:	405a      	eors	r2, r3
 8000de2:	68fb      	ldr	r3, [r7, #12]
 8000de4:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000de8:	69bb      	ldr	r3, [r7, #24]
 8000dea:	0a1b      	lsrs	r3, r3, #8
 8000dec:	b2db      	uxtb	r3, r3
 8000dee:	009b      	lsls	r3, r3, #2
 8000df0:	440b      	add	r3, r1
 8000df2:	681b      	ldr	r3, [r3, #0]
 8000df4:	405a      	eors	r2, r3
 8000df6:	68fb      	ldr	r3, [r7, #12]
 8000df8:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000dfc:	697b      	ldr	r3, [r7, #20]
 8000dfe:	b2db      	uxtb	r3, r3
 8000e00:	009b      	lsls	r3, r3, #2
 8000e02:	440b      	add	r3, r1
 8000e04:	681b      	ldr	r3, [r3, #0]
 8000e06:	405a      	eors	r2, r3
 8000e08:	68bb      	ldr	r3, [r7, #8]
 8000e0a:	331c      	adds	r3, #28
 8000e0c:	681b      	ldr	r3, [r3, #0]
 8000e0e:	4053      	eors	r3, r2
 8000e10:	623b      	str	r3, [r7, #32]
    /* round 2: */
    s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[ 8];
 8000e12:	68fb      	ldr	r3, [r7, #12]
 8000e14:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000e18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000e1a:	0e1b      	lsrs	r3, r3, #24
 8000e1c:	009b      	lsls	r3, r3, #2
 8000e1e:	4413      	add	r3, r2
 8000e20:	681a      	ldr	r2, [r3, #0]
 8000e22:	68fb      	ldr	r3, [r7, #12]
 8000e24:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000e28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000e2a:	0c1b      	lsrs	r3, r3, #16
 8000e2c:	b2db      	uxtb	r3, r3
 8000e2e:	009b      	lsls	r3, r3, #2
 8000e30:	440b      	add	r3, r1
 8000e32:	681b      	ldr	r3, [r3, #0]
 8000e34:	405a      	eors	r2, r3
 8000e36:	68fb      	ldr	r3, [r7, #12]
 8000e38:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000e3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000e3e:	0a1b      	lsrs	r3, r3, #8
 8000e40:	b2db      	uxtb	r3, r3
 8000e42:	009b      	lsls	r3, r3, #2
 8000e44:	440b      	add	r3, r1
 8000e46:	681b      	ldr	r3, [r3, #0]
 8000e48:	405a      	eors	r2, r3
 8000e4a:	68fb      	ldr	r3, [r7, #12]
 8000e4c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000e50:	6a3b      	ldr	r3, [r7, #32]
 8000e52:	b2db      	uxtb	r3, r3
 8000e54:	009b      	lsls	r3, r3, #2
 8000e56:	440b      	add	r3, r1
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	405a      	eors	r2, r3
 8000e5c:	68bb      	ldr	r3, [r7, #8]
 8000e5e:	3320      	adds	r3, #32
 8000e60:	681b      	ldr	r3, [r3, #0]
 8000e62:	4053      	eors	r3, r2
 8000e64:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[ 9];
 8000e66:	68fb      	ldr	r3, [r7, #12]
 8000e68:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000e6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000e6e:	0e1b      	lsrs	r3, r3, #24
 8000e70:	009b      	lsls	r3, r3, #2
 8000e72:	4413      	add	r3, r2
 8000e74:	681a      	ldr	r2, [r3, #0]
 8000e76:	68fb      	ldr	r3, [r7, #12]
 8000e78:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000e7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000e7e:	0c1b      	lsrs	r3, r3, #16
 8000e80:	b2db      	uxtb	r3, r3
 8000e82:	009b      	lsls	r3, r3, #2
 8000e84:	440b      	add	r3, r1
 8000e86:	681b      	ldr	r3, [r3, #0]
 8000e88:	405a      	eors	r2, r3
 8000e8a:	68fb      	ldr	r3, [r7, #12]
 8000e8c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000e90:	6a3b      	ldr	r3, [r7, #32]
 8000e92:	0a1b      	lsrs	r3, r3, #8
 8000e94:	b2db      	uxtb	r3, r3
 8000e96:	009b      	lsls	r3, r3, #2
 8000e98:	440b      	add	r3, r1
 8000e9a:	681b      	ldr	r3, [r3, #0]
 8000e9c:	405a      	eors	r2, r3
 8000e9e:	68fb      	ldr	r3, [r7, #12]
 8000ea0:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000ea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000ea6:	b2db      	uxtb	r3, r3
 8000ea8:	009b      	lsls	r3, r3, #2
 8000eaa:	440b      	add	r3, r1
 8000eac:	681b      	ldr	r3, [r3, #0]
 8000eae:	405a      	eors	r2, r3
 8000eb0:	68bb      	ldr	r3, [r7, #8]
 8000eb2:	3324      	adds	r3, #36	; 0x24
 8000eb4:	681b      	ldr	r3, [r3, #0]
 8000eb6:	4053      	eors	r3, r2
 8000eb8:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[10];
 8000eba:	68fb      	ldr	r3, [r7, #12]
 8000ebc:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000ec0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ec2:	0e1b      	lsrs	r3, r3, #24
 8000ec4:	009b      	lsls	r3, r3, #2
 8000ec6:	4413      	add	r3, r2
 8000ec8:	681a      	ldr	r2, [r3, #0]
 8000eca:	68fb      	ldr	r3, [r7, #12]
 8000ecc:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000ed0:	6a3b      	ldr	r3, [r7, #32]
 8000ed2:	0c1b      	lsrs	r3, r3, #16
 8000ed4:	b2db      	uxtb	r3, r3
 8000ed6:	009b      	lsls	r3, r3, #2
 8000ed8:	440b      	add	r3, r1
 8000eda:	681b      	ldr	r3, [r3, #0]
 8000edc:	405a      	eors	r2, r3
 8000ede:	68fb      	ldr	r3, [r7, #12]
 8000ee0:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000ee4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000ee6:	0a1b      	lsrs	r3, r3, #8
 8000ee8:	b2db      	uxtb	r3, r3
 8000eea:	009b      	lsls	r3, r3, #2
 8000eec:	440b      	add	r3, r1
 8000eee:	681b      	ldr	r3, [r3, #0]
 8000ef0:	405a      	eors	r2, r3
 8000ef2:	68fb      	ldr	r3, [r7, #12]
 8000ef4:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000ef8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000efa:	b2db      	uxtb	r3, r3
 8000efc:	009b      	lsls	r3, r3, #2
 8000efe:	440b      	add	r3, r1
 8000f00:	681b      	ldr	r3, [r3, #0]
 8000f02:	405a      	eors	r2, r3
 8000f04:	68bb      	ldr	r3, [r7, #8]
 8000f06:	3328      	adds	r3, #40	; 0x28
 8000f08:	681b      	ldr	r3, [r3, #0]
 8000f0a:	4053      	eors	r3, r2
 8000f0c:	617b      	str	r3, [r7, #20]
    s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[11];
 8000f0e:	68fb      	ldr	r3, [r7, #12]
 8000f10:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000f14:	6a3b      	ldr	r3, [r7, #32]
 8000f16:	0e1b      	lsrs	r3, r3, #24
 8000f18:	009b      	lsls	r3, r3, #2
 8000f1a:	4413      	add	r3, r2
 8000f1c:	681a      	ldr	r2, [r3, #0]
 8000f1e:	68fb      	ldr	r3, [r7, #12]
 8000f20:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000f24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000f26:	0c1b      	lsrs	r3, r3, #16
 8000f28:	b2db      	uxtb	r3, r3
 8000f2a:	009b      	lsls	r3, r3, #2
 8000f2c:	440b      	add	r3, r1
 8000f2e:	681b      	ldr	r3, [r3, #0]
 8000f30:	405a      	eors	r2, r3
 8000f32:	68fb      	ldr	r3, [r7, #12]
 8000f34:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000f38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000f3a:	0a1b      	lsrs	r3, r3, #8
 8000f3c:	b2db      	uxtb	r3, r3
 8000f3e:	009b      	lsls	r3, r3, #2
 8000f40:	440b      	add	r3, r1
 8000f42:	681b      	ldr	r3, [r3, #0]
 8000f44:	405a      	eors	r2, r3
 8000f46:	68fb      	ldr	r3, [r7, #12]
 8000f48:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000f4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f4e:	b2db      	uxtb	r3, r3
 8000f50:	009b      	lsls	r3, r3, #2
 8000f52:	440b      	add	r3, r1
 8000f54:	681b      	ldr	r3, [r3, #0]
 8000f56:	405a      	eors	r2, r3
 8000f58:	68bb      	ldr	r3, [r7, #8]
 8000f5a:	332c      	adds	r3, #44	; 0x2c
 8000f5c:	681b      	ldr	r3, [r3, #0]
 8000f5e:	4053      	eors	r3, r2
 8000f60:	613b      	str	r3, [r7, #16]
    /* round 3: */
    t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[12];
 8000f62:	68fb      	ldr	r3, [r7, #12]
 8000f64:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000f68:	69fb      	ldr	r3, [r7, #28]
 8000f6a:	0e1b      	lsrs	r3, r3, #24
 8000f6c:	009b      	lsls	r3, r3, #2
 8000f6e:	4413      	add	r3, r2
 8000f70:	681a      	ldr	r2, [r3, #0]
 8000f72:	68fb      	ldr	r3, [r7, #12]
 8000f74:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000f78:	69bb      	ldr	r3, [r7, #24]
 8000f7a:	0c1b      	lsrs	r3, r3, #16
 8000f7c:	b2db      	uxtb	r3, r3
 8000f7e:	009b      	lsls	r3, r3, #2
 8000f80:	440b      	add	r3, r1
 8000f82:	681b      	ldr	r3, [r3, #0]
 8000f84:	405a      	eors	r2, r3
 8000f86:	68fb      	ldr	r3, [r7, #12]
 8000f88:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000f8c:	697b      	ldr	r3, [r7, #20]
 8000f8e:	0a1b      	lsrs	r3, r3, #8
 8000f90:	b2db      	uxtb	r3, r3
 8000f92:	009b      	lsls	r3, r3, #2
 8000f94:	440b      	add	r3, r1
 8000f96:	681b      	ldr	r3, [r3, #0]
 8000f98:	405a      	eors	r2, r3
 8000f9a:	68fb      	ldr	r3, [r7, #12]
 8000f9c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000fa0:	693b      	ldr	r3, [r7, #16]
 8000fa2:	b2db      	uxtb	r3, r3
 8000fa4:	009b      	lsls	r3, r3, #2
 8000fa6:	440b      	add	r3, r1
 8000fa8:	681b      	ldr	r3, [r3, #0]
 8000faa:	405a      	eors	r2, r3
 8000fac:	68bb      	ldr	r3, [r7, #8]
 8000fae:	3330      	adds	r3, #48	; 0x30
 8000fb0:	681b      	ldr	r3, [r3, #0]
 8000fb2:	4053      	eors	r3, r2
 8000fb4:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[13];
 8000fb6:	68fb      	ldr	r3, [r7, #12]
 8000fb8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8000fbc:	69bb      	ldr	r3, [r7, #24]
 8000fbe:	0e1b      	lsrs	r3, r3, #24
 8000fc0:	009b      	lsls	r3, r3, #2
 8000fc2:	4413      	add	r3, r2
 8000fc4:	681a      	ldr	r2, [r3, #0]
 8000fc6:	68fb      	ldr	r3, [r7, #12]
 8000fc8:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8000fcc:	697b      	ldr	r3, [r7, #20]
 8000fce:	0c1b      	lsrs	r3, r3, #16
 8000fd0:	b2db      	uxtb	r3, r3
 8000fd2:	009b      	lsls	r3, r3, #2
 8000fd4:	440b      	add	r3, r1
 8000fd6:	681b      	ldr	r3, [r3, #0]
 8000fd8:	405a      	eors	r2, r3
 8000fda:	68fb      	ldr	r3, [r7, #12]
 8000fdc:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8000fe0:	693b      	ldr	r3, [r7, #16]
 8000fe2:	0a1b      	lsrs	r3, r3, #8
 8000fe4:	b2db      	uxtb	r3, r3
 8000fe6:	009b      	lsls	r3, r3, #2
 8000fe8:	440b      	add	r3, r1
 8000fea:	681b      	ldr	r3, [r3, #0]
 8000fec:	405a      	eors	r2, r3
 8000fee:	68fb      	ldr	r3, [r7, #12]
 8000ff0:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8000ff4:	69fb      	ldr	r3, [r7, #28]
 8000ff6:	b2db      	uxtb	r3, r3
 8000ff8:	009b      	lsls	r3, r3, #2
 8000ffa:	440b      	add	r3, r1
 8000ffc:	681b      	ldr	r3, [r3, #0]
 8000ffe:	405a      	eors	r2, r3
 8001000:	68bb      	ldr	r3, [r7, #8]
 8001002:	3334      	adds	r3, #52	; 0x34
 8001004:	681b      	ldr	r3, [r3, #0]
 8001006:	4053      	eors	r3, r2
 8001008:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[14];
 800100a:	68fb      	ldr	r3, [r7, #12]
 800100c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001010:	697b      	ldr	r3, [r7, #20]
 8001012:	0e1b      	lsrs	r3, r3, #24
 8001014:	009b      	lsls	r3, r3, #2
 8001016:	4413      	add	r3, r2
 8001018:	681a      	ldr	r2, [r3, #0]
 800101a:	68fb      	ldr	r3, [r7, #12]
 800101c:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001020:	693b      	ldr	r3, [r7, #16]
 8001022:	0c1b      	lsrs	r3, r3, #16
 8001024:	b2db      	uxtb	r3, r3
 8001026:	009b      	lsls	r3, r3, #2
 8001028:	440b      	add	r3, r1
 800102a:	681b      	ldr	r3, [r3, #0]
 800102c:	405a      	eors	r2, r3
 800102e:	68fb      	ldr	r3, [r7, #12]
 8001030:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001034:	69fb      	ldr	r3, [r7, #28]
 8001036:	0a1b      	lsrs	r3, r3, #8
 8001038:	b2db      	uxtb	r3, r3
 800103a:	009b      	lsls	r3, r3, #2
 800103c:	440b      	add	r3, r1
 800103e:	681b      	ldr	r3, [r3, #0]
 8001040:	405a      	eors	r2, r3
 8001042:	68fb      	ldr	r3, [r7, #12]
 8001044:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001048:	69bb      	ldr	r3, [r7, #24]
 800104a:	b2db      	uxtb	r3, r3
 800104c:	009b      	lsls	r3, r3, #2
 800104e:	440b      	add	r3, r1
 8001050:	681b      	ldr	r3, [r3, #0]
 8001052:	405a      	eors	r2, r3
 8001054:	68bb      	ldr	r3, [r7, #8]
 8001056:	3338      	adds	r3, #56	; 0x38
 8001058:	681b      	ldr	r3, [r3, #0]
 800105a:	4053      	eors	r3, r2
 800105c:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[15];
 800105e:	68fb      	ldr	r3, [r7, #12]
 8001060:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001064:	693b      	ldr	r3, [r7, #16]
 8001066:	0e1b      	lsrs	r3, r3, #24
 8001068:	009b      	lsls	r3, r3, #2
 800106a:	4413      	add	r3, r2
 800106c:	681a      	ldr	r2, [r3, #0]
 800106e:	68fb      	ldr	r3, [r7, #12]
 8001070:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001074:	69fb      	ldr	r3, [r7, #28]
 8001076:	0c1b      	lsrs	r3, r3, #16
 8001078:	b2db      	uxtb	r3, r3
 800107a:	009b      	lsls	r3, r3, #2
 800107c:	440b      	add	r3, r1
 800107e:	681b      	ldr	r3, [r3, #0]
 8001080:	405a      	eors	r2, r3
 8001082:	68fb      	ldr	r3, [r7, #12]
 8001084:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001088:	69bb      	ldr	r3, [r7, #24]
 800108a:	0a1b      	lsrs	r3, r3, #8
 800108c:	b2db      	uxtb	r3, r3
 800108e:	009b      	lsls	r3, r3, #2
 8001090:	440b      	add	r3, r1
 8001092:	681b      	ldr	r3, [r3, #0]
 8001094:	405a      	eors	r2, r3
 8001096:	68fb      	ldr	r3, [r7, #12]
 8001098:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800109c:	697b      	ldr	r3, [r7, #20]
 800109e:	b2db      	uxtb	r3, r3
 80010a0:	009b      	lsls	r3, r3, #2
 80010a2:	440b      	add	r3, r1
 80010a4:	681b      	ldr	r3, [r3, #0]
 80010a6:	405a      	eors	r2, r3
 80010a8:	68bb      	ldr	r3, [r7, #8]
 80010aa:	333c      	adds	r3, #60	; 0x3c
 80010ac:	681b      	ldr	r3, [r3, #0]
 80010ae:	4053      	eors	r3, r2
 80010b0:	623b      	str	r3, [r7, #32]
    /* round 4: */
    s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[16];
 80010b2:	68fb      	ldr	r3, [r7, #12]
 80010b4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80010b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80010ba:	0e1b      	lsrs	r3, r3, #24
 80010bc:	009b      	lsls	r3, r3, #2
 80010be:	4413      	add	r3, r2
 80010c0:	681a      	ldr	r2, [r3, #0]
 80010c2:	68fb      	ldr	r3, [r7, #12]
 80010c4:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80010c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80010ca:	0c1b      	lsrs	r3, r3, #16
 80010cc:	b2db      	uxtb	r3, r3
 80010ce:	009b      	lsls	r3, r3, #2
 80010d0:	440b      	add	r3, r1
 80010d2:	681b      	ldr	r3, [r3, #0]
 80010d4:	405a      	eors	r2, r3
 80010d6:	68fb      	ldr	r3, [r7, #12]
 80010d8:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80010dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80010de:	0a1b      	lsrs	r3, r3, #8
 80010e0:	b2db      	uxtb	r3, r3
 80010e2:	009b      	lsls	r3, r3, #2
 80010e4:	440b      	add	r3, r1
 80010e6:	681b      	ldr	r3, [r3, #0]
 80010e8:	405a      	eors	r2, r3
 80010ea:	68fb      	ldr	r3, [r7, #12]
 80010ec:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80010f0:	6a3b      	ldr	r3, [r7, #32]
 80010f2:	b2db      	uxtb	r3, r3
 80010f4:	009b      	lsls	r3, r3, #2
 80010f6:	440b      	add	r3, r1
 80010f8:	681b      	ldr	r3, [r3, #0]
 80010fa:	405a      	eors	r2, r3
 80010fc:	68bb      	ldr	r3, [r7, #8]
 80010fe:	3340      	adds	r3, #64	; 0x40
 8001100:	681b      	ldr	r3, [r3, #0]
 8001102:	4053      	eors	r3, r2
 8001104:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[17];
 8001106:	68fb      	ldr	r3, [r7, #12]
 8001108:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800110c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800110e:	0e1b      	lsrs	r3, r3, #24
 8001110:	009b      	lsls	r3, r3, #2
 8001112:	4413      	add	r3, r2
 8001114:	681a      	ldr	r2, [r3, #0]
 8001116:	68fb      	ldr	r3, [r7, #12]
 8001118:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 800111c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800111e:	0c1b      	lsrs	r3, r3, #16
 8001120:	b2db      	uxtb	r3, r3
 8001122:	009b      	lsls	r3, r3, #2
 8001124:	440b      	add	r3, r1
 8001126:	681b      	ldr	r3, [r3, #0]
 8001128:	405a      	eors	r2, r3
 800112a:	68fb      	ldr	r3, [r7, #12]
 800112c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001130:	6a3b      	ldr	r3, [r7, #32]
 8001132:	0a1b      	lsrs	r3, r3, #8
 8001134:	b2db      	uxtb	r3, r3
 8001136:	009b      	lsls	r3, r3, #2
 8001138:	440b      	add	r3, r1
 800113a:	681b      	ldr	r3, [r3, #0]
 800113c:	405a      	eors	r2, r3
 800113e:	68fb      	ldr	r3, [r7, #12]
 8001140:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001144:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001146:	b2db      	uxtb	r3, r3
 8001148:	009b      	lsls	r3, r3, #2
 800114a:	440b      	add	r3, r1
 800114c:	681b      	ldr	r3, [r3, #0]
 800114e:	405a      	eors	r2, r3
 8001150:	68bb      	ldr	r3, [r7, #8]
 8001152:	3344      	adds	r3, #68	; 0x44
 8001154:	681b      	ldr	r3, [r3, #0]
 8001156:	4053      	eors	r3, r2
 8001158:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[18];
 800115a:	68fb      	ldr	r3, [r7, #12]
 800115c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001160:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001162:	0e1b      	lsrs	r3, r3, #24
 8001164:	009b      	lsls	r3, r3, #2
 8001166:	4413      	add	r3, r2
 8001168:	681a      	ldr	r2, [r3, #0]
 800116a:	68fb      	ldr	r3, [r7, #12]
 800116c:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001170:	6a3b      	ldr	r3, [r7, #32]
 8001172:	0c1b      	lsrs	r3, r3, #16
 8001174:	b2db      	uxtb	r3, r3
 8001176:	009b      	lsls	r3, r3, #2
 8001178:	440b      	add	r3, r1
 800117a:	681b      	ldr	r3, [r3, #0]
 800117c:	405a      	eors	r2, r3
 800117e:	68fb      	ldr	r3, [r7, #12]
 8001180:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001184:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001186:	0a1b      	lsrs	r3, r3, #8
 8001188:	b2db      	uxtb	r3, r3
 800118a:	009b      	lsls	r3, r3, #2
 800118c:	440b      	add	r3, r1
 800118e:	681b      	ldr	r3, [r3, #0]
 8001190:	405a      	eors	r2, r3
 8001192:	68fb      	ldr	r3, [r7, #12]
 8001194:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001198:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800119a:	b2db      	uxtb	r3, r3
 800119c:	009b      	lsls	r3, r3, #2
 800119e:	440b      	add	r3, r1
 80011a0:	681b      	ldr	r3, [r3, #0]
 80011a2:	405a      	eors	r2, r3
 80011a4:	68bb      	ldr	r3, [r7, #8]
 80011a6:	3348      	adds	r3, #72	; 0x48
 80011a8:	681b      	ldr	r3, [r3, #0]
 80011aa:	4053      	eors	r3, r2
 80011ac:	617b      	str	r3, [r7, #20]
    s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[19];
 80011ae:	68fb      	ldr	r3, [r7, #12]
 80011b0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80011b4:	6a3b      	ldr	r3, [r7, #32]
 80011b6:	0e1b      	lsrs	r3, r3, #24
 80011b8:	009b      	lsls	r3, r3, #2
 80011ba:	4413      	add	r3, r2
 80011bc:	681a      	ldr	r2, [r3, #0]
 80011be:	68fb      	ldr	r3, [r7, #12]
 80011c0:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80011c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80011c6:	0c1b      	lsrs	r3, r3, #16
 80011c8:	b2db      	uxtb	r3, r3
 80011ca:	009b      	lsls	r3, r3, #2
 80011cc:	440b      	add	r3, r1
 80011ce:	681b      	ldr	r3, [r3, #0]
 80011d0:	405a      	eors	r2, r3
 80011d2:	68fb      	ldr	r3, [r7, #12]
 80011d4:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80011d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80011da:	0a1b      	lsrs	r3, r3, #8
 80011dc:	b2db      	uxtb	r3, r3
 80011de:	009b      	lsls	r3, r3, #2
 80011e0:	440b      	add	r3, r1
 80011e2:	681b      	ldr	r3, [r3, #0]
 80011e4:	405a      	eors	r2, r3
 80011e6:	68fb      	ldr	r3, [r7, #12]
 80011e8:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80011ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80011ee:	b2db      	uxtb	r3, r3
 80011f0:	009b      	lsls	r3, r3, #2
 80011f2:	440b      	add	r3, r1
 80011f4:	681b      	ldr	r3, [r3, #0]
 80011f6:	405a      	eors	r2, r3
 80011f8:	68bb      	ldr	r3, [r7, #8]
 80011fa:	334c      	adds	r3, #76	; 0x4c
 80011fc:	681b      	ldr	r3, [r3, #0]
 80011fe:	4053      	eors	r3, r2
 8001200:	613b      	str	r3, [r7, #16]
    /* round 5: */
    t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[20];
 8001202:	68fb      	ldr	r3, [r7, #12]
 8001204:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001208:	69fb      	ldr	r3, [r7, #28]
 800120a:	0e1b      	lsrs	r3, r3, #24
 800120c:	009b      	lsls	r3, r3, #2
 800120e:	4413      	add	r3, r2
 8001210:	681a      	ldr	r2, [r3, #0]
 8001212:	68fb      	ldr	r3, [r7, #12]
 8001214:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001218:	69bb      	ldr	r3, [r7, #24]
 800121a:	0c1b      	lsrs	r3, r3, #16
 800121c:	b2db      	uxtb	r3, r3
 800121e:	009b      	lsls	r3, r3, #2
 8001220:	440b      	add	r3, r1
 8001222:	681b      	ldr	r3, [r3, #0]
 8001224:	405a      	eors	r2, r3
 8001226:	68fb      	ldr	r3, [r7, #12]
 8001228:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800122c:	697b      	ldr	r3, [r7, #20]
 800122e:	0a1b      	lsrs	r3, r3, #8
 8001230:	b2db      	uxtb	r3, r3
 8001232:	009b      	lsls	r3, r3, #2
 8001234:	440b      	add	r3, r1
 8001236:	681b      	ldr	r3, [r3, #0]
 8001238:	405a      	eors	r2, r3
 800123a:	68fb      	ldr	r3, [r7, #12]
 800123c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001240:	693b      	ldr	r3, [r7, #16]
 8001242:	b2db      	uxtb	r3, r3
 8001244:	009b      	lsls	r3, r3, #2
 8001246:	440b      	add	r3, r1
 8001248:	681b      	ldr	r3, [r3, #0]
 800124a:	405a      	eors	r2, r3
 800124c:	68bb      	ldr	r3, [r7, #8]
 800124e:	3350      	adds	r3, #80	; 0x50
 8001250:	681b      	ldr	r3, [r3, #0]
 8001252:	4053      	eors	r3, r2
 8001254:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[21];
 8001256:	68fb      	ldr	r3, [r7, #12]
 8001258:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800125c:	69bb      	ldr	r3, [r7, #24]
 800125e:	0e1b      	lsrs	r3, r3, #24
 8001260:	009b      	lsls	r3, r3, #2
 8001262:	4413      	add	r3, r2
 8001264:	681a      	ldr	r2, [r3, #0]
 8001266:	68fb      	ldr	r3, [r7, #12]
 8001268:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 800126c:	697b      	ldr	r3, [r7, #20]
 800126e:	0c1b      	lsrs	r3, r3, #16
 8001270:	b2db      	uxtb	r3, r3
 8001272:	009b      	lsls	r3, r3, #2
 8001274:	440b      	add	r3, r1
 8001276:	681b      	ldr	r3, [r3, #0]
 8001278:	405a      	eors	r2, r3
 800127a:	68fb      	ldr	r3, [r7, #12]
 800127c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001280:	693b      	ldr	r3, [r7, #16]
 8001282:	0a1b      	lsrs	r3, r3, #8
 8001284:	b2db      	uxtb	r3, r3
 8001286:	009b      	lsls	r3, r3, #2
 8001288:	440b      	add	r3, r1
 800128a:	681b      	ldr	r3, [r3, #0]
 800128c:	405a      	eors	r2, r3
 800128e:	68fb      	ldr	r3, [r7, #12]
 8001290:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001294:	69fb      	ldr	r3, [r7, #28]
 8001296:	b2db      	uxtb	r3, r3
 8001298:	009b      	lsls	r3, r3, #2
 800129a:	440b      	add	r3, r1
 800129c:	681b      	ldr	r3, [r3, #0]
 800129e:	405a      	eors	r2, r3
 80012a0:	68bb      	ldr	r3, [r7, #8]
 80012a2:	3354      	adds	r3, #84	; 0x54
 80012a4:	681b      	ldr	r3, [r3, #0]
 80012a6:	4053      	eors	r3, r2
 80012a8:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[22];
 80012aa:	68fb      	ldr	r3, [r7, #12]
 80012ac:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80012b0:	697b      	ldr	r3, [r7, #20]
 80012b2:	0e1b      	lsrs	r3, r3, #24
 80012b4:	009b      	lsls	r3, r3, #2
 80012b6:	4413      	add	r3, r2
 80012b8:	681a      	ldr	r2, [r3, #0]
 80012ba:	68fb      	ldr	r3, [r7, #12]
 80012bc:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80012c0:	693b      	ldr	r3, [r7, #16]
 80012c2:	0c1b      	lsrs	r3, r3, #16
 80012c4:	b2db      	uxtb	r3, r3
 80012c6:	009b      	lsls	r3, r3, #2
 80012c8:	440b      	add	r3, r1
 80012ca:	681b      	ldr	r3, [r3, #0]
 80012cc:	405a      	eors	r2, r3
 80012ce:	68fb      	ldr	r3, [r7, #12]
 80012d0:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80012d4:	69fb      	ldr	r3, [r7, #28]
 80012d6:	0a1b      	lsrs	r3, r3, #8
 80012d8:	b2db      	uxtb	r3, r3
 80012da:	009b      	lsls	r3, r3, #2
 80012dc:	440b      	add	r3, r1
 80012de:	681b      	ldr	r3, [r3, #0]
 80012e0:	405a      	eors	r2, r3
 80012e2:	68fb      	ldr	r3, [r7, #12]
 80012e4:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80012e8:	69bb      	ldr	r3, [r7, #24]
 80012ea:	b2db      	uxtb	r3, r3
 80012ec:	009b      	lsls	r3, r3, #2
 80012ee:	440b      	add	r3, r1
 80012f0:	681b      	ldr	r3, [r3, #0]
 80012f2:	405a      	eors	r2, r3
 80012f4:	68bb      	ldr	r3, [r7, #8]
 80012f6:	3358      	adds	r3, #88	; 0x58
 80012f8:	681b      	ldr	r3, [r3, #0]
 80012fa:	4053      	eors	r3, r2
 80012fc:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[23];
 80012fe:	68fb      	ldr	r3, [r7, #12]
 8001300:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001304:	693b      	ldr	r3, [r7, #16]
 8001306:	0e1b      	lsrs	r3, r3, #24
 8001308:	009b      	lsls	r3, r3, #2
 800130a:	4413      	add	r3, r2
 800130c:	681a      	ldr	r2, [r3, #0]
 800130e:	68fb      	ldr	r3, [r7, #12]
 8001310:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001314:	69fb      	ldr	r3, [r7, #28]
 8001316:	0c1b      	lsrs	r3, r3, #16
 8001318:	b2db      	uxtb	r3, r3
 800131a:	009b      	lsls	r3, r3, #2
 800131c:	440b      	add	r3, r1
 800131e:	681b      	ldr	r3, [r3, #0]
 8001320:	405a      	eors	r2, r3
 8001322:	68fb      	ldr	r3, [r7, #12]
 8001324:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001328:	69bb      	ldr	r3, [r7, #24]
 800132a:	0a1b      	lsrs	r3, r3, #8
 800132c:	b2db      	uxtb	r3, r3
 800132e:	009b      	lsls	r3, r3, #2
 8001330:	440b      	add	r3, r1
 8001332:	681b      	ldr	r3, [r3, #0]
 8001334:	405a      	eors	r2, r3
 8001336:	68fb      	ldr	r3, [r7, #12]
 8001338:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800133c:	697b      	ldr	r3, [r7, #20]
 800133e:	b2db      	uxtb	r3, r3
 8001340:	009b      	lsls	r3, r3, #2
 8001342:	440b      	add	r3, r1
 8001344:	681b      	ldr	r3, [r3, #0]
 8001346:	405a      	eors	r2, r3
 8001348:	68bb      	ldr	r3, [r7, #8]
 800134a:	335c      	adds	r3, #92	; 0x5c
 800134c:	681b      	ldr	r3, [r3, #0]
 800134e:	4053      	eors	r3, r2
 8001350:	623b      	str	r3, [r7, #32]
    /* round 6: */
    s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[24];
 8001352:	68fb      	ldr	r3, [r7, #12]
 8001354:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001358:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800135a:	0e1b      	lsrs	r3, r3, #24
 800135c:	009b      	lsls	r3, r3, #2
 800135e:	4413      	add	r3, r2
 8001360:	681a      	ldr	r2, [r3, #0]
 8001362:	68fb      	ldr	r3, [r7, #12]
 8001364:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001368:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800136a:	0c1b      	lsrs	r3, r3, #16
 800136c:	b2db      	uxtb	r3, r3
 800136e:	009b      	lsls	r3, r3, #2
 8001370:	440b      	add	r3, r1
 8001372:	681b      	ldr	r3, [r3, #0]
 8001374:	405a      	eors	r2, r3
 8001376:	68fb      	ldr	r3, [r7, #12]
 8001378:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800137c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800137e:	0a1b      	lsrs	r3, r3, #8
 8001380:	b2db      	uxtb	r3, r3
 8001382:	009b      	lsls	r3, r3, #2
 8001384:	440b      	add	r3, r1
 8001386:	681b      	ldr	r3, [r3, #0]
 8001388:	405a      	eors	r2, r3
 800138a:	68fb      	ldr	r3, [r7, #12]
 800138c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001390:	6a3b      	ldr	r3, [r7, #32]
 8001392:	b2db      	uxtb	r3, r3
 8001394:	009b      	lsls	r3, r3, #2
 8001396:	440b      	add	r3, r1
 8001398:	681b      	ldr	r3, [r3, #0]
 800139a:	405a      	eors	r2, r3
 800139c:	68bb      	ldr	r3, [r7, #8]
 800139e:	3360      	adds	r3, #96	; 0x60
 80013a0:	681b      	ldr	r3, [r3, #0]
 80013a2:	4053      	eors	r3, r2
 80013a4:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[25];
 80013a6:	68fb      	ldr	r3, [r7, #12]
 80013a8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80013ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80013ae:	0e1b      	lsrs	r3, r3, #24
 80013b0:	009b      	lsls	r3, r3, #2
 80013b2:	4413      	add	r3, r2
 80013b4:	681a      	ldr	r2, [r3, #0]
 80013b6:	68fb      	ldr	r3, [r7, #12]
 80013b8:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80013bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80013be:	0c1b      	lsrs	r3, r3, #16
 80013c0:	b2db      	uxtb	r3, r3
 80013c2:	009b      	lsls	r3, r3, #2
 80013c4:	440b      	add	r3, r1
 80013c6:	681b      	ldr	r3, [r3, #0]
 80013c8:	405a      	eors	r2, r3
 80013ca:	68fb      	ldr	r3, [r7, #12]
 80013cc:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80013d0:	6a3b      	ldr	r3, [r7, #32]
 80013d2:	0a1b      	lsrs	r3, r3, #8
 80013d4:	b2db      	uxtb	r3, r3
 80013d6:	009b      	lsls	r3, r3, #2
 80013d8:	440b      	add	r3, r1
 80013da:	681b      	ldr	r3, [r3, #0]
 80013dc:	405a      	eors	r2, r3
 80013de:	68fb      	ldr	r3, [r7, #12]
 80013e0:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80013e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80013e6:	b2db      	uxtb	r3, r3
 80013e8:	009b      	lsls	r3, r3, #2
 80013ea:	440b      	add	r3, r1
 80013ec:	681b      	ldr	r3, [r3, #0]
 80013ee:	405a      	eors	r2, r3
 80013f0:	68bb      	ldr	r3, [r7, #8]
 80013f2:	3364      	adds	r3, #100	; 0x64
 80013f4:	681b      	ldr	r3, [r3, #0]
 80013f6:	4053      	eors	r3, r2
 80013f8:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[26];
 80013fa:	68fb      	ldr	r3, [r7, #12]
 80013fc:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001400:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001402:	0e1b      	lsrs	r3, r3, #24
 8001404:	009b      	lsls	r3, r3, #2
 8001406:	4413      	add	r3, r2
 8001408:	681a      	ldr	r2, [r3, #0]
 800140a:	68fb      	ldr	r3, [r7, #12]
 800140c:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001410:	6a3b      	ldr	r3, [r7, #32]
 8001412:	0c1b      	lsrs	r3, r3, #16
 8001414:	b2db      	uxtb	r3, r3
 8001416:	009b      	lsls	r3, r3, #2
 8001418:	440b      	add	r3, r1
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	405a      	eors	r2, r3
 800141e:	68fb      	ldr	r3, [r7, #12]
 8001420:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001424:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001426:	0a1b      	lsrs	r3, r3, #8
 8001428:	b2db      	uxtb	r3, r3
 800142a:	009b      	lsls	r3, r3, #2
 800142c:	440b      	add	r3, r1
 800142e:	681b      	ldr	r3, [r3, #0]
 8001430:	405a      	eors	r2, r3
 8001432:	68fb      	ldr	r3, [r7, #12]
 8001434:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001438:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800143a:	b2db      	uxtb	r3, r3
 800143c:	009b      	lsls	r3, r3, #2
 800143e:	440b      	add	r3, r1
 8001440:	681b      	ldr	r3, [r3, #0]
 8001442:	405a      	eors	r2, r3
 8001444:	68bb      	ldr	r3, [r7, #8]
 8001446:	3368      	adds	r3, #104	; 0x68
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	4053      	eors	r3, r2
 800144c:	617b      	str	r3, [r7, #20]
    s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[27];
 800144e:	68fb      	ldr	r3, [r7, #12]
 8001450:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001454:	6a3b      	ldr	r3, [r7, #32]
 8001456:	0e1b      	lsrs	r3, r3, #24
 8001458:	009b      	lsls	r3, r3, #2
 800145a:	4413      	add	r3, r2
 800145c:	681a      	ldr	r2, [r3, #0]
 800145e:	68fb      	ldr	r3, [r7, #12]
 8001460:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001464:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001466:	0c1b      	lsrs	r3, r3, #16
 8001468:	b2db      	uxtb	r3, r3
 800146a:	009b      	lsls	r3, r3, #2
 800146c:	440b      	add	r3, r1
 800146e:	681b      	ldr	r3, [r3, #0]
 8001470:	405a      	eors	r2, r3
 8001472:	68fb      	ldr	r3, [r7, #12]
 8001474:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001478:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800147a:	0a1b      	lsrs	r3, r3, #8
 800147c:	b2db      	uxtb	r3, r3
 800147e:	009b      	lsls	r3, r3, #2
 8001480:	440b      	add	r3, r1
 8001482:	681b      	ldr	r3, [r3, #0]
 8001484:	405a      	eors	r2, r3
 8001486:	68fb      	ldr	r3, [r7, #12]
 8001488:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800148c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800148e:	b2db      	uxtb	r3, r3
 8001490:	009b      	lsls	r3, r3, #2
 8001492:	440b      	add	r3, r1
 8001494:	681b      	ldr	r3, [r3, #0]
 8001496:	405a      	eors	r2, r3
 8001498:	68bb      	ldr	r3, [r7, #8]
 800149a:	336c      	adds	r3, #108	; 0x6c
 800149c:	681b      	ldr	r3, [r3, #0]
 800149e:	4053      	eors	r3, r2
 80014a0:	613b      	str	r3, [r7, #16]
    /* round 7: */
    t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[28];
 80014a2:	68fb      	ldr	r3, [r7, #12]
 80014a4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80014a8:	69fb      	ldr	r3, [r7, #28]
 80014aa:	0e1b      	lsrs	r3, r3, #24
 80014ac:	009b      	lsls	r3, r3, #2
 80014ae:	4413      	add	r3, r2
 80014b0:	681a      	ldr	r2, [r3, #0]
 80014b2:	68fb      	ldr	r3, [r7, #12]
 80014b4:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80014b8:	69bb      	ldr	r3, [r7, #24]
 80014ba:	0c1b      	lsrs	r3, r3, #16
 80014bc:	b2db      	uxtb	r3, r3
 80014be:	009b      	lsls	r3, r3, #2
 80014c0:	440b      	add	r3, r1
 80014c2:	681b      	ldr	r3, [r3, #0]
 80014c4:	405a      	eors	r2, r3
 80014c6:	68fb      	ldr	r3, [r7, #12]
 80014c8:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80014cc:	697b      	ldr	r3, [r7, #20]
 80014ce:	0a1b      	lsrs	r3, r3, #8
 80014d0:	b2db      	uxtb	r3, r3
 80014d2:	009b      	lsls	r3, r3, #2
 80014d4:	440b      	add	r3, r1
 80014d6:	681b      	ldr	r3, [r3, #0]
 80014d8:	405a      	eors	r2, r3
 80014da:	68fb      	ldr	r3, [r7, #12]
 80014dc:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80014e0:	693b      	ldr	r3, [r7, #16]
 80014e2:	b2db      	uxtb	r3, r3
 80014e4:	009b      	lsls	r3, r3, #2
 80014e6:	440b      	add	r3, r1
 80014e8:	681b      	ldr	r3, [r3, #0]
 80014ea:	405a      	eors	r2, r3
 80014ec:	68bb      	ldr	r3, [r7, #8]
 80014ee:	3370      	adds	r3, #112	; 0x70
 80014f0:	681b      	ldr	r3, [r3, #0]
 80014f2:	4053      	eors	r3, r2
 80014f4:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[29];
 80014f6:	68fb      	ldr	r3, [r7, #12]
 80014f8:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80014fc:	69bb      	ldr	r3, [r7, #24]
 80014fe:	0e1b      	lsrs	r3, r3, #24
 8001500:	009b      	lsls	r3, r3, #2
 8001502:	4413      	add	r3, r2
 8001504:	681a      	ldr	r2, [r3, #0]
 8001506:	68fb      	ldr	r3, [r7, #12]
 8001508:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 800150c:	697b      	ldr	r3, [r7, #20]
 800150e:	0c1b      	lsrs	r3, r3, #16
 8001510:	b2db      	uxtb	r3, r3
 8001512:	009b      	lsls	r3, r3, #2
 8001514:	440b      	add	r3, r1
 8001516:	681b      	ldr	r3, [r3, #0]
 8001518:	405a      	eors	r2, r3
 800151a:	68fb      	ldr	r3, [r7, #12]
 800151c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001520:	693b      	ldr	r3, [r7, #16]
 8001522:	0a1b      	lsrs	r3, r3, #8
 8001524:	b2db      	uxtb	r3, r3
 8001526:	009b      	lsls	r3, r3, #2
 8001528:	440b      	add	r3, r1
 800152a:	681b      	ldr	r3, [r3, #0]
 800152c:	405a      	eors	r2, r3
 800152e:	68fb      	ldr	r3, [r7, #12]
 8001530:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001534:	69fb      	ldr	r3, [r7, #28]
 8001536:	b2db      	uxtb	r3, r3
 8001538:	009b      	lsls	r3, r3, #2
 800153a:	440b      	add	r3, r1
 800153c:	681b      	ldr	r3, [r3, #0]
 800153e:	405a      	eors	r2, r3
 8001540:	68bb      	ldr	r3, [r7, #8]
 8001542:	3374      	adds	r3, #116	; 0x74
 8001544:	681b      	ldr	r3, [r3, #0]
 8001546:	4053      	eors	r3, r2
 8001548:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[30];
 800154a:	68fb      	ldr	r3, [r7, #12]
 800154c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001550:	697b      	ldr	r3, [r7, #20]
 8001552:	0e1b      	lsrs	r3, r3, #24
 8001554:	009b      	lsls	r3, r3, #2
 8001556:	4413      	add	r3, r2
 8001558:	681a      	ldr	r2, [r3, #0]
 800155a:	68fb      	ldr	r3, [r7, #12]
 800155c:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001560:	693b      	ldr	r3, [r7, #16]
 8001562:	0c1b      	lsrs	r3, r3, #16
 8001564:	b2db      	uxtb	r3, r3
 8001566:	009b      	lsls	r3, r3, #2
 8001568:	440b      	add	r3, r1
 800156a:	681b      	ldr	r3, [r3, #0]
 800156c:	405a      	eors	r2, r3
 800156e:	68fb      	ldr	r3, [r7, #12]
 8001570:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001574:	69fb      	ldr	r3, [r7, #28]
 8001576:	0a1b      	lsrs	r3, r3, #8
 8001578:	b2db      	uxtb	r3, r3
 800157a:	009b      	lsls	r3, r3, #2
 800157c:	440b      	add	r3, r1
 800157e:	681b      	ldr	r3, [r3, #0]
 8001580:	405a      	eors	r2, r3
 8001582:	68fb      	ldr	r3, [r7, #12]
 8001584:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001588:	69bb      	ldr	r3, [r7, #24]
 800158a:	b2db      	uxtb	r3, r3
 800158c:	009b      	lsls	r3, r3, #2
 800158e:	440b      	add	r3, r1
 8001590:	681b      	ldr	r3, [r3, #0]
 8001592:	405a      	eors	r2, r3
 8001594:	68bb      	ldr	r3, [r7, #8]
 8001596:	3378      	adds	r3, #120	; 0x78
 8001598:	681b      	ldr	r3, [r3, #0]
 800159a:	4053      	eors	r3, r2
 800159c:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[31];
 800159e:	68fb      	ldr	r3, [r7, #12]
 80015a0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80015a4:	693b      	ldr	r3, [r7, #16]
 80015a6:	0e1b      	lsrs	r3, r3, #24
 80015a8:	009b      	lsls	r3, r3, #2
 80015aa:	4413      	add	r3, r2
 80015ac:	681a      	ldr	r2, [r3, #0]
 80015ae:	68fb      	ldr	r3, [r7, #12]
 80015b0:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80015b4:	69fb      	ldr	r3, [r7, #28]
 80015b6:	0c1b      	lsrs	r3, r3, #16
 80015b8:	b2db      	uxtb	r3, r3
 80015ba:	009b      	lsls	r3, r3, #2
 80015bc:	440b      	add	r3, r1
 80015be:	681b      	ldr	r3, [r3, #0]
 80015c0:	405a      	eors	r2, r3
 80015c2:	68fb      	ldr	r3, [r7, #12]
 80015c4:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80015c8:	69bb      	ldr	r3, [r7, #24]
 80015ca:	0a1b      	lsrs	r3, r3, #8
 80015cc:	b2db      	uxtb	r3, r3
 80015ce:	009b      	lsls	r3, r3, #2
 80015d0:	440b      	add	r3, r1
 80015d2:	681b      	ldr	r3, [r3, #0]
 80015d4:	405a      	eors	r2, r3
 80015d6:	68fb      	ldr	r3, [r7, #12]
 80015d8:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80015dc:	697b      	ldr	r3, [r7, #20]
 80015de:	b2db      	uxtb	r3, r3
 80015e0:	009b      	lsls	r3, r3, #2
 80015e2:	440b      	add	r3, r1
 80015e4:	681b      	ldr	r3, [r3, #0]
 80015e6:	405a      	eors	r2, r3
 80015e8:	68bb      	ldr	r3, [r7, #8]
 80015ea:	337c      	adds	r3, #124	; 0x7c
 80015ec:	681b      	ldr	r3, [r3, #0]
 80015ee:	4053      	eors	r3, r2
 80015f0:	623b      	str	r3, [r7, #32]
    /* round 8: */
    s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[32];
 80015f2:	68fb      	ldr	r3, [r7, #12]
 80015f4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80015f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80015fa:	0e1b      	lsrs	r3, r3, #24
 80015fc:	009b      	lsls	r3, r3, #2
 80015fe:	4413      	add	r3, r2
 8001600:	681a      	ldr	r2, [r3, #0]
 8001602:	68fb      	ldr	r3, [r7, #12]
 8001604:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001608:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800160a:	0c1b      	lsrs	r3, r3, #16
 800160c:	b2db      	uxtb	r3, r3
 800160e:	009b      	lsls	r3, r3, #2
 8001610:	440b      	add	r3, r1
 8001612:	681b      	ldr	r3, [r3, #0]
 8001614:	405a      	eors	r2, r3
 8001616:	68fb      	ldr	r3, [r7, #12]
 8001618:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800161c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800161e:	0a1b      	lsrs	r3, r3, #8
 8001620:	b2db      	uxtb	r3, r3
 8001622:	009b      	lsls	r3, r3, #2
 8001624:	440b      	add	r3, r1
 8001626:	681b      	ldr	r3, [r3, #0]
 8001628:	405a      	eors	r2, r3
 800162a:	68fb      	ldr	r3, [r7, #12]
 800162c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001630:	6a3b      	ldr	r3, [r7, #32]
 8001632:	b2db      	uxtb	r3, r3
 8001634:	009b      	lsls	r3, r3, #2
 8001636:	440b      	add	r3, r1
 8001638:	681b      	ldr	r3, [r3, #0]
 800163a:	405a      	eors	r2, r3
 800163c:	68bb      	ldr	r3, [r7, #8]
 800163e:	3380      	adds	r3, #128	; 0x80
 8001640:	681b      	ldr	r3, [r3, #0]
 8001642:	4053      	eors	r3, r2
 8001644:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[33];
 8001646:	68fb      	ldr	r3, [r7, #12]
 8001648:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800164c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800164e:	0e1b      	lsrs	r3, r3, #24
 8001650:	009b      	lsls	r3, r3, #2
 8001652:	4413      	add	r3, r2
 8001654:	681a      	ldr	r2, [r3, #0]
 8001656:	68fb      	ldr	r3, [r7, #12]
 8001658:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 800165c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800165e:	0c1b      	lsrs	r3, r3, #16
 8001660:	b2db      	uxtb	r3, r3
 8001662:	009b      	lsls	r3, r3, #2
 8001664:	440b      	add	r3, r1
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	405a      	eors	r2, r3
 800166a:	68fb      	ldr	r3, [r7, #12]
 800166c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001670:	6a3b      	ldr	r3, [r7, #32]
 8001672:	0a1b      	lsrs	r3, r3, #8
 8001674:	b2db      	uxtb	r3, r3
 8001676:	009b      	lsls	r3, r3, #2
 8001678:	440b      	add	r3, r1
 800167a:	681b      	ldr	r3, [r3, #0]
 800167c:	405a      	eors	r2, r3
 800167e:	68fb      	ldr	r3, [r7, #12]
 8001680:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001686:	b2db      	uxtb	r3, r3
 8001688:	009b      	lsls	r3, r3, #2
 800168a:	440b      	add	r3, r1
 800168c:	681b      	ldr	r3, [r3, #0]
 800168e:	405a      	eors	r2, r3
 8001690:	68bb      	ldr	r3, [r7, #8]
 8001692:	3384      	adds	r3, #132	; 0x84
 8001694:	681b      	ldr	r3, [r3, #0]
 8001696:	4053      	eors	r3, r2
 8001698:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[34];
 800169a:	68fb      	ldr	r3, [r7, #12]
 800169c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80016a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80016a2:	0e1b      	lsrs	r3, r3, #24
 80016a4:	009b      	lsls	r3, r3, #2
 80016a6:	4413      	add	r3, r2
 80016a8:	681a      	ldr	r2, [r3, #0]
 80016aa:	68fb      	ldr	r3, [r7, #12]
 80016ac:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80016b0:	6a3b      	ldr	r3, [r7, #32]
 80016b2:	0c1b      	lsrs	r3, r3, #16
 80016b4:	b2db      	uxtb	r3, r3
 80016b6:	009b      	lsls	r3, r3, #2
 80016b8:	440b      	add	r3, r1
 80016ba:	681b      	ldr	r3, [r3, #0]
 80016bc:	405a      	eors	r2, r3
 80016be:	68fb      	ldr	r3, [r7, #12]
 80016c0:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80016c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80016c6:	0a1b      	lsrs	r3, r3, #8
 80016c8:	b2db      	uxtb	r3, r3
 80016ca:	009b      	lsls	r3, r3, #2
 80016cc:	440b      	add	r3, r1
 80016ce:	681b      	ldr	r3, [r3, #0]
 80016d0:	405a      	eors	r2, r3
 80016d2:	68fb      	ldr	r3, [r7, #12]
 80016d4:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80016d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80016da:	b2db      	uxtb	r3, r3
 80016dc:	009b      	lsls	r3, r3, #2
 80016de:	440b      	add	r3, r1
 80016e0:	681b      	ldr	r3, [r3, #0]
 80016e2:	405a      	eors	r2, r3
 80016e4:	68bb      	ldr	r3, [r7, #8]
 80016e6:	3388      	adds	r3, #136	; 0x88
 80016e8:	681b      	ldr	r3, [r3, #0]
 80016ea:	4053      	eors	r3, r2
 80016ec:	617b      	str	r3, [r7, #20]
    s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[35];
 80016ee:	68fb      	ldr	r3, [r7, #12]
 80016f0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80016f4:	6a3b      	ldr	r3, [r7, #32]
 80016f6:	0e1b      	lsrs	r3, r3, #24
 80016f8:	009b      	lsls	r3, r3, #2
 80016fa:	4413      	add	r3, r2
 80016fc:	681a      	ldr	r2, [r3, #0]
 80016fe:	68fb      	ldr	r3, [r7, #12]
 8001700:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001706:	0c1b      	lsrs	r3, r3, #16
 8001708:	b2db      	uxtb	r3, r3
 800170a:	009b      	lsls	r3, r3, #2
 800170c:	440b      	add	r3, r1
 800170e:	681b      	ldr	r3, [r3, #0]
 8001710:	405a      	eors	r2, r3
 8001712:	68fb      	ldr	r3, [r7, #12]
 8001714:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001718:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800171a:	0a1b      	lsrs	r3, r3, #8
 800171c:	b2db      	uxtb	r3, r3
 800171e:	009b      	lsls	r3, r3, #2
 8001720:	440b      	add	r3, r1
 8001722:	681b      	ldr	r3, [r3, #0]
 8001724:	405a      	eors	r2, r3
 8001726:	68fb      	ldr	r3, [r7, #12]
 8001728:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800172c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800172e:	b2db      	uxtb	r3, r3
 8001730:	009b      	lsls	r3, r3, #2
 8001732:	440b      	add	r3, r1
 8001734:	681b      	ldr	r3, [r3, #0]
 8001736:	405a      	eors	r2, r3
 8001738:	68bb      	ldr	r3, [r7, #8]
 800173a:	338c      	adds	r3, #140	; 0x8c
 800173c:	681b      	ldr	r3, [r3, #0]
 800173e:	4053      	eors	r3, r2
 8001740:	613b      	str	r3, [r7, #16]
    /* round 9: */
    t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[36];
 8001742:	68fb      	ldr	r3, [r7, #12]
 8001744:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001748:	69fb      	ldr	r3, [r7, #28]
 800174a:	0e1b      	lsrs	r3, r3, #24
 800174c:	009b      	lsls	r3, r3, #2
 800174e:	4413      	add	r3, r2
 8001750:	681a      	ldr	r2, [r3, #0]
 8001752:	68fb      	ldr	r3, [r7, #12]
 8001754:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001758:	69bb      	ldr	r3, [r7, #24]
 800175a:	0c1b      	lsrs	r3, r3, #16
 800175c:	b2db      	uxtb	r3, r3
 800175e:	009b      	lsls	r3, r3, #2
 8001760:	440b      	add	r3, r1
 8001762:	681b      	ldr	r3, [r3, #0]
 8001764:	405a      	eors	r2, r3
 8001766:	68fb      	ldr	r3, [r7, #12]
 8001768:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800176c:	697b      	ldr	r3, [r7, #20]
 800176e:	0a1b      	lsrs	r3, r3, #8
 8001770:	b2db      	uxtb	r3, r3
 8001772:	009b      	lsls	r3, r3, #2
 8001774:	440b      	add	r3, r1
 8001776:	681b      	ldr	r3, [r3, #0]
 8001778:	405a      	eors	r2, r3
 800177a:	68fb      	ldr	r3, [r7, #12]
 800177c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001780:	693b      	ldr	r3, [r7, #16]
 8001782:	b2db      	uxtb	r3, r3
 8001784:	009b      	lsls	r3, r3, #2
 8001786:	440b      	add	r3, r1
 8001788:	681b      	ldr	r3, [r3, #0]
 800178a:	405a      	eors	r2, r3
 800178c:	68bb      	ldr	r3, [r7, #8]
 800178e:	3390      	adds	r3, #144	; 0x90
 8001790:	681b      	ldr	r3, [r3, #0]
 8001792:	4053      	eors	r3, r2
 8001794:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[37];
 8001796:	68fb      	ldr	r3, [r7, #12]
 8001798:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800179c:	69bb      	ldr	r3, [r7, #24]
 800179e:	0e1b      	lsrs	r3, r3, #24
 80017a0:	009b      	lsls	r3, r3, #2
 80017a2:	4413      	add	r3, r2
 80017a4:	681a      	ldr	r2, [r3, #0]
 80017a6:	68fb      	ldr	r3, [r7, #12]
 80017a8:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80017ac:	697b      	ldr	r3, [r7, #20]
 80017ae:	0c1b      	lsrs	r3, r3, #16
 80017b0:	b2db      	uxtb	r3, r3
 80017b2:	009b      	lsls	r3, r3, #2
 80017b4:	440b      	add	r3, r1
 80017b6:	681b      	ldr	r3, [r3, #0]
 80017b8:	405a      	eors	r2, r3
 80017ba:	68fb      	ldr	r3, [r7, #12]
 80017bc:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80017c0:	693b      	ldr	r3, [r7, #16]
 80017c2:	0a1b      	lsrs	r3, r3, #8
 80017c4:	b2db      	uxtb	r3, r3
 80017c6:	009b      	lsls	r3, r3, #2
 80017c8:	440b      	add	r3, r1
 80017ca:	681b      	ldr	r3, [r3, #0]
 80017cc:	405a      	eors	r2, r3
 80017ce:	68fb      	ldr	r3, [r7, #12]
 80017d0:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80017d4:	69fb      	ldr	r3, [r7, #28]
 80017d6:	b2db      	uxtb	r3, r3
 80017d8:	009b      	lsls	r3, r3, #2
 80017da:	440b      	add	r3, r1
 80017dc:	681b      	ldr	r3, [r3, #0]
 80017de:	405a      	eors	r2, r3
 80017e0:	68bb      	ldr	r3, [r7, #8]
 80017e2:	3394      	adds	r3, #148	; 0x94
 80017e4:	681b      	ldr	r3, [r3, #0]
 80017e6:	4053      	eors	r3, r2
 80017e8:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[38];
 80017ea:	68fb      	ldr	r3, [r7, #12]
 80017ec:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80017f0:	697b      	ldr	r3, [r7, #20]
 80017f2:	0e1b      	lsrs	r3, r3, #24
 80017f4:	009b      	lsls	r3, r3, #2
 80017f6:	4413      	add	r3, r2
 80017f8:	681a      	ldr	r2, [r3, #0]
 80017fa:	68fb      	ldr	r3, [r7, #12]
 80017fc:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001800:	693b      	ldr	r3, [r7, #16]
 8001802:	0c1b      	lsrs	r3, r3, #16
 8001804:	b2db      	uxtb	r3, r3
 8001806:	009b      	lsls	r3, r3, #2
 8001808:	440b      	add	r3, r1
 800180a:	681b      	ldr	r3, [r3, #0]
 800180c:	405a      	eors	r2, r3
 800180e:	68fb      	ldr	r3, [r7, #12]
 8001810:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001814:	69fb      	ldr	r3, [r7, #28]
 8001816:	0a1b      	lsrs	r3, r3, #8
 8001818:	b2db      	uxtb	r3, r3
 800181a:	009b      	lsls	r3, r3, #2
 800181c:	440b      	add	r3, r1
 800181e:	681b      	ldr	r3, [r3, #0]
 8001820:	405a      	eors	r2, r3
 8001822:	68fb      	ldr	r3, [r7, #12]
 8001824:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001828:	69bb      	ldr	r3, [r7, #24]
 800182a:	b2db      	uxtb	r3, r3
 800182c:	009b      	lsls	r3, r3, #2
 800182e:	440b      	add	r3, r1
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	405a      	eors	r2, r3
 8001834:	68bb      	ldr	r3, [r7, #8]
 8001836:	3398      	adds	r3, #152	; 0x98
 8001838:	681b      	ldr	r3, [r3, #0]
 800183a:	4053      	eors	r3, r2
 800183c:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[39];
 800183e:	68fb      	ldr	r3, [r7, #12]
 8001840:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001844:	693b      	ldr	r3, [r7, #16]
 8001846:	0e1b      	lsrs	r3, r3, #24
 8001848:	009b      	lsls	r3, r3, #2
 800184a:	4413      	add	r3, r2
 800184c:	681a      	ldr	r2, [r3, #0]
 800184e:	68fb      	ldr	r3, [r7, #12]
 8001850:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001854:	69fb      	ldr	r3, [r7, #28]
 8001856:	0c1b      	lsrs	r3, r3, #16
 8001858:	b2db      	uxtb	r3, r3
 800185a:	009b      	lsls	r3, r3, #2
 800185c:	440b      	add	r3, r1
 800185e:	681b      	ldr	r3, [r3, #0]
 8001860:	405a      	eors	r2, r3
 8001862:	68fb      	ldr	r3, [r7, #12]
 8001864:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001868:	69bb      	ldr	r3, [r7, #24]
 800186a:	0a1b      	lsrs	r3, r3, #8
 800186c:	b2db      	uxtb	r3, r3
 800186e:	009b      	lsls	r3, r3, #2
 8001870:	440b      	add	r3, r1
 8001872:	681b      	ldr	r3, [r3, #0]
 8001874:	405a      	eors	r2, r3
 8001876:	68fb      	ldr	r3, [r7, #12]
 8001878:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800187c:	697b      	ldr	r3, [r7, #20]
 800187e:	b2db      	uxtb	r3, r3
 8001880:	009b      	lsls	r3, r3, #2
 8001882:	440b      	add	r3, r1
 8001884:	681b      	ldr	r3, [r3, #0]
 8001886:	405a      	eors	r2, r3
 8001888:	68bb      	ldr	r3, [r7, #8]
 800188a:	339c      	adds	r3, #156	; 0x9c
 800188c:	681b      	ldr	r3, [r3, #0]
 800188e:	4053      	eors	r3, r2
 8001890:	623b      	str	r3, [r7, #32]
    if (Nr > 10) {
 8001892:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8001896:	2b0a      	cmp	r3, #10
 8001898:	f340 82a5 	ble.w	8001de6 <B5_rijndaelEncrypt+0x1186>
        /* round 10: */
        s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[40];
 800189c:	68fb      	ldr	r3, [r7, #12]
 800189e:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80018a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80018a4:	0e1b      	lsrs	r3, r3, #24
 80018a6:	009b      	lsls	r3, r3, #2
 80018a8:	4413      	add	r3, r2
 80018aa:	681a      	ldr	r2, [r3, #0]
 80018ac:	68fb      	ldr	r3, [r7, #12]
 80018ae:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80018b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80018b4:	0c1b      	lsrs	r3, r3, #16
 80018b6:	b2db      	uxtb	r3, r3
 80018b8:	009b      	lsls	r3, r3, #2
 80018ba:	440b      	add	r3, r1
 80018bc:	681b      	ldr	r3, [r3, #0]
 80018be:	405a      	eors	r2, r3
 80018c0:	68fb      	ldr	r3, [r7, #12]
 80018c2:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80018c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80018c8:	0a1b      	lsrs	r3, r3, #8
 80018ca:	b2db      	uxtb	r3, r3
 80018cc:	009b      	lsls	r3, r3, #2
 80018ce:	440b      	add	r3, r1
 80018d0:	681b      	ldr	r3, [r3, #0]
 80018d2:	405a      	eors	r2, r3
 80018d4:	68fb      	ldr	r3, [r7, #12]
 80018d6:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80018da:	6a3b      	ldr	r3, [r7, #32]
 80018dc:	b2db      	uxtb	r3, r3
 80018de:	009b      	lsls	r3, r3, #2
 80018e0:	440b      	add	r3, r1
 80018e2:	681b      	ldr	r3, [r3, #0]
 80018e4:	405a      	eors	r2, r3
 80018e6:	68bb      	ldr	r3, [r7, #8]
 80018e8:	33a0      	adds	r3, #160	; 0xa0
 80018ea:	681b      	ldr	r3, [r3, #0]
 80018ec:	4053      	eors	r3, r2
 80018ee:	61fb      	str	r3, [r7, #28]
        s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[41];
 80018f0:	68fb      	ldr	r3, [r7, #12]
 80018f2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80018f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80018f8:	0e1b      	lsrs	r3, r3, #24
 80018fa:	009b      	lsls	r3, r3, #2
 80018fc:	4413      	add	r3, r2
 80018fe:	681a      	ldr	r2, [r3, #0]
 8001900:	68fb      	ldr	r3, [r7, #12]
 8001902:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001906:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001908:	0c1b      	lsrs	r3, r3, #16
 800190a:	b2db      	uxtb	r3, r3
 800190c:	009b      	lsls	r3, r3, #2
 800190e:	440b      	add	r3, r1
 8001910:	681b      	ldr	r3, [r3, #0]
 8001912:	405a      	eors	r2, r3
 8001914:	68fb      	ldr	r3, [r7, #12]
 8001916:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800191a:	6a3b      	ldr	r3, [r7, #32]
 800191c:	0a1b      	lsrs	r3, r3, #8
 800191e:	b2db      	uxtb	r3, r3
 8001920:	009b      	lsls	r3, r3, #2
 8001922:	440b      	add	r3, r1
 8001924:	681b      	ldr	r3, [r3, #0]
 8001926:	405a      	eors	r2, r3
 8001928:	68fb      	ldr	r3, [r7, #12]
 800192a:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 800192e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001930:	b2db      	uxtb	r3, r3
 8001932:	009b      	lsls	r3, r3, #2
 8001934:	440b      	add	r3, r1
 8001936:	681b      	ldr	r3, [r3, #0]
 8001938:	405a      	eors	r2, r3
 800193a:	68bb      	ldr	r3, [r7, #8]
 800193c:	33a4      	adds	r3, #164	; 0xa4
 800193e:	681b      	ldr	r3, [r3, #0]
 8001940:	4053      	eors	r3, r2
 8001942:	61bb      	str	r3, [r7, #24]
        s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[42];
 8001944:	68fb      	ldr	r3, [r7, #12]
 8001946:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800194a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800194c:	0e1b      	lsrs	r3, r3, #24
 800194e:	009b      	lsls	r3, r3, #2
 8001950:	4413      	add	r3, r2
 8001952:	681a      	ldr	r2, [r3, #0]
 8001954:	68fb      	ldr	r3, [r7, #12]
 8001956:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 800195a:	6a3b      	ldr	r3, [r7, #32]
 800195c:	0c1b      	lsrs	r3, r3, #16
 800195e:	b2db      	uxtb	r3, r3
 8001960:	009b      	lsls	r3, r3, #2
 8001962:	440b      	add	r3, r1
 8001964:	681b      	ldr	r3, [r3, #0]
 8001966:	405a      	eors	r2, r3
 8001968:	68fb      	ldr	r3, [r7, #12]
 800196a:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 800196e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001970:	0a1b      	lsrs	r3, r3, #8
 8001972:	b2db      	uxtb	r3, r3
 8001974:	009b      	lsls	r3, r3, #2
 8001976:	440b      	add	r3, r1
 8001978:	681b      	ldr	r3, [r3, #0]
 800197a:	405a      	eors	r2, r3
 800197c:	68fb      	ldr	r3, [r7, #12]
 800197e:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001982:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001984:	b2db      	uxtb	r3, r3
 8001986:	009b      	lsls	r3, r3, #2
 8001988:	440b      	add	r3, r1
 800198a:	681b      	ldr	r3, [r3, #0]
 800198c:	405a      	eors	r2, r3
 800198e:	68bb      	ldr	r3, [r7, #8]
 8001990:	33a8      	adds	r3, #168	; 0xa8
 8001992:	681b      	ldr	r3, [r3, #0]
 8001994:	4053      	eors	r3, r2
 8001996:	617b      	str	r3, [r7, #20]
        s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[43];
 8001998:	68fb      	ldr	r3, [r7, #12]
 800199a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800199e:	6a3b      	ldr	r3, [r7, #32]
 80019a0:	0e1b      	lsrs	r3, r3, #24
 80019a2:	009b      	lsls	r3, r3, #2
 80019a4:	4413      	add	r3, r2
 80019a6:	681a      	ldr	r2, [r3, #0]
 80019a8:	68fb      	ldr	r3, [r7, #12]
 80019aa:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 80019ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80019b0:	0c1b      	lsrs	r3, r3, #16
 80019b2:	b2db      	uxtb	r3, r3
 80019b4:	009b      	lsls	r3, r3, #2
 80019b6:	440b      	add	r3, r1
 80019b8:	681b      	ldr	r3, [r3, #0]
 80019ba:	405a      	eors	r2, r3
 80019bc:	68fb      	ldr	r3, [r7, #12]
 80019be:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 80019c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80019c4:	0a1b      	lsrs	r3, r3, #8
 80019c6:	b2db      	uxtb	r3, r3
 80019c8:	009b      	lsls	r3, r3, #2
 80019ca:	440b      	add	r3, r1
 80019cc:	681b      	ldr	r3, [r3, #0]
 80019ce:	405a      	eors	r2, r3
 80019d0:	68fb      	ldr	r3, [r7, #12]
 80019d2:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 80019d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80019d8:	b2db      	uxtb	r3, r3
 80019da:	009b      	lsls	r3, r3, #2
 80019dc:	440b      	add	r3, r1
 80019de:	681b      	ldr	r3, [r3, #0]
 80019e0:	405a      	eors	r2, r3
 80019e2:	68bb      	ldr	r3, [r7, #8]
 80019e4:	33ac      	adds	r3, #172	; 0xac
 80019e6:	681b      	ldr	r3, [r3, #0]
 80019e8:	4053      	eors	r3, r2
 80019ea:	613b      	str	r3, [r7, #16]
        /* round 11: */
        t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[44];
 80019ec:	68fb      	ldr	r3, [r7, #12]
 80019ee:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 80019f2:	69fb      	ldr	r3, [r7, #28]
 80019f4:	0e1b      	lsrs	r3, r3, #24
 80019f6:	009b      	lsls	r3, r3, #2
 80019f8:	4413      	add	r3, r2
 80019fa:	681a      	ldr	r2, [r3, #0]
 80019fc:	68fb      	ldr	r3, [r7, #12]
 80019fe:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001a02:	69bb      	ldr	r3, [r7, #24]
 8001a04:	0c1b      	lsrs	r3, r3, #16
 8001a06:	b2db      	uxtb	r3, r3
 8001a08:	009b      	lsls	r3, r3, #2
 8001a0a:	440b      	add	r3, r1
 8001a0c:	681b      	ldr	r3, [r3, #0]
 8001a0e:	405a      	eors	r2, r3
 8001a10:	68fb      	ldr	r3, [r7, #12]
 8001a12:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001a16:	697b      	ldr	r3, [r7, #20]
 8001a18:	0a1b      	lsrs	r3, r3, #8
 8001a1a:	b2db      	uxtb	r3, r3
 8001a1c:	009b      	lsls	r3, r3, #2
 8001a1e:	440b      	add	r3, r1
 8001a20:	681b      	ldr	r3, [r3, #0]
 8001a22:	405a      	eors	r2, r3
 8001a24:	68fb      	ldr	r3, [r7, #12]
 8001a26:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001a2a:	693b      	ldr	r3, [r7, #16]
 8001a2c:	b2db      	uxtb	r3, r3
 8001a2e:	009b      	lsls	r3, r3, #2
 8001a30:	440b      	add	r3, r1
 8001a32:	681b      	ldr	r3, [r3, #0]
 8001a34:	405a      	eors	r2, r3
 8001a36:	68bb      	ldr	r3, [r7, #8]
 8001a38:	33b0      	adds	r3, #176	; 0xb0
 8001a3a:	681b      	ldr	r3, [r3, #0]
 8001a3c:	4053      	eors	r3, r2
 8001a3e:	62fb      	str	r3, [r7, #44]	; 0x2c
        t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[45];
 8001a40:	68fb      	ldr	r3, [r7, #12]
 8001a42:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001a46:	69bb      	ldr	r3, [r7, #24]
 8001a48:	0e1b      	lsrs	r3, r3, #24
 8001a4a:	009b      	lsls	r3, r3, #2
 8001a4c:	4413      	add	r3, r2
 8001a4e:	681a      	ldr	r2, [r3, #0]
 8001a50:	68fb      	ldr	r3, [r7, #12]
 8001a52:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001a56:	697b      	ldr	r3, [r7, #20]
 8001a58:	0c1b      	lsrs	r3, r3, #16
 8001a5a:	b2db      	uxtb	r3, r3
 8001a5c:	009b      	lsls	r3, r3, #2
 8001a5e:	440b      	add	r3, r1
 8001a60:	681b      	ldr	r3, [r3, #0]
 8001a62:	405a      	eors	r2, r3
 8001a64:	68fb      	ldr	r3, [r7, #12]
 8001a66:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001a6a:	693b      	ldr	r3, [r7, #16]
 8001a6c:	0a1b      	lsrs	r3, r3, #8
 8001a6e:	b2db      	uxtb	r3, r3
 8001a70:	009b      	lsls	r3, r3, #2
 8001a72:	440b      	add	r3, r1
 8001a74:	681b      	ldr	r3, [r3, #0]
 8001a76:	405a      	eors	r2, r3
 8001a78:	68fb      	ldr	r3, [r7, #12]
 8001a7a:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001a7e:	69fb      	ldr	r3, [r7, #28]
 8001a80:	b2db      	uxtb	r3, r3
 8001a82:	009b      	lsls	r3, r3, #2
 8001a84:	440b      	add	r3, r1
 8001a86:	681b      	ldr	r3, [r3, #0]
 8001a88:	405a      	eors	r2, r3
 8001a8a:	68bb      	ldr	r3, [r7, #8]
 8001a8c:	33b4      	adds	r3, #180	; 0xb4
 8001a8e:	681b      	ldr	r3, [r3, #0]
 8001a90:	4053      	eors	r3, r2
 8001a92:	62bb      	str	r3, [r7, #40]	; 0x28
        t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[46];
 8001a94:	68fb      	ldr	r3, [r7, #12]
 8001a96:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001a9a:	697b      	ldr	r3, [r7, #20]
 8001a9c:	0e1b      	lsrs	r3, r3, #24
 8001a9e:	009b      	lsls	r3, r3, #2
 8001aa0:	4413      	add	r3, r2
 8001aa2:	681a      	ldr	r2, [r3, #0]
 8001aa4:	68fb      	ldr	r3, [r7, #12]
 8001aa6:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001aaa:	693b      	ldr	r3, [r7, #16]
 8001aac:	0c1b      	lsrs	r3, r3, #16
 8001aae:	b2db      	uxtb	r3, r3
 8001ab0:	009b      	lsls	r3, r3, #2
 8001ab2:	440b      	add	r3, r1
 8001ab4:	681b      	ldr	r3, [r3, #0]
 8001ab6:	405a      	eors	r2, r3
 8001ab8:	68fb      	ldr	r3, [r7, #12]
 8001aba:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001abe:	69fb      	ldr	r3, [r7, #28]
 8001ac0:	0a1b      	lsrs	r3, r3, #8
 8001ac2:	b2db      	uxtb	r3, r3
 8001ac4:	009b      	lsls	r3, r3, #2
 8001ac6:	440b      	add	r3, r1
 8001ac8:	681b      	ldr	r3, [r3, #0]
 8001aca:	405a      	eors	r2, r3
 8001acc:	68fb      	ldr	r3, [r7, #12]
 8001ace:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001ad2:	69bb      	ldr	r3, [r7, #24]
 8001ad4:	b2db      	uxtb	r3, r3
 8001ad6:	009b      	lsls	r3, r3, #2
 8001ad8:	440b      	add	r3, r1
 8001ada:	681b      	ldr	r3, [r3, #0]
 8001adc:	405a      	eors	r2, r3
 8001ade:	68bb      	ldr	r3, [r7, #8]
 8001ae0:	33b8      	adds	r3, #184	; 0xb8
 8001ae2:	681b      	ldr	r3, [r3, #0]
 8001ae4:	4053      	eors	r3, r2
 8001ae6:	627b      	str	r3, [r7, #36]	; 0x24
        t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[47];
 8001ae8:	68fb      	ldr	r3, [r7, #12]
 8001aea:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001aee:	693b      	ldr	r3, [r7, #16]
 8001af0:	0e1b      	lsrs	r3, r3, #24
 8001af2:	009b      	lsls	r3, r3, #2
 8001af4:	4413      	add	r3, r2
 8001af6:	681a      	ldr	r2, [r3, #0]
 8001af8:	68fb      	ldr	r3, [r7, #12]
 8001afa:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001afe:	69fb      	ldr	r3, [r7, #28]
 8001b00:	0c1b      	lsrs	r3, r3, #16
 8001b02:	b2db      	uxtb	r3, r3
 8001b04:	009b      	lsls	r3, r3, #2
 8001b06:	440b      	add	r3, r1
 8001b08:	681b      	ldr	r3, [r3, #0]
 8001b0a:	405a      	eors	r2, r3
 8001b0c:	68fb      	ldr	r3, [r7, #12]
 8001b0e:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001b12:	69bb      	ldr	r3, [r7, #24]
 8001b14:	0a1b      	lsrs	r3, r3, #8
 8001b16:	b2db      	uxtb	r3, r3
 8001b18:	009b      	lsls	r3, r3, #2
 8001b1a:	440b      	add	r3, r1
 8001b1c:	681b      	ldr	r3, [r3, #0]
 8001b1e:	405a      	eors	r2, r3
 8001b20:	68fb      	ldr	r3, [r7, #12]
 8001b22:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001b26:	697b      	ldr	r3, [r7, #20]
 8001b28:	b2db      	uxtb	r3, r3
 8001b2a:	009b      	lsls	r3, r3, #2
 8001b2c:	440b      	add	r3, r1
 8001b2e:	681b      	ldr	r3, [r3, #0]
 8001b30:	405a      	eors	r2, r3
 8001b32:	68bb      	ldr	r3, [r7, #8]
 8001b34:	33bc      	adds	r3, #188	; 0xbc
 8001b36:	681b      	ldr	r3, [r3, #0]
 8001b38:	4053      	eors	r3, r2
 8001b3a:	623b      	str	r3, [r7, #32]
        if (Nr > 12) {
 8001b3c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8001b40:	2b0c      	cmp	r3, #12
 8001b42:	f340 8150 	ble.w	8001de6 <B5_rijndaelEncrypt+0x1186>
            /* round 12: */
            s0 = ctx->Te0[t0 >> 24] ^ ctx->Te1[(t1 >> 16) & 0xff] ^ ctx->Te2[(t2 >>  8) & 0xff] ^ ctx->Te3[t3 & 0xff] ^ rk[48];
 8001b46:	68fb      	ldr	r3, [r7, #12]
 8001b48:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001b4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001b4e:	0e1b      	lsrs	r3, r3, #24
 8001b50:	009b      	lsls	r3, r3, #2
 8001b52:	4413      	add	r3, r2
 8001b54:	681a      	ldr	r2, [r3, #0]
 8001b56:	68fb      	ldr	r3, [r7, #12]
 8001b58:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001b5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001b5e:	0c1b      	lsrs	r3, r3, #16
 8001b60:	b2db      	uxtb	r3, r3
 8001b62:	009b      	lsls	r3, r3, #2
 8001b64:	440b      	add	r3, r1
 8001b66:	681b      	ldr	r3, [r3, #0]
 8001b68:	405a      	eors	r2, r3
 8001b6a:	68fb      	ldr	r3, [r7, #12]
 8001b6c:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001b70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001b72:	0a1b      	lsrs	r3, r3, #8
 8001b74:	b2db      	uxtb	r3, r3
 8001b76:	009b      	lsls	r3, r3, #2
 8001b78:	440b      	add	r3, r1
 8001b7a:	681b      	ldr	r3, [r3, #0]
 8001b7c:	405a      	eors	r2, r3
 8001b7e:	68fb      	ldr	r3, [r7, #12]
 8001b80:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001b84:	6a3b      	ldr	r3, [r7, #32]
 8001b86:	b2db      	uxtb	r3, r3
 8001b88:	009b      	lsls	r3, r3, #2
 8001b8a:	440b      	add	r3, r1
 8001b8c:	681b      	ldr	r3, [r3, #0]
 8001b8e:	405a      	eors	r2, r3
 8001b90:	68bb      	ldr	r3, [r7, #8]
 8001b92:	33c0      	adds	r3, #192	; 0xc0
 8001b94:	681b      	ldr	r3, [r3, #0]
 8001b96:	4053      	eors	r3, r2
 8001b98:	61fb      	str	r3, [r7, #28]
            s1 = ctx->Te0[t1 >> 24] ^ ctx->Te1[(t2 >> 16) & 0xff] ^ ctx->Te2[(t3 >>  8) & 0xff] ^ ctx->Te3[t0 & 0xff] ^ rk[49];
 8001b9a:	68fb      	ldr	r3, [r7, #12]
 8001b9c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001ba0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001ba2:	0e1b      	lsrs	r3, r3, #24
 8001ba4:	009b      	lsls	r3, r3, #2
 8001ba6:	4413      	add	r3, r2
 8001ba8:	681a      	ldr	r2, [r3, #0]
 8001baa:	68fb      	ldr	r3, [r7, #12]
 8001bac:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001bb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001bb2:	0c1b      	lsrs	r3, r3, #16
 8001bb4:	b2db      	uxtb	r3, r3
 8001bb6:	009b      	lsls	r3, r3, #2
 8001bb8:	440b      	add	r3, r1
 8001bba:	681b      	ldr	r3, [r3, #0]
 8001bbc:	405a      	eors	r2, r3
 8001bbe:	68fb      	ldr	r3, [r7, #12]
 8001bc0:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001bc4:	6a3b      	ldr	r3, [r7, #32]
 8001bc6:	0a1b      	lsrs	r3, r3, #8
 8001bc8:	b2db      	uxtb	r3, r3
 8001bca:	009b      	lsls	r3, r3, #2
 8001bcc:	440b      	add	r3, r1
 8001bce:	681b      	ldr	r3, [r3, #0]
 8001bd0:	405a      	eors	r2, r3
 8001bd2:	68fb      	ldr	r3, [r7, #12]
 8001bd4:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001bd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001bda:	b2db      	uxtb	r3, r3
 8001bdc:	009b      	lsls	r3, r3, #2
 8001bde:	440b      	add	r3, r1
 8001be0:	681b      	ldr	r3, [r3, #0]
 8001be2:	405a      	eors	r2, r3
 8001be4:	68bb      	ldr	r3, [r7, #8]
 8001be6:	33c4      	adds	r3, #196	; 0xc4
 8001be8:	681b      	ldr	r3, [r3, #0]
 8001bea:	4053      	eors	r3, r2
 8001bec:	61bb      	str	r3, [r7, #24]
            s2 = ctx->Te0[t2 >> 24] ^ ctx->Te1[(t3 >> 16) & 0xff] ^ ctx->Te2[(t0 >>  8) & 0xff] ^ ctx->Te3[t1 & 0xff] ^ rk[50];
 8001bee:	68fb      	ldr	r3, [r7, #12]
 8001bf0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001bf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001bf6:	0e1b      	lsrs	r3, r3, #24
 8001bf8:	009b      	lsls	r3, r3, #2
 8001bfa:	4413      	add	r3, r2
 8001bfc:	681a      	ldr	r2, [r3, #0]
 8001bfe:	68fb      	ldr	r3, [r7, #12]
 8001c00:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001c04:	6a3b      	ldr	r3, [r7, #32]
 8001c06:	0c1b      	lsrs	r3, r3, #16
 8001c08:	b2db      	uxtb	r3, r3
 8001c0a:	009b      	lsls	r3, r3, #2
 8001c0c:	440b      	add	r3, r1
 8001c0e:	681b      	ldr	r3, [r3, #0]
 8001c10:	405a      	eors	r2, r3
 8001c12:	68fb      	ldr	r3, [r7, #12]
 8001c14:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001c18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c1a:	0a1b      	lsrs	r3, r3, #8
 8001c1c:	b2db      	uxtb	r3, r3
 8001c1e:	009b      	lsls	r3, r3, #2
 8001c20:	440b      	add	r3, r1
 8001c22:	681b      	ldr	r3, [r3, #0]
 8001c24:	405a      	eors	r2, r3
 8001c26:	68fb      	ldr	r3, [r7, #12]
 8001c28:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001c2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001c2e:	b2db      	uxtb	r3, r3
 8001c30:	009b      	lsls	r3, r3, #2
 8001c32:	440b      	add	r3, r1
 8001c34:	681b      	ldr	r3, [r3, #0]
 8001c36:	405a      	eors	r2, r3
 8001c38:	68bb      	ldr	r3, [r7, #8]
 8001c3a:	33c8      	adds	r3, #200	; 0xc8
 8001c3c:	681b      	ldr	r3, [r3, #0]
 8001c3e:	4053      	eors	r3, r2
 8001c40:	617b      	str	r3, [r7, #20]
            s3 = ctx->Te0[t3 >> 24] ^ ctx->Te1[(t0 >> 16) & 0xff] ^ ctx->Te2[(t1 >>  8) & 0xff] ^ ctx->Te3[t2 & 0xff] ^ rk[51];
 8001c42:	68fb      	ldr	r3, [r7, #12]
 8001c44:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001c48:	6a3b      	ldr	r3, [r7, #32]
 8001c4a:	0e1b      	lsrs	r3, r3, #24
 8001c4c:	009b      	lsls	r3, r3, #2
 8001c4e:	4413      	add	r3, r2
 8001c50:	681a      	ldr	r2, [r3, #0]
 8001c52:	68fb      	ldr	r3, [r7, #12]
 8001c54:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001c58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001c5a:	0c1b      	lsrs	r3, r3, #16
 8001c5c:	b2db      	uxtb	r3, r3
 8001c5e:	009b      	lsls	r3, r3, #2
 8001c60:	440b      	add	r3, r1
 8001c62:	681b      	ldr	r3, [r3, #0]
 8001c64:	405a      	eors	r2, r3
 8001c66:	68fb      	ldr	r3, [r7, #12]
 8001c68:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001c6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001c6e:	0a1b      	lsrs	r3, r3, #8
 8001c70:	b2db      	uxtb	r3, r3
 8001c72:	009b      	lsls	r3, r3, #2
 8001c74:	440b      	add	r3, r1
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	405a      	eors	r2, r3
 8001c7a:	68fb      	ldr	r3, [r7, #12]
 8001c7c:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001c80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001c82:	b2db      	uxtb	r3, r3
 8001c84:	009b      	lsls	r3, r3, #2
 8001c86:	440b      	add	r3, r1
 8001c88:	681b      	ldr	r3, [r3, #0]
 8001c8a:	405a      	eors	r2, r3
 8001c8c:	68bb      	ldr	r3, [r7, #8]
 8001c8e:	33cc      	adds	r3, #204	; 0xcc
 8001c90:	681b      	ldr	r3, [r3, #0]
 8001c92:	4053      	eors	r3, r2
 8001c94:	613b      	str	r3, [r7, #16]
            /* round 13: */
            t0 = ctx->Te0[s0 >> 24] ^ ctx->Te1[(s1 >> 16) & 0xff] ^ ctx->Te2[(s2 >>  8) & 0xff] ^ ctx->Te3[s3 & 0xff] ^ rk[52];
 8001c96:	68fb      	ldr	r3, [r7, #12]
 8001c98:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001c9c:	69fb      	ldr	r3, [r7, #28]
 8001c9e:	0e1b      	lsrs	r3, r3, #24
 8001ca0:	009b      	lsls	r3, r3, #2
 8001ca2:	4413      	add	r3, r2
 8001ca4:	681a      	ldr	r2, [r3, #0]
 8001ca6:	68fb      	ldr	r3, [r7, #12]
 8001ca8:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001cac:	69bb      	ldr	r3, [r7, #24]
 8001cae:	0c1b      	lsrs	r3, r3, #16
 8001cb0:	b2db      	uxtb	r3, r3
 8001cb2:	009b      	lsls	r3, r3, #2
 8001cb4:	440b      	add	r3, r1
 8001cb6:	681b      	ldr	r3, [r3, #0]
 8001cb8:	405a      	eors	r2, r3
 8001cba:	68fb      	ldr	r3, [r7, #12]
 8001cbc:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001cc0:	697b      	ldr	r3, [r7, #20]
 8001cc2:	0a1b      	lsrs	r3, r3, #8
 8001cc4:	b2db      	uxtb	r3, r3
 8001cc6:	009b      	lsls	r3, r3, #2
 8001cc8:	440b      	add	r3, r1
 8001cca:	681b      	ldr	r3, [r3, #0]
 8001ccc:	405a      	eors	r2, r3
 8001cce:	68fb      	ldr	r3, [r7, #12]
 8001cd0:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001cd4:	693b      	ldr	r3, [r7, #16]
 8001cd6:	b2db      	uxtb	r3, r3
 8001cd8:	009b      	lsls	r3, r3, #2
 8001cda:	440b      	add	r3, r1
 8001cdc:	681b      	ldr	r3, [r3, #0]
 8001cde:	405a      	eors	r2, r3
 8001ce0:	68bb      	ldr	r3, [r7, #8]
 8001ce2:	33d0      	adds	r3, #208	; 0xd0
 8001ce4:	681b      	ldr	r3, [r3, #0]
 8001ce6:	4053      	eors	r3, r2
 8001ce8:	62fb      	str	r3, [r7, #44]	; 0x2c
            t1 = ctx->Te0[s1 >> 24] ^ ctx->Te1[(s2 >> 16) & 0xff] ^ ctx->Te2[(s3 >>  8) & 0xff] ^ ctx->Te3[s0 & 0xff] ^ rk[53];
 8001cea:	68fb      	ldr	r3, [r7, #12]
 8001cec:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001cf0:	69bb      	ldr	r3, [r7, #24]
 8001cf2:	0e1b      	lsrs	r3, r3, #24
 8001cf4:	009b      	lsls	r3, r3, #2
 8001cf6:	4413      	add	r3, r2
 8001cf8:	681a      	ldr	r2, [r3, #0]
 8001cfa:	68fb      	ldr	r3, [r7, #12]
 8001cfc:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001d00:	697b      	ldr	r3, [r7, #20]
 8001d02:	0c1b      	lsrs	r3, r3, #16
 8001d04:	b2db      	uxtb	r3, r3
 8001d06:	009b      	lsls	r3, r3, #2
 8001d08:	440b      	add	r3, r1
 8001d0a:	681b      	ldr	r3, [r3, #0]
 8001d0c:	405a      	eors	r2, r3
 8001d0e:	68fb      	ldr	r3, [r7, #12]
 8001d10:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001d14:	693b      	ldr	r3, [r7, #16]
 8001d16:	0a1b      	lsrs	r3, r3, #8
 8001d18:	b2db      	uxtb	r3, r3
 8001d1a:	009b      	lsls	r3, r3, #2
 8001d1c:	440b      	add	r3, r1
 8001d1e:	681b      	ldr	r3, [r3, #0]
 8001d20:	405a      	eors	r2, r3
 8001d22:	68fb      	ldr	r3, [r7, #12]
 8001d24:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001d28:	69fb      	ldr	r3, [r7, #28]
 8001d2a:	b2db      	uxtb	r3, r3
 8001d2c:	009b      	lsls	r3, r3, #2
 8001d2e:	440b      	add	r3, r1
 8001d30:	681b      	ldr	r3, [r3, #0]
 8001d32:	405a      	eors	r2, r3
 8001d34:	68bb      	ldr	r3, [r7, #8]
 8001d36:	33d4      	adds	r3, #212	; 0xd4
 8001d38:	681b      	ldr	r3, [r3, #0]
 8001d3a:	4053      	eors	r3, r2
 8001d3c:	62bb      	str	r3, [r7, #40]	; 0x28
            t2 = ctx->Te0[s2 >> 24] ^ ctx->Te1[(s3 >> 16) & 0xff] ^ ctx->Te2[(s0 >>  8) & 0xff] ^ ctx->Te3[s1 & 0xff] ^ rk[54];
 8001d3e:	68fb      	ldr	r3, [r7, #12]
 8001d40:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001d44:	697b      	ldr	r3, [r7, #20]
 8001d46:	0e1b      	lsrs	r3, r3, #24
 8001d48:	009b      	lsls	r3, r3, #2
 8001d4a:	4413      	add	r3, r2
 8001d4c:	681a      	ldr	r2, [r3, #0]
 8001d4e:	68fb      	ldr	r3, [r7, #12]
 8001d50:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001d54:	693b      	ldr	r3, [r7, #16]
 8001d56:	0c1b      	lsrs	r3, r3, #16
 8001d58:	b2db      	uxtb	r3, r3
 8001d5a:	009b      	lsls	r3, r3, #2
 8001d5c:	440b      	add	r3, r1
 8001d5e:	681b      	ldr	r3, [r3, #0]
 8001d60:	405a      	eors	r2, r3
 8001d62:	68fb      	ldr	r3, [r7, #12]
 8001d64:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001d68:	69fb      	ldr	r3, [r7, #28]
 8001d6a:	0a1b      	lsrs	r3, r3, #8
 8001d6c:	b2db      	uxtb	r3, r3
 8001d6e:	009b      	lsls	r3, r3, #2
 8001d70:	440b      	add	r3, r1
 8001d72:	681b      	ldr	r3, [r3, #0]
 8001d74:	405a      	eors	r2, r3
 8001d76:	68fb      	ldr	r3, [r7, #12]
 8001d78:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001d7c:	69bb      	ldr	r3, [r7, #24]
 8001d7e:	b2db      	uxtb	r3, r3
 8001d80:	009b      	lsls	r3, r3, #2
 8001d82:	440b      	add	r3, r1
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	405a      	eors	r2, r3
 8001d88:	68bb      	ldr	r3, [r7, #8]
 8001d8a:	33d8      	adds	r3, #216	; 0xd8
 8001d8c:	681b      	ldr	r3, [r3, #0]
 8001d8e:	4053      	eors	r3, r2
 8001d90:	627b      	str	r3, [r7, #36]	; 0x24
            t3 = ctx->Te0[s3 >> 24] ^ ctx->Te1[(s0 >> 16) & 0xff] ^ ctx->Te2[(s1 >>  8) & 0xff] ^ ctx->Te3[s2 & 0xff] ^ rk[55];
 8001d92:	68fb      	ldr	r3, [r7, #12]
 8001d94:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8001d98:	693b      	ldr	r3, [r7, #16]
 8001d9a:	0e1b      	lsrs	r3, r3, #24
 8001d9c:	009b      	lsls	r3, r3, #2
 8001d9e:	4413      	add	r3, r2
 8001da0:	681a      	ldr	r2, [r3, #0]
 8001da2:	68fb      	ldr	r3, [r7, #12]
 8001da4:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 8001da8:	69fb      	ldr	r3, [r7, #28]
 8001daa:	0c1b      	lsrs	r3, r3, #16
 8001dac:	b2db      	uxtb	r3, r3
 8001dae:	009b      	lsls	r3, r3, #2
 8001db0:	440b      	add	r3, r1
 8001db2:	681b      	ldr	r3, [r3, #0]
 8001db4:	405a      	eors	r2, r3
 8001db6:	68fb      	ldr	r3, [r7, #12]
 8001db8:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
 8001dbc:	69bb      	ldr	r3, [r7, #24]
 8001dbe:	0a1b      	lsrs	r3, r3, #8
 8001dc0:	b2db      	uxtb	r3, r3
 8001dc2:	009b      	lsls	r3, r3, #2
 8001dc4:	440b      	add	r3, r1
 8001dc6:	681b      	ldr	r3, [r3, #0]
 8001dc8:	405a      	eors	r2, r3
 8001dca:	68fb      	ldr	r3, [r7, #12]
 8001dcc:	f8d3 1110 	ldr.w	r1, [r3, #272]	; 0x110
 8001dd0:	697b      	ldr	r3, [r7, #20]
 8001dd2:	b2db      	uxtb	r3, r3
 8001dd4:	009b      	lsls	r3, r3, #2
 8001dd6:	440b      	add	r3, r1
 8001dd8:	681b      	ldr	r3, [r3, #0]
 8001dda:	405a      	eors	r2, r3
 8001ddc:	68bb      	ldr	r3, [r7, #8]
 8001dde:	33dc      	adds	r3, #220	; 0xdc
 8001de0:	681b      	ldr	r3, [r3, #0]
 8001de2:	4053      	eors	r3, r2
 8001de4:	623b      	str	r3, [r7, #32]
        }
    }
    rk += Nr << 2;
 8001de6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8001dea:	009b      	lsls	r3, r3, #2
 8001dec:	009b      	lsls	r3, r3, #2
 8001dee:	68ba      	ldr	r2, [r7, #8]
 8001df0:	4413      	add	r3, r2
 8001df2:	60bb      	str	r3, [r7, #8]
    /*
     * apply last round and
     * map cipher Te to Te array block:
     */
    s0 =
            (ctx->Te4[(t0 >> 24)       ] & 0xff000000) ^
 8001df4:	68fb      	ldr	r3, [r7, #12]
 8001df6:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8001dfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001dfc:	0e1b      	lsrs	r3, r3, #24
 8001dfe:	009b      	lsls	r3, r3, #2
 8001e00:	4413      	add	r3, r2
 8001e02:	681b      	ldr	r3, [r3, #0]
 8001e04:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
 8001e08:	68fb      	ldr	r3, [r7, #12]
 8001e0a:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001e0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001e10:	0c1b      	lsrs	r3, r3, #16
 8001e12:	b2db      	uxtb	r3, r3
 8001e14:	009b      	lsls	r3, r3, #2
 8001e16:	440b      	add	r3, r1
 8001e18:	681b      	ldr	r3, [r3, #0]
 8001e1a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Te4[(t0 >> 24)       ] & 0xff000000) ^
 8001e1e:	431a      	orrs	r2, r3
            (ctx->Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
 8001e20:	68fb      	ldr	r3, [r7, #12]
 8001e22:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001e26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e28:	0a1b      	lsrs	r3, r3, #8
 8001e2a:	b2db      	uxtb	r3, r3
 8001e2c:	009b      	lsls	r3, r3, #2
 8001e2e:	440b      	add	r3, r1
 8001e30:	681b      	ldr	r3, [r3, #0]
 8001e32:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
 8001e36:	405a      	eors	r2, r3
            (ctx->Te4[(t3      ) & 0xff] & 0x000000ff) ^
 8001e38:	68fb      	ldr	r3, [r7, #12]
 8001e3a:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001e3e:	6a3b      	ldr	r3, [r7, #32]
 8001e40:	b2db      	uxtb	r3, r3
 8001e42:	009b      	lsls	r3, r3, #2
 8001e44:	440b      	add	r3, r1
 8001e46:	681b      	ldr	r3, [r3, #0]
 8001e48:	b2db      	uxtb	r3, r3
            (ctx->Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
 8001e4a:	405a      	eors	r2, r3
            rk[0];
 8001e4c:	68bb      	ldr	r3, [r7, #8]
 8001e4e:	681b      	ldr	r3, [r3, #0]
    s0 =
 8001e50:	4053      	eors	r3, r2
 8001e52:	61fb      	str	r3, [r7, #28]
    B5_AES256_PUTUINT32(ct     , s0);
 8001e54:	69f9      	ldr	r1, [r7, #28]
 8001e56:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8001e58:	f7fe fa74 	bl	8000344 <B5_AES256_PUTUINT32>
    s1 =
            (ctx->Te4[(t1 >> 24)       ] & 0xff000000) ^
 8001e5c:	68fb      	ldr	r3, [r7, #12]
 8001e5e:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8001e62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001e64:	0e1b      	lsrs	r3, r3, #24
 8001e66:	009b      	lsls	r3, r3, #2
 8001e68:	4413      	add	r3, r2
 8001e6a:	681b      	ldr	r3, [r3, #0]
 8001e6c:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
 8001e70:	68fb      	ldr	r3, [r7, #12]
 8001e72:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001e76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e78:	0c1b      	lsrs	r3, r3, #16
 8001e7a:	b2db      	uxtb	r3, r3
 8001e7c:	009b      	lsls	r3, r3, #2
 8001e7e:	440b      	add	r3, r1
 8001e80:	681b      	ldr	r3, [r3, #0]
 8001e82:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Te4[(t1 >> 24)       ] & 0xff000000) ^
 8001e86:	431a      	orrs	r2, r3
            (ctx->Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
 8001e88:	68fb      	ldr	r3, [r7, #12]
 8001e8a:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001e8e:	6a3b      	ldr	r3, [r7, #32]
 8001e90:	0a1b      	lsrs	r3, r3, #8
 8001e92:	b2db      	uxtb	r3, r3
 8001e94:	009b      	lsls	r3, r3, #2
 8001e96:	440b      	add	r3, r1
 8001e98:	681b      	ldr	r3, [r3, #0]
 8001e9a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
 8001e9e:	405a      	eors	r2, r3
            (ctx->Te4[(t0      ) & 0xff] & 0x000000ff) ^
 8001ea0:	68fb      	ldr	r3, [r7, #12]
 8001ea2:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001ea6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001ea8:	b2db      	uxtb	r3, r3
 8001eaa:	009b      	lsls	r3, r3, #2
 8001eac:	440b      	add	r3, r1
 8001eae:	681b      	ldr	r3, [r3, #0]
 8001eb0:	b2db      	uxtb	r3, r3
            (ctx->Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
 8001eb2:	405a      	eors	r2, r3
            rk[1];
 8001eb4:	68bb      	ldr	r3, [r7, #8]
 8001eb6:	3304      	adds	r3, #4
 8001eb8:	681b      	ldr	r3, [r3, #0]
    s1 =
 8001eba:	4053      	eors	r3, r2
 8001ebc:	61bb      	str	r3, [r7, #24]
    B5_AES256_PUTUINT32(ct +  4, s1);
 8001ebe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8001ec0:	3304      	adds	r3, #4
 8001ec2:	69b9      	ldr	r1, [r7, #24]
 8001ec4:	4618      	mov	r0, r3
 8001ec6:	f7fe fa3d 	bl	8000344 <B5_AES256_PUTUINT32>
    s2 =
            (ctx->Te4[(t2 >> 24)       ] & 0xff000000) ^
 8001eca:	68fb      	ldr	r3, [r7, #12]
 8001ecc:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8001ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001ed2:	0e1b      	lsrs	r3, r3, #24
 8001ed4:	009b      	lsls	r3, r3, #2
 8001ed6:	4413      	add	r3, r2
 8001ed8:	681b      	ldr	r3, [r3, #0]
 8001eda:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
 8001ede:	68fb      	ldr	r3, [r7, #12]
 8001ee0:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001ee4:	6a3b      	ldr	r3, [r7, #32]
 8001ee6:	0c1b      	lsrs	r3, r3, #16
 8001ee8:	b2db      	uxtb	r3, r3
 8001eea:	009b      	lsls	r3, r3, #2
 8001eec:	440b      	add	r3, r1
 8001eee:	681b      	ldr	r3, [r3, #0]
 8001ef0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Te4[(t2 >> 24)       ] & 0xff000000) ^
 8001ef4:	431a      	orrs	r2, r3
            (ctx->Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
 8001ef6:	68fb      	ldr	r3, [r7, #12]
 8001ef8:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001efc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001efe:	0a1b      	lsrs	r3, r3, #8
 8001f00:	b2db      	uxtb	r3, r3
 8001f02:	009b      	lsls	r3, r3, #2
 8001f04:	440b      	add	r3, r1
 8001f06:	681b      	ldr	r3, [r3, #0]
 8001f08:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
 8001f0c:	405a      	eors	r2, r3
            (ctx->Te4[(t1      ) & 0xff] & 0x000000ff) ^
 8001f0e:	68fb      	ldr	r3, [r7, #12]
 8001f10:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001f14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001f16:	b2db      	uxtb	r3, r3
 8001f18:	009b      	lsls	r3, r3, #2
 8001f1a:	440b      	add	r3, r1
 8001f1c:	681b      	ldr	r3, [r3, #0]
 8001f1e:	b2db      	uxtb	r3, r3
            (ctx->Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
 8001f20:	405a      	eors	r2, r3
            rk[2];
 8001f22:	68bb      	ldr	r3, [r7, #8]
 8001f24:	3308      	adds	r3, #8
 8001f26:	681b      	ldr	r3, [r3, #0]
    s2 =
 8001f28:	4053      	eors	r3, r2
 8001f2a:	617b      	str	r3, [r7, #20]
    B5_AES256_PUTUINT32(ct +  8, s2);
 8001f2c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8001f2e:	3308      	adds	r3, #8
 8001f30:	6979      	ldr	r1, [r7, #20]
 8001f32:	4618      	mov	r0, r3
 8001f34:	f7fe fa06 	bl	8000344 <B5_AES256_PUTUINT32>
    s3 =
            (ctx->Te4[(t3 >> 24)       ] & 0xff000000) ^
 8001f38:	68fb      	ldr	r3, [r7, #12]
 8001f3a:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
 8001f3e:	6a3b      	ldr	r3, [r7, #32]
 8001f40:	0e1b      	lsrs	r3, r3, #24
 8001f42:	009b      	lsls	r3, r3, #2
 8001f44:	4413      	add	r3, r2
 8001f46:	681b      	ldr	r3, [r3, #0]
 8001f48:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
 8001f4c:	68fb      	ldr	r3, [r7, #12]
 8001f4e:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001f52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001f54:	0c1b      	lsrs	r3, r3, #16
 8001f56:	b2db      	uxtb	r3, r3
 8001f58:	009b      	lsls	r3, r3, #2
 8001f5a:	440b      	add	r3, r1
 8001f5c:	681b      	ldr	r3, [r3, #0]
 8001f5e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Te4[(t3 >> 24)       ] & 0xff000000) ^
 8001f62:	431a      	orrs	r2, r3
            (ctx->Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
 8001f64:	68fb      	ldr	r3, [r7, #12]
 8001f66:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001f6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001f6c:	0a1b      	lsrs	r3, r3, #8
 8001f6e:	b2db      	uxtb	r3, r3
 8001f70:	009b      	lsls	r3, r3, #2
 8001f72:	440b      	add	r3, r1
 8001f74:	681b      	ldr	r3, [r3, #0]
 8001f76:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
 8001f7a:	405a      	eors	r2, r3
            (ctx->Te4[(t2      ) & 0xff] & 0x000000ff) ^
 8001f7c:	68fb      	ldr	r3, [r7, #12]
 8001f7e:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
 8001f82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f84:	b2db      	uxtb	r3, r3
 8001f86:	009b      	lsls	r3, r3, #2
 8001f88:	440b      	add	r3, r1
 8001f8a:	681b      	ldr	r3, [r3, #0]
 8001f8c:	b2db      	uxtb	r3, r3
            (ctx->Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
 8001f8e:	405a      	eors	r2, r3
            rk[3];
 8001f90:	68bb      	ldr	r3, [r7, #8]
 8001f92:	330c      	adds	r3, #12
 8001f94:	681b      	ldr	r3, [r3, #0]
    s3 =
 8001f96:	4053      	eors	r3, r2
 8001f98:	613b      	str	r3, [r7, #16]
    B5_AES256_PUTUINT32(ct + 12, s3);
 8001f9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8001f9c:	330c      	adds	r3, #12
 8001f9e:	6939      	ldr	r1, [r7, #16]
 8001fa0:	4618      	mov	r0, r3
 8001fa2:	f7fe f9cf 	bl	8000344 <B5_AES256_PUTUINT32>
}
 8001fa6:	bf00      	nop
 8001fa8:	3730      	adds	r7, #48	; 0x30
 8001faa:	46bd      	mov	sp, r7
 8001fac:	bd80      	pop	{r7, pc}

08001fae <B5_rijndaelDecrypt>:
 * @param Nr number of rounds (depends on the original key length)
 * @param ct output block
 * @param pt input block
 */
void B5_rijndaelDecrypt (B5_tAesCtx *ctx, uint32_t *rk, int16_t Nr, const uint8_t *ct, uint8_t *pt)
{
 8001fae:	b580      	push	{r7, lr}
 8001fb0:	b08c      	sub	sp, #48	; 0x30
 8001fb2:	af00      	add	r7, sp, #0
 8001fb4:	60f8      	str	r0, [r7, #12]
 8001fb6:	60b9      	str	r1, [r7, #8]
 8001fb8:	603b      	str	r3, [r7, #0]
 8001fba:	4613      	mov	r3, r2
 8001fbc:	80fb      	strh	r3, [r7, #6]
    
    /*
     map byte array block to cipher state
     and add initial round key:
     */
    s0 = B5_AES256_GETUINT32(ct     ) ^ rk[0];
 8001fbe:	6838      	ldr	r0, [r7, #0]
 8001fc0:	f7fe f997 	bl	80002f2 <B5_AES256_GETUINT32>
 8001fc4:	4602      	mov	r2, r0
 8001fc6:	68bb      	ldr	r3, [r7, #8]
 8001fc8:	681b      	ldr	r3, [r3, #0]
 8001fca:	4053      	eors	r3, r2
 8001fcc:	61fb      	str	r3, [r7, #28]
    s1 = B5_AES256_GETUINT32(ct +  4) ^ rk[1];
 8001fce:	683b      	ldr	r3, [r7, #0]
 8001fd0:	3304      	adds	r3, #4
 8001fd2:	4618      	mov	r0, r3
 8001fd4:	f7fe f98d 	bl	80002f2 <B5_AES256_GETUINT32>
 8001fd8:	4602      	mov	r2, r0
 8001fda:	68bb      	ldr	r3, [r7, #8]
 8001fdc:	3304      	adds	r3, #4
 8001fde:	681b      	ldr	r3, [r3, #0]
 8001fe0:	4053      	eors	r3, r2
 8001fe2:	61bb      	str	r3, [r7, #24]
    s2 = B5_AES256_GETUINT32(ct +  8) ^ rk[2];
 8001fe4:	683b      	ldr	r3, [r7, #0]
 8001fe6:	3308      	adds	r3, #8
 8001fe8:	4618      	mov	r0, r3
 8001fea:	f7fe f982 	bl	80002f2 <B5_AES256_GETUINT32>
 8001fee:	4602      	mov	r2, r0
 8001ff0:	68bb      	ldr	r3, [r7, #8]
 8001ff2:	3308      	adds	r3, #8
 8001ff4:	681b      	ldr	r3, [r3, #0]
 8001ff6:	4053      	eors	r3, r2
 8001ff8:	617b      	str	r3, [r7, #20]
    s3 = B5_AES256_GETUINT32(ct + 12) ^ rk[3];
 8001ffa:	683b      	ldr	r3, [r7, #0]
 8001ffc:	330c      	adds	r3, #12
 8001ffe:	4618      	mov	r0, r3
 8002000:	f7fe f977 	bl	80002f2 <B5_AES256_GETUINT32>
 8002004:	4602      	mov	r2, r0
 8002006:	68bb      	ldr	r3, [r7, #8]
 8002008:	330c      	adds	r3, #12
 800200a:	681b      	ldr	r3, [r3, #0]
 800200c:	4053      	eors	r3, r2
 800200e:	613b      	str	r3, [r7, #16]
    
    
    /* round 1: */
    t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[ 4];
 8002010:	68fb      	ldr	r3, [r7, #12]
 8002012:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002016:	69fb      	ldr	r3, [r7, #28]
 8002018:	0e1b      	lsrs	r3, r3, #24
 800201a:	009b      	lsls	r3, r3, #2
 800201c:	4413      	add	r3, r2
 800201e:	681a      	ldr	r2, [r3, #0]
 8002020:	68fb      	ldr	r3, [r7, #12]
 8002022:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002026:	693b      	ldr	r3, [r7, #16]
 8002028:	0c1b      	lsrs	r3, r3, #16
 800202a:	b2db      	uxtb	r3, r3
 800202c:	009b      	lsls	r3, r3, #2
 800202e:	440b      	add	r3, r1
 8002030:	681b      	ldr	r3, [r3, #0]
 8002032:	405a      	eors	r2, r3
 8002034:	68fb      	ldr	r3, [r7, #12]
 8002036:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800203a:	697b      	ldr	r3, [r7, #20]
 800203c:	0a1b      	lsrs	r3, r3, #8
 800203e:	b2db      	uxtb	r3, r3
 8002040:	009b      	lsls	r3, r3, #2
 8002042:	440b      	add	r3, r1
 8002044:	681b      	ldr	r3, [r3, #0]
 8002046:	405a      	eors	r2, r3
 8002048:	68fb      	ldr	r3, [r7, #12]
 800204a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800204e:	69bb      	ldr	r3, [r7, #24]
 8002050:	b2db      	uxtb	r3, r3
 8002052:	009b      	lsls	r3, r3, #2
 8002054:	440b      	add	r3, r1
 8002056:	681b      	ldr	r3, [r3, #0]
 8002058:	405a      	eors	r2, r3
 800205a:	68bb      	ldr	r3, [r7, #8]
 800205c:	3310      	adds	r3, #16
 800205e:	681b      	ldr	r3, [r3, #0]
 8002060:	4053      	eors	r3, r2
 8002062:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[ 5];
 8002064:	68fb      	ldr	r3, [r7, #12]
 8002066:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800206a:	69bb      	ldr	r3, [r7, #24]
 800206c:	0e1b      	lsrs	r3, r3, #24
 800206e:	009b      	lsls	r3, r3, #2
 8002070:	4413      	add	r3, r2
 8002072:	681a      	ldr	r2, [r3, #0]
 8002074:	68fb      	ldr	r3, [r7, #12]
 8002076:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800207a:	69fb      	ldr	r3, [r7, #28]
 800207c:	0c1b      	lsrs	r3, r3, #16
 800207e:	b2db      	uxtb	r3, r3
 8002080:	009b      	lsls	r3, r3, #2
 8002082:	440b      	add	r3, r1
 8002084:	681b      	ldr	r3, [r3, #0]
 8002086:	405a      	eors	r2, r3
 8002088:	68fb      	ldr	r3, [r7, #12]
 800208a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800208e:	693b      	ldr	r3, [r7, #16]
 8002090:	0a1b      	lsrs	r3, r3, #8
 8002092:	b2db      	uxtb	r3, r3
 8002094:	009b      	lsls	r3, r3, #2
 8002096:	440b      	add	r3, r1
 8002098:	681b      	ldr	r3, [r3, #0]
 800209a:	405a      	eors	r2, r3
 800209c:	68fb      	ldr	r3, [r7, #12]
 800209e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80020a2:	697b      	ldr	r3, [r7, #20]
 80020a4:	b2db      	uxtb	r3, r3
 80020a6:	009b      	lsls	r3, r3, #2
 80020a8:	440b      	add	r3, r1
 80020aa:	681b      	ldr	r3, [r3, #0]
 80020ac:	405a      	eors	r2, r3
 80020ae:	68bb      	ldr	r3, [r7, #8]
 80020b0:	3314      	adds	r3, #20
 80020b2:	681b      	ldr	r3, [r3, #0]
 80020b4:	4053      	eors	r3, r2
 80020b6:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[ 6];
 80020b8:	68fb      	ldr	r3, [r7, #12]
 80020ba:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80020be:	697b      	ldr	r3, [r7, #20]
 80020c0:	0e1b      	lsrs	r3, r3, #24
 80020c2:	009b      	lsls	r3, r3, #2
 80020c4:	4413      	add	r3, r2
 80020c6:	681a      	ldr	r2, [r3, #0]
 80020c8:	68fb      	ldr	r3, [r7, #12]
 80020ca:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80020ce:	69bb      	ldr	r3, [r7, #24]
 80020d0:	0c1b      	lsrs	r3, r3, #16
 80020d2:	b2db      	uxtb	r3, r3
 80020d4:	009b      	lsls	r3, r3, #2
 80020d6:	440b      	add	r3, r1
 80020d8:	681b      	ldr	r3, [r3, #0]
 80020da:	405a      	eors	r2, r3
 80020dc:	68fb      	ldr	r3, [r7, #12]
 80020de:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80020e2:	69fb      	ldr	r3, [r7, #28]
 80020e4:	0a1b      	lsrs	r3, r3, #8
 80020e6:	b2db      	uxtb	r3, r3
 80020e8:	009b      	lsls	r3, r3, #2
 80020ea:	440b      	add	r3, r1
 80020ec:	681b      	ldr	r3, [r3, #0]
 80020ee:	405a      	eors	r2, r3
 80020f0:	68fb      	ldr	r3, [r7, #12]
 80020f2:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80020f6:	693b      	ldr	r3, [r7, #16]
 80020f8:	b2db      	uxtb	r3, r3
 80020fa:	009b      	lsls	r3, r3, #2
 80020fc:	440b      	add	r3, r1
 80020fe:	681b      	ldr	r3, [r3, #0]
 8002100:	405a      	eors	r2, r3
 8002102:	68bb      	ldr	r3, [r7, #8]
 8002104:	3318      	adds	r3, #24
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	4053      	eors	r3, r2
 800210a:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[ 7];
 800210c:	68fb      	ldr	r3, [r7, #12]
 800210e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002112:	693b      	ldr	r3, [r7, #16]
 8002114:	0e1b      	lsrs	r3, r3, #24
 8002116:	009b      	lsls	r3, r3, #2
 8002118:	4413      	add	r3, r2
 800211a:	681a      	ldr	r2, [r3, #0]
 800211c:	68fb      	ldr	r3, [r7, #12]
 800211e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002122:	697b      	ldr	r3, [r7, #20]
 8002124:	0c1b      	lsrs	r3, r3, #16
 8002126:	b2db      	uxtb	r3, r3
 8002128:	009b      	lsls	r3, r3, #2
 800212a:	440b      	add	r3, r1
 800212c:	681b      	ldr	r3, [r3, #0]
 800212e:	405a      	eors	r2, r3
 8002130:	68fb      	ldr	r3, [r7, #12]
 8002132:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002136:	69bb      	ldr	r3, [r7, #24]
 8002138:	0a1b      	lsrs	r3, r3, #8
 800213a:	b2db      	uxtb	r3, r3
 800213c:	009b      	lsls	r3, r3, #2
 800213e:	440b      	add	r3, r1
 8002140:	681b      	ldr	r3, [r3, #0]
 8002142:	405a      	eors	r2, r3
 8002144:	68fb      	ldr	r3, [r7, #12]
 8002146:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800214a:	69fb      	ldr	r3, [r7, #28]
 800214c:	b2db      	uxtb	r3, r3
 800214e:	009b      	lsls	r3, r3, #2
 8002150:	440b      	add	r3, r1
 8002152:	681b      	ldr	r3, [r3, #0]
 8002154:	405a      	eors	r2, r3
 8002156:	68bb      	ldr	r3, [r7, #8]
 8002158:	331c      	adds	r3, #28
 800215a:	681b      	ldr	r3, [r3, #0]
 800215c:	4053      	eors	r3, r2
 800215e:	623b      	str	r3, [r7, #32]
    /* round 2: */
    s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[ 8];
 8002160:	68fb      	ldr	r3, [r7, #12]
 8002162:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002166:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002168:	0e1b      	lsrs	r3, r3, #24
 800216a:	009b      	lsls	r3, r3, #2
 800216c:	4413      	add	r3, r2
 800216e:	681a      	ldr	r2, [r3, #0]
 8002170:	68fb      	ldr	r3, [r7, #12]
 8002172:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002176:	6a3b      	ldr	r3, [r7, #32]
 8002178:	0c1b      	lsrs	r3, r3, #16
 800217a:	b2db      	uxtb	r3, r3
 800217c:	009b      	lsls	r3, r3, #2
 800217e:	440b      	add	r3, r1
 8002180:	681b      	ldr	r3, [r3, #0]
 8002182:	405a      	eors	r2, r3
 8002184:	68fb      	ldr	r3, [r7, #12]
 8002186:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800218a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800218c:	0a1b      	lsrs	r3, r3, #8
 800218e:	b2db      	uxtb	r3, r3
 8002190:	009b      	lsls	r3, r3, #2
 8002192:	440b      	add	r3, r1
 8002194:	681b      	ldr	r3, [r3, #0]
 8002196:	405a      	eors	r2, r3
 8002198:	68fb      	ldr	r3, [r7, #12]
 800219a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800219e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021a0:	b2db      	uxtb	r3, r3
 80021a2:	009b      	lsls	r3, r3, #2
 80021a4:	440b      	add	r3, r1
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	405a      	eors	r2, r3
 80021aa:	68bb      	ldr	r3, [r7, #8]
 80021ac:	3320      	adds	r3, #32
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	4053      	eors	r3, r2
 80021b2:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[ 9];
 80021b4:	68fb      	ldr	r3, [r7, #12]
 80021b6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80021ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021bc:	0e1b      	lsrs	r3, r3, #24
 80021be:	009b      	lsls	r3, r3, #2
 80021c0:	4413      	add	r3, r2
 80021c2:	681a      	ldr	r2, [r3, #0]
 80021c4:	68fb      	ldr	r3, [r7, #12]
 80021c6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80021ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80021cc:	0c1b      	lsrs	r3, r3, #16
 80021ce:	b2db      	uxtb	r3, r3
 80021d0:	009b      	lsls	r3, r3, #2
 80021d2:	440b      	add	r3, r1
 80021d4:	681b      	ldr	r3, [r3, #0]
 80021d6:	405a      	eors	r2, r3
 80021d8:	68fb      	ldr	r3, [r7, #12]
 80021da:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80021de:	6a3b      	ldr	r3, [r7, #32]
 80021e0:	0a1b      	lsrs	r3, r3, #8
 80021e2:	b2db      	uxtb	r3, r3
 80021e4:	009b      	lsls	r3, r3, #2
 80021e6:	440b      	add	r3, r1
 80021e8:	681b      	ldr	r3, [r3, #0]
 80021ea:	405a      	eors	r2, r3
 80021ec:	68fb      	ldr	r3, [r7, #12]
 80021ee:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80021f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80021f4:	b2db      	uxtb	r3, r3
 80021f6:	009b      	lsls	r3, r3, #2
 80021f8:	440b      	add	r3, r1
 80021fa:	681b      	ldr	r3, [r3, #0]
 80021fc:	405a      	eors	r2, r3
 80021fe:	68bb      	ldr	r3, [r7, #8]
 8002200:	3324      	adds	r3, #36	; 0x24
 8002202:	681b      	ldr	r3, [r3, #0]
 8002204:	4053      	eors	r3, r2
 8002206:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[10];
 8002208:	68fb      	ldr	r3, [r7, #12]
 800220a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800220e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002210:	0e1b      	lsrs	r3, r3, #24
 8002212:	009b      	lsls	r3, r3, #2
 8002214:	4413      	add	r3, r2
 8002216:	681a      	ldr	r2, [r3, #0]
 8002218:	68fb      	ldr	r3, [r7, #12]
 800221a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800221e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002220:	0c1b      	lsrs	r3, r3, #16
 8002222:	b2db      	uxtb	r3, r3
 8002224:	009b      	lsls	r3, r3, #2
 8002226:	440b      	add	r3, r1
 8002228:	681b      	ldr	r3, [r3, #0]
 800222a:	405a      	eors	r2, r3
 800222c:	68fb      	ldr	r3, [r7, #12]
 800222e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002232:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002234:	0a1b      	lsrs	r3, r3, #8
 8002236:	b2db      	uxtb	r3, r3
 8002238:	009b      	lsls	r3, r3, #2
 800223a:	440b      	add	r3, r1
 800223c:	681b      	ldr	r3, [r3, #0]
 800223e:	405a      	eors	r2, r3
 8002240:	68fb      	ldr	r3, [r7, #12]
 8002242:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002246:	6a3b      	ldr	r3, [r7, #32]
 8002248:	b2db      	uxtb	r3, r3
 800224a:	009b      	lsls	r3, r3, #2
 800224c:	440b      	add	r3, r1
 800224e:	681b      	ldr	r3, [r3, #0]
 8002250:	405a      	eors	r2, r3
 8002252:	68bb      	ldr	r3, [r7, #8]
 8002254:	3328      	adds	r3, #40	; 0x28
 8002256:	681b      	ldr	r3, [r3, #0]
 8002258:	4053      	eors	r3, r2
 800225a:	617b      	str	r3, [r7, #20]
    s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[11];
 800225c:	68fb      	ldr	r3, [r7, #12]
 800225e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002262:	6a3b      	ldr	r3, [r7, #32]
 8002264:	0e1b      	lsrs	r3, r3, #24
 8002266:	009b      	lsls	r3, r3, #2
 8002268:	4413      	add	r3, r2
 800226a:	681a      	ldr	r2, [r3, #0]
 800226c:	68fb      	ldr	r3, [r7, #12]
 800226e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002272:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002274:	0c1b      	lsrs	r3, r3, #16
 8002276:	b2db      	uxtb	r3, r3
 8002278:	009b      	lsls	r3, r3, #2
 800227a:	440b      	add	r3, r1
 800227c:	681b      	ldr	r3, [r3, #0]
 800227e:	405a      	eors	r2, r3
 8002280:	68fb      	ldr	r3, [r7, #12]
 8002282:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002286:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002288:	0a1b      	lsrs	r3, r3, #8
 800228a:	b2db      	uxtb	r3, r3
 800228c:	009b      	lsls	r3, r3, #2
 800228e:	440b      	add	r3, r1
 8002290:	681b      	ldr	r3, [r3, #0]
 8002292:	405a      	eors	r2, r3
 8002294:	68fb      	ldr	r3, [r7, #12]
 8002296:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800229a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800229c:	b2db      	uxtb	r3, r3
 800229e:	009b      	lsls	r3, r3, #2
 80022a0:	440b      	add	r3, r1
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	405a      	eors	r2, r3
 80022a6:	68bb      	ldr	r3, [r7, #8]
 80022a8:	332c      	adds	r3, #44	; 0x2c
 80022aa:	681b      	ldr	r3, [r3, #0]
 80022ac:	4053      	eors	r3, r2
 80022ae:	613b      	str	r3, [r7, #16]
    /* round 3: */
    t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[12];
 80022b0:	68fb      	ldr	r3, [r7, #12]
 80022b2:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80022b6:	69fb      	ldr	r3, [r7, #28]
 80022b8:	0e1b      	lsrs	r3, r3, #24
 80022ba:	009b      	lsls	r3, r3, #2
 80022bc:	4413      	add	r3, r2
 80022be:	681a      	ldr	r2, [r3, #0]
 80022c0:	68fb      	ldr	r3, [r7, #12]
 80022c2:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80022c6:	693b      	ldr	r3, [r7, #16]
 80022c8:	0c1b      	lsrs	r3, r3, #16
 80022ca:	b2db      	uxtb	r3, r3
 80022cc:	009b      	lsls	r3, r3, #2
 80022ce:	440b      	add	r3, r1
 80022d0:	681b      	ldr	r3, [r3, #0]
 80022d2:	405a      	eors	r2, r3
 80022d4:	68fb      	ldr	r3, [r7, #12]
 80022d6:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80022da:	697b      	ldr	r3, [r7, #20]
 80022dc:	0a1b      	lsrs	r3, r3, #8
 80022de:	b2db      	uxtb	r3, r3
 80022e0:	009b      	lsls	r3, r3, #2
 80022e2:	440b      	add	r3, r1
 80022e4:	681b      	ldr	r3, [r3, #0]
 80022e6:	405a      	eors	r2, r3
 80022e8:	68fb      	ldr	r3, [r7, #12]
 80022ea:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80022ee:	69bb      	ldr	r3, [r7, #24]
 80022f0:	b2db      	uxtb	r3, r3
 80022f2:	009b      	lsls	r3, r3, #2
 80022f4:	440b      	add	r3, r1
 80022f6:	681b      	ldr	r3, [r3, #0]
 80022f8:	405a      	eors	r2, r3
 80022fa:	68bb      	ldr	r3, [r7, #8]
 80022fc:	3330      	adds	r3, #48	; 0x30
 80022fe:	681b      	ldr	r3, [r3, #0]
 8002300:	4053      	eors	r3, r2
 8002302:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[13];
 8002304:	68fb      	ldr	r3, [r7, #12]
 8002306:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800230a:	69bb      	ldr	r3, [r7, #24]
 800230c:	0e1b      	lsrs	r3, r3, #24
 800230e:	009b      	lsls	r3, r3, #2
 8002310:	4413      	add	r3, r2
 8002312:	681a      	ldr	r2, [r3, #0]
 8002314:	68fb      	ldr	r3, [r7, #12]
 8002316:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800231a:	69fb      	ldr	r3, [r7, #28]
 800231c:	0c1b      	lsrs	r3, r3, #16
 800231e:	b2db      	uxtb	r3, r3
 8002320:	009b      	lsls	r3, r3, #2
 8002322:	440b      	add	r3, r1
 8002324:	681b      	ldr	r3, [r3, #0]
 8002326:	405a      	eors	r2, r3
 8002328:	68fb      	ldr	r3, [r7, #12]
 800232a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800232e:	693b      	ldr	r3, [r7, #16]
 8002330:	0a1b      	lsrs	r3, r3, #8
 8002332:	b2db      	uxtb	r3, r3
 8002334:	009b      	lsls	r3, r3, #2
 8002336:	440b      	add	r3, r1
 8002338:	681b      	ldr	r3, [r3, #0]
 800233a:	405a      	eors	r2, r3
 800233c:	68fb      	ldr	r3, [r7, #12]
 800233e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002342:	697b      	ldr	r3, [r7, #20]
 8002344:	b2db      	uxtb	r3, r3
 8002346:	009b      	lsls	r3, r3, #2
 8002348:	440b      	add	r3, r1
 800234a:	681b      	ldr	r3, [r3, #0]
 800234c:	405a      	eors	r2, r3
 800234e:	68bb      	ldr	r3, [r7, #8]
 8002350:	3334      	adds	r3, #52	; 0x34
 8002352:	681b      	ldr	r3, [r3, #0]
 8002354:	4053      	eors	r3, r2
 8002356:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[14];
 8002358:	68fb      	ldr	r3, [r7, #12]
 800235a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800235e:	697b      	ldr	r3, [r7, #20]
 8002360:	0e1b      	lsrs	r3, r3, #24
 8002362:	009b      	lsls	r3, r3, #2
 8002364:	4413      	add	r3, r2
 8002366:	681a      	ldr	r2, [r3, #0]
 8002368:	68fb      	ldr	r3, [r7, #12]
 800236a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800236e:	69bb      	ldr	r3, [r7, #24]
 8002370:	0c1b      	lsrs	r3, r3, #16
 8002372:	b2db      	uxtb	r3, r3
 8002374:	009b      	lsls	r3, r3, #2
 8002376:	440b      	add	r3, r1
 8002378:	681b      	ldr	r3, [r3, #0]
 800237a:	405a      	eors	r2, r3
 800237c:	68fb      	ldr	r3, [r7, #12]
 800237e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002382:	69fb      	ldr	r3, [r7, #28]
 8002384:	0a1b      	lsrs	r3, r3, #8
 8002386:	b2db      	uxtb	r3, r3
 8002388:	009b      	lsls	r3, r3, #2
 800238a:	440b      	add	r3, r1
 800238c:	681b      	ldr	r3, [r3, #0]
 800238e:	405a      	eors	r2, r3
 8002390:	68fb      	ldr	r3, [r7, #12]
 8002392:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002396:	693b      	ldr	r3, [r7, #16]
 8002398:	b2db      	uxtb	r3, r3
 800239a:	009b      	lsls	r3, r3, #2
 800239c:	440b      	add	r3, r1
 800239e:	681b      	ldr	r3, [r3, #0]
 80023a0:	405a      	eors	r2, r3
 80023a2:	68bb      	ldr	r3, [r7, #8]
 80023a4:	3338      	adds	r3, #56	; 0x38
 80023a6:	681b      	ldr	r3, [r3, #0]
 80023a8:	4053      	eors	r3, r2
 80023aa:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[15];
 80023ac:	68fb      	ldr	r3, [r7, #12]
 80023ae:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80023b2:	693b      	ldr	r3, [r7, #16]
 80023b4:	0e1b      	lsrs	r3, r3, #24
 80023b6:	009b      	lsls	r3, r3, #2
 80023b8:	4413      	add	r3, r2
 80023ba:	681a      	ldr	r2, [r3, #0]
 80023bc:	68fb      	ldr	r3, [r7, #12]
 80023be:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80023c2:	697b      	ldr	r3, [r7, #20]
 80023c4:	0c1b      	lsrs	r3, r3, #16
 80023c6:	b2db      	uxtb	r3, r3
 80023c8:	009b      	lsls	r3, r3, #2
 80023ca:	440b      	add	r3, r1
 80023cc:	681b      	ldr	r3, [r3, #0]
 80023ce:	405a      	eors	r2, r3
 80023d0:	68fb      	ldr	r3, [r7, #12]
 80023d2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80023d6:	69bb      	ldr	r3, [r7, #24]
 80023d8:	0a1b      	lsrs	r3, r3, #8
 80023da:	b2db      	uxtb	r3, r3
 80023dc:	009b      	lsls	r3, r3, #2
 80023de:	440b      	add	r3, r1
 80023e0:	681b      	ldr	r3, [r3, #0]
 80023e2:	405a      	eors	r2, r3
 80023e4:	68fb      	ldr	r3, [r7, #12]
 80023e6:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80023ea:	69fb      	ldr	r3, [r7, #28]
 80023ec:	b2db      	uxtb	r3, r3
 80023ee:	009b      	lsls	r3, r3, #2
 80023f0:	440b      	add	r3, r1
 80023f2:	681b      	ldr	r3, [r3, #0]
 80023f4:	405a      	eors	r2, r3
 80023f6:	68bb      	ldr	r3, [r7, #8]
 80023f8:	333c      	adds	r3, #60	; 0x3c
 80023fa:	681b      	ldr	r3, [r3, #0]
 80023fc:	4053      	eors	r3, r2
 80023fe:	623b      	str	r3, [r7, #32]
    /* round 4: */
    s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[16];
 8002400:	68fb      	ldr	r3, [r7, #12]
 8002402:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002406:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002408:	0e1b      	lsrs	r3, r3, #24
 800240a:	009b      	lsls	r3, r3, #2
 800240c:	4413      	add	r3, r2
 800240e:	681a      	ldr	r2, [r3, #0]
 8002410:	68fb      	ldr	r3, [r7, #12]
 8002412:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002416:	6a3b      	ldr	r3, [r7, #32]
 8002418:	0c1b      	lsrs	r3, r3, #16
 800241a:	b2db      	uxtb	r3, r3
 800241c:	009b      	lsls	r3, r3, #2
 800241e:	440b      	add	r3, r1
 8002420:	681b      	ldr	r3, [r3, #0]
 8002422:	405a      	eors	r2, r3
 8002424:	68fb      	ldr	r3, [r7, #12]
 8002426:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800242a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800242c:	0a1b      	lsrs	r3, r3, #8
 800242e:	b2db      	uxtb	r3, r3
 8002430:	009b      	lsls	r3, r3, #2
 8002432:	440b      	add	r3, r1
 8002434:	681b      	ldr	r3, [r3, #0]
 8002436:	405a      	eors	r2, r3
 8002438:	68fb      	ldr	r3, [r7, #12]
 800243a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800243e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002440:	b2db      	uxtb	r3, r3
 8002442:	009b      	lsls	r3, r3, #2
 8002444:	440b      	add	r3, r1
 8002446:	681b      	ldr	r3, [r3, #0]
 8002448:	405a      	eors	r2, r3
 800244a:	68bb      	ldr	r3, [r7, #8]
 800244c:	3340      	adds	r3, #64	; 0x40
 800244e:	681b      	ldr	r3, [r3, #0]
 8002450:	4053      	eors	r3, r2
 8002452:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[17];
 8002454:	68fb      	ldr	r3, [r7, #12]
 8002456:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800245a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800245c:	0e1b      	lsrs	r3, r3, #24
 800245e:	009b      	lsls	r3, r3, #2
 8002460:	4413      	add	r3, r2
 8002462:	681a      	ldr	r2, [r3, #0]
 8002464:	68fb      	ldr	r3, [r7, #12]
 8002466:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800246a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800246c:	0c1b      	lsrs	r3, r3, #16
 800246e:	b2db      	uxtb	r3, r3
 8002470:	009b      	lsls	r3, r3, #2
 8002472:	440b      	add	r3, r1
 8002474:	681b      	ldr	r3, [r3, #0]
 8002476:	405a      	eors	r2, r3
 8002478:	68fb      	ldr	r3, [r7, #12]
 800247a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800247e:	6a3b      	ldr	r3, [r7, #32]
 8002480:	0a1b      	lsrs	r3, r3, #8
 8002482:	b2db      	uxtb	r3, r3
 8002484:	009b      	lsls	r3, r3, #2
 8002486:	440b      	add	r3, r1
 8002488:	681b      	ldr	r3, [r3, #0]
 800248a:	405a      	eors	r2, r3
 800248c:	68fb      	ldr	r3, [r7, #12]
 800248e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002492:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002494:	b2db      	uxtb	r3, r3
 8002496:	009b      	lsls	r3, r3, #2
 8002498:	440b      	add	r3, r1
 800249a:	681b      	ldr	r3, [r3, #0]
 800249c:	405a      	eors	r2, r3
 800249e:	68bb      	ldr	r3, [r7, #8]
 80024a0:	3344      	adds	r3, #68	; 0x44
 80024a2:	681b      	ldr	r3, [r3, #0]
 80024a4:	4053      	eors	r3, r2
 80024a6:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[18];
 80024a8:	68fb      	ldr	r3, [r7, #12]
 80024aa:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80024ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80024b0:	0e1b      	lsrs	r3, r3, #24
 80024b2:	009b      	lsls	r3, r3, #2
 80024b4:	4413      	add	r3, r2
 80024b6:	681a      	ldr	r2, [r3, #0]
 80024b8:	68fb      	ldr	r3, [r7, #12]
 80024ba:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80024be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80024c0:	0c1b      	lsrs	r3, r3, #16
 80024c2:	b2db      	uxtb	r3, r3
 80024c4:	009b      	lsls	r3, r3, #2
 80024c6:	440b      	add	r3, r1
 80024c8:	681b      	ldr	r3, [r3, #0]
 80024ca:	405a      	eors	r2, r3
 80024cc:	68fb      	ldr	r3, [r7, #12]
 80024ce:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80024d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80024d4:	0a1b      	lsrs	r3, r3, #8
 80024d6:	b2db      	uxtb	r3, r3
 80024d8:	009b      	lsls	r3, r3, #2
 80024da:	440b      	add	r3, r1
 80024dc:	681b      	ldr	r3, [r3, #0]
 80024de:	405a      	eors	r2, r3
 80024e0:	68fb      	ldr	r3, [r7, #12]
 80024e2:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80024e6:	6a3b      	ldr	r3, [r7, #32]
 80024e8:	b2db      	uxtb	r3, r3
 80024ea:	009b      	lsls	r3, r3, #2
 80024ec:	440b      	add	r3, r1
 80024ee:	681b      	ldr	r3, [r3, #0]
 80024f0:	405a      	eors	r2, r3
 80024f2:	68bb      	ldr	r3, [r7, #8]
 80024f4:	3348      	adds	r3, #72	; 0x48
 80024f6:	681b      	ldr	r3, [r3, #0]
 80024f8:	4053      	eors	r3, r2
 80024fa:	617b      	str	r3, [r7, #20]
    s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[19];
 80024fc:	68fb      	ldr	r3, [r7, #12]
 80024fe:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002502:	6a3b      	ldr	r3, [r7, #32]
 8002504:	0e1b      	lsrs	r3, r3, #24
 8002506:	009b      	lsls	r3, r3, #2
 8002508:	4413      	add	r3, r2
 800250a:	681a      	ldr	r2, [r3, #0]
 800250c:	68fb      	ldr	r3, [r7, #12]
 800250e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002512:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002514:	0c1b      	lsrs	r3, r3, #16
 8002516:	b2db      	uxtb	r3, r3
 8002518:	009b      	lsls	r3, r3, #2
 800251a:	440b      	add	r3, r1
 800251c:	681b      	ldr	r3, [r3, #0]
 800251e:	405a      	eors	r2, r3
 8002520:	68fb      	ldr	r3, [r7, #12]
 8002522:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002526:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002528:	0a1b      	lsrs	r3, r3, #8
 800252a:	b2db      	uxtb	r3, r3
 800252c:	009b      	lsls	r3, r3, #2
 800252e:	440b      	add	r3, r1
 8002530:	681b      	ldr	r3, [r3, #0]
 8002532:	405a      	eors	r2, r3
 8002534:	68fb      	ldr	r3, [r7, #12]
 8002536:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800253a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800253c:	b2db      	uxtb	r3, r3
 800253e:	009b      	lsls	r3, r3, #2
 8002540:	440b      	add	r3, r1
 8002542:	681b      	ldr	r3, [r3, #0]
 8002544:	405a      	eors	r2, r3
 8002546:	68bb      	ldr	r3, [r7, #8]
 8002548:	334c      	adds	r3, #76	; 0x4c
 800254a:	681b      	ldr	r3, [r3, #0]
 800254c:	4053      	eors	r3, r2
 800254e:	613b      	str	r3, [r7, #16]
    /* round 5: */
    t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[20];
 8002550:	68fb      	ldr	r3, [r7, #12]
 8002552:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002556:	69fb      	ldr	r3, [r7, #28]
 8002558:	0e1b      	lsrs	r3, r3, #24
 800255a:	009b      	lsls	r3, r3, #2
 800255c:	4413      	add	r3, r2
 800255e:	681a      	ldr	r2, [r3, #0]
 8002560:	68fb      	ldr	r3, [r7, #12]
 8002562:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002566:	693b      	ldr	r3, [r7, #16]
 8002568:	0c1b      	lsrs	r3, r3, #16
 800256a:	b2db      	uxtb	r3, r3
 800256c:	009b      	lsls	r3, r3, #2
 800256e:	440b      	add	r3, r1
 8002570:	681b      	ldr	r3, [r3, #0]
 8002572:	405a      	eors	r2, r3
 8002574:	68fb      	ldr	r3, [r7, #12]
 8002576:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800257a:	697b      	ldr	r3, [r7, #20]
 800257c:	0a1b      	lsrs	r3, r3, #8
 800257e:	b2db      	uxtb	r3, r3
 8002580:	009b      	lsls	r3, r3, #2
 8002582:	440b      	add	r3, r1
 8002584:	681b      	ldr	r3, [r3, #0]
 8002586:	405a      	eors	r2, r3
 8002588:	68fb      	ldr	r3, [r7, #12]
 800258a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800258e:	69bb      	ldr	r3, [r7, #24]
 8002590:	b2db      	uxtb	r3, r3
 8002592:	009b      	lsls	r3, r3, #2
 8002594:	440b      	add	r3, r1
 8002596:	681b      	ldr	r3, [r3, #0]
 8002598:	405a      	eors	r2, r3
 800259a:	68bb      	ldr	r3, [r7, #8]
 800259c:	3350      	adds	r3, #80	; 0x50
 800259e:	681b      	ldr	r3, [r3, #0]
 80025a0:	4053      	eors	r3, r2
 80025a2:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[21];
 80025a4:	68fb      	ldr	r3, [r7, #12]
 80025a6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80025aa:	69bb      	ldr	r3, [r7, #24]
 80025ac:	0e1b      	lsrs	r3, r3, #24
 80025ae:	009b      	lsls	r3, r3, #2
 80025b0:	4413      	add	r3, r2
 80025b2:	681a      	ldr	r2, [r3, #0]
 80025b4:	68fb      	ldr	r3, [r7, #12]
 80025b6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80025ba:	69fb      	ldr	r3, [r7, #28]
 80025bc:	0c1b      	lsrs	r3, r3, #16
 80025be:	b2db      	uxtb	r3, r3
 80025c0:	009b      	lsls	r3, r3, #2
 80025c2:	440b      	add	r3, r1
 80025c4:	681b      	ldr	r3, [r3, #0]
 80025c6:	405a      	eors	r2, r3
 80025c8:	68fb      	ldr	r3, [r7, #12]
 80025ca:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80025ce:	693b      	ldr	r3, [r7, #16]
 80025d0:	0a1b      	lsrs	r3, r3, #8
 80025d2:	b2db      	uxtb	r3, r3
 80025d4:	009b      	lsls	r3, r3, #2
 80025d6:	440b      	add	r3, r1
 80025d8:	681b      	ldr	r3, [r3, #0]
 80025da:	405a      	eors	r2, r3
 80025dc:	68fb      	ldr	r3, [r7, #12]
 80025de:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80025e2:	697b      	ldr	r3, [r7, #20]
 80025e4:	b2db      	uxtb	r3, r3
 80025e6:	009b      	lsls	r3, r3, #2
 80025e8:	440b      	add	r3, r1
 80025ea:	681b      	ldr	r3, [r3, #0]
 80025ec:	405a      	eors	r2, r3
 80025ee:	68bb      	ldr	r3, [r7, #8]
 80025f0:	3354      	adds	r3, #84	; 0x54
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	4053      	eors	r3, r2
 80025f6:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[22];
 80025f8:	68fb      	ldr	r3, [r7, #12]
 80025fa:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80025fe:	697b      	ldr	r3, [r7, #20]
 8002600:	0e1b      	lsrs	r3, r3, #24
 8002602:	009b      	lsls	r3, r3, #2
 8002604:	4413      	add	r3, r2
 8002606:	681a      	ldr	r2, [r3, #0]
 8002608:	68fb      	ldr	r3, [r7, #12]
 800260a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800260e:	69bb      	ldr	r3, [r7, #24]
 8002610:	0c1b      	lsrs	r3, r3, #16
 8002612:	b2db      	uxtb	r3, r3
 8002614:	009b      	lsls	r3, r3, #2
 8002616:	440b      	add	r3, r1
 8002618:	681b      	ldr	r3, [r3, #0]
 800261a:	405a      	eors	r2, r3
 800261c:	68fb      	ldr	r3, [r7, #12]
 800261e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002622:	69fb      	ldr	r3, [r7, #28]
 8002624:	0a1b      	lsrs	r3, r3, #8
 8002626:	b2db      	uxtb	r3, r3
 8002628:	009b      	lsls	r3, r3, #2
 800262a:	440b      	add	r3, r1
 800262c:	681b      	ldr	r3, [r3, #0]
 800262e:	405a      	eors	r2, r3
 8002630:	68fb      	ldr	r3, [r7, #12]
 8002632:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002636:	693b      	ldr	r3, [r7, #16]
 8002638:	b2db      	uxtb	r3, r3
 800263a:	009b      	lsls	r3, r3, #2
 800263c:	440b      	add	r3, r1
 800263e:	681b      	ldr	r3, [r3, #0]
 8002640:	405a      	eors	r2, r3
 8002642:	68bb      	ldr	r3, [r7, #8]
 8002644:	3358      	adds	r3, #88	; 0x58
 8002646:	681b      	ldr	r3, [r3, #0]
 8002648:	4053      	eors	r3, r2
 800264a:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[23];
 800264c:	68fb      	ldr	r3, [r7, #12]
 800264e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002652:	693b      	ldr	r3, [r7, #16]
 8002654:	0e1b      	lsrs	r3, r3, #24
 8002656:	009b      	lsls	r3, r3, #2
 8002658:	4413      	add	r3, r2
 800265a:	681a      	ldr	r2, [r3, #0]
 800265c:	68fb      	ldr	r3, [r7, #12]
 800265e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002662:	697b      	ldr	r3, [r7, #20]
 8002664:	0c1b      	lsrs	r3, r3, #16
 8002666:	b2db      	uxtb	r3, r3
 8002668:	009b      	lsls	r3, r3, #2
 800266a:	440b      	add	r3, r1
 800266c:	681b      	ldr	r3, [r3, #0]
 800266e:	405a      	eors	r2, r3
 8002670:	68fb      	ldr	r3, [r7, #12]
 8002672:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002676:	69bb      	ldr	r3, [r7, #24]
 8002678:	0a1b      	lsrs	r3, r3, #8
 800267a:	b2db      	uxtb	r3, r3
 800267c:	009b      	lsls	r3, r3, #2
 800267e:	440b      	add	r3, r1
 8002680:	681b      	ldr	r3, [r3, #0]
 8002682:	405a      	eors	r2, r3
 8002684:	68fb      	ldr	r3, [r7, #12]
 8002686:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800268a:	69fb      	ldr	r3, [r7, #28]
 800268c:	b2db      	uxtb	r3, r3
 800268e:	009b      	lsls	r3, r3, #2
 8002690:	440b      	add	r3, r1
 8002692:	681b      	ldr	r3, [r3, #0]
 8002694:	405a      	eors	r2, r3
 8002696:	68bb      	ldr	r3, [r7, #8]
 8002698:	335c      	adds	r3, #92	; 0x5c
 800269a:	681b      	ldr	r3, [r3, #0]
 800269c:	4053      	eors	r3, r2
 800269e:	623b      	str	r3, [r7, #32]
    /* round 6: */
    s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[24];
 80026a0:	68fb      	ldr	r3, [r7, #12]
 80026a2:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80026a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80026a8:	0e1b      	lsrs	r3, r3, #24
 80026aa:	009b      	lsls	r3, r3, #2
 80026ac:	4413      	add	r3, r2
 80026ae:	681a      	ldr	r2, [r3, #0]
 80026b0:	68fb      	ldr	r3, [r7, #12]
 80026b2:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80026b6:	6a3b      	ldr	r3, [r7, #32]
 80026b8:	0c1b      	lsrs	r3, r3, #16
 80026ba:	b2db      	uxtb	r3, r3
 80026bc:	009b      	lsls	r3, r3, #2
 80026be:	440b      	add	r3, r1
 80026c0:	681b      	ldr	r3, [r3, #0]
 80026c2:	405a      	eors	r2, r3
 80026c4:	68fb      	ldr	r3, [r7, #12]
 80026c6:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80026ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80026cc:	0a1b      	lsrs	r3, r3, #8
 80026ce:	b2db      	uxtb	r3, r3
 80026d0:	009b      	lsls	r3, r3, #2
 80026d2:	440b      	add	r3, r1
 80026d4:	681b      	ldr	r3, [r3, #0]
 80026d6:	405a      	eors	r2, r3
 80026d8:	68fb      	ldr	r3, [r7, #12]
 80026da:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80026de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80026e0:	b2db      	uxtb	r3, r3
 80026e2:	009b      	lsls	r3, r3, #2
 80026e4:	440b      	add	r3, r1
 80026e6:	681b      	ldr	r3, [r3, #0]
 80026e8:	405a      	eors	r2, r3
 80026ea:	68bb      	ldr	r3, [r7, #8]
 80026ec:	3360      	adds	r3, #96	; 0x60
 80026ee:	681b      	ldr	r3, [r3, #0]
 80026f0:	4053      	eors	r3, r2
 80026f2:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[25];
 80026f4:	68fb      	ldr	r3, [r7, #12]
 80026f6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80026fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80026fc:	0e1b      	lsrs	r3, r3, #24
 80026fe:	009b      	lsls	r3, r3, #2
 8002700:	4413      	add	r3, r2
 8002702:	681a      	ldr	r2, [r3, #0]
 8002704:	68fb      	ldr	r3, [r7, #12]
 8002706:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800270a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800270c:	0c1b      	lsrs	r3, r3, #16
 800270e:	b2db      	uxtb	r3, r3
 8002710:	009b      	lsls	r3, r3, #2
 8002712:	440b      	add	r3, r1
 8002714:	681b      	ldr	r3, [r3, #0]
 8002716:	405a      	eors	r2, r3
 8002718:	68fb      	ldr	r3, [r7, #12]
 800271a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800271e:	6a3b      	ldr	r3, [r7, #32]
 8002720:	0a1b      	lsrs	r3, r3, #8
 8002722:	b2db      	uxtb	r3, r3
 8002724:	009b      	lsls	r3, r3, #2
 8002726:	440b      	add	r3, r1
 8002728:	681b      	ldr	r3, [r3, #0]
 800272a:	405a      	eors	r2, r3
 800272c:	68fb      	ldr	r3, [r7, #12]
 800272e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002732:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002734:	b2db      	uxtb	r3, r3
 8002736:	009b      	lsls	r3, r3, #2
 8002738:	440b      	add	r3, r1
 800273a:	681b      	ldr	r3, [r3, #0]
 800273c:	405a      	eors	r2, r3
 800273e:	68bb      	ldr	r3, [r7, #8]
 8002740:	3364      	adds	r3, #100	; 0x64
 8002742:	681b      	ldr	r3, [r3, #0]
 8002744:	4053      	eors	r3, r2
 8002746:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[26];
 8002748:	68fb      	ldr	r3, [r7, #12]
 800274a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800274e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002750:	0e1b      	lsrs	r3, r3, #24
 8002752:	009b      	lsls	r3, r3, #2
 8002754:	4413      	add	r3, r2
 8002756:	681a      	ldr	r2, [r3, #0]
 8002758:	68fb      	ldr	r3, [r7, #12]
 800275a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800275e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002760:	0c1b      	lsrs	r3, r3, #16
 8002762:	b2db      	uxtb	r3, r3
 8002764:	009b      	lsls	r3, r3, #2
 8002766:	440b      	add	r3, r1
 8002768:	681b      	ldr	r3, [r3, #0]
 800276a:	405a      	eors	r2, r3
 800276c:	68fb      	ldr	r3, [r7, #12]
 800276e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002772:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002774:	0a1b      	lsrs	r3, r3, #8
 8002776:	b2db      	uxtb	r3, r3
 8002778:	009b      	lsls	r3, r3, #2
 800277a:	440b      	add	r3, r1
 800277c:	681b      	ldr	r3, [r3, #0]
 800277e:	405a      	eors	r2, r3
 8002780:	68fb      	ldr	r3, [r7, #12]
 8002782:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002786:	6a3b      	ldr	r3, [r7, #32]
 8002788:	b2db      	uxtb	r3, r3
 800278a:	009b      	lsls	r3, r3, #2
 800278c:	440b      	add	r3, r1
 800278e:	681b      	ldr	r3, [r3, #0]
 8002790:	405a      	eors	r2, r3
 8002792:	68bb      	ldr	r3, [r7, #8]
 8002794:	3368      	adds	r3, #104	; 0x68
 8002796:	681b      	ldr	r3, [r3, #0]
 8002798:	4053      	eors	r3, r2
 800279a:	617b      	str	r3, [r7, #20]
    s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[27];
 800279c:	68fb      	ldr	r3, [r7, #12]
 800279e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80027a2:	6a3b      	ldr	r3, [r7, #32]
 80027a4:	0e1b      	lsrs	r3, r3, #24
 80027a6:	009b      	lsls	r3, r3, #2
 80027a8:	4413      	add	r3, r2
 80027aa:	681a      	ldr	r2, [r3, #0]
 80027ac:	68fb      	ldr	r3, [r7, #12]
 80027ae:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80027b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80027b4:	0c1b      	lsrs	r3, r3, #16
 80027b6:	b2db      	uxtb	r3, r3
 80027b8:	009b      	lsls	r3, r3, #2
 80027ba:	440b      	add	r3, r1
 80027bc:	681b      	ldr	r3, [r3, #0]
 80027be:	405a      	eors	r2, r3
 80027c0:	68fb      	ldr	r3, [r7, #12]
 80027c2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80027c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80027c8:	0a1b      	lsrs	r3, r3, #8
 80027ca:	b2db      	uxtb	r3, r3
 80027cc:	009b      	lsls	r3, r3, #2
 80027ce:	440b      	add	r3, r1
 80027d0:	681b      	ldr	r3, [r3, #0]
 80027d2:	405a      	eors	r2, r3
 80027d4:	68fb      	ldr	r3, [r7, #12]
 80027d6:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80027da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80027dc:	b2db      	uxtb	r3, r3
 80027de:	009b      	lsls	r3, r3, #2
 80027e0:	440b      	add	r3, r1
 80027e2:	681b      	ldr	r3, [r3, #0]
 80027e4:	405a      	eors	r2, r3
 80027e6:	68bb      	ldr	r3, [r7, #8]
 80027e8:	336c      	adds	r3, #108	; 0x6c
 80027ea:	681b      	ldr	r3, [r3, #0]
 80027ec:	4053      	eors	r3, r2
 80027ee:	613b      	str	r3, [r7, #16]
    /* round 7: */
    t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[28];
 80027f0:	68fb      	ldr	r3, [r7, #12]
 80027f2:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80027f6:	69fb      	ldr	r3, [r7, #28]
 80027f8:	0e1b      	lsrs	r3, r3, #24
 80027fa:	009b      	lsls	r3, r3, #2
 80027fc:	4413      	add	r3, r2
 80027fe:	681a      	ldr	r2, [r3, #0]
 8002800:	68fb      	ldr	r3, [r7, #12]
 8002802:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002806:	693b      	ldr	r3, [r7, #16]
 8002808:	0c1b      	lsrs	r3, r3, #16
 800280a:	b2db      	uxtb	r3, r3
 800280c:	009b      	lsls	r3, r3, #2
 800280e:	440b      	add	r3, r1
 8002810:	681b      	ldr	r3, [r3, #0]
 8002812:	405a      	eors	r2, r3
 8002814:	68fb      	ldr	r3, [r7, #12]
 8002816:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800281a:	697b      	ldr	r3, [r7, #20]
 800281c:	0a1b      	lsrs	r3, r3, #8
 800281e:	b2db      	uxtb	r3, r3
 8002820:	009b      	lsls	r3, r3, #2
 8002822:	440b      	add	r3, r1
 8002824:	681b      	ldr	r3, [r3, #0]
 8002826:	405a      	eors	r2, r3
 8002828:	68fb      	ldr	r3, [r7, #12]
 800282a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800282e:	69bb      	ldr	r3, [r7, #24]
 8002830:	b2db      	uxtb	r3, r3
 8002832:	009b      	lsls	r3, r3, #2
 8002834:	440b      	add	r3, r1
 8002836:	681b      	ldr	r3, [r3, #0]
 8002838:	405a      	eors	r2, r3
 800283a:	68bb      	ldr	r3, [r7, #8]
 800283c:	3370      	adds	r3, #112	; 0x70
 800283e:	681b      	ldr	r3, [r3, #0]
 8002840:	4053      	eors	r3, r2
 8002842:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[29];
 8002844:	68fb      	ldr	r3, [r7, #12]
 8002846:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800284a:	69bb      	ldr	r3, [r7, #24]
 800284c:	0e1b      	lsrs	r3, r3, #24
 800284e:	009b      	lsls	r3, r3, #2
 8002850:	4413      	add	r3, r2
 8002852:	681a      	ldr	r2, [r3, #0]
 8002854:	68fb      	ldr	r3, [r7, #12]
 8002856:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800285a:	69fb      	ldr	r3, [r7, #28]
 800285c:	0c1b      	lsrs	r3, r3, #16
 800285e:	b2db      	uxtb	r3, r3
 8002860:	009b      	lsls	r3, r3, #2
 8002862:	440b      	add	r3, r1
 8002864:	681b      	ldr	r3, [r3, #0]
 8002866:	405a      	eors	r2, r3
 8002868:	68fb      	ldr	r3, [r7, #12]
 800286a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800286e:	693b      	ldr	r3, [r7, #16]
 8002870:	0a1b      	lsrs	r3, r3, #8
 8002872:	b2db      	uxtb	r3, r3
 8002874:	009b      	lsls	r3, r3, #2
 8002876:	440b      	add	r3, r1
 8002878:	681b      	ldr	r3, [r3, #0]
 800287a:	405a      	eors	r2, r3
 800287c:	68fb      	ldr	r3, [r7, #12]
 800287e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002882:	697b      	ldr	r3, [r7, #20]
 8002884:	b2db      	uxtb	r3, r3
 8002886:	009b      	lsls	r3, r3, #2
 8002888:	440b      	add	r3, r1
 800288a:	681b      	ldr	r3, [r3, #0]
 800288c:	405a      	eors	r2, r3
 800288e:	68bb      	ldr	r3, [r7, #8]
 8002890:	3374      	adds	r3, #116	; 0x74
 8002892:	681b      	ldr	r3, [r3, #0]
 8002894:	4053      	eors	r3, r2
 8002896:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[30];
 8002898:	68fb      	ldr	r3, [r7, #12]
 800289a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800289e:	697b      	ldr	r3, [r7, #20]
 80028a0:	0e1b      	lsrs	r3, r3, #24
 80028a2:	009b      	lsls	r3, r3, #2
 80028a4:	4413      	add	r3, r2
 80028a6:	681a      	ldr	r2, [r3, #0]
 80028a8:	68fb      	ldr	r3, [r7, #12]
 80028aa:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80028ae:	69bb      	ldr	r3, [r7, #24]
 80028b0:	0c1b      	lsrs	r3, r3, #16
 80028b2:	b2db      	uxtb	r3, r3
 80028b4:	009b      	lsls	r3, r3, #2
 80028b6:	440b      	add	r3, r1
 80028b8:	681b      	ldr	r3, [r3, #0]
 80028ba:	405a      	eors	r2, r3
 80028bc:	68fb      	ldr	r3, [r7, #12]
 80028be:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80028c2:	69fb      	ldr	r3, [r7, #28]
 80028c4:	0a1b      	lsrs	r3, r3, #8
 80028c6:	b2db      	uxtb	r3, r3
 80028c8:	009b      	lsls	r3, r3, #2
 80028ca:	440b      	add	r3, r1
 80028cc:	681b      	ldr	r3, [r3, #0]
 80028ce:	405a      	eors	r2, r3
 80028d0:	68fb      	ldr	r3, [r7, #12]
 80028d2:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80028d6:	693b      	ldr	r3, [r7, #16]
 80028d8:	b2db      	uxtb	r3, r3
 80028da:	009b      	lsls	r3, r3, #2
 80028dc:	440b      	add	r3, r1
 80028de:	681b      	ldr	r3, [r3, #0]
 80028e0:	405a      	eors	r2, r3
 80028e2:	68bb      	ldr	r3, [r7, #8]
 80028e4:	3378      	adds	r3, #120	; 0x78
 80028e6:	681b      	ldr	r3, [r3, #0]
 80028e8:	4053      	eors	r3, r2
 80028ea:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[31];
 80028ec:	68fb      	ldr	r3, [r7, #12]
 80028ee:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80028f2:	693b      	ldr	r3, [r7, #16]
 80028f4:	0e1b      	lsrs	r3, r3, #24
 80028f6:	009b      	lsls	r3, r3, #2
 80028f8:	4413      	add	r3, r2
 80028fa:	681a      	ldr	r2, [r3, #0]
 80028fc:	68fb      	ldr	r3, [r7, #12]
 80028fe:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002902:	697b      	ldr	r3, [r7, #20]
 8002904:	0c1b      	lsrs	r3, r3, #16
 8002906:	b2db      	uxtb	r3, r3
 8002908:	009b      	lsls	r3, r3, #2
 800290a:	440b      	add	r3, r1
 800290c:	681b      	ldr	r3, [r3, #0]
 800290e:	405a      	eors	r2, r3
 8002910:	68fb      	ldr	r3, [r7, #12]
 8002912:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002916:	69bb      	ldr	r3, [r7, #24]
 8002918:	0a1b      	lsrs	r3, r3, #8
 800291a:	b2db      	uxtb	r3, r3
 800291c:	009b      	lsls	r3, r3, #2
 800291e:	440b      	add	r3, r1
 8002920:	681b      	ldr	r3, [r3, #0]
 8002922:	405a      	eors	r2, r3
 8002924:	68fb      	ldr	r3, [r7, #12]
 8002926:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800292a:	69fb      	ldr	r3, [r7, #28]
 800292c:	b2db      	uxtb	r3, r3
 800292e:	009b      	lsls	r3, r3, #2
 8002930:	440b      	add	r3, r1
 8002932:	681b      	ldr	r3, [r3, #0]
 8002934:	405a      	eors	r2, r3
 8002936:	68bb      	ldr	r3, [r7, #8]
 8002938:	337c      	adds	r3, #124	; 0x7c
 800293a:	681b      	ldr	r3, [r3, #0]
 800293c:	4053      	eors	r3, r2
 800293e:	623b      	str	r3, [r7, #32]
    /* round 8: */
    s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[32];
 8002940:	68fb      	ldr	r3, [r7, #12]
 8002942:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002946:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002948:	0e1b      	lsrs	r3, r3, #24
 800294a:	009b      	lsls	r3, r3, #2
 800294c:	4413      	add	r3, r2
 800294e:	681a      	ldr	r2, [r3, #0]
 8002950:	68fb      	ldr	r3, [r7, #12]
 8002952:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002956:	6a3b      	ldr	r3, [r7, #32]
 8002958:	0c1b      	lsrs	r3, r3, #16
 800295a:	b2db      	uxtb	r3, r3
 800295c:	009b      	lsls	r3, r3, #2
 800295e:	440b      	add	r3, r1
 8002960:	681b      	ldr	r3, [r3, #0]
 8002962:	405a      	eors	r2, r3
 8002964:	68fb      	ldr	r3, [r7, #12]
 8002966:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800296a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800296c:	0a1b      	lsrs	r3, r3, #8
 800296e:	b2db      	uxtb	r3, r3
 8002970:	009b      	lsls	r3, r3, #2
 8002972:	440b      	add	r3, r1
 8002974:	681b      	ldr	r3, [r3, #0]
 8002976:	405a      	eors	r2, r3
 8002978:	68fb      	ldr	r3, [r7, #12]
 800297a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800297e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002980:	b2db      	uxtb	r3, r3
 8002982:	009b      	lsls	r3, r3, #2
 8002984:	440b      	add	r3, r1
 8002986:	681b      	ldr	r3, [r3, #0]
 8002988:	405a      	eors	r2, r3
 800298a:	68bb      	ldr	r3, [r7, #8]
 800298c:	3380      	adds	r3, #128	; 0x80
 800298e:	681b      	ldr	r3, [r3, #0]
 8002990:	4053      	eors	r3, r2
 8002992:	61fb      	str	r3, [r7, #28]
    s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[33];
 8002994:	68fb      	ldr	r3, [r7, #12]
 8002996:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800299a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800299c:	0e1b      	lsrs	r3, r3, #24
 800299e:	009b      	lsls	r3, r3, #2
 80029a0:	4413      	add	r3, r2
 80029a2:	681a      	ldr	r2, [r3, #0]
 80029a4:	68fb      	ldr	r3, [r7, #12]
 80029a6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80029aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80029ac:	0c1b      	lsrs	r3, r3, #16
 80029ae:	b2db      	uxtb	r3, r3
 80029b0:	009b      	lsls	r3, r3, #2
 80029b2:	440b      	add	r3, r1
 80029b4:	681b      	ldr	r3, [r3, #0]
 80029b6:	405a      	eors	r2, r3
 80029b8:	68fb      	ldr	r3, [r7, #12]
 80029ba:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80029be:	6a3b      	ldr	r3, [r7, #32]
 80029c0:	0a1b      	lsrs	r3, r3, #8
 80029c2:	b2db      	uxtb	r3, r3
 80029c4:	009b      	lsls	r3, r3, #2
 80029c6:	440b      	add	r3, r1
 80029c8:	681b      	ldr	r3, [r3, #0]
 80029ca:	405a      	eors	r2, r3
 80029cc:	68fb      	ldr	r3, [r7, #12]
 80029ce:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80029d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029d4:	b2db      	uxtb	r3, r3
 80029d6:	009b      	lsls	r3, r3, #2
 80029d8:	440b      	add	r3, r1
 80029da:	681b      	ldr	r3, [r3, #0]
 80029dc:	405a      	eors	r2, r3
 80029de:	68bb      	ldr	r3, [r7, #8]
 80029e0:	3384      	adds	r3, #132	; 0x84
 80029e2:	681b      	ldr	r3, [r3, #0]
 80029e4:	4053      	eors	r3, r2
 80029e6:	61bb      	str	r3, [r7, #24]
    s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[34];
 80029e8:	68fb      	ldr	r3, [r7, #12]
 80029ea:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80029ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029f0:	0e1b      	lsrs	r3, r3, #24
 80029f2:	009b      	lsls	r3, r3, #2
 80029f4:	4413      	add	r3, r2
 80029f6:	681a      	ldr	r2, [r3, #0]
 80029f8:	68fb      	ldr	r3, [r7, #12]
 80029fa:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80029fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a00:	0c1b      	lsrs	r3, r3, #16
 8002a02:	b2db      	uxtb	r3, r3
 8002a04:	009b      	lsls	r3, r3, #2
 8002a06:	440b      	add	r3, r1
 8002a08:	681b      	ldr	r3, [r3, #0]
 8002a0a:	405a      	eors	r2, r3
 8002a0c:	68fb      	ldr	r3, [r7, #12]
 8002a0e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002a12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002a14:	0a1b      	lsrs	r3, r3, #8
 8002a16:	b2db      	uxtb	r3, r3
 8002a18:	009b      	lsls	r3, r3, #2
 8002a1a:	440b      	add	r3, r1
 8002a1c:	681b      	ldr	r3, [r3, #0]
 8002a1e:	405a      	eors	r2, r3
 8002a20:	68fb      	ldr	r3, [r7, #12]
 8002a22:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002a26:	6a3b      	ldr	r3, [r7, #32]
 8002a28:	b2db      	uxtb	r3, r3
 8002a2a:	009b      	lsls	r3, r3, #2
 8002a2c:	440b      	add	r3, r1
 8002a2e:	681b      	ldr	r3, [r3, #0]
 8002a30:	405a      	eors	r2, r3
 8002a32:	68bb      	ldr	r3, [r7, #8]
 8002a34:	3388      	adds	r3, #136	; 0x88
 8002a36:	681b      	ldr	r3, [r3, #0]
 8002a38:	4053      	eors	r3, r2
 8002a3a:	617b      	str	r3, [r7, #20]
    s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[35];
 8002a3c:	68fb      	ldr	r3, [r7, #12]
 8002a3e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002a42:	6a3b      	ldr	r3, [r7, #32]
 8002a44:	0e1b      	lsrs	r3, r3, #24
 8002a46:	009b      	lsls	r3, r3, #2
 8002a48:	4413      	add	r3, r2
 8002a4a:	681a      	ldr	r2, [r3, #0]
 8002a4c:	68fb      	ldr	r3, [r7, #12]
 8002a4e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002a52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a54:	0c1b      	lsrs	r3, r3, #16
 8002a56:	b2db      	uxtb	r3, r3
 8002a58:	009b      	lsls	r3, r3, #2
 8002a5a:	440b      	add	r3, r1
 8002a5c:	681b      	ldr	r3, [r3, #0]
 8002a5e:	405a      	eors	r2, r3
 8002a60:	68fb      	ldr	r3, [r7, #12]
 8002a62:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002a66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a68:	0a1b      	lsrs	r3, r3, #8
 8002a6a:	b2db      	uxtb	r3, r3
 8002a6c:	009b      	lsls	r3, r3, #2
 8002a6e:	440b      	add	r3, r1
 8002a70:	681b      	ldr	r3, [r3, #0]
 8002a72:	405a      	eors	r2, r3
 8002a74:	68fb      	ldr	r3, [r7, #12]
 8002a76:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002a7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002a7c:	b2db      	uxtb	r3, r3
 8002a7e:	009b      	lsls	r3, r3, #2
 8002a80:	440b      	add	r3, r1
 8002a82:	681b      	ldr	r3, [r3, #0]
 8002a84:	405a      	eors	r2, r3
 8002a86:	68bb      	ldr	r3, [r7, #8]
 8002a88:	338c      	adds	r3, #140	; 0x8c
 8002a8a:	681b      	ldr	r3, [r3, #0]
 8002a8c:	4053      	eors	r3, r2
 8002a8e:	613b      	str	r3, [r7, #16]
    /* round 9: */
    t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[36];
 8002a90:	68fb      	ldr	r3, [r7, #12]
 8002a92:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002a96:	69fb      	ldr	r3, [r7, #28]
 8002a98:	0e1b      	lsrs	r3, r3, #24
 8002a9a:	009b      	lsls	r3, r3, #2
 8002a9c:	4413      	add	r3, r2
 8002a9e:	681a      	ldr	r2, [r3, #0]
 8002aa0:	68fb      	ldr	r3, [r7, #12]
 8002aa2:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002aa6:	693b      	ldr	r3, [r7, #16]
 8002aa8:	0c1b      	lsrs	r3, r3, #16
 8002aaa:	b2db      	uxtb	r3, r3
 8002aac:	009b      	lsls	r3, r3, #2
 8002aae:	440b      	add	r3, r1
 8002ab0:	681b      	ldr	r3, [r3, #0]
 8002ab2:	405a      	eors	r2, r3
 8002ab4:	68fb      	ldr	r3, [r7, #12]
 8002ab6:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002aba:	697b      	ldr	r3, [r7, #20]
 8002abc:	0a1b      	lsrs	r3, r3, #8
 8002abe:	b2db      	uxtb	r3, r3
 8002ac0:	009b      	lsls	r3, r3, #2
 8002ac2:	440b      	add	r3, r1
 8002ac4:	681b      	ldr	r3, [r3, #0]
 8002ac6:	405a      	eors	r2, r3
 8002ac8:	68fb      	ldr	r3, [r7, #12]
 8002aca:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002ace:	69bb      	ldr	r3, [r7, #24]
 8002ad0:	b2db      	uxtb	r3, r3
 8002ad2:	009b      	lsls	r3, r3, #2
 8002ad4:	440b      	add	r3, r1
 8002ad6:	681b      	ldr	r3, [r3, #0]
 8002ad8:	405a      	eors	r2, r3
 8002ada:	68bb      	ldr	r3, [r7, #8]
 8002adc:	3390      	adds	r3, #144	; 0x90
 8002ade:	681b      	ldr	r3, [r3, #0]
 8002ae0:	4053      	eors	r3, r2
 8002ae2:	62fb      	str	r3, [r7, #44]	; 0x2c
    t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[37];
 8002ae4:	68fb      	ldr	r3, [r7, #12]
 8002ae6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002aea:	69bb      	ldr	r3, [r7, #24]
 8002aec:	0e1b      	lsrs	r3, r3, #24
 8002aee:	009b      	lsls	r3, r3, #2
 8002af0:	4413      	add	r3, r2
 8002af2:	681a      	ldr	r2, [r3, #0]
 8002af4:	68fb      	ldr	r3, [r7, #12]
 8002af6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002afa:	69fb      	ldr	r3, [r7, #28]
 8002afc:	0c1b      	lsrs	r3, r3, #16
 8002afe:	b2db      	uxtb	r3, r3
 8002b00:	009b      	lsls	r3, r3, #2
 8002b02:	440b      	add	r3, r1
 8002b04:	681b      	ldr	r3, [r3, #0]
 8002b06:	405a      	eors	r2, r3
 8002b08:	68fb      	ldr	r3, [r7, #12]
 8002b0a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002b0e:	693b      	ldr	r3, [r7, #16]
 8002b10:	0a1b      	lsrs	r3, r3, #8
 8002b12:	b2db      	uxtb	r3, r3
 8002b14:	009b      	lsls	r3, r3, #2
 8002b16:	440b      	add	r3, r1
 8002b18:	681b      	ldr	r3, [r3, #0]
 8002b1a:	405a      	eors	r2, r3
 8002b1c:	68fb      	ldr	r3, [r7, #12]
 8002b1e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002b22:	697b      	ldr	r3, [r7, #20]
 8002b24:	b2db      	uxtb	r3, r3
 8002b26:	009b      	lsls	r3, r3, #2
 8002b28:	440b      	add	r3, r1
 8002b2a:	681b      	ldr	r3, [r3, #0]
 8002b2c:	405a      	eors	r2, r3
 8002b2e:	68bb      	ldr	r3, [r7, #8]
 8002b30:	3394      	adds	r3, #148	; 0x94
 8002b32:	681b      	ldr	r3, [r3, #0]
 8002b34:	4053      	eors	r3, r2
 8002b36:	62bb      	str	r3, [r7, #40]	; 0x28
    t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[38];
 8002b38:	68fb      	ldr	r3, [r7, #12]
 8002b3a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002b3e:	697b      	ldr	r3, [r7, #20]
 8002b40:	0e1b      	lsrs	r3, r3, #24
 8002b42:	009b      	lsls	r3, r3, #2
 8002b44:	4413      	add	r3, r2
 8002b46:	681a      	ldr	r2, [r3, #0]
 8002b48:	68fb      	ldr	r3, [r7, #12]
 8002b4a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002b4e:	69bb      	ldr	r3, [r7, #24]
 8002b50:	0c1b      	lsrs	r3, r3, #16
 8002b52:	b2db      	uxtb	r3, r3
 8002b54:	009b      	lsls	r3, r3, #2
 8002b56:	440b      	add	r3, r1
 8002b58:	681b      	ldr	r3, [r3, #0]
 8002b5a:	405a      	eors	r2, r3
 8002b5c:	68fb      	ldr	r3, [r7, #12]
 8002b5e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002b62:	69fb      	ldr	r3, [r7, #28]
 8002b64:	0a1b      	lsrs	r3, r3, #8
 8002b66:	b2db      	uxtb	r3, r3
 8002b68:	009b      	lsls	r3, r3, #2
 8002b6a:	440b      	add	r3, r1
 8002b6c:	681b      	ldr	r3, [r3, #0]
 8002b6e:	405a      	eors	r2, r3
 8002b70:	68fb      	ldr	r3, [r7, #12]
 8002b72:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002b76:	693b      	ldr	r3, [r7, #16]
 8002b78:	b2db      	uxtb	r3, r3
 8002b7a:	009b      	lsls	r3, r3, #2
 8002b7c:	440b      	add	r3, r1
 8002b7e:	681b      	ldr	r3, [r3, #0]
 8002b80:	405a      	eors	r2, r3
 8002b82:	68bb      	ldr	r3, [r7, #8]
 8002b84:	3398      	adds	r3, #152	; 0x98
 8002b86:	681b      	ldr	r3, [r3, #0]
 8002b88:	4053      	eors	r3, r2
 8002b8a:	627b      	str	r3, [r7, #36]	; 0x24
    t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[39];
 8002b8c:	68fb      	ldr	r3, [r7, #12]
 8002b8e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002b92:	693b      	ldr	r3, [r7, #16]
 8002b94:	0e1b      	lsrs	r3, r3, #24
 8002b96:	009b      	lsls	r3, r3, #2
 8002b98:	4413      	add	r3, r2
 8002b9a:	681a      	ldr	r2, [r3, #0]
 8002b9c:	68fb      	ldr	r3, [r7, #12]
 8002b9e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002ba2:	697b      	ldr	r3, [r7, #20]
 8002ba4:	0c1b      	lsrs	r3, r3, #16
 8002ba6:	b2db      	uxtb	r3, r3
 8002ba8:	009b      	lsls	r3, r3, #2
 8002baa:	440b      	add	r3, r1
 8002bac:	681b      	ldr	r3, [r3, #0]
 8002bae:	405a      	eors	r2, r3
 8002bb0:	68fb      	ldr	r3, [r7, #12]
 8002bb2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002bb6:	69bb      	ldr	r3, [r7, #24]
 8002bb8:	0a1b      	lsrs	r3, r3, #8
 8002bba:	b2db      	uxtb	r3, r3
 8002bbc:	009b      	lsls	r3, r3, #2
 8002bbe:	440b      	add	r3, r1
 8002bc0:	681b      	ldr	r3, [r3, #0]
 8002bc2:	405a      	eors	r2, r3
 8002bc4:	68fb      	ldr	r3, [r7, #12]
 8002bc6:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002bca:	69fb      	ldr	r3, [r7, #28]
 8002bcc:	b2db      	uxtb	r3, r3
 8002bce:	009b      	lsls	r3, r3, #2
 8002bd0:	440b      	add	r3, r1
 8002bd2:	681b      	ldr	r3, [r3, #0]
 8002bd4:	405a      	eors	r2, r3
 8002bd6:	68bb      	ldr	r3, [r7, #8]
 8002bd8:	339c      	adds	r3, #156	; 0x9c
 8002bda:	681b      	ldr	r3, [r3, #0]
 8002bdc:	4053      	eors	r3, r2
 8002bde:	623b      	str	r3, [r7, #32]
    if (Nr > 10) {
 8002be0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8002be4:	2b0a      	cmp	r3, #10
 8002be6:	f340 82a5 	ble.w	8003134 <B5_rijndaelDecrypt+0x1186>
        /* round 10: */
        s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[40];
 8002bea:	68fb      	ldr	r3, [r7, #12]
 8002bec:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002bf0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002bf2:	0e1b      	lsrs	r3, r3, #24
 8002bf4:	009b      	lsls	r3, r3, #2
 8002bf6:	4413      	add	r3, r2
 8002bf8:	681a      	ldr	r2, [r3, #0]
 8002bfa:	68fb      	ldr	r3, [r7, #12]
 8002bfc:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002c00:	6a3b      	ldr	r3, [r7, #32]
 8002c02:	0c1b      	lsrs	r3, r3, #16
 8002c04:	b2db      	uxtb	r3, r3
 8002c06:	009b      	lsls	r3, r3, #2
 8002c08:	440b      	add	r3, r1
 8002c0a:	681b      	ldr	r3, [r3, #0]
 8002c0c:	405a      	eors	r2, r3
 8002c0e:	68fb      	ldr	r3, [r7, #12]
 8002c10:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002c14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c16:	0a1b      	lsrs	r3, r3, #8
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	009b      	lsls	r3, r3, #2
 8002c1c:	440b      	add	r3, r1
 8002c1e:	681b      	ldr	r3, [r3, #0]
 8002c20:	405a      	eors	r2, r3
 8002c22:	68fb      	ldr	r3, [r7, #12]
 8002c24:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002c28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002c2a:	b2db      	uxtb	r3, r3
 8002c2c:	009b      	lsls	r3, r3, #2
 8002c2e:	440b      	add	r3, r1
 8002c30:	681b      	ldr	r3, [r3, #0]
 8002c32:	405a      	eors	r2, r3
 8002c34:	68bb      	ldr	r3, [r7, #8]
 8002c36:	33a0      	adds	r3, #160	; 0xa0
 8002c38:	681b      	ldr	r3, [r3, #0]
 8002c3a:	4053      	eors	r3, r2
 8002c3c:	61fb      	str	r3, [r7, #28]
        s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[41];
 8002c3e:	68fb      	ldr	r3, [r7, #12]
 8002c40:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002c44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002c46:	0e1b      	lsrs	r3, r3, #24
 8002c48:	009b      	lsls	r3, r3, #2
 8002c4a:	4413      	add	r3, r2
 8002c4c:	681a      	ldr	r2, [r3, #0]
 8002c4e:	68fb      	ldr	r3, [r7, #12]
 8002c50:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002c54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c56:	0c1b      	lsrs	r3, r3, #16
 8002c58:	b2db      	uxtb	r3, r3
 8002c5a:	009b      	lsls	r3, r3, #2
 8002c5c:	440b      	add	r3, r1
 8002c5e:	681b      	ldr	r3, [r3, #0]
 8002c60:	405a      	eors	r2, r3
 8002c62:	68fb      	ldr	r3, [r7, #12]
 8002c64:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002c68:	6a3b      	ldr	r3, [r7, #32]
 8002c6a:	0a1b      	lsrs	r3, r3, #8
 8002c6c:	b2db      	uxtb	r3, r3
 8002c6e:	009b      	lsls	r3, r3, #2
 8002c70:	440b      	add	r3, r1
 8002c72:	681b      	ldr	r3, [r3, #0]
 8002c74:	405a      	eors	r2, r3
 8002c76:	68fb      	ldr	r3, [r7, #12]
 8002c78:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002c7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c7e:	b2db      	uxtb	r3, r3
 8002c80:	009b      	lsls	r3, r3, #2
 8002c82:	440b      	add	r3, r1
 8002c84:	681b      	ldr	r3, [r3, #0]
 8002c86:	405a      	eors	r2, r3
 8002c88:	68bb      	ldr	r3, [r7, #8]
 8002c8a:	33a4      	adds	r3, #164	; 0xa4
 8002c8c:	681b      	ldr	r3, [r3, #0]
 8002c8e:	4053      	eors	r3, r2
 8002c90:	61bb      	str	r3, [r7, #24]
        s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[42];
 8002c92:	68fb      	ldr	r3, [r7, #12]
 8002c94:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002c98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c9a:	0e1b      	lsrs	r3, r3, #24
 8002c9c:	009b      	lsls	r3, r3, #2
 8002c9e:	4413      	add	r3, r2
 8002ca0:	681a      	ldr	r2, [r3, #0]
 8002ca2:	68fb      	ldr	r3, [r7, #12]
 8002ca4:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002ca8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002caa:	0c1b      	lsrs	r3, r3, #16
 8002cac:	b2db      	uxtb	r3, r3
 8002cae:	009b      	lsls	r3, r3, #2
 8002cb0:	440b      	add	r3, r1
 8002cb2:	681b      	ldr	r3, [r3, #0]
 8002cb4:	405a      	eors	r2, r3
 8002cb6:	68fb      	ldr	r3, [r7, #12]
 8002cb8:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002cbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002cbe:	0a1b      	lsrs	r3, r3, #8
 8002cc0:	b2db      	uxtb	r3, r3
 8002cc2:	009b      	lsls	r3, r3, #2
 8002cc4:	440b      	add	r3, r1
 8002cc6:	681b      	ldr	r3, [r3, #0]
 8002cc8:	405a      	eors	r2, r3
 8002cca:	68fb      	ldr	r3, [r7, #12]
 8002ccc:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002cd0:	6a3b      	ldr	r3, [r7, #32]
 8002cd2:	b2db      	uxtb	r3, r3
 8002cd4:	009b      	lsls	r3, r3, #2
 8002cd6:	440b      	add	r3, r1
 8002cd8:	681b      	ldr	r3, [r3, #0]
 8002cda:	405a      	eors	r2, r3
 8002cdc:	68bb      	ldr	r3, [r7, #8]
 8002cde:	33a8      	adds	r3, #168	; 0xa8
 8002ce0:	681b      	ldr	r3, [r3, #0]
 8002ce2:	4053      	eors	r3, r2
 8002ce4:	617b      	str	r3, [r7, #20]
        s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[43];
 8002ce6:	68fb      	ldr	r3, [r7, #12]
 8002ce8:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002cec:	6a3b      	ldr	r3, [r7, #32]
 8002cee:	0e1b      	lsrs	r3, r3, #24
 8002cf0:	009b      	lsls	r3, r3, #2
 8002cf2:	4413      	add	r3, r2
 8002cf4:	681a      	ldr	r2, [r3, #0]
 8002cf6:	68fb      	ldr	r3, [r7, #12]
 8002cf8:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002cfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cfe:	0c1b      	lsrs	r3, r3, #16
 8002d00:	b2db      	uxtb	r3, r3
 8002d02:	009b      	lsls	r3, r3, #2
 8002d04:	440b      	add	r3, r1
 8002d06:	681b      	ldr	r3, [r3, #0]
 8002d08:	405a      	eors	r2, r3
 8002d0a:	68fb      	ldr	r3, [r7, #12]
 8002d0c:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002d10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002d12:	0a1b      	lsrs	r3, r3, #8
 8002d14:	b2db      	uxtb	r3, r3
 8002d16:	009b      	lsls	r3, r3, #2
 8002d18:	440b      	add	r3, r1
 8002d1a:	681b      	ldr	r3, [r3, #0]
 8002d1c:	405a      	eors	r2, r3
 8002d1e:	68fb      	ldr	r3, [r7, #12]
 8002d20:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002d24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002d26:	b2db      	uxtb	r3, r3
 8002d28:	009b      	lsls	r3, r3, #2
 8002d2a:	440b      	add	r3, r1
 8002d2c:	681b      	ldr	r3, [r3, #0]
 8002d2e:	405a      	eors	r2, r3
 8002d30:	68bb      	ldr	r3, [r7, #8]
 8002d32:	33ac      	adds	r3, #172	; 0xac
 8002d34:	681b      	ldr	r3, [r3, #0]
 8002d36:	4053      	eors	r3, r2
 8002d38:	613b      	str	r3, [r7, #16]
        /* round 11: */
        t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[44];
 8002d3a:	68fb      	ldr	r3, [r7, #12]
 8002d3c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002d40:	69fb      	ldr	r3, [r7, #28]
 8002d42:	0e1b      	lsrs	r3, r3, #24
 8002d44:	009b      	lsls	r3, r3, #2
 8002d46:	4413      	add	r3, r2
 8002d48:	681a      	ldr	r2, [r3, #0]
 8002d4a:	68fb      	ldr	r3, [r7, #12]
 8002d4c:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002d50:	693b      	ldr	r3, [r7, #16]
 8002d52:	0c1b      	lsrs	r3, r3, #16
 8002d54:	b2db      	uxtb	r3, r3
 8002d56:	009b      	lsls	r3, r3, #2
 8002d58:	440b      	add	r3, r1
 8002d5a:	681b      	ldr	r3, [r3, #0]
 8002d5c:	405a      	eors	r2, r3
 8002d5e:	68fb      	ldr	r3, [r7, #12]
 8002d60:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002d64:	697b      	ldr	r3, [r7, #20]
 8002d66:	0a1b      	lsrs	r3, r3, #8
 8002d68:	b2db      	uxtb	r3, r3
 8002d6a:	009b      	lsls	r3, r3, #2
 8002d6c:	440b      	add	r3, r1
 8002d6e:	681b      	ldr	r3, [r3, #0]
 8002d70:	405a      	eors	r2, r3
 8002d72:	68fb      	ldr	r3, [r7, #12]
 8002d74:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002d78:	69bb      	ldr	r3, [r7, #24]
 8002d7a:	b2db      	uxtb	r3, r3
 8002d7c:	009b      	lsls	r3, r3, #2
 8002d7e:	440b      	add	r3, r1
 8002d80:	681b      	ldr	r3, [r3, #0]
 8002d82:	405a      	eors	r2, r3
 8002d84:	68bb      	ldr	r3, [r7, #8]
 8002d86:	33b0      	adds	r3, #176	; 0xb0
 8002d88:	681b      	ldr	r3, [r3, #0]
 8002d8a:	4053      	eors	r3, r2
 8002d8c:	62fb      	str	r3, [r7, #44]	; 0x2c
        t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[45];
 8002d8e:	68fb      	ldr	r3, [r7, #12]
 8002d90:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002d94:	69bb      	ldr	r3, [r7, #24]
 8002d96:	0e1b      	lsrs	r3, r3, #24
 8002d98:	009b      	lsls	r3, r3, #2
 8002d9a:	4413      	add	r3, r2
 8002d9c:	681a      	ldr	r2, [r3, #0]
 8002d9e:	68fb      	ldr	r3, [r7, #12]
 8002da0:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002da4:	69fb      	ldr	r3, [r7, #28]
 8002da6:	0c1b      	lsrs	r3, r3, #16
 8002da8:	b2db      	uxtb	r3, r3
 8002daa:	009b      	lsls	r3, r3, #2
 8002dac:	440b      	add	r3, r1
 8002dae:	681b      	ldr	r3, [r3, #0]
 8002db0:	405a      	eors	r2, r3
 8002db2:	68fb      	ldr	r3, [r7, #12]
 8002db4:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002db8:	693b      	ldr	r3, [r7, #16]
 8002dba:	0a1b      	lsrs	r3, r3, #8
 8002dbc:	b2db      	uxtb	r3, r3
 8002dbe:	009b      	lsls	r3, r3, #2
 8002dc0:	440b      	add	r3, r1
 8002dc2:	681b      	ldr	r3, [r3, #0]
 8002dc4:	405a      	eors	r2, r3
 8002dc6:	68fb      	ldr	r3, [r7, #12]
 8002dc8:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002dcc:	697b      	ldr	r3, [r7, #20]
 8002dce:	b2db      	uxtb	r3, r3
 8002dd0:	009b      	lsls	r3, r3, #2
 8002dd2:	440b      	add	r3, r1
 8002dd4:	681b      	ldr	r3, [r3, #0]
 8002dd6:	405a      	eors	r2, r3
 8002dd8:	68bb      	ldr	r3, [r7, #8]
 8002dda:	33b4      	adds	r3, #180	; 0xb4
 8002ddc:	681b      	ldr	r3, [r3, #0]
 8002dde:	4053      	eors	r3, r2
 8002de0:	62bb      	str	r3, [r7, #40]	; 0x28
        t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[46];
 8002de2:	68fb      	ldr	r3, [r7, #12]
 8002de4:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002de8:	697b      	ldr	r3, [r7, #20]
 8002dea:	0e1b      	lsrs	r3, r3, #24
 8002dec:	009b      	lsls	r3, r3, #2
 8002dee:	4413      	add	r3, r2
 8002df0:	681a      	ldr	r2, [r3, #0]
 8002df2:	68fb      	ldr	r3, [r7, #12]
 8002df4:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002df8:	69bb      	ldr	r3, [r7, #24]
 8002dfa:	0c1b      	lsrs	r3, r3, #16
 8002dfc:	b2db      	uxtb	r3, r3
 8002dfe:	009b      	lsls	r3, r3, #2
 8002e00:	440b      	add	r3, r1
 8002e02:	681b      	ldr	r3, [r3, #0]
 8002e04:	405a      	eors	r2, r3
 8002e06:	68fb      	ldr	r3, [r7, #12]
 8002e08:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002e0c:	69fb      	ldr	r3, [r7, #28]
 8002e0e:	0a1b      	lsrs	r3, r3, #8
 8002e10:	b2db      	uxtb	r3, r3
 8002e12:	009b      	lsls	r3, r3, #2
 8002e14:	440b      	add	r3, r1
 8002e16:	681b      	ldr	r3, [r3, #0]
 8002e18:	405a      	eors	r2, r3
 8002e1a:	68fb      	ldr	r3, [r7, #12]
 8002e1c:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002e20:	693b      	ldr	r3, [r7, #16]
 8002e22:	b2db      	uxtb	r3, r3
 8002e24:	009b      	lsls	r3, r3, #2
 8002e26:	440b      	add	r3, r1
 8002e28:	681b      	ldr	r3, [r3, #0]
 8002e2a:	405a      	eors	r2, r3
 8002e2c:	68bb      	ldr	r3, [r7, #8]
 8002e2e:	33b8      	adds	r3, #184	; 0xb8
 8002e30:	681b      	ldr	r3, [r3, #0]
 8002e32:	4053      	eors	r3, r2
 8002e34:	627b      	str	r3, [r7, #36]	; 0x24
        t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[47];
 8002e36:	68fb      	ldr	r3, [r7, #12]
 8002e38:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002e3c:	693b      	ldr	r3, [r7, #16]
 8002e3e:	0e1b      	lsrs	r3, r3, #24
 8002e40:	009b      	lsls	r3, r3, #2
 8002e42:	4413      	add	r3, r2
 8002e44:	681a      	ldr	r2, [r3, #0]
 8002e46:	68fb      	ldr	r3, [r7, #12]
 8002e48:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002e4c:	697b      	ldr	r3, [r7, #20]
 8002e4e:	0c1b      	lsrs	r3, r3, #16
 8002e50:	b2db      	uxtb	r3, r3
 8002e52:	009b      	lsls	r3, r3, #2
 8002e54:	440b      	add	r3, r1
 8002e56:	681b      	ldr	r3, [r3, #0]
 8002e58:	405a      	eors	r2, r3
 8002e5a:	68fb      	ldr	r3, [r7, #12]
 8002e5c:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002e60:	69bb      	ldr	r3, [r7, #24]
 8002e62:	0a1b      	lsrs	r3, r3, #8
 8002e64:	b2db      	uxtb	r3, r3
 8002e66:	009b      	lsls	r3, r3, #2
 8002e68:	440b      	add	r3, r1
 8002e6a:	681b      	ldr	r3, [r3, #0]
 8002e6c:	405a      	eors	r2, r3
 8002e6e:	68fb      	ldr	r3, [r7, #12]
 8002e70:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002e74:	69fb      	ldr	r3, [r7, #28]
 8002e76:	b2db      	uxtb	r3, r3
 8002e78:	009b      	lsls	r3, r3, #2
 8002e7a:	440b      	add	r3, r1
 8002e7c:	681b      	ldr	r3, [r3, #0]
 8002e7e:	405a      	eors	r2, r3
 8002e80:	68bb      	ldr	r3, [r7, #8]
 8002e82:	33bc      	adds	r3, #188	; 0xbc
 8002e84:	681b      	ldr	r3, [r3, #0]
 8002e86:	4053      	eors	r3, r2
 8002e88:	623b      	str	r3, [r7, #32]
        if (Nr > 12) {
 8002e8a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8002e8e:	2b0c      	cmp	r3, #12
 8002e90:	f340 8150 	ble.w	8003134 <B5_rijndaelDecrypt+0x1186>
            /* round 12: */
            s0 = ctx->Td0[t0 >> 24] ^ ctx->Td1[(t3 >> 16) & 0xff] ^ ctx->Td2[(t2 >>  8) & 0xff] ^ ctx->Td3[t1 & 0xff] ^ rk[48];
 8002e94:	68fb      	ldr	r3, [r7, #12]
 8002e96:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002e9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002e9c:	0e1b      	lsrs	r3, r3, #24
 8002e9e:	009b      	lsls	r3, r3, #2
 8002ea0:	4413      	add	r3, r2
 8002ea2:	681a      	ldr	r2, [r3, #0]
 8002ea4:	68fb      	ldr	r3, [r7, #12]
 8002ea6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002eaa:	6a3b      	ldr	r3, [r7, #32]
 8002eac:	0c1b      	lsrs	r3, r3, #16
 8002eae:	b2db      	uxtb	r3, r3
 8002eb0:	009b      	lsls	r3, r3, #2
 8002eb2:	440b      	add	r3, r1
 8002eb4:	681b      	ldr	r3, [r3, #0]
 8002eb6:	405a      	eors	r2, r3
 8002eb8:	68fb      	ldr	r3, [r7, #12]
 8002eba:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002ec0:	0a1b      	lsrs	r3, r3, #8
 8002ec2:	b2db      	uxtb	r3, r3
 8002ec4:	009b      	lsls	r3, r3, #2
 8002ec6:	440b      	add	r3, r1
 8002ec8:	681b      	ldr	r3, [r3, #0]
 8002eca:	405a      	eors	r2, r3
 8002ecc:	68fb      	ldr	r3, [r7, #12]
 8002ece:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002ed2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ed4:	b2db      	uxtb	r3, r3
 8002ed6:	009b      	lsls	r3, r3, #2
 8002ed8:	440b      	add	r3, r1
 8002eda:	681b      	ldr	r3, [r3, #0]
 8002edc:	405a      	eors	r2, r3
 8002ede:	68bb      	ldr	r3, [r7, #8]
 8002ee0:	33c0      	adds	r3, #192	; 0xc0
 8002ee2:	681b      	ldr	r3, [r3, #0]
 8002ee4:	4053      	eors	r3, r2
 8002ee6:	61fb      	str	r3, [r7, #28]
            s1 = ctx->Td0[t1 >> 24] ^ ctx->Td1[(t0 >> 16) & 0xff] ^ ctx->Td2[(t3 >>  8) & 0xff] ^ ctx->Td3[t2 & 0xff] ^ rk[49];
 8002ee8:	68fb      	ldr	r3, [r7, #12]
 8002eea:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002eee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ef0:	0e1b      	lsrs	r3, r3, #24
 8002ef2:	009b      	lsls	r3, r3, #2
 8002ef4:	4413      	add	r3, r2
 8002ef6:	681a      	ldr	r2, [r3, #0]
 8002ef8:	68fb      	ldr	r3, [r7, #12]
 8002efa:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002f00:	0c1b      	lsrs	r3, r3, #16
 8002f02:	b2db      	uxtb	r3, r3
 8002f04:	009b      	lsls	r3, r3, #2
 8002f06:	440b      	add	r3, r1
 8002f08:	681b      	ldr	r3, [r3, #0]
 8002f0a:	405a      	eors	r2, r3
 8002f0c:	68fb      	ldr	r3, [r7, #12]
 8002f0e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002f12:	6a3b      	ldr	r3, [r7, #32]
 8002f14:	0a1b      	lsrs	r3, r3, #8
 8002f16:	b2db      	uxtb	r3, r3
 8002f18:	009b      	lsls	r3, r3, #2
 8002f1a:	440b      	add	r3, r1
 8002f1c:	681b      	ldr	r3, [r3, #0]
 8002f1e:	405a      	eors	r2, r3
 8002f20:	68fb      	ldr	r3, [r7, #12]
 8002f22:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002f26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002f28:	b2db      	uxtb	r3, r3
 8002f2a:	009b      	lsls	r3, r3, #2
 8002f2c:	440b      	add	r3, r1
 8002f2e:	681b      	ldr	r3, [r3, #0]
 8002f30:	405a      	eors	r2, r3
 8002f32:	68bb      	ldr	r3, [r7, #8]
 8002f34:	33c4      	adds	r3, #196	; 0xc4
 8002f36:	681b      	ldr	r3, [r3, #0]
 8002f38:	4053      	eors	r3, r2
 8002f3a:	61bb      	str	r3, [r7, #24]
            s2 = ctx->Td0[t2 >> 24] ^ ctx->Td1[(t1 >> 16) & 0xff] ^ ctx->Td2[(t0 >>  8) & 0xff] ^ ctx->Td3[t3 & 0xff] ^ rk[50];
 8002f3c:	68fb      	ldr	r3, [r7, #12]
 8002f3e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002f42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002f44:	0e1b      	lsrs	r3, r3, #24
 8002f46:	009b      	lsls	r3, r3, #2
 8002f48:	4413      	add	r3, r2
 8002f4a:	681a      	ldr	r2, [r3, #0]
 8002f4c:	68fb      	ldr	r3, [r7, #12]
 8002f4e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002f52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002f54:	0c1b      	lsrs	r3, r3, #16
 8002f56:	b2db      	uxtb	r3, r3
 8002f58:	009b      	lsls	r3, r3, #2
 8002f5a:	440b      	add	r3, r1
 8002f5c:	681b      	ldr	r3, [r3, #0]
 8002f5e:	405a      	eors	r2, r3
 8002f60:	68fb      	ldr	r3, [r7, #12]
 8002f62:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002f66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002f68:	0a1b      	lsrs	r3, r3, #8
 8002f6a:	b2db      	uxtb	r3, r3
 8002f6c:	009b      	lsls	r3, r3, #2
 8002f6e:	440b      	add	r3, r1
 8002f70:	681b      	ldr	r3, [r3, #0]
 8002f72:	405a      	eors	r2, r3
 8002f74:	68fb      	ldr	r3, [r7, #12]
 8002f76:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002f7a:	6a3b      	ldr	r3, [r7, #32]
 8002f7c:	b2db      	uxtb	r3, r3
 8002f7e:	009b      	lsls	r3, r3, #2
 8002f80:	440b      	add	r3, r1
 8002f82:	681b      	ldr	r3, [r3, #0]
 8002f84:	405a      	eors	r2, r3
 8002f86:	68bb      	ldr	r3, [r7, #8]
 8002f88:	33c8      	adds	r3, #200	; 0xc8
 8002f8a:	681b      	ldr	r3, [r3, #0]
 8002f8c:	4053      	eors	r3, r2
 8002f8e:	617b      	str	r3, [r7, #20]
            s3 = ctx->Td0[t3 >> 24] ^ ctx->Td1[(t2 >> 16) & 0xff] ^ ctx->Td2[(t1 >>  8) & 0xff] ^ ctx->Td3[t0 & 0xff] ^ rk[51];
 8002f90:	68fb      	ldr	r3, [r7, #12]
 8002f92:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002f96:	6a3b      	ldr	r3, [r7, #32]
 8002f98:	0e1b      	lsrs	r3, r3, #24
 8002f9a:	009b      	lsls	r3, r3, #2
 8002f9c:	4413      	add	r3, r2
 8002f9e:	681a      	ldr	r2, [r3, #0]
 8002fa0:	68fb      	ldr	r3, [r7, #12]
 8002fa2:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002fa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002fa8:	0c1b      	lsrs	r3, r3, #16
 8002faa:	b2db      	uxtb	r3, r3
 8002fac:	009b      	lsls	r3, r3, #2
 8002fae:	440b      	add	r3, r1
 8002fb0:	681b      	ldr	r3, [r3, #0]
 8002fb2:	405a      	eors	r2, r3
 8002fb4:	68fb      	ldr	r3, [r7, #12]
 8002fb6:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8002fba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002fbc:	0a1b      	lsrs	r3, r3, #8
 8002fbe:	b2db      	uxtb	r3, r3
 8002fc0:	009b      	lsls	r3, r3, #2
 8002fc2:	440b      	add	r3, r1
 8002fc4:	681b      	ldr	r3, [r3, #0]
 8002fc6:	405a      	eors	r2, r3
 8002fc8:	68fb      	ldr	r3, [r7, #12]
 8002fca:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8002fce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002fd0:	b2db      	uxtb	r3, r3
 8002fd2:	009b      	lsls	r3, r3, #2
 8002fd4:	440b      	add	r3, r1
 8002fd6:	681b      	ldr	r3, [r3, #0]
 8002fd8:	405a      	eors	r2, r3
 8002fda:	68bb      	ldr	r3, [r7, #8]
 8002fdc:	33cc      	adds	r3, #204	; 0xcc
 8002fde:	681b      	ldr	r3, [r3, #0]
 8002fe0:	4053      	eors	r3, r2
 8002fe2:	613b      	str	r3, [r7, #16]
            /* round 13: */
            t0 = ctx->Td0[s0 >> 24] ^ ctx->Td1[(s3 >> 16) & 0xff] ^ ctx->Td2[(s2 >>  8) & 0xff] ^ ctx->Td3[s1 & 0xff] ^ rk[52];
 8002fe4:	68fb      	ldr	r3, [r7, #12]
 8002fe6:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8002fea:	69fb      	ldr	r3, [r7, #28]
 8002fec:	0e1b      	lsrs	r3, r3, #24
 8002fee:	009b      	lsls	r3, r3, #2
 8002ff0:	4413      	add	r3, r2
 8002ff2:	681a      	ldr	r2, [r3, #0]
 8002ff4:	68fb      	ldr	r3, [r7, #12]
 8002ff6:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 8002ffa:	693b      	ldr	r3, [r7, #16]
 8002ffc:	0c1b      	lsrs	r3, r3, #16
 8002ffe:	b2db      	uxtb	r3, r3
 8003000:	009b      	lsls	r3, r3, #2
 8003002:	440b      	add	r3, r1
 8003004:	681b      	ldr	r3, [r3, #0]
 8003006:	405a      	eors	r2, r3
 8003008:	68fb      	ldr	r3, [r7, #12]
 800300a:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800300e:	697b      	ldr	r3, [r7, #20]
 8003010:	0a1b      	lsrs	r3, r3, #8
 8003012:	b2db      	uxtb	r3, r3
 8003014:	009b      	lsls	r3, r3, #2
 8003016:	440b      	add	r3, r1
 8003018:	681b      	ldr	r3, [r3, #0]
 800301a:	405a      	eors	r2, r3
 800301c:	68fb      	ldr	r3, [r7, #12]
 800301e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8003022:	69bb      	ldr	r3, [r7, #24]
 8003024:	b2db      	uxtb	r3, r3
 8003026:	009b      	lsls	r3, r3, #2
 8003028:	440b      	add	r3, r1
 800302a:	681b      	ldr	r3, [r3, #0]
 800302c:	405a      	eors	r2, r3
 800302e:	68bb      	ldr	r3, [r7, #8]
 8003030:	33d0      	adds	r3, #208	; 0xd0
 8003032:	681b      	ldr	r3, [r3, #0]
 8003034:	4053      	eors	r3, r2
 8003036:	62fb      	str	r3, [r7, #44]	; 0x2c
            t1 = ctx->Td0[s1 >> 24] ^ ctx->Td1[(s0 >> 16) & 0xff] ^ ctx->Td2[(s3 >>  8) & 0xff] ^ ctx->Td3[s2 & 0xff] ^ rk[53];
 8003038:	68fb      	ldr	r3, [r7, #12]
 800303a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 800303e:	69bb      	ldr	r3, [r7, #24]
 8003040:	0e1b      	lsrs	r3, r3, #24
 8003042:	009b      	lsls	r3, r3, #2
 8003044:	4413      	add	r3, r2
 8003046:	681a      	ldr	r2, [r3, #0]
 8003048:	68fb      	ldr	r3, [r7, #12]
 800304a:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 800304e:	69fb      	ldr	r3, [r7, #28]
 8003050:	0c1b      	lsrs	r3, r3, #16
 8003052:	b2db      	uxtb	r3, r3
 8003054:	009b      	lsls	r3, r3, #2
 8003056:	440b      	add	r3, r1
 8003058:	681b      	ldr	r3, [r3, #0]
 800305a:	405a      	eors	r2, r3
 800305c:	68fb      	ldr	r3, [r7, #12]
 800305e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 8003062:	693b      	ldr	r3, [r7, #16]
 8003064:	0a1b      	lsrs	r3, r3, #8
 8003066:	b2db      	uxtb	r3, r3
 8003068:	009b      	lsls	r3, r3, #2
 800306a:	440b      	add	r3, r1
 800306c:	681b      	ldr	r3, [r3, #0]
 800306e:	405a      	eors	r2, r3
 8003070:	68fb      	ldr	r3, [r7, #12]
 8003072:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 8003076:	697b      	ldr	r3, [r7, #20]
 8003078:	b2db      	uxtb	r3, r3
 800307a:	009b      	lsls	r3, r3, #2
 800307c:	440b      	add	r3, r1
 800307e:	681b      	ldr	r3, [r3, #0]
 8003080:	405a      	eors	r2, r3
 8003082:	68bb      	ldr	r3, [r7, #8]
 8003084:	33d4      	adds	r3, #212	; 0xd4
 8003086:	681b      	ldr	r3, [r3, #0]
 8003088:	4053      	eors	r3, r2
 800308a:	62bb      	str	r3, [r7, #40]	; 0x28
            t2 = ctx->Td0[s2 >> 24] ^ ctx->Td1[(s1 >> 16) & 0xff] ^ ctx->Td2[(s0 >>  8) & 0xff] ^ ctx->Td3[s3 & 0xff] ^ rk[54];
 800308c:	68fb      	ldr	r3, [r7, #12]
 800308e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8003092:	697b      	ldr	r3, [r7, #20]
 8003094:	0e1b      	lsrs	r3, r3, #24
 8003096:	009b      	lsls	r3, r3, #2
 8003098:	4413      	add	r3, r2
 800309a:	681a      	ldr	r2, [r3, #0]
 800309c:	68fb      	ldr	r3, [r7, #12]
 800309e:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80030a2:	69bb      	ldr	r3, [r7, #24]
 80030a4:	0c1b      	lsrs	r3, r3, #16
 80030a6:	b2db      	uxtb	r3, r3
 80030a8:	009b      	lsls	r3, r3, #2
 80030aa:	440b      	add	r3, r1
 80030ac:	681b      	ldr	r3, [r3, #0]
 80030ae:	405a      	eors	r2, r3
 80030b0:	68fb      	ldr	r3, [r7, #12]
 80030b2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 80030b6:	69fb      	ldr	r3, [r7, #28]
 80030b8:	0a1b      	lsrs	r3, r3, #8
 80030ba:	b2db      	uxtb	r3, r3
 80030bc:	009b      	lsls	r3, r3, #2
 80030be:	440b      	add	r3, r1
 80030c0:	681b      	ldr	r3, [r3, #0]
 80030c2:	405a      	eors	r2, r3
 80030c4:	68fb      	ldr	r3, [r7, #12]
 80030c6:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 80030ca:	693b      	ldr	r3, [r7, #16]
 80030cc:	b2db      	uxtb	r3, r3
 80030ce:	009b      	lsls	r3, r3, #2
 80030d0:	440b      	add	r3, r1
 80030d2:	681b      	ldr	r3, [r3, #0]
 80030d4:	405a      	eors	r2, r3
 80030d6:	68bb      	ldr	r3, [r7, #8]
 80030d8:	33d8      	adds	r3, #216	; 0xd8
 80030da:	681b      	ldr	r3, [r3, #0]
 80030dc:	4053      	eors	r3, r2
 80030de:	627b      	str	r3, [r7, #36]	; 0x24
            t3 = ctx->Td0[s3 >> 24] ^ ctx->Td1[(s2 >> 16) & 0xff] ^ ctx->Td2[(s1 >>  8) & 0xff] ^ ctx->Td3[s0 & 0xff] ^ rk[55];
 80030e0:	68fb      	ldr	r3, [r7, #12]
 80030e2:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 80030e6:	693b      	ldr	r3, [r7, #16]
 80030e8:	0e1b      	lsrs	r3, r3, #24
 80030ea:	009b      	lsls	r3, r3, #2
 80030ec:	4413      	add	r3, r2
 80030ee:	681a      	ldr	r2, [r3, #0]
 80030f0:	68fb      	ldr	r3, [r7, #12]
 80030f2:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
 80030f6:	697b      	ldr	r3, [r7, #20]
 80030f8:	0c1b      	lsrs	r3, r3, #16
 80030fa:	b2db      	uxtb	r3, r3
 80030fc:	009b      	lsls	r3, r3, #2
 80030fe:	440b      	add	r3, r1
 8003100:	681b      	ldr	r3, [r3, #0]
 8003102:	405a      	eors	r2, r3
 8003104:	68fb      	ldr	r3, [r7, #12]
 8003106:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
 800310a:	69bb      	ldr	r3, [r7, #24]
 800310c:	0a1b      	lsrs	r3, r3, #8
 800310e:	b2db      	uxtb	r3, r3
 8003110:	009b      	lsls	r3, r3, #2
 8003112:	440b      	add	r3, r1
 8003114:	681b      	ldr	r3, [r3, #0]
 8003116:	405a      	eors	r2, r3
 8003118:	68fb      	ldr	r3, [r7, #12]
 800311a:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
 800311e:	69fb      	ldr	r3, [r7, #28]
 8003120:	b2db      	uxtb	r3, r3
 8003122:	009b      	lsls	r3, r3, #2
 8003124:	440b      	add	r3, r1
 8003126:	681b      	ldr	r3, [r3, #0]
 8003128:	405a      	eors	r2, r3
 800312a:	68bb      	ldr	r3, [r7, #8]
 800312c:	33dc      	adds	r3, #220	; 0xdc
 800312e:	681b      	ldr	r3, [r3, #0]
 8003130:	4053      	eors	r3, r2
 8003132:	623b      	str	r3, [r7, #32]
        }
    }
    rk += Nr << 2;
 8003134:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003138:	009b      	lsls	r3, r3, #2
 800313a:	009b      	lsls	r3, r3, #2
 800313c:	68ba      	ldr	r2, [r7, #8]
 800313e:	4413      	add	r3, r2
 8003140:	60bb      	str	r3, [r7, #8]
    /*
     * apply last round and
     * map cipher state to byte array block:
     */
    s0 =
            (ctx->Td4[(t0 >> 24)       ] & 0xff000000) ^
 8003142:	68fb      	ldr	r3, [r7, #12]
 8003144:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 8003148:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800314a:	0e1b      	lsrs	r3, r3, #24
 800314c:	009b      	lsls	r3, r3, #2
 800314e:	4413      	add	r3, r2
 8003150:	681b      	ldr	r3, [r3, #0]
 8003152:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
 8003156:	68fb      	ldr	r3, [r7, #12]
 8003158:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 800315c:	6a3b      	ldr	r3, [r7, #32]
 800315e:	0c1b      	lsrs	r3, r3, #16
 8003160:	b2db      	uxtb	r3, r3
 8003162:	009b      	lsls	r3, r3, #2
 8003164:	440b      	add	r3, r1
 8003166:	681b      	ldr	r3, [r3, #0]
 8003168:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Td4[(t0 >> 24)       ] & 0xff000000) ^
 800316c:	431a      	orrs	r2, r3
            (ctx->Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
 800316e:	68fb      	ldr	r3, [r7, #12]
 8003170:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 8003174:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003176:	0a1b      	lsrs	r3, r3, #8
 8003178:	b2db      	uxtb	r3, r3
 800317a:	009b      	lsls	r3, r3, #2
 800317c:	440b      	add	r3, r1
 800317e:	681b      	ldr	r3, [r3, #0]
 8003180:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
 8003184:	405a      	eors	r2, r3
            (ctx->Td4[(t1      ) & 0xff] & 0x000000ff) ^
 8003186:	68fb      	ldr	r3, [r7, #12]
 8003188:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 800318c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800318e:	b2db      	uxtb	r3, r3
 8003190:	009b      	lsls	r3, r3, #2
 8003192:	440b      	add	r3, r1
 8003194:	681b      	ldr	r3, [r3, #0]
 8003196:	b2db      	uxtb	r3, r3
            (ctx->Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
 8003198:	405a      	eors	r2, r3
            rk[0];
 800319a:	68bb      	ldr	r3, [r7, #8]
 800319c:	681b      	ldr	r3, [r3, #0]
    s0 =
 800319e:	4053      	eors	r3, r2
 80031a0:	61fb      	str	r3, [r7, #28]
    B5_AES256_PUTUINT32(pt     , s0);
 80031a2:	69f9      	ldr	r1, [r7, #28]
 80031a4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80031a6:	f7fd f8cd 	bl	8000344 <B5_AES256_PUTUINT32>
    s1 =
            (ctx->Td4[(t1 >> 24)       ] & 0xff000000) ^
 80031aa:	68fb      	ldr	r3, [r7, #12]
 80031ac:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 80031b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80031b2:	0e1b      	lsrs	r3, r3, #24
 80031b4:	009b      	lsls	r3, r3, #2
 80031b6:	4413      	add	r3, r2
 80031b8:	681b      	ldr	r3, [r3, #0]
 80031ba:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
 80031be:	68fb      	ldr	r3, [r7, #12]
 80031c0:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80031c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80031c6:	0c1b      	lsrs	r3, r3, #16
 80031c8:	b2db      	uxtb	r3, r3
 80031ca:	009b      	lsls	r3, r3, #2
 80031cc:	440b      	add	r3, r1
 80031ce:	681b      	ldr	r3, [r3, #0]
 80031d0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Td4[(t1 >> 24)       ] & 0xff000000) ^
 80031d4:	431a      	orrs	r2, r3
            (ctx->Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
 80031d6:	68fb      	ldr	r3, [r7, #12]
 80031d8:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80031dc:	6a3b      	ldr	r3, [r7, #32]
 80031de:	0a1b      	lsrs	r3, r3, #8
 80031e0:	b2db      	uxtb	r3, r3
 80031e2:	009b      	lsls	r3, r3, #2
 80031e4:	440b      	add	r3, r1
 80031e6:	681b      	ldr	r3, [r3, #0]
 80031e8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
 80031ec:	405a      	eors	r2, r3
            (ctx->Td4[(t2      ) & 0xff] & 0x000000ff) ^
 80031ee:	68fb      	ldr	r3, [r7, #12]
 80031f0:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80031f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80031f6:	b2db      	uxtb	r3, r3
 80031f8:	009b      	lsls	r3, r3, #2
 80031fa:	440b      	add	r3, r1
 80031fc:	681b      	ldr	r3, [r3, #0]
 80031fe:	b2db      	uxtb	r3, r3
            (ctx->Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
 8003200:	405a      	eors	r2, r3
            rk[1];
 8003202:	68bb      	ldr	r3, [r7, #8]
 8003204:	3304      	adds	r3, #4
 8003206:	681b      	ldr	r3, [r3, #0]
    s1 =
 8003208:	4053      	eors	r3, r2
 800320a:	61bb      	str	r3, [r7, #24]
    B5_AES256_PUTUINT32(pt +  4, s1);
 800320c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800320e:	3304      	adds	r3, #4
 8003210:	69b9      	ldr	r1, [r7, #24]
 8003212:	4618      	mov	r0, r3
 8003214:	f7fd f896 	bl	8000344 <B5_AES256_PUTUINT32>
    s2 =
            (ctx->Td4[(t2 >> 24)       ] & 0xff000000) ^
 8003218:	68fb      	ldr	r3, [r7, #12]
 800321a:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 800321e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003220:	0e1b      	lsrs	r3, r3, #24
 8003222:	009b      	lsls	r3, r3, #2
 8003224:	4413      	add	r3, r2
 8003226:	681b      	ldr	r3, [r3, #0]
 8003228:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
 800322c:	68fb      	ldr	r3, [r7, #12]
 800322e:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 8003232:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003234:	0c1b      	lsrs	r3, r3, #16
 8003236:	b2db      	uxtb	r3, r3
 8003238:	009b      	lsls	r3, r3, #2
 800323a:	440b      	add	r3, r1
 800323c:	681b      	ldr	r3, [r3, #0]
 800323e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Td4[(t2 >> 24)       ] & 0xff000000) ^
 8003242:	431a      	orrs	r2, r3
            (ctx->Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
 8003244:	68fb      	ldr	r3, [r7, #12]
 8003246:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 800324a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800324c:	0a1b      	lsrs	r3, r3, #8
 800324e:	b2db      	uxtb	r3, r3
 8003250:	009b      	lsls	r3, r3, #2
 8003252:	440b      	add	r3, r1
 8003254:	681b      	ldr	r3, [r3, #0]
 8003256:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
 800325a:	405a      	eors	r2, r3
            (ctx->Td4[(t3      ) & 0xff] & 0x000000ff) ^
 800325c:	68fb      	ldr	r3, [r7, #12]
 800325e:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 8003262:	6a3b      	ldr	r3, [r7, #32]
 8003264:	b2db      	uxtb	r3, r3
 8003266:	009b      	lsls	r3, r3, #2
 8003268:	440b      	add	r3, r1
 800326a:	681b      	ldr	r3, [r3, #0]
 800326c:	b2db      	uxtb	r3, r3
            (ctx->Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
 800326e:	405a      	eors	r2, r3
            rk[2];
 8003270:	68bb      	ldr	r3, [r7, #8]
 8003272:	3308      	adds	r3, #8
 8003274:	681b      	ldr	r3, [r3, #0]
    s2 =
 8003276:	4053      	eors	r3, r2
 8003278:	617b      	str	r3, [r7, #20]
    B5_AES256_PUTUINT32(pt +  8, s2);
 800327a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800327c:	3308      	adds	r3, #8
 800327e:	6979      	ldr	r1, [r7, #20]
 8003280:	4618      	mov	r0, r3
 8003282:	f7fd f85f 	bl	8000344 <B5_AES256_PUTUINT32>
    s3 =
            (ctx->Td4[(t3 >> 24)       ] & 0xff000000) ^
 8003286:	68fb      	ldr	r3, [r7, #12]
 8003288:	f8d3 2128 	ldr.w	r2, [r3, #296]	; 0x128
 800328c:	6a3b      	ldr	r3, [r7, #32]
 800328e:	0e1b      	lsrs	r3, r3, #24
 8003290:	009b      	lsls	r3, r3, #2
 8003292:	4413      	add	r3, r2
 8003294:	681b      	ldr	r3, [r3, #0]
 8003296:	f003 427f 	and.w	r2, r3, #4278190080	; 0xff000000
            (ctx->Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
 800329a:	68fb      	ldr	r3, [r7, #12]
 800329c:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80032a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80032a2:	0c1b      	lsrs	r3, r3, #16
 80032a4:	b2db      	uxtb	r3, r3
 80032a6:	009b      	lsls	r3, r3, #2
 80032a8:	440b      	add	r3, r1
 80032aa:	681b      	ldr	r3, [r3, #0]
 80032ac:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
            (ctx->Td4[(t3 >> 24)       ] & 0xff000000) ^
 80032b0:	431a      	orrs	r2, r3
            (ctx->Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
 80032b2:	68fb      	ldr	r3, [r7, #12]
 80032b4:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80032b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80032ba:	0a1b      	lsrs	r3, r3, #8
 80032bc:	b2db      	uxtb	r3, r3
 80032be:	009b      	lsls	r3, r3, #2
 80032c0:	440b      	add	r3, r1
 80032c2:	681b      	ldr	r3, [r3, #0]
 80032c4:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
            (ctx->Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
 80032c8:	405a      	eors	r2, r3
            (ctx->Td4[(t0      ) & 0xff] & 0x000000ff) ^
 80032ca:	68fb      	ldr	r3, [r7, #12]
 80032cc:	f8d3 1128 	ldr.w	r1, [r3, #296]	; 0x128
 80032d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80032d2:	b2db      	uxtb	r3, r3
 80032d4:	009b      	lsls	r3, r3, #2
 80032d6:	440b      	add	r3, r1
 80032d8:	681b      	ldr	r3, [r3, #0]
 80032da:	b2db      	uxtb	r3, r3
            (ctx->Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
 80032dc:	405a      	eors	r2, r3
            rk[3];
 80032de:	68bb      	ldr	r3, [r7, #8]
 80032e0:	330c      	adds	r3, #12
 80032e2:	681b      	ldr	r3, [r3, #0]
    s3 =
 80032e4:	4053      	eors	r3, r2
 80032e6:	613b      	str	r3, [r7, #16]
    B5_AES256_PUTUINT32(pt + 12, s3);
 80032e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80032ea:	330c      	adds	r3, #12
 80032ec:	6939      	ldr	r1, [r7, #16]
 80032ee:	4618      	mov	r0, r3
 80032f0:	f7fd f828 	bl	8000344 <B5_AES256_PUTUINT32>
}
 80032f4:	bf00      	nop
 80032f6:	3730      	adds	r7, #48	; 0x30
 80032f8:	46bd      	mov	sp, r7
 80032fa:	bd80      	pop	{r7, pc}

080032fc <inc32>:




//gcm incrementing function
static void inc32(uint8_t *block){
 80032fc:	b580      	push	{r7, lr}
 80032fe:	b084      	sub	sp, #16
 8003300:	af00      	add	r7, sp, #0
 8003302:	6078      	str	r0, [r7, #4]
	uint32_t val;
	val = B5_AES256_GETUINT32(block + B5_AES_BLK_SIZE - 4);
 8003304:	687b      	ldr	r3, [r7, #4]
 8003306:	330c      	adds	r3, #12
 8003308:	4618      	mov	r0, r3
 800330a:	f7fc fff2 	bl	80002f2 <B5_AES256_GETUINT32>
 800330e:	60f8      	str	r0, [r7, #12]
	val++;
 8003310:	68fb      	ldr	r3, [r7, #12]
 8003312:	3301      	adds	r3, #1
 8003314:	60fb      	str	r3, [r7, #12]
	B5_AES256_PUTUINT32(block + B5_AES_BLK_SIZE - 4, val);
 8003316:	687b      	ldr	r3, [r7, #4]
 8003318:	330c      	adds	r3, #12
 800331a:	68f9      	ldr	r1, [r7, #12]
 800331c:	4618      	mov	r0, r3
 800331e:	f7fd f811 	bl	8000344 <B5_AES256_PUTUINT32>
}
 8003322:	bf00      	nop
 8003324:	3710      	adds	r7, #16
 8003326:	46bd      	mov	sp, r7
 8003328:	bd80      	pop	{r7, pc}

0800332a <xor_block>:

//gcm block xor
static void xor_block(uint8_t *dst, const uint8_t *src){
 800332a:	b480      	push	{r7}
 800332c:	b085      	sub	sp, #20
 800332e:	af00      	add	r7, sp, #0
 8003330:	6078      	str	r0, [r7, #4]
 8003332:	6039      	str	r1, [r7, #0]

	uint32_t *d = (uint32_t *) dst;
 8003334:	687b      	ldr	r3, [r7, #4]
 8003336:	60fb      	str	r3, [r7, #12]
	uint32_t *s = (uint32_t *) src;
 8003338:	683b      	ldr	r3, [r7, #0]
 800333a:	60bb      	str	r3, [r7, #8]
	*d++ ^= *s++;
 800333c:	68bb      	ldr	r3, [r7, #8]
 800333e:	1d1a      	adds	r2, r3, #4
 8003340:	60ba      	str	r2, [r7, #8]
 8003342:	6819      	ldr	r1, [r3, #0]
 8003344:	68fb      	ldr	r3, [r7, #12]
 8003346:	1d1a      	adds	r2, r3, #4
 8003348:	60fa      	str	r2, [r7, #12]
 800334a:	681a      	ldr	r2, [r3, #0]
 800334c:	404a      	eors	r2, r1
 800334e:	601a      	str	r2, [r3, #0]
	*d++ ^= *s++;
 8003350:	68bb      	ldr	r3, [r7, #8]
 8003352:	1d1a      	adds	r2, r3, #4
 8003354:	60ba      	str	r2, [r7, #8]
 8003356:	6819      	ldr	r1, [r3, #0]
 8003358:	68fb      	ldr	r3, [r7, #12]
 800335a:	1d1a      	adds	r2, r3, #4
 800335c:	60fa      	str	r2, [r7, #12]
 800335e:	681a      	ldr	r2, [r3, #0]
 8003360:	404a      	eors	r2, r1
 8003362:	601a      	str	r2, [r3, #0]
	*d++ ^= *s++;
 8003364:	68bb      	ldr	r3, [r7, #8]
 8003366:	1d1a      	adds	r2, r3, #4
 8003368:	60ba      	str	r2, [r7, #8]
 800336a:	6819      	ldr	r1, [r3, #0]
 800336c:	68fb      	ldr	r3, [r7, #12]
 800336e:	1d1a      	adds	r2, r3, #4
 8003370:	60fa      	str	r2, [r7, #12]
 8003372:	681a      	ldr	r2, [r3, #0]
 8003374:	404a      	eors	r2, r1
 8003376:	601a      	str	r2, [r3, #0]
	*d++ ^= *s++;
 8003378:	68bb      	ldr	r3, [r7, #8]
 800337a:	1d1a      	adds	r2, r3, #4
 800337c:	60ba      	str	r2, [r7, #8]
 800337e:	6819      	ldr	r1, [r3, #0]
 8003380:	68fb      	ldr	r3, [r7, #12]
 8003382:	1d1a      	adds	r2, r3, #4
 8003384:	60fa      	str	r2, [r7, #12]
 8003386:	681a      	ldr	r2, [r3, #0]
 8003388:	404a      	eors	r2, r1
 800338a:	601a      	str	r2, [r3, #0]

}
 800338c:	bf00      	nop
 800338e:	3714      	adds	r7, #20
 8003390:	46bd      	mov	sp, r7
 8003392:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003396:	4770      	bx	lr

08003398 <shift_right_block>:

//gcm shift right block
static void shift_right_block(uint8_t *v){
 8003398:	b580      	push	{r7, lr}
 800339a:	b084      	sub	sp, #16
 800339c:	af00      	add	r7, sp, #0
 800339e:	6078      	str	r0, [r7, #4]
	uint32_t val;

	val = B5_AES256_GETUINT32(v + 12);
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	330c      	adds	r3, #12
 80033a4:	4618      	mov	r0, r3
 80033a6:	f7fc ffa4 	bl	80002f2 <B5_AES256_GETUINT32>
 80033aa:	60f8      	str	r0, [r7, #12]
	val >>= 1;
 80033ac:	68fb      	ldr	r3, [r7, #12]
 80033ae:	085b      	lsrs	r3, r3, #1
 80033b0:	60fb      	str	r3, [r7, #12]
	if (v[11] & 0x01)
 80033b2:	687b      	ldr	r3, [r7, #4]
 80033b4:	330b      	adds	r3, #11
 80033b6:	781b      	ldrb	r3, [r3, #0]
 80033b8:	f003 0301 	and.w	r3, r3, #1
 80033bc:	2b00      	cmp	r3, #0
 80033be:	d003      	beq.n	80033c8 <shift_right_block+0x30>
		val |= 0x80000000;
 80033c0:	68fb      	ldr	r3, [r7, #12]
 80033c2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033c6:	60fb      	str	r3, [r7, #12]
	B5_AES256_PUTUINT32(v + 12, val);
 80033c8:	687b      	ldr	r3, [r7, #4]
 80033ca:	330c      	adds	r3, #12
 80033cc:	68f9      	ldr	r1, [r7, #12]
 80033ce:	4618      	mov	r0, r3
 80033d0:	f7fc ffb8 	bl	8000344 <B5_AES256_PUTUINT32>

	val = B5_AES256_GETUINT32(v + 8);
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	3308      	adds	r3, #8
 80033d8:	4618      	mov	r0, r3
 80033da:	f7fc ff8a 	bl	80002f2 <B5_AES256_GETUINT32>
 80033de:	60f8      	str	r0, [r7, #12]
	val >>= 1;
 80033e0:	68fb      	ldr	r3, [r7, #12]
 80033e2:	085b      	lsrs	r3, r3, #1
 80033e4:	60fb      	str	r3, [r7, #12]
	if (v[7] & 0x01)
 80033e6:	687b      	ldr	r3, [r7, #4]
 80033e8:	3307      	adds	r3, #7
 80033ea:	781b      	ldrb	r3, [r3, #0]
 80033ec:	f003 0301 	and.w	r3, r3, #1
 80033f0:	2b00      	cmp	r3, #0
 80033f2:	d003      	beq.n	80033fc <shift_right_block+0x64>
		val |= 0x80000000;
 80033f4:	68fb      	ldr	r3, [r7, #12]
 80033f6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80033fa:	60fb      	str	r3, [r7, #12]
	B5_AES256_PUTUINT32(v + 8, val);
 80033fc:	687b      	ldr	r3, [r7, #4]
 80033fe:	3308      	adds	r3, #8
 8003400:	68f9      	ldr	r1, [r7, #12]
 8003402:	4618      	mov	r0, r3
 8003404:	f7fc ff9e 	bl	8000344 <B5_AES256_PUTUINT32>

	val = B5_AES256_GETUINT32(v + 4);
 8003408:	687b      	ldr	r3, [r7, #4]
 800340a:	3304      	adds	r3, #4
 800340c:	4618      	mov	r0, r3
 800340e:	f7fc ff70 	bl	80002f2 <B5_AES256_GETUINT32>
 8003412:	60f8      	str	r0, [r7, #12]
	val >>= 1;
 8003414:	68fb      	ldr	r3, [r7, #12]
 8003416:	085b      	lsrs	r3, r3, #1
 8003418:	60fb      	str	r3, [r7, #12]
	if (v[3] & 0x01)
 800341a:	687b      	ldr	r3, [r7, #4]
 800341c:	3303      	adds	r3, #3
 800341e:	781b      	ldrb	r3, [r3, #0]
 8003420:	f003 0301 	and.w	r3, r3, #1
 8003424:	2b00      	cmp	r3, #0
 8003426:	d003      	beq.n	8003430 <shift_right_block+0x98>
		val |= 0x80000000;
 8003428:	68fb      	ldr	r3, [r7, #12]
 800342a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800342e:	60fb      	str	r3, [r7, #12]
	B5_AES256_PUTUINT32(v + 4, val);
 8003430:	687b      	ldr	r3, [r7, #4]
 8003432:	3304      	adds	r3, #4
 8003434:	68f9      	ldr	r1, [r7, #12]
 8003436:	4618      	mov	r0, r3
 8003438:	f7fc ff84 	bl	8000344 <B5_AES256_PUTUINT32>

	val = B5_AES256_GETUINT32(v);
 800343c:	6878      	ldr	r0, [r7, #4]
 800343e:	f7fc ff58 	bl	80002f2 <B5_AES256_GETUINT32>
 8003442:	60f8      	str	r0, [r7, #12]
	val >>= 1;
 8003444:	68fb      	ldr	r3, [r7, #12]
 8003446:	085b      	lsrs	r3, r3, #1
 8003448:	60fb      	str	r3, [r7, #12]
	B5_AES256_PUTUINT32(v, val);
 800344a:	68f9      	ldr	r1, [r7, #12]
 800344c:	6878      	ldr	r0, [r7, #4]
 800344e:	f7fc ff79 	bl	8000344 <B5_AES256_PUTUINT32>
}
 8003452:	bf00      	nop
 8003454:	3710      	adds	r7, #16
 8003456:	46bd      	mov	sp, r7
 8003458:	bd80      	pop	{r7, pc}

0800345a <gf_mult>:

// gcm Multiplication in GF(2^128)
static void gf_mult(const uint8_t *x, const uint8_t *y, uint8_t *z){
 800345a:	b590      	push	{r4, r7, lr}
 800345c:	b08b      	sub	sp, #44	; 0x2c
 800345e:	af00      	add	r7, sp, #0
 8003460:	60f8      	str	r0, [r7, #12]
 8003462:	60b9      	str	r1, [r7, #8]
 8003464:	607a      	str	r2, [r7, #4]
	uint8_t v[16];
	int i, j;

	memset(z, 0, 16); /* Z_0 = 0^128 */
 8003466:	2210      	movs	r2, #16
 8003468:	2100      	movs	r1, #0
 800346a:	6878      	ldr	r0, [r7, #4]
 800346c:	f017 fdbf 	bl	801afee <memset>
	memcpy(v, y, 16); /* V_0 = Y */
 8003470:	68bb      	ldr	r3, [r7, #8]
 8003472:	f107 0410 	add.w	r4, r7, #16
 8003476:	6818      	ldr	r0, [r3, #0]
 8003478:	6859      	ldr	r1, [r3, #4]
 800347a:	689a      	ldr	r2, [r3, #8]
 800347c:	68db      	ldr	r3, [r3, #12]
 800347e:	c40f      	stmia	r4!, {r0, r1, r2, r3}

	for (i = 0; i < 16; i++) {
 8003480:	2300      	movs	r3, #0
 8003482:	627b      	str	r3, [r7, #36]	; 0x24
 8003484:	e035      	b.n	80034f2 <gf_mult+0x98>
		for (j = 0; j < 8; j++) {
 8003486:	2300      	movs	r3, #0
 8003488:	623b      	str	r3, [r7, #32]
 800348a:	e02c      	b.n	80034e6 <gf_mult+0x8c>
			if (x[i] & 1 << (7 - j)) {
 800348c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800348e:	68fa      	ldr	r2, [r7, #12]
 8003490:	4413      	add	r3, r2
 8003492:	781b      	ldrb	r3, [r3, #0]
 8003494:	461a      	mov	r2, r3
 8003496:	6a3b      	ldr	r3, [r7, #32]
 8003498:	f1c3 0307 	rsb	r3, r3, #7
 800349c:	fa42 f303 	asr.w	r3, r2, r3
 80034a0:	f003 0301 	and.w	r3, r3, #1
 80034a4:	2b00      	cmp	r3, #0
 80034a6:	d005      	beq.n	80034b4 <gf_mult+0x5a>
				/* Z_(i + 1) = Z_i XOR V_i */
				xor_block(z, v);
 80034a8:	f107 0310 	add.w	r3, r7, #16
 80034ac:	4619      	mov	r1, r3
 80034ae:	6878      	ldr	r0, [r7, #4]
 80034b0:	f7ff ff3b 	bl	800332a <xor_block>
			} else {
				/* Z_(i + 1) = Z_i */
			}

			if (v[15] & 0x01) {
 80034b4:	7ffb      	ldrb	r3, [r7, #31]
 80034b6:	f003 0301 	and.w	r3, r3, #1
 80034ba:	2b00      	cmp	r3, #0
 80034bc:	d00b      	beq.n	80034d6 <gf_mult+0x7c>
				/* V_(i + 1) = (V_i >> 1) XOR R */
				shift_right_block(v);
 80034be:	f107 0310 	add.w	r3, r7, #16
 80034c2:	4618      	mov	r0, r3
 80034c4:	f7ff ff68 	bl	8003398 <shift_right_block>

				/* R = 11100001 || 0^120 */
				v[0] ^= 0xe1;
 80034c8:	7c3b      	ldrb	r3, [r7, #16]
 80034ca:	f083 031e 	eor.w	r3, r3, #30
 80034ce:	43db      	mvns	r3, r3
 80034d0:	b2db      	uxtb	r3, r3
 80034d2:	743b      	strb	r3, [r7, #16]
 80034d4:	e004      	b.n	80034e0 <gf_mult+0x86>

			} else {
				/* V_(i + 1) = V_i >> 1 */
				shift_right_block(v);
 80034d6:	f107 0310 	add.w	r3, r7, #16
 80034da:	4618      	mov	r0, r3
 80034dc:	f7ff ff5c 	bl	8003398 <shift_right_block>
		for (j = 0; j < 8; j++) {
 80034e0:	6a3b      	ldr	r3, [r7, #32]
 80034e2:	3301      	adds	r3, #1
 80034e4:	623b      	str	r3, [r7, #32]
 80034e6:	6a3b      	ldr	r3, [r7, #32]
 80034e8:	2b07      	cmp	r3, #7
 80034ea:	ddcf      	ble.n	800348c <gf_mult+0x32>
	for (i = 0; i < 16; i++) {
 80034ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80034ee:	3301      	adds	r3, #1
 80034f0:	627b      	str	r3, [r7, #36]	; 0x24
 80034f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80034f4:	2b0f      	cmp	r3, #15
 80034f6:	ddc6      	ble.n	8003486 <gf_mult+0x2c>

			}
		}
	}
}
 80034f8:	bf00      	nop
 80034fa:	372c      	adds	r7, #44	; 0x2c
 80034fc:	46bd      	mov	sp, r7
 80034fe:	bd90      	pop	{r4, r7, pc}

08003500 <ghash_start>:

//gcm ghash init
static void ghash_start(uint8_t *y){
 8003500:	b580      	push	{r7, lr}
 8003502:	b082      	sub	sp, #8
 8003504:	af00      	add	r7, sp, #0
 8003506:	6078      	str	r0, [r7, #4]
	/* Y_0 = 0^128 */
	memset(y, 0, 16);
 8003508:	2210      	movs	r2, #16
 800350a:	2100      	movs	r1, #0
 800350c:	6878      	ldr	r0, [r7, #4]
 800350e:	f017 fd6e 	bl	801afee <memset>
}
 8003512:	bf00      	nop
 8003514:	3708      	adds	r7, #8
 8003516:	46bd      	mov	sp, r7
 8003518:	bd80      	pop	{r7, pc}

0800351a <ghash>:

//gcm ghash
static void ghash(const uint8_t *h, const uint8_t *x, size_t xlen, uint8_t *y){
 800351a:	b5b0      	push	{r4, r5, r7, lr}
 800351c:	b08c      	sub	sp, #48	; 0x30
 800351e:	af00      	add	r7, sp, #0
 8003520:	60f8      	str	r0, [r7, #12]
 8003522:	60b9      	str	r1, [r7, #8]
 8003524:	607a      	str	r2, [r7, #4]
 8003526:	603b      	str	r3, [r7, #0]

	size_t m, i;
	const uint8_t *xpos = x;
 8003528:	68bb      	ldr	r3, [r7, #8]
 800352a:	62bb      	str	r3, [r7, #40]	; 0x28
	uint8_t tmp[16];

	m = xlen / 16;
 800352c:	687b      	ldr	r3, [r7, #4]
 800352e:	091b      	lsrs	r3, r3, #4
 8003530:	627b      	str	r3, [r7, #36]	; 0x24

	for (i = 0; i < m; i++) {
 8003532:	2300      	movs	r3, #0
 8003534:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003536:	e019      	b.n	800356c <ghash+0x52>
		/* Y_i = (Y^(i-1) XOR X_i) dot H */
		xor_block(y, xpos);
 8003538:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800353a:	6838      	ldr	r0, [r7, #0]
 800353c:	f7ff fef5 	bl	800332a <xor_block>
		xpos += 16;
 8003540:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003542:	3310      	adds	r3, #16
 8003544:	62bb      	str	r3, [r7, #40]	; 0x28

		/* dot operation:
		 * multiplication operation for binary Galois (finite) field of
		 * 2^128 elements */
		gf_mult(y, h, tmp);
 8003546:	f107 0310 	add.w	r3, r7, #16
 800354a:	461a      	mov	r2, r3
 800354c:	68f9      	ldr	r1, [r7, #12]
 800354e:	6838      	ldr	r0, [r7, #0]
 8003550:	f7ff ff83 	bl	800345a <gf_mult>
		memcpy(y, tmp, 16);
 8003554:	683b      	ldr	r3, [r7, #0]
 8003556:	461d      	mov	r5, r3
 8003558:	f107 0410 	add.w	r4, r7, #16
 800355c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800355e:	6028      	str	r0, [r5, #0]
 8003560:	6069      	str	r1, [r5, #4]
 8003562:	60aa      	str	r2, [r5, #8]
 8003564:	60eb      	str	r3, [r5, #12]
	for (i = 0; i < m; i++) {
 8003566:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003568:	3301      	adds	r3, #1
 800356a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800356c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800356e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003570:	429a      	cmp	r2, r3
 8003572:	d3e1      	bcc.n	8003538 <ghash+0x1e>
	}


	if (x + xlen > xpos) {
 8003574:	68ba      	ldr	r2, [r7, #8]
 8003576:	687b      	ldr	r3, [r7, #4]
 8003578:	4413      	add	r3, r2
 800357a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800357c:	429a      	cmp	r2, r3
 800357e:	d22e      	bcs.n	80035de <ghash+0xc4>
		/* Add zero padded last block */
		size_t last = x + xlen - xpos;
 8003580:	68ba      	ldr	r2, [r7, #8]
 8003582:	687b      	ldr	r3, [r7, #4]
 8003584:	4413      	add	r3, r2
 8003586:	461a      	mov	r2, r3
 8003588:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800358a:	1ad3      	subs	r3, r2, r3
 800358c:	623b      	str	r3, [r7, #32]
		memcpy(tmp, xpos, last);
 800358e:	f107 0310 	add.w	r3, r7, #16
 8003592:	6a3a      	ldr	r2, [r7, #32]
 8003594:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8003596:	4618      	mov	r0, r3
 8003598:	f017 fd05 	bl	801afa6 <memcpy>
		memset(tmp + last, 0, sizeof(tmp) - last);
 800359c:	f107 0210 	add.w	r2, r7, #16
 80035a0:	6a3b      	ldr	r3, [r7, #32]
 80035a2:	18d0      	adds	r0, r2, r3
 80035a4:	6a3b      	ldr	r3, [r7, #32]
 80035a6:	f1c3 0310 	rsb	r3, r3, #16
 80035aa:	461a      	mov	r2, r3
 80035ac:	2100      	movs	r1, #0
 80035ae:	f017 fd1e 	bl	801afee <memset>

		/* Y_i = (Y^(i-1) XOR X_i) dot H */
		xor_block(y, tmp);
 80035b2:	f107 0310 	add.w	r3, r7, #16
 80035b6:	4619      	mov	r1, r3
 80035b8:	6838      	ldr	r0, [r7, #0]
 80035ba:	f7ff feb6 	bl	800332a <xor_block>

		/* dot operation:
		 * multiplication operation for binary Galois (finite) field of
		 * 2^128 elements */
		gf_mult(y, h, tmp);
 80035be:	f107 0310 	add.w	r3, r7, #16
 80035c2:	461a      	mov	r2, r3
 80035c4:	68f9      	ldr	r1, [r7, #12]
 80035c6:	6838      	ldr	r0, [r7, #0]
 80035c8:	f7ff ff47 	bl	800345a <gf_mult>
		memcpy(y, tmp, 16);
 80035cc:	683b      	ldr	r3, [r7, #0]
 80035ce:	461d      	mov	r5, r3
 80035d0:	f107 0410 	add.w	r4, r7, #16
 80035d4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80035d6:	6028      	str	r0, [r5, #0]
 80035d8:	6069      	str	r1, [r5, #4]
 80035da:	60aa      	str	r2, [r5, #8]
 80035dc:	60eb      	str	r3, [r5, #12]
	}

	/* Return Y_m */
}
 80035de:	bf00      	nop
 80035e0:	3730      	adds	r7, #48	; 0x30
 80035e2:	46bd      	mov	sp, r7
 80035e4:	bdb0      	pop	{r4, r5, r7, pc}

080035e6 <gctr>:

//gcm gctr
static void gctr(B5_tAesCtx	*ctx, const uint8_t *icb, const uint8_t *x, size_t xlen, uint8_t *y){
 80035e6:	b590      	push	{r4, r7, lr}
 80035e8:	b095      	sub	sp, #84	; 0x54
 80035ea:	af02      	add	r7, sp, #8
 80035ec:	60f8      	str	r0, [r7, #12]
 80035ee:	60b9      	str	r1, [r7, #8]
 80035f0:	607a      	str	r2, [r7, #4]
 80035f2:	603b      	str	r3, [r7, #0]
	size_t i, n, last;
	uint8_t cb[B5_AES_BLK_SIZE], tmp[B5_AES_BLK_SIZE];
	const uint8_t *xpos = x;
 80035f4:	687b      	ldr	r3, [r7, #4]
 80035f6:	643b      	str	r3, [r7, #64]	; 0x40
	uint8_t *ypos = y;
 80035f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80035fa:	63fb      	str	r3, [r7, #60]	; 0x3c

	if (xlen == 0)
 80035fc:	683b      	ldr	r3, [r7, #0]
 80035fe:	2b00      	cmp	r3, #0
 8003600:	d066      	beq.n	80036d0 <gctr+0xea>
		return;

	n = xlen / 16;
 8003602:	683b      	ldr	r3, [r7, #0]
 8003604:	091b      	lsrs	r3, r3, #4
 8003606:	63bb      	str	r3, [r7, #56]	; 0x38

	memcpy(cb, icb, B5_AES_BLK_SIZE);
 8003608:	68bb      	ldr	r3, [r7, #8]
 800360a:	f107 0424 	add.w	r4, r7, #36	; 0x24
 800360e:	6818      	ldr	r0, [r3, #0]
 8003610:	6859      	ldr	r1, [r3, #4]
 8003612:	689a      	ldr	r2, [r3, #8]
 8003614:	68db      	ldr	r3, [r3, #12]
 8003616:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	/* Full blocks */
	for (i = 0; i < n; i++) {
 8003618:	2300      	movs	r3, #0
 800361a:	647b      	str	r3, [r7, #68]	; 0x44
 800361c:	e01e      	b.n	800365c <gctr+0x76>

		//TODO aes_encrypt(aes, cb, ypos);
        //B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, ypos);
		B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, cb, ypos);
 800361e:	68f9      	ldr	r1, [r7, #12]
 8003620:	68fb      	ldr	r3, [r7, #12]
 8003622:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003626:	b21a      	sxth	r2, r3
 8003628:	f107 0024 	add.w	r0, r7, #36	; 0x24
 800362c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800362e:	9300      	str	r3, [sp, #0]
 8003630:	4603      	mov	r3, r0
 8003632:	68f8      	ldr	r0, [r7, #12]
 8003634:	f7fd fb14 	bl	8000c60 <B5_rijndaelEncrypt>
		xor_block(ypos, xpos);
 8003638:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800363a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800363c:	f7ff fe75 	bl	800332a <xor_block>
		xpos += B5_AES_BLK_SIZE;
 8003640:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003642:	3310      	adds	r3, #16
 8003644:	643b      	str	r3, [r7, #64]	; 0x40
		ypos += B5_AES_BLK_SIZE;
 8003646:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003648:	3310      	adds	r3, #16
 800364a:	63fb      	str	r3, [r7, #60]	; 0x3c
		inc32(cb);
 800364c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8003650:	4618      	mov	r0, r3
 8003652:	f7ff fe53 	bl	80032fc <inc32>
	for (i = 0; i < n; i++) {
 8003656:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003658:	3301      	adds	r3, #1
 800365a:	647b      	str	r3, [r7, #68]	; 0x44
 800365c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800365e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003660:	429a      	cmp	r2, r3
 8003662:	d3dc      	bcc.n	800361e <gctr+0x38>
	}

	last = x + xlen - xpos;
 8003664:	687a      	ldr	r2, [r7, #4]
 8003666:	683b      	ldr	r3, [r7, #0]
 8003668:	4413      	add	r3, r2
 800366a:	461a      	mov	r2, r3
 800366c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800366e:	1ad3      	subs	r3, r2, r3
 8003670:	637b      	str	r3, [r7, #52]	; 0x34
	if (last) {
 8003672:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003674:	2b00      	cmp	r3, #0
 8003676:	d02c      	beq.n	80036d2 <gctr+0xec>
		/* Last, partial block */
		//TODO aes_encrypt(aes, cb, tmp);
        //B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, tmp);
		B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, cb, tmp);
 8003678:	68f9      	ldr	r1, [r7, #12]
 800367a:	68fb      	ldr	r3, [r7, #12]
 800367c:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003680:	b21a      	sxth	r2, r3
 8003682:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8003686:	f107 0314 	add.w	r3, r7, #20
 800368a:	9300      	str	r3, [sp, #0]
 800368c:	4603      	mov	r3, r0
 800368e:	68f8      	ldr	r0, [r7, #12]
 8003690:	f7fd fae6 	bl	8000c60 <B5_rijndaelEncrypt>
		xor_block(ypos, xpos);
 8003694:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8003696:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8003698:	f7ff fe47 	bl	800332a <xor_block>
		for (i = 0; i < last; i++)
 800369c:	2300      	movs	r3, #0
 800369e:	647b      	str	r3, [r7, #68]	; 0x44
 80036a0:	e011      	b.n	80036c6 <gctr+0xe0>
			*ypos++ = *xpos++ ^ tmp[i];
 80036a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80036a4:	1c5a      	adds	r2, r3, #1
 80036a6:	643a      	str	r2, [r7, #64]	; 0x40
 80036a8:	7819      	ldrb	r1, [r3, #0]
 80036aa:	f107 0214 	add.w	r2, r7, #20
 80036ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80036b0:	4413      	add	r3, r2
 80036b2:	781a      	ldrb	r2, [r3, #0]
 80036b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80036b6:	1c58      	adds	r0, r3, #1
 80036b8:	63f8      	str	r0, [r7, #60]	; 0x3c
 80036ba:	404a      	eors	r2, r1
 80036bc:	b2d2      	uxtb	r2, r2
 80036be:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < last; i++)
 80036c0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80036c2:	3301      	adds	r3, #1
 80036c4:	647b      	str	r3, [r7, #68]	; 0x44
 80036c6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80036c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80036ca:	429a      	cmp	r2, r3
 80036cc:	d3e9      	bcc.n	80036a2 <gctr+0xbc>
 80036ce:	e000      	b.n	80036d2 <gctr+0xec>
		return;
 80036d0:	bf00      	nop
	}
}
 80036d2:	374c      	adds	r7, #76	; 0x4c
 80036d4:	46bd      	mov	sp, r7
 80036d6:	bd90      	pop	{r4, r7, pc}

080036d8 <gcm_init_hash_subkey>:

//gcm init hash subkey
static void * gcm_init_hash_subkey(B5_tAesCtx	*ctx, uint8_t *H){
 80036d8:	b580      	push	{r7, lr}
 80036da:	b084      	sub	sp, #16
 80036dc:	af02      	add	r7, sp, #8
 80036de:	6078      	str	r0, [r7, #4]
 80036e0:	6039      	str	r1, [r7, #0]
	/* Generate hash subkey H = AES_K(0^128) */
	memset(H, 0, B5_AES_BLK_SIZE);
 80036e2:	2210      	movs	r2, #16
 80036e4:	2100      	movs	r1, #0
 80036e6:	6838      	ldr	r0, [r7, #0]
 80036e8:	f017 fc81 	bl	801afee <memset>
	//aes_encrypt(aes, H, H);
	B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, H, H);
 80036ec:	6879      	ldr	r1, [r7, #4]
 80036ee:	687b      	ldr	r3, [r7, #4]
 80036f0:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 80036f4:	b21a      	sxth	r2, r3
 80036f6:	683b      	ldr	r3, [r7, #0]
 80036f8:	9300      	str	r3, [sp, #0]
 80036fa:	683b      	ldr	r3, [r7, #0]
 80036fc:	6878      	ldr	r0, [r7, #4]
 80036fe:	f7fd faaf 	bl	8000c60 <B5_rijndaelEncrypt>
}
 8003702:	bf00      	nop
 8003704:	4618      	mov	r0, r3
 8003706:	3708      	adds	r7, #8
 8003708:	46bd      	mov	sp, r7
 800370a:	bd80      	pop	{r7, pc}

0800370c <gcm_prepare_j0>:

//gcm prepare IV
static void gcm_prepare_j0(const uint8_t *iv, size_t iv_len, const uint8_t *H, uint8_t *J0){
 800370c:	b590      	push	{r4, r7, lr}
 800370e:	b089      	sub	sp, #36	; 0x24
 8003710:	af00      	add	r7, sp, #0
 8003712:	60f8      	str	r0, [r7, #12]
 8003714:	60b9      	str	r1, [r7, #8]
 8003716:	607a      	str	r2, [r7, #4]
 8003718:	603b      	str	r3, [r7, #0]
	uint8_t len_buf[16];

	if (iv_len == 12) {
 800371a:	68bb      	ldr	r3, [r7, #8]
 800371c:	2b0c      	cmp	r3, #12
 800371e:	d113      	bne.n	8003748 <gcm_prepare_j0+0x3c>
		/* Prepare block J_0 = IV || 0^31 || 1 [len(IV) = 96] */
		memcpy(J0, iv, iv_len);
 8003720:	68ba      	ldr	r2, [r7, #8]
 8003722:	68f9      	ldr	r1, [r7, #12]
 8003724:	6838      	ldr	r0, [r7, #0]
 8003726:	f017 fc3e 	bl	801afa6 <memcpy>
		memset(J0 + iv_len, 0, B5_AES_BLK_SIZE - iv_len);
 800372a:	683a      	ldr	r2, [r7, #0]
 800372c:	68bb      	ldr	r3, [r7, #8]
 800372e:	18d0      	adds	r0, r2, r3
 8003730:	68bb      	ldr	r3, [r7, #8]
 8003732:	f1c3 0310 	rsb	r3, r3, #16
 8003736:	461a      	mov	r2, r3
 8003738:	2100      	movs	r1, #0
 800373a:	f017 fc58 	bl	801afee <memset>
		J0[B5_AES_BLK_SIZE - 1] = 0x01;
 800373e:	683b      	ldr	r3, [r7, #0]
 8003740:	330f      	adds	r3, #15
 8003742:	2201      	movs	r2, #1
 8003744:	701a      	strb	r2, [r3, #0]
		ghash(H, iv, iv_len, J0);
		B5_AES256_PUTUINT64(len_buf, 0);
		B5_AES256_PUTUINT64(len_buf + 8, iv_len * 8);
		ghash(H, len_buf, sizeof(len_buf), J0);
	}
}
 8003746:	e024      	b.n	8003792 <gcm_prepare_j0+0x86>
		ghash_start(J0);
 8003748:	6838      	ldr	r0, [r7, #0]
 800374a:	f7ff fed9 	bl	8003500 <ghash_start>
		ghash(H, iv, iv_len, J0);
 800374e:	683b      	ldr	r3, [r7, #0]
 8003750:	68ba      	ldr	r2, [r7, #8]
 8003752:	68f9      	ldr	r1, [r7, #12]
 8003754:	6878      	ldr	r0, [r7, #4]
 8003756:	f7ff fee0 	bl	800351a <ghash>
		B5_AES256_PUTUINT64(len_buf, 0);
 800375a:	f107 0110 	add.w	r1, r7, #16
 800375e:	f04f 0200 	mov.w	r2, #0
 8003762:	f04f 0300 	mov.w	r3, #0
 8003766:	4608      	mov	r0, r1
 8003768:	f7fc fe0d 	bl	8000386 <B5_AES256_PUTUINT64>
		B5_AES256_PUTUINT64(len_buf + 8, iv_len * 8);
 800376c:	f107 0110 	add.w	r1, r7, #16
 8003770:	3108      	adds	r1, #8
 8003772:	68bb      	ldr	r3, [r7, #8]
 8003774:	00db      	lsls	r3, r3, #3
 8003776:	f04f 0400 	mov.w	r4, #0
 800377a:	461a      	mov	r2, r3
 800377c:	4623      	mov	r3, r4
 800377e:	4608      	mov	r0, r1
 8003780:	f7fc fe01 	bl	8000386 <B5_AES256_PUTUINT64>
		ghash(H, len_buf, sizeof(len_buf), J0);
 8003784:	f107 0110 	add.w	r1, r7, #16
 8003788:	683b      	ldr	r3, [r7, #0]
 800378a:	2210      	movs	r2, #16
 800378c:	6878      	ldr	r0, [r7, #4]
 800378e:	f7ff fec4 	bl	800351a <ghash>
}
 8003792:	bf00      	nop
 8003794:	3724      	adds	r7, #36	; 0x24
 8003796:	46bd      	mov	sp, r7
 8003798:	bd90      	pop	{r4, r7, pc}

0800379a <gcm_gctr>:

// gcm gctr
static void gcm_gctr(B5_tAesCtx	*ctx, const uint8_t *J0, const uint8_t *in, size_t len, uint8_t *out){
 800379a:	b590      	push	{r4, r7, lr}
 800379c:	b08b      	sub	sp, #44	; 0x2c
 800379e:	af02      	add	r7, sp, #8
 80037a0:	60f8      	str	r0, [r7, #12]
 80037a2:	60b9      	str	r1, [r7, #8]
 80037a4:	607a      	str	r2, [r7, #4]
 80037a6:	603b      	str	r3, [r7, #0]
	uint8_t J0inc[B5_AES_BLK_SIZE];

	if (len == 0)
 80037a8:	683b      	ldr	r3, [r7, #0]
 80037aa:	2b00      	cmp	r3, #0
 80037ac:	d016      	beq.n	80037dc <gcm_gctr+0x42>
		return;

	memcpy(J0inc, J0, B5_AES_BLK_SIZE);
 80037ae:	68bb      	ldr	r3, [r7, #8]
 80037b0:	f107 0410 	add.w	r4, r7, #16
 80037b4:	6818      	ldr	r0, [r3, #0]
 80037b6:	6859      	ldr	r1, [r3, #4]
 80037b8:	689a      	ldr	r2, [r3, #8]
 80037ba:	68db      	ldr	r3, [r3, #12]
 80037bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	inc32(J0inc);
 80037be:	f107 0310 	add.w	r3, r7, #16
 80037c2:	4618      	mov	r0, r3
 80037c4:	f7ff fd9a 	bl	80032fc <inc32>
	gctr(ctx,J0inc, in, len, out);
 80037c8:	f107 0110 	add.w	r1, r7, #16
 80037cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80037ce:	9300      	str	r3, [sp, #0]
 80037d0:	683b      	ldr	r3, [r7, #0]
 80037d2:	687a      	ldr	r2, [r7, #4]
 80037d4:	68f8      	ldr	r0, [r7, #12]
 80037d6:	f7ff ff06 	bl	80035e6 <gctr>
 80037da:	e000      	b.n	80037de <gcm_gctr+0x44>
		return;
 80037dc:	bf00      	nop
}
 80037de:	3724      	adds	r7, #36	; 0x24
 80037e0:	46bd      	mov	sp, r7
 80037e2:	bd90      	pop	{r4, r7, pc}

080037e4 <gcm_ghash>:


//gcm ghash
static void gcm_ghash(const uint8_t *H, const uint8_t *aad, size_t aad_len, const uint8_t *crypt, size_t crypt_len, uint8_t *S){
 80037e4:	b590      	push	{r4, r7, lr}
 80037e6:	b089      	sub	sp, #36	; 0x24
 80037e8:	af00      	add	r7, sp, #0
 80037ea:	60f8      	str	r0, [r7, #12]
 80037ec:	60b9      	str	r1, [r7, #8]
 80037ee:	607a      	str	r2, [r7, #4]
 80037f0:	603b      	str	r3, [r7, #0]
	 * v = 128 * ceil[len(A)/128] - len(A)
	 * S = GHASH_H(A || 0^v || C || 0^u || [len(A)]64 || [len(C)]64)
	 * (i.e., zero padded to block size A || C and lengths of each in bits)
	 */

	ghash_start(S);
 80037f2:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80037f4:	f7ff fe84 	bl	8003500 <ghash_start>
	ghash(H, aad, aad_len, S);
 80037f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80037fa:	687a      	ldr	r2, [r7, #4]
 80037fc:	68b9      	ldr	r1, [r7, #8]
 80037fe:	68f8      	ldr	r0, [r7, #12]
 8003800:	f7ff fe8b 	bl	800351a <ghash>
	ghash(H, crypt, crypt_len, S);
 8003804:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003806:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8003808:	6839      	ldr	r1, [r7, #0]
 800380a:	68f8      	ldr	r0, [r7, #12]
 800380c:	f7ff fe85 	bl	800351a <ghash>
	B5_AES256_PUTUINT64(len_buf, aad_len * 8);
 8003810:	687b      	ldr	r3, [r7, #4]
 8003812:	00db      	lsls	r3, r3, #3
 8003814:	f04f 0400 	mov.w	r4, #0
 8003818:	f107 0110 	add.w	r1, r7, #16
 800381c:	461a      	mov	r2, r3
 800381e:	4623      	mov	r3, r4
 8003820:	4608      	mov	r0, r1
 8003822:	f7fc fdb0 	bl	8000386 <B5_AES256_PUTUINT64>
	B5_AES256_PUTUINT64(len_buf + 8, crypt_len * 8);
 8003826:	f107 0110 	add.w	r1, r7, #16
 800382a:	3108      	adds	r1, #8
 800382c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800382e:	00db      	lsls	r3, r3, #3
 8003830:	f04f 0400 	mov.w	r4, #0
 8003834:	461a      	mov	r2, r3
 8003836:	4623      	mov	r3, r4
 8003838:	4608      	mov	r0, r1
 800383a:	f7fc fda4 	bl	8000386 <B5_AES256_PUTUINT64>
	ghash(H, len_buf, sizeof(len_buf), S);
 800383e:	f107 0110 	add.w	r1, r7, #16
 8003842:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003844:	2210      	movs	r2, #16
 8003846:	68f8      	ldr	r0, [r7, #12]
 8003848:	f7ff fe67 	bl	800351a <ghash>

}
 800384c:	bf00      	nop
 800384e:	3724      	adds	r7, #36	; 0x24
 8003850:	46bd      	mov	sp, r7
 8003852:	bd90      	pop	{r4, r7, pc}

08003854 <gcm_ae>:

/**
 * aes_gcm_ae - GCM-AE_K(IV, P, A)
 */
uint8_t gcm_ae(B5_tAesCtx	*ctx, const uint8_t *iv, size_t iv_len, const uint8_t *plain,
		size_t plain_len, const uint8_t *aad, size_t aad_len, uint8_t *crypt, uint8_t *tag){
 8003854:	b580      	push	{r7, lr}
 8003856:	b092      	sub	sp, #72	; 0x48
 8003858:	af02      	add	r7, sp, #8
 800385a:	60f8      	str	r0, [r7, #12]
 800385c:	60b9      	str	r1, [r7, #8]
 800385e:	607a      	str	r2, [r7, #4]
 8003860:	603b      	str	r3, [r7, #0]

	uint8_t H[B5_AES_BLK_SIZE];
	uint8_t J0[B5_AES_BLK_SIZE];
	uint8_t S[16];

	gcm_init_hash_subkey(ctx, H);
 8003862:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8003866:	4619      	mov	r1, r3
 8003868:	68f8      	ldr	r0, [r7, #12]
 800386a:	f7ff ff35 	bl	80036d8 <gcm_init_hash_subkey>
	gcm_prepare_j0(iv, iv_len, H, J0);
 800386e:	f107 0320 	add.w	r3, r7, #32
 8003872:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8003876:	6879      	ldr	r1, [r7, #4]
 8003878:	68b8      	ldr	r0, [r7, #8]
 800387a:	f7ff ff47 	bl	800370c <gcm_prepare_j0>

	/* C = GCTR_K(inc_32(J_0), P) */
	gcm_gctr(ctx, J0, plain, plain_len, crypt);
 800387e:	f107 0120 	add.w	r1, r7, #32
 8003882:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8003884:	9300      	str	r3, [sp, #0]
 8003886:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8003888:	683a      	ldr	r2, [r7, #0]
 800388a:	68f8      	ldr	r0, [r7, #12]
 800388c:	f7ff ff85 	bl	800379a <gcm_gctr>
	gcm_ghash(H, aad, aad_len, crypt, plain_len, S);
 8003890:	f107 0030 	add.w	r0, r7, #48	; 0x30
 8003894:	f107 0310 	add.w	r3, r7, #16
 8003898:	9301      	str	r3, [sp, #4]
 800389a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800389c:	9300      	str	r3, [sp, #0]
 800389e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80038a0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80038a2:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80038a4:	f7ff ff9e 	bl	80037e4 <gcm_ghash>

	/* T = MSB_t(GCTR_K(J_0, S)) */
	gctr(ctx, J0, S, sizeof(S), tag);
 80038a8:	f107 0210 	add.w	r2, r7, #16
 80038ac:	f107 0120 	add.w	r1, r7, #32
 80038b0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80038b2:	9300      	str	r3, [sp, #0]
 80038b4:	2310      	movs	r3, #16
 80038b6:	68f8      	ldr	r0, [r7, #12]
 80038b8:	f7ff fe95 	bl	80035e6 <gctr>

	/* Return (C, T) */
	return 0;
 80038bc:	2300      	movs	r3, #0
}
 80038be:	4618      	mov	r0, r3
 80038c0:	3740      	adds	r7, #64	; 0x40
 80038c2:	46bd      	mov	sp, r7
 80038c4:	bd80      	pop	{r7, pc}

080038c6 <gcm_ad>:

/**
 * aes_gcm_ad - GCM-AD_K(IV, C, A, T)
 */
uint8_t gcm_ad(B5_tAesCtx *ctx, const uint8_t *iv, size_t iv_len, const uint8_t *crypt,
		size_t crypt_len, const uint8_t *aad, size_t aad_len, const uint8_t *tag, uint8_t *plain){
 80038c6:	b580      	push	{r7, lr}
 80038c8:	b096      	sub	sp, #88	; 0x58
 80038ca:	af02      	add	r7, sp, #8
 80038cc:	60f8      	str	r0, [r7, #12]
 80038ce:	60b9      	str	r1, [r7, #8]
 80038d0:	607a      	str	r2, [r7, #4]
 80038d2:	603b      	str	r3, [r7, #0]

	uint8_t H[B5_AES_BLK_SIZE];
	uint8_t J0[B5_AES_BLK_SIZE];
	uint8_t S[16], T[16];

	gcm_init_hash_subkey(ctx, H);
 80038d4:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80038d8:	4619      	mov	r1, r3
 80038da:	68f8      	ldr	r0, [r7, #12]
 80038dc:	f7ff fefc 	bl	80036d8 <gcm_init_hash_subkey>
	gcm_prepare_j0(iv, iv_len, H, J0);
 80038e0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80038e4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 80038e8:	6879      	ldr	r1, [r7, #4]
 80038ea:	68b8      	ldr	r0, [r7, #8]
 80038ec:	f7ff ff0e 	bl	800370c <gcm_prepare_j0>

	/* P = GCTR_K(inc_32(J_0), C) */
	gcm_gctr(ctx, J0, crypt, crypt_len, plain);
 80038f0:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80038f4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80038f6:	9300      	str	r3, [sp, #0]
 80038f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80038fa:	683a      	ldr	r2, [r7, #0]
 80038fc:	68f8      	ldr	r0, [r7, #12]
 80038fe:	f7ff ff4c 	bl	800379a <gcm_gctr>
	gcm_ghash(H, aad, aad_len, crypt, crypt_len, S);
 8003902:	f107 0040 	add.w	r0, r7, #64	; 0x40
 8003906:	f107 0320 	add.w	r3, r7, #32
 800390a:	9301      	str	r3, [sp, #4]
 800390c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800390e:	9300      	str	r3, [sp, #0]
 8003910:	683b      	ldr	r3, [r7, #0]
 8003912:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8003914:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8003916:	f7ff ff65 	bl	80037e4 <gcm_ghash>

	/* T' = MSB_t(GCTR_K(J_0, S)) */
	gctr(ctx, J0, S, sizeof(S), T);
 800391a:	f107 0220 	add.w	r2, r7, #32
 800391e:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8003922:	f107 0310 	add.w	r3, r7, #16
 8003926:	9300      	str	r3, [sp, #0]
 8003928:	2310      	movs	r3, #16
 800392a:	68f8      	ldr	r0, [r7, #12]
 800392c:	f7ff fe5b 	bl	80035e6 <gctr>

	if (memcmp(tag, T, 16) != 0) {
 8003930:	f107 0310 	add.w	r3, r7, #16
 8003934:	2210      	movs	r2, #16
 8003936:	4619      	mov	r1, r3
 8003938:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800393a:	f017 fb25 	bl	801af88 <memcmp>
 800393e:	4603      	mov	r3, r0
 8003940:	2b00      	cmp	r3, #0
 8003942:	d001      	beq.n	8003948 <gcm_ad+0x82>
		//aes_printf(MSG_EXCESSIVE, "GCM: Tag mismatch");
		return -1;
 8003944:	23ff      	movs	r3, #255	; 0xff
 8003946:	e000      	b.n	800394a <gcm_ad+0x84>
	}

	return 0;
 8003948:	2300      	movs	r3, #0
}
 800394a:	4618      	mov	r0, r3
 800394c:	3750      	adds	r7, #80	; 0x50
 800394e:	46bd      	mov	sp, r7
 8003950:	bd80      	pop	{r7, pc}

08003952 <aes_gcm_enc>:
	return gcm_ae(ctx, iv, iv_len, NULL, 0, aad, aad_len, NULL, tag);
}


uint8_t aes_gcm_enc(B5_tAesCtx	*ctx, const uint8_t *iv, size_t iv_len, const uint8_t *plain,
		size_t plain_len, const uint8_t *aad, size_t aad_len, uint8_t *crypt){
 8003952:	b580      	push	{r7, lr}
 8003954:	b08a      	sub	sp, #40	; 0x28
 8003956:	af06      	add	r7, sp, #24
 8003958:	60f8      	str	r0, [r7, #12]
 800395a:	60b9      	str	r1, [r7, #8]
 800395c:	607a      	str	r2, [r7, #4]
 800395e:	603b      	str	r3, [r7, #0]
	gcm_ae(ctx, iv, iv_len, plain, plain_len, aad, aad_len, crypt, crypt+plain_len);
 8003960:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003962:	69bb      	ldr	r3, [r7, #24]
 8003964:	4413      	add	r3, r2
 8003966:	9304      	str	r3, [sp, #16]
 8003968:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800396a:	9303      	str	r3, [sp, #12]
 800396c:	6a3b      	ldr	r3, [r7, #32]
 800396e:	9302      	str	r3, [sp, #8]
 8003970:	69fb      	ldr	r3, [r7, #28]
 8003972:	9301      	str	r3, [sp, #4]
 8003974:	69bb      	ldr	r3, [r7, #24]
 8003976:	9300      	str	r3, [sp, #0]
 8003978:	683b      	ldr	r3, [r7, #0]
 800397a:	687a      	ldr	r2, [r7, #4]
 800397c:	68b9      	ldr	r1, [r7, #8]
 800397e:	68f8      	ldr	r0, [r7, #12]
 8003980:	f7ff ff68 	bl	8003854 <gcm_ae>
}
 8003984:	bf00      	nop
 8003986:	4618      	mov	r0, r3
 8003988:	3710      	adds	r7, #16
 800398a:	46bd      	mov	sp, r7
 800398c:	bd80      	pop	{r7, pc}

0800398e <aes_gcm_dec>:

uint8_t aes_gcm_dec(B5_tAesCtx	*ctx, const uint8_t *iv, size_t iv_len, const uint8_t *crypt,
		size_t crypt_len, const uint8_t *aad, size_t aad_len, uint8_t *plain){
 800398e:	b580      	push	{r7, lr}
 8003990:	b08a      	sub	sp, #40	; 0x28
 8003992:	af06      	add	r7, sp, #24
 8003994:	60f8      	str	r0, [r7, #12]
 8003996:	60b9      	str	r1, [r7, #8]
 8003998:	607a      	str	r2, [r7, #4]
 800399a:	603b      	str	r3, [r7, #0]

/*	gcm_ad(B5_tAesCtx *ctx, const uint8_t *iv, size_t iv_len, const uint8_t *crypt,
			size_t crypt_len, const uint8_t *aad, size_t aad_len, const uint8_t *tag, uint8_t *plain){
*/
	gcm_ad(ctx, iv, iv_len, crypt, crypt_len-B5_AES_BLK_SIZE, aad, aad_len, crypt+crypt_len-B5_AES_BLK_SIZE,plain);
 800399c:	69bb      	ldr	r3, [r7, #24]
 800399e:	3b10      	subs	r3, #16
 80039a0:	69ba      	ldr	r2, [r7, #24]
 80039a2:	3a10      	subs	r2, #16
 80039a4:	6839      	ldr	r1, [r7, #0]
 80039a6:	440a      	add	r2, r1
 80039a8:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80039aa:	9104      	str	r1, [sp, #16]
 80039ac:	9203      	str	r2, [sp, #12]
 80039ae:	6a3a      	ldr	r2, [r7, #32]
 80039b0:	9202      	str	r2, [sp, #8]
 80039b2:	69fa      	ldr	r2, [r7, #28]
 80039b4:	9201      	str	r2, [sp, #4]
 80039b6:	9300      	str	r3, [sp, #0]
 80039b8:	683b      	ldr	r3, [r7, #0]
 80039ba:	687a      	ldr	r2, [r7, #4]
 80039bc:	68b9      	ldr	r1, [r7, #8]
 80039be:	68f8      	ldr	r0, [r7, #12]
 80039c0:	f7ff ff81 	bl	80038c6 <gcm_ad>
}
 80039c4:	bf00      	nop
 80039c6:	4618      	mov	r0, r3
 80039c8:	3710      	adds	r7, #16
 80039ca:	46bd      	mov	sp, r7
 80039cc:	bd80      	pop	{r7, pc}
	...

080039d0 <B5_Aes256_Init>:




int32_t B5_Aes256_Init (B5_tAesCtx *ctx, const uint8_t *Key, int16_t keySize, uint8_t aesMode)
{
 80039d0:	b580      	push	{r7, lr}
 80039d2:	b084      	sub	sp, #16
 80039d4:	af00      	add	r7, sp, #0
 80039d6:	60f8      	str	r0, [r7, #12]
 80039d8:	60b9      	str	r1, [r7, #8]
 80039da:	4611      	mov	r1, r2
 80039dc:	461a      	mov	r2, r3
 80039de:	460b      	mov	r3, r1
 80039e0:	80fb      	strh	r3, [r7, #6]
 80039e2:	4613      	mov	r3, r2
 80039e4:	717b      	strb	r3, [r7, #5]
    if(Key == NULL) 
 80039e6:	68bb      	ldr	r3, [r7, #8]
 80039e8:	2b00      	cmp	r3, #0
 80039ea:	d102      	bne.n	80039f2 <B5_Aes256_Init+0x22>
        return B5_AES256_RES_INVALID_ARGUMENT;
 80039ec:	f06f 0303 	mvn.w	r3, #3
 80039f0:	e0aa      	b.n	8003b48 <B5_Aes256_Init+0x178>
    
    if(ctx == NULL)
 80039f2:	68fb      	ldr	r3, [r7, #12]
 80039f4:	2b00      	cmp	r3, #0
 80039f6:	d102      	bne.n	80039fe <B5_Aes256_Init+0x2e>
        return  B5_AES256_RES_INVALID_CONTEXT;
 80039f8:	f04f 33ff 	mov.w	r3, #4294967295
 80039fc:	e0a4      	b.n	8003b48 <B5_Aes256_Init+0x178>
    
    memset(ctx, 0, sizeof(B5_tAesCtx));
 80039fe:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8003a02:	2100      	movs	r1, #0
 8003a04:	68f8      	ldr	r0, [r7, #12]
 8003a06:	f017 faf2 	bl	801afee <memset>
    
    //if ((aesMode < B5_AES256_OFB) || (aesMode > B5_AES256_CTR ))
    if ((aesMode < B5_AES256_OFB) || (aesMode > B5_AES256_GCM_DEC ))
 8003a0a:	797b      	ldrb	r3, [r7, #5]
 8003a0c:	2b00      	cmp	r3, #0
 8003a0e:	d002      	beq.n	8003a16 <B5_Aes256_Init+0x46>
 8003a10:	797b      	ldrb	r3, [r7, #5]
 8003a12:	2b0a      	cmp	r3, #10
 8003a14:	d902      	bls.n	8003a1c <B5_Aes256_Init+0x4c>
        return B5_AES256_RES_INVALID_MODE;
 8003a16:	f06f 0304 	mvn.w	r3, #4
 8003a1a:	e095      	b.n	8003b48 <B5_Aes256_Init+0x178>
    
    if((keySize != B5_AES_128) && (keySize != B5_AES_192) && (keySize != B5_AES_256)) 
 8003a1c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003a20:	2b10      	cmp	r3, #16
 8003a22:	d00a      	beq.n	8003a3a <B5_Aes256_Init+0x6a>
 8003a24:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003a28:	2b18      	cmp	r3, #24
 8003a2a:	d006      	beq.n	8003a3a <B5_Aes256_Init+0x6a>
 8003a2c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003a30:	2b20      	cmp	r3, #32
 8003a32:	d002      	beq.n	8003a3a <B5_Aes256_Init+0x6a>
        return B5_AES256_RES_INVALID_KEY_SIZE;
 8003a34:	f06f 0302 	mvn.w	r3, #2
 8003a38:	e086      	b.n	8003b48 <B5_Aes256_Init+0x178>
    
    ctx->mode = aesMode;
 8003a3a:	68fb      	ldr	r3, [r7, #12]
 8003a3c:	797a      	ldrb	r2, [r7, #5]
 8003a3e:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
    
    ctx->Te0 = B5Te0_S;
 8003a42:	68fb      	ldr	r3, [r7, #12]
 8003a44:	4a42      	ldr	r2, [pc, #264]	; (8003b50 <B5_Aes256_Init+0x180>)
 8003a46:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    ctx->Te1 = B5Te1_S;
 8003a4a:	68fb      	ldr	r3, [r7, #12]
 8003a4c:	4a41      	ldr	r2, [pc, #260]	; (8003b54 <B5_Aes256_Init+0x184>)
 8003a4e:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    ctx->Te2 = B5Te2_S;
 8003a52:	68fb      	ldr	r3, [r7, #12]
 8003a54:	4a40      	ldr	r2, [pc, #256]	; (8003b58 <B5_Aes256_Init+0x188>)
 8003a56:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    ctx->Te3 = B5Te3_S;
 8003a5a:	68fb      	ldr	r3, [r7, #12]
 8003a5c:	4a3f      	ldr	r2, [pc, #252]	; (8003b5c <B5_Aes256_Init+0x18c>)
 8003a5e:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    ctx->Te4 = B5Te4_S;
 8003a62:	68fb      	ldr	r3, [r7, #12]
 8003a64:	4a3e      	ldr	r2, [pc, #248]	; (8003b60 <B5_Aes256_Init+0x190>)
 8003a66:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    ctx->Td0 = B5Td0_S;
 8003a6a:	68fb      	ldr	r3, [r7, #12]
 8003a6c:	4a3d      	ldr	r2, [pc, #244]	; (8003b64 <B5_Aes256_Init+0x194>)
 8003a6e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    ctx->Td1 = B5Td1_S;
 8003a72:	68fb      	ldr	r3, [r7, #12]
 8003a74:	4a3c      	ldr	r2, [pc, #240]	; (8003b68 <B5_Aes256_Init+0x198>)
 8003a76:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    ctx->Td2 = B5Td2_S;
 8003a7a:	68fb      	ldr	r3, [r7, #12]
 8003a7c:	4a3b      	ldr	r2, [pc, #236]	; (8003b6c <B5_Aes256_Init+0x19c>)
 8003a7e:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    ctx->Td3 = B5Td3_S;
 8003a82:	68fb      	ldr	r3, [r7, #12]
 8003a84:	4a3a      	ldr	r2, [pc, #232]	; (8003b70 <B5_Aes256_Init+0x1a0>)
 8003a86:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    ctx->Td4 = B5Td4_S;
 8003a8a:	68fb      	ldr	r3, [r7, #12]
 8003a8c:	4a39      	ldr	r2, [pc, #228]	; (8003b74 <B5_Aes256_Init+0x1a4>)
 8003a8e:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    
    memset(ctx->InitVector, 0x55, B5_AES_IV_SIZE);
 8003a92:	68fb      	ldr	r3, [r7, #12]
 8003a94:	33f1      	adds	r3, #241	; 0xf1
 8003a96:	2210      	movs	r2, #16
 8003a98:	2155      	movs	r1, #85	; 0x55
 8003a9a:	4618      	mov	r0, r3
 8003a9c:	f017 faa7 	bl	801afee <memset>
    
    if ((ctx->mode == B5_AES256_ECB_ENC) || (ctx->mode == B5_AES256_OFB) || (ctx->mode == B5_AES256_CBC_ENC) || (ctx->mode == B5_AES256_CTR) || (ctx->mode == B5_AES256_GCM_ENC) || (ctx->mode == B5_AES256_GCM_DEC) || (ctx->mode == B5_AES256_CFB_ENC) || (ctx->mode == B5_AES256_CFB_DEC))
 8003aa0:	68fb      	ldr	r3, [r7, #12]
 8003aa2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003aa6:	2b02      	cmp	r3, #2
 8003aa8:	d022      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003aaa:	68fb      	ldr	r3, [r7, #12]
 8003aac:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ab0:	2b01      	cmp	r3, #1
 8003ab2:	d01d      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003ab4:	68fb      	ldr	r3, [r7, #12]
 8003ab6:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003aba:	2b04      	cmp	r3, #4
 8003abc:	d018      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003abe:	68fb      	ldr	r3, [r7, #12]
 8003ac0:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ac4:	2b08      	cmp	r3, #8
 8003ac6:	d013      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003ac8:	68fb      	ldr	r3, [r7, #12]
 8003aca:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ace:	2b09      	cmp	r3, #9
 8003ad0:	d00e      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003ad2:	68fb      	ldr	r3, [r7, #12]
 8003ad4:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ad8:	2b0a      	cmp	r3, #10
 8003ada:	d009      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003adc:	68fb      	ldr	r3, [r7, #12]
 8003ade:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ae2:	2b06      	cmp	r3, #6
 8003ae4:	d004      	beq.n	8003af0 <B5_Aes256_Init+0x120>
 8003ae6:	68fb      	ldr	r3, [r7, #12]
 8003ae8:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003aec:	2b07      	cmp	r3, #7
 8003aee:	d10e      	bne.n	8003b0e <B5_Aes256_Init+0x13e>
    {
        ctx->Nr = B5_rijndaelKeySetupEnc(ctx, ctx->rk, Key, keySize<<3);
 8003af0:	68f9      	ldr	r1, [r7, #12]
 8003af2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003af6:	00db      	lsls	r3, r3, #3
 8003af8:	b21b      	sxth	r3, r3
 8003afa:	68ba      	ldr	r2, [r7, #8]
 8003afc:	68f8      	ldr	r0, [r7, #12]
 8003afe:	f7fc fcab 	bl	8000458 <B5_rijndaelKeySetupEnc>
 8003b02:	4603      	mov	r3, r0
 8003b04:	461a      	mov	r2, r3
 8003b06:	68fb      	ldr	r3, [r7, #12]
 8003b08:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
 8003b0c:	e01b      	b.n	8003b46 <B5_Aes256_Init+0x176>
    } 
    else if ((ctx->mode == B5_AES256_ECB_DEC) || (ctx->mode == B5_AES256_CBC_DEC) )  
 8003b0e:	68fb      	ldr	r3, [r7, #12]
 8003b10:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003b14:	2b03      	cmp	r3, #3
 8003b16:	d004      	beq.n	8003b22 <B5_Aes256_Init+0x152>
 8003b18:	68fb      	ldr	r3, [r7, #12]
 8003b1a:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003b1e:	2b05      	cmp	r3, #5
 8003b20:	d10e      	bne.n	8003b40 <B5_Aes256_Init+0x170>
    {
        ctx->Nr = B5_rijndaelKeySetupDec(ctx, ctx->rk, Key, keySize<<3);
 8003b22:	68f9      	ldr	r1, [r7, #12]
 8003b24:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003b28:	00db      	lsls	r3, r3, #3
 8003b2a:	b21b      	sxth	r3, r3
 8003b2c:	68ba      	ldr	r2, [r7, #8]
 8003b2e:	68f8      	ldr	r0, [r7, #12]
 8003b30:	f7fc fed0 	bl	80008d4 <B5_rijndaelKeySetupDec>
 8003b34:	4603      	mov	r3, r0
 8003b36:	461a      	mov	r2, r3
 8003b38:	68fb      	ldr	r3, [r7, #12]
 8003b3a:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
 8003b3e:	e002      	b.n	8003b46 <B5_Aes256_Init+0x176>
    }
    else
    {
        return B5_AES256_RES_INVALID_MODE;        
 8003b40:	f06f 0304 	mvn.w	r3, #4
 8003b44:	e000      	b.n	8003b48 <B5_Aes256_Init+0x178>
    }
    
    
    return B5_AES256_RES_OK;
 8003b46:	2300      	movs	r3, #0
}
 8003b48:	4618      	mov	r0, r3
 8003b4a:	3710      	adds	r7, #16
 8003b4c:	46bd      	mov	sp, r7
 8003b4e:	bd80      	pop	{r7, pc}
 8003b50:	0801b800 	.word	0x0801b800
 8003b54:	0801bc00 	.word	0x0801bc00
 8003b58:	0801c000 	.word	0x0801c000
 8003b5c:	0801c400 	.word	0x0801c400
 8003b60:	0801c800 	.word	0x0801c800
 8003b64:	0801cc00 	.word	0x0801cc00
 8003b68:	0801d000 	.word	0x0801d000
 8003b6c:	0801d400 	.word	0x0801d400
 8003b70:	0801d800 	.word	0x0801d800
 8003b74:	0801dc00 	.word	0x0801dc00

08003b78 <B5_Aes256_SetIV>:




int32_t B5_Aes256_SetIV (B5_tAesCtx    *ctx, const uint8_t *IV)
{
 8003b78:	b580      	push	{r7, lr}
 8003b7a:	b082      	sub	sp, #8
 8003b7c:	af00      	add	r7, sp, #0
 8003b7e:	6078      	str	r0, [r7, #4]
 8003b80:	6039      	str	r1, [r7, #0]
    if(ctx == NULL)
 8003b82:	687b      	ldr	r3, [r7, #4]
 8003b84:	2b00      	cmp	r3, #0
 8003b86:	d102      	bne.n	8003b8e <B5_Aes256_SetIV+0x16>
        return  B5_AES256_RES_INVALID_CONTEXT;
 8003b88:	f04f 33ff 	mov.w	r3, #4294967295
 8003b8c:	e038      	b.n	8003c00 <B5_Aes256_SetIV+0x88>
    
    
    if(IV == NULL) 
 8003b8e:	683b      	ldr	r3, [r7, #0]
 8003b90:	2b00      	cmp	r3, #0
 8003b92:	d102      	bne.n	8003b9a <B5_Aes256_SetIV+0x22>
        return B5_AES256_RES_INVALID_ARGUMENT;
 8003b94:	f06f 0303 	mvn.w	r3, #3
 8003b98:	e032      	b.n	8003c00 <B5_Aes256_SetIV+0x88>
    
    
    if ( (ctx->mode != B5_AES256_OFB) && (ctx->mode != B5_AES256_CBC_ENC) && (ctx->mode != B5_AES256_CBC_DEC) && (ctx->mode != B5_AES256_CTR) && (ctx->mode != B5_AES256_GCM_ENC) && (ctx->mode != B5_AES256_GCM_DEC) &&
 8003b9a:	687b      	ldr	r3, [r7, #4]
 8003b9c:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003ba0:	2b01      	cmp	r3, #1
 8003ba2:	d025      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
 8003ba4:	687b      	ldr	r3, [r7, #4]
 8003ba6:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003baa:	2b04      	cmp	r3, #4
 8003bac:	d020      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
 8003bae:	687b      	ldr	r3, [r7, #4]
 8003bb0:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003bb4:	2b05      	cmp	r3, #5
 8003bb6:	d01b      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
 8003bb8:	687b      	ldr	r3, [r7, #4]
 8003bba:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003bbe:	2b08      	cmp	r3, #8
 8003bc0:	d016      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
 8003bc2:	687b      	ldr	r3, [r7, #4]
 8003bc4:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003bc8:	2b09      	cmp	r3, #9
 8003bca:	d011      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
 8003bcc:	687b      	ldr	r3, [r7, #4]
 8003bce:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003bd2:	2b0a      	cmp	r3, #10
 8003bd4:	d00c      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
         (ctx->mode != B5_AES256_CFB_ENC) &&  (ctx->mode != B5_AES256_CFB_DEC))    
 8003bd6:	687b      	ldr	r3, [r7, #4]
 8003bd8:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
    if ( (ctx->mode != B5_AES256_OFB) && (ctx->mode != B5_AES256_CBC_ENC) && (ctx->mode != B5_AES256_CBC_DEC) && (ctx->mode != B5_AES256_CTR) && (ctx->mode != B5_AES256_GCM_ENC) && (ctx->mode != B5_AES256_GCM_DEC) &&
 8003bdc:	2b06      	cmp	r3, #6
 8003bde:	d007      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
         (ctx->mode != B5_AES256_CFB_ENC) &&  (ctx->mode != B5_AES256_CFB_DEC))    
 8003be0:	687b      	ldr	r3, [r7, #4]
 8003be2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003be6:	2b07      	cmp	r3, #7
 8003be8:	d002      	beq.n	8003bf0 <B5_Aes256_SetIV+0x78>
        return B5_AES256_RES_INVALID_MODE; 
 8003bea:	f06f 0304 	mvn.w	r3, #4
 8003bee:	e007      	b.n	8003c00 <B5_Aes256_SetIV+0x88>
    
    memcpy(ctx->InitVector, IV, B5_AES_IV_SIZE);
 8003bf0:	687b      	ldr	r3, [r7, #4]
 8003bf2:	33f1      	adds	r3, #241	; 0xf1
 8003bf4:	2210      	movs	r2, #16
 8003bf6:	6839      	ldr	r1, [r7, #0]
 8003bf8:	4618      	mov	r0, r3
 8003bfa:	f017 f9d4 	bl	801afa6 <memcpy>
    
    return B5_AES256_RES_OK;
 8003bfe:	2300      	movs	r3, #0
}
 8003c00:	4618      	mov	r0, r3
 8003c02:	3708      	adds	r7, #8
 8003c04:	46bd      	mov	sp, r7
 8003c06:	bd80      	pop	{r7, pc}

08003c08 <B5_Aes256_Update>:




int32_t B5_Aes256_Update (B5_tAesCtx	*ctx, uint8_t *assData, uint8_t *encData, uint8_t *clrData, int16_t nAssBlk, int16_t nBlk)
{
 8003c08:	b580      	push	{r7, lr}
 8003c0a:	b08e      	sub	sp, #56	; 0x38
 8003c0c:	af04      	add	r7, sp, #16
 8003c0e:	60f8      	str	r0, [r7, #12]
 8003c10:	60b9      	str	r1, [r7, #8]
 8003c12:	607a      	str	r2, [r7, #4]
 8003c14:	603b      	str	r3, [r7, #0]
    int16_t    i, j, cb;
    uint8_t    tmp[B5_AES_BLK_SIZE];
    
    
    
    if(ctx == NULL)
 8003c16:	68fb      	ldr	r3, [r7, #12]
 8003c18:	2b00      	cmp	r3, #0
 8003c1a:	d102      	bne.n	8003c22 <B5_Aes256_Update+0x1a>
        return  B5_AES256_RES_INVALID_CONTEXT;
 8003c1c:	f04f 33ff 	mov.w	r3, #4294967295
 8003c20:	e2a0      	b.n	8004164 <B5_Aes256_Update+0x55c>
    
    
    if((encData == NULL) || (clrData == NULL) || (nBlk <= 0))
 8003c22:	687b      	ldr	r3, [r7, #4]
 8003c24:	2b00      	cmp	r3, #0
 8003c26:	d006      	beq.n	8003c36 <B5_Aes256_Update+0x2e>
 8003c28:	683b      	ldr	r3, [r7, #0]
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	d003      	beq.n	8003c36 <B5_Aes256_Update+0x2e>
 8003c2e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003c32:	2b00      	cmp	r3, #0
 8003c34:	dc02      	bgt.n	8003c3c <B5_Aes256_Update+0x34>
        return B5_AES256_RES_INVALID_ARGUMENT;
 8003c36:	f06f 0303 	mvn.w	r3, #3
 8003c3a:	e293      	b.n	8004164 <B5_Aes256_Update+0x55c>
    
    
    switch(ctx->mode) {
 8003c3c:	68fb      	ldr	r3, [r7, #12]
 8003c3e:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8003c42:	3b01      	subs	r3, #1
 8003c44:	2b09      	cmp	r3, #9
 8003c46:	f200 8289 	bhi.w	800415c <B5_Aes256_Update+0x554>
 8003c4a:	a201      	add	r2, pc, #4	; (adr r2, 8003c50 <B5_Aes256_Update+0x48>)
 8003c4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003c50:	08003d95 	.word	0x08003d95
 8003c54:	08003e0d 	.word	0x08003e0d
 8003c58:	08003e4f 	.word	0x08003e4f
 8003c5c:	08003e91 	.word	0x08003e91
 8003c60:	08003f4b 	.word	0x08003f4b
 8003c64:	08004019 	.word	0x08004019
 8003c68:	080040bb 	.word	0x080040bb
 8003c6c:	08003c79 	.word	0x08003c79
 8003c70:	08003d39 	.word	0x08003d39
 8003c74:	08003d67 	.word	0x08003d67
        
        
        case B5_AES256_CTR: 
        {
            for (i = 0; i < nBlk; i++) 
 8003c78:	2300      	movs	r3, #0
 8003c7a:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c7c:	e055      	b.n	8003d2a <B5_Aes256_Update+0x122>
            {
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, encData);
 8003c7e:	68f9      	ldr	r1, [r7, #12]
 8003c80:	68fb      	ldr	r3, [r7, #12]
 8003c82:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003c86:	b21a      	sxth	r2, r3
 8003c88:	68fb      	ldr	r3, [r7, #12]
 8003c8a:	f103 00f1 	add.w	r0, r3, #241	; 0xf1
 8003c8e:	687b      	ldr	r3, [r7, #4]
 8003c90:	9300      	str	r3, [sp, #0]
 8003c92:	4603      	mov	r3, r0
 8003c94:	68f8      	ldr	r0, [r7, #12]
 8003c96:	f7fc ffe3 	bl	8000c60 <B5_rijndaelEncrypt>
                for (j = 0; j < B5_AES_BLK_SIZE; j++) 
 8003c9a:	2300      	movs	r3, #0
 8003c9c:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003c9e:	e013      	b.n	8003cc8 <B5_Aes256_Update+0xc0>
                {
                    //*encData = *clrData++ ^ encData[j];
                    //*encData++;
                    /*Working*/
					*encData = *encData ^ *clrData;
 8003ca0:	687b      	ldr	r3, [r7, #4]
 8003ca2:	781a      	ldrb	r2, [r3, #0]
 8003ca4:	683b      	ldr	r3, [r7, #0]
 8003ca6:	781b      	ldrb	r3, [r3, #0]
 8003ca8:	4053      	eors	r3, r2
 8003caa:	b2da      	uxtb	r2, r3
 8003cac:	687b      	ldr	r3, [r7, #4]
 8003cae:	701a      	strb	r2, [r3, #0]
					encData++;
 8003cb0:	687b      	ldr	r3, [r7, #4]
 8003cb2:	3301      	adds	r3, #1
 8003cb4:	607b      	str	r3, [r7, #4]
					clrData++;
 8003cb6:	683b      	ldr	r3, [r7, #0]
 8003cb8:	3301      	adds	r3, #1
 8003cba:	603b      	str	r3, [r7, #0]
                for (j = 0; j < B5_AES_BLK_SIZE; j++) 
 8003cbc:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003cc0:	b29b      	uxth	r3, r3
 8003cc2:	3301      	adds	r3, #1
 8003cc4:	b29b      	uxth	r3, r3
 8003cc6:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003cc8:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003ccc:	2b0f      	cmp	r3, #15
 8003cce:	dde7      	ble.n	8003ca0 <B5_Aes256_Update+0x98>
                }
                
                j = 15;
 8003cd0:	230f      	movs	r3, #15
 8003cd2:	84bb      	strh	r3, [r7, #36]	; 0x24
                do {
                    ctx->InitVector[j]++;
 8003cd4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003cd8:	68fa      	ldr	r2, [r7, #12]
 8003cda:	441a      	add	r2, r3
 8003cdc:	f892 20f1 	ldrb.w	r2, [r2, #241]	; 0xf1
 8003ce0:	3201      	adds	r2, #1
 8003ce2:	b2d1      	uxtb	r1, r2
 8003ce4:	68fa      	ldr	r2, [r7, #12]
 8003ce6:	4413      	add	r3, r2
 8003ce8:	460a      	mov	r2, r1
 8003cea:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
                    cb = ctx->InitVector[j] == 0;
 8003cee:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003cf2:	68fa      	ldr	r2, [r7, #12]
 8003cf4:	4413      	add	r3, r2
 8003cf6:	f893 30f1 	ldrb.w	r3, [r3, #241]	; 0xf1
 8003cfa:	2b00      	cmp	r3, #0
 8003cfc:	bf0c      	ite	eq
 8003cfe:	2301      	moveq	r3, #1
 8003d00:	2300      	movne	r3, #0
 8003d02:	b2db      	uxtb	r3, r3
 8003d04:	847b      	strh	r3, [r7, #34]	; 0x22
                } while( j-- && cb ); 
 8003d06:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003d0a:	b29a      	uxth	r2, r3
 8003d0c:	3a01      	subs	r2, #1
 8003d0e:	b292      	uxth	r2, r2
 8003d10:	84ba      	strh	r2, [r7, #36]	; 0x24
 8003d12:	2b00      	cmp	r3, #0
 8003d14:	d003      	beq.n	8003d1e <B5_Aes256_Update+0x116>
 8003d16:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8003d1a:	2b00      	cmp	r3, #0
 8003d1c:	d1da      	bne.n	8003cd4 <B5_Aes256_Update+0xcc>
            for (i = 0; i < nBlk; i++) 
 8003d1e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8003d22:	b29b      	uxth	r3, r3
 8003d24:	3301      	adds	r3, #1
 8003d26:	b29b      	uxth	r3, r3
 8003d28:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003d2a:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8003d2e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003d32:	429a      	cmp	r2, r3
 8003d34:	dba3      	blt.n	8003c7e <B5_Aes256_Update+0x76>
            }
            
            break;
 8003d36:	e214      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        case B5_AES256_GCM_ENC:
        {
        	if(aes_gcm_enc(ctx, ctx->InitVector, B5_AES_IV_SIZE, clrData, nBlk*B5_AES_BLK_SIZE, assData, nAssBlk*B5_AES_BLK_SIZE, encData)==-1)
 8003d38:	68fb      	ldr	r3, [r7, #12]
 8003d3a:	f103 01f1 	add.w	r1, r3, #241	; 0xf1
 8003d3e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003d42:	011b      	lsls	r3, r3, #4
 8003d44:	461a      	mov	r2, r3
 8003d46:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8003d4a:	011b      	lsls	r3, r3, #4
 8003d4c:	4618      	mov	r0, r3
 8003d4e:	687b      	ldr	r3, [r7, #4]
 8003d50:	9303      	str	r3, [sp, #12]
 8003d52:	9002      	str	r0, [sp, #8]
 8003d54:	68bb      	ldr	r3, [r7, #8]
 8003d56:	9301      	str	r3, [sp, #4]
 8003d58:	9200      	str	r2, [sp, #0]
 8003d5a:	683b      	ldr	r3, [r7, #0]
 8003d5c:	2210      	movs	r2, #16
 8003d5e:	68f8      	ldr	r0, [r7, #12]
 8003d60:	f7ff fdf7 	bl	8003952 <aes_gcm_enc>
        		return B5_AES256_RES_INVALID_MODE;
        	break;
 8003d64:	e1fd      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        case B5_AES256_GCM_DEC:
        {
        	if( aes_gcm_dec(ctx, ctx->InitVector, B5_AES_IV_SIZE, encData, nBlk*B5_AES_BLK_SIZE, assData, nAssBlk*B5_AES_BLK_SIZE, clrData)==-1)
 8003d66:	68fb      	ldr	r3, [r7, #12]
 8003d68:	f103 01f1 	add.w	r1, r3, #241	; 0xf1
 8003d6c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003d70:	011b      	lsls	r3, r3, #4
 8003d72:	461a      	mov	r2, r3
 8003d74:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8003d78:	011b      	lsls	r3, r3, #4
 8003d7a:	4618      	mov	r0, r3
 8003d7c:	683b      	ldr	r3, [r7, #0]
 8003d7e:	9303      	str	r3, [sp, #12]
 8003d80:	9002      	str	r0, [sp, #8]
 8003d82:	68bb      	ldr	r3, [r7, #8]
 8003d84:	9301      	str	r3, [sp, #4]
 8003d86:	9200      	str	r2, [sp, #0]
 8003d88:	687b      	ldr	r3, [r7, #4]
 8003d8a:	2210      	movs	r2, #16
 8003d8c:	68f8      	ldr	r0, [r7, #12]
 8003d8e:	f7ff fdfe 	bl	800398e <aes_gcm_dec>
        		return B5_AES256_RES_INVALID_MODE;
        	//gmac(ctx,ctx->InitVector,16,clrData,B5_AES_BLK_SIZE,encData);
            break;
 8003d92:	e1e6      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        case B5_AES256_OFB: 
        {
            for (i = 0; i < nBlk; i++) 
 8003d94:	2300      	movs	r3, #0
 8003d96:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003d98:	e031      	b.n	8003dfe <B5_Aes256_Update+0x1f6>
            {
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, ctx->InitVector);
 8003d9a:	68f9      	ldr	r1, [r7, #12]
 8003d9c:	68fb      	ldr	r3, [r7, #12]
 8003d9e:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003da2:	b21a      	sxth	r2, r3
 8003da4:	68fb      	ldr	r3, [r7, #12]
 8003da6:	f103 00f1 	add.w	r0, r3, #241	; 0xf1
 8003daa:	68fb      	ldr	r3, [r7, #12]
 8003dac:	33f1      	adds	r3, #241	; 0xf1
 8003dae:	9300      	str	r3, [sp, #0]
 8003db0:	4603      	mov	r3, r0
 8003db2:	68f8      	ldr	r0, [r7, #12]
 8003db4:	f7fc ff54 	bl	8000c60 <B5_rijndaelEncrypt>
                for (j = 0; j < 16; j++) 
 8003db8:	2300      	movs	r3, #0
 8003dba:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003dbc:	e015      	b.n	8003dea <B5_Aes256_Update+0x1e2>
                {
                    *encData++ = *clrData++ ^ ctx->InitVector[j];
 8003dbe:	683b      	ldr	r3, [r7, #0]
 8003dc0:	1c5a      	adds	r2, r3, #1
 8003dc2:	603a      	str	r2, [r7, #0]
 8003dc4:	7819      	ldrb	r1, [r3, #0]
 8003dc6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003dca:	68fa      	ldr	r2, [r7, #12]
 8003dcc:	4413      	add	r3, r2
 8003dce:	f893 20f1 	ldrb.w	r2, [r3, #241]	; 0xf1
 8003dd2:	687b      	ldr	r3, [r7, #4]
 8003dd4:	1c58      	adds	r0, r3, #1
 8003dd6:	6078      	str	r0, [r7, #4]
 8003dd8:	404a      	eors	r2, r1
 8003dda:	b2d2      	uxtb	r2, r2
 8003ddc:	701a      	strb	r2, [r3, #0]
                for (j = 0; j < 16; j++) 
 8003dde:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003de2:	b29b      	uxth	r3, r3
 8003de4:	3301      	adds	r3, #1
 8003de6:	b29b      	uxth	r3, r3
 8003de8:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003dea:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003dee:	2b0f      	cmp	r3, #15
 8003df0:	dde5      	ble.n	8003dbe <B5_Aes256_Update+0x1b6>
            for (i = 0; i < nBlk; i++) 
 8003df2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8003df6:	b29b      	uxth	r3, r3
 8003df8:	3301      	adds	r3, #1
 8003dfa:	b29b      	uxth	r3, r3
 8003dfc:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003dfe:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8003e02:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003e06:	429a      	cmp	r2, r3
 8003e08:	dbc7      	blt.n	8003d9a <B5_Aes256_Update+0x192>
                }
            }
            
            break;
 8003e0a:	e1aa      	b.n	8004162 <B5_Aes256_Update+0x55a>
        
        
        
        case B5_AES256_ECB_ENC:
        {
            for (i = 0; i < nBlk; i++) 
 8003e0c:	2300      	movs	r3, #0
 8003e0e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003e10:	e016      	b.n	8003e40 <B5_Aes256_Update+0x238>
            {
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, clrData, encData);
 8003e12:	68f9      	ldr	r1, [r7, #12]
 8003e14:	68fb      	ldr	r3, [r7, #12]
 8003e16:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003e1a:	b21a      	sxth	r2, r3
 8003e1c:	687b      	ldr	r3, [r7, #4]
 8003e1e:	9300      	str	r3, [sp, #0]
 8003e20:	683b      	ldr	r3, [r7, #0]
 8003e22:	68f8      	ldr	r0, [r7, #12]
 8003e24:	f7fc ff1c 	bl	8000c60 <B5_rijndaelEncrypt>
                clrData += 16;
 8003e28:	683b      	ldr	r3, [r7, #0]
 8003e2a:	3310      	adds	r3, #16
 8003e2c:	603b      	str	r3, [r7, #0]
                encData += 16;
 8003e2e:	687b      	ldr	r3, [r7, #4]
 8003e30:	3310      	adds	r3, #16
 8003e32:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 8003e34:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8003e38:	b29b      	uxth	r3, r3
 8003e3a:	3301      	adds	r3, #1
 8003e3c:	b29b      	uxth	r3, r3
 8003e3e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003e40:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8003e44:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003e48:	429a      	cmp	r2, r3
 8003e4a:	dbe2      	blt.n	8003e12 <B5_Aes256_Update+0x20a>
            }
            
            break;
 8003e4c:	e189      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        
        case B5_AES256_ECB_DEC:
        {
            for (i = 0; i < nBlk; i++) 
 8003e4e:	2300      	movs	r3, #0
 8003e50:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003e52:	e016      	b.n	8003e82 <B5_Aes256_Update+0x27a>
            {
                B5_rijndaelDecrypt(ctx, ctx->rk, ctx->Nr, encData, clrData);
 8003e54:	68f9      	ldr	r1, [r7, #12]
 8003e56:	68fb      	ldr	r3, [r7, #12]
 8003e58:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003e5c:	b21a      	sxth	r2, r3
 8003e5e:	683b      	ldr	r3, [r7, #0]
 8003e60:	9300      	str	r3, [sp, #0]
 8003e62:	687b      	ldr	r3, [r7, #4]
 8003e64:	68f8      	ldr	r0, [r7, #12]
 8003e66:	f7fe f8a2 	bl	8001fae <B5_rijndaelDecrypt>
                clrData += 16;
 8003e6a:	683b      	ldr	r3, [r7, #0]
 8003e6c:	3310      	adds	r3, #16
 8003e6e:	603b      	str	r3, [r7, #0]
                encData += 16;
 8003e70:	687b      	ldr	r3, [r7, #4]
 8003e72:	3310      	adds	r3, #16
 8003e74:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 8003e76:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8003e7a:	b29b      	uxth	r3, r3
 8003e7c:	3301      	adds	r3, #1
 8003e7e:	b29b      	uxth	r3, r3
 8003e80:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003e82:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8003e86:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003e8a:	429a      	cmp	r2, r3
 8003e8c:	dbe2      	blt.n	8003e54 <B5_Aes256_Update+0x24c>
            }
            
            break;
 8003e8e:	e168      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        
        case B5_AES256_CBC_ENC:
        {
            for (i = 0; i < nBlk; i++) 
 8003e90:	2300      	movs	r3, #0
 8003e92:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003e94:	e052      	b.n	8003f3c <B5_Aes256_Update+0x334>
            {
                for (j = 0; j < 16; j++) 
 8003e96:	2300      	movs	r3, #0
 8003e98:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003e9a:	e019      	b.n	8003ed0 <B5_Aes256_Update+0x2c8>
                {
                    tmp[j] = clrData[j] ^ ctx->InitVector[j];
 8003e9c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003ea0:	683a      	ldr	r2, [r7, #0]
 8003ea2:	4413      	add	r3, r2
 8003ea4:	7819      	ldrb	r1, [r3, #0]
 8003ea6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003eaa:	68fa      	ldr	r2, [r7, #12]
 8003eac:	4413      	add	r3, r2
 8003eae:	f893 20f1 	ldrb.w	r2, [r3, #241]	; 0xf1
 8003eb2:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003eb6:	404a      	eors	r2, r1
 8003eb8:	b2d2      	uxtb	r2, r2
 8003eba:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8003ebe:	440b      	add	r3, r1
 8003ec0:	f803 2c18 	strb.w	r2, [r3, #-24]
                for (j = 0; j < 16; j++) 
 8003ec4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003ec8:	b29b      	uxth	r3, r3
 8003eca:	3301      	adds	r3, #1
 8003ecc:	b29b      	uxth	r3, r3
 8003ece:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003ed0:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003ed4:	2b0f      	cmp	r3, #15
 8003ed6:	dde1      	ble.n	8003e9c <B5_Aes256_Update+0x294>
                }      
                
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, tmp, encData);
 8003ed8:	68f9      	ldr	r1, [r7, #12]
 8003eda:	68fb      	ldr	r3, [r7, #12]
 8003edc:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003ee0:	b21a      	sxth	r2, r3
 8003ee2:	f107 0010 	add.w	r0, r7, #16
 8003ee6:	687b      	ldr	r3, [r7, #4]
 8003ee8:	9300      	str	r3, [sp, #0]
 8003eea:	4603      	mov	r3, r0
 8003eec:	68f8      	ldr	r0, [r7, #12]
 8003eee:	f7fc feb7 	bl	8000c60 <B5_rijndaelEncrypt>
                for (j = 0; j < 16; j++) 
 8003ef2:	2300      	movs	r3, #0
 8003ef4:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003ef6:	e011      	b.n	8003f1c <B5_Aes256_Update+0x314>
                {
                    ctx->InitVector[j] = encData[j];
 8003ef8:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003efc:	687a      	ldr	r2, [r7, #4]
 8003efe:	441a      	add	r2, r3
 8003f00:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f04:	7811      	ldrb	r1, [r2, #0]
 8003f06:	68fa      	ldr	r2, [r7, #12]
 8003f08:	4413      	add	r3, r2
 8003f0a:	460a      	mov	r2, r1
 8003f0c:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
                for (j = 0; j < 16; j++) 
 8003f10:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f14:	b29b      	uxth	r3, r3
 8003f16:	3301      	adds	r3, #1
 8003f18:	b29b      	uxth	r3, r3
 8003f1a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003f1c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f20:	2b0f      	cmp	r3, #15
 8003f22:	dde9      	ble.n	8003ef8 <B5_Aes256_Update+0x2f0>
                }
                
                clrData += 16;
 8003f24:	683b      	ldr	r3, [r7, #0]
 8003f26:	3310      	adds	r3, #16
 8003f28:	603b      	str	r3, [r7, #0]
                encData += 16;
 8003f2a:	687b      	ldr	r3, [r7, #4]
 8003f2c:	3310      	adds	r3, #16
 8003f2e:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 8003f30:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8003f34:	b29b      	uxth	r3, r3
 8003f36:	3301      	adds	r3, #1
 8003f38:	b29b      	uxth	r3, r3
 8003f3a:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003f3c:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8003f40:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8003f44:	429a      	cmp	r2, r3
 8003f46:	dba6      	blt.n	8003e96 <B5_Aes256_Update+0x28e>
            }
            
            break;
 8003f48:	e10b      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        
        case B5_AES256_CBC_DEC:
        {
            for (i = 0; i < nBlk; i++) 
 8003f4a:	2300      	movs	r3, #0
 8003f4c:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003f4e:	e05c      	b.n	800400a <B5_Aes256_Update+0x402>
            {
                for (j = 0; j < 16; j++) 
 8003f50:	2300      	movs	r3, #0
 8003f52:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003f54:	e011      	b.n	8003f7a <B5_Aes256_Update+0x372>
                {
                    tmp[j] = encData[j];
 8003f56:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f5a:	687a      	ldr	r2, [r7, #4]
 8003f5c:	441a      	add	r2, r3
 8003f5e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f62:	7812      	ldrb	r2, [r2, #0]
 8003f64:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8003f68:	440b      	add	r3, r1
 8003f6a:	f803 2c18 	strb.w	r2, [r3, #-24]
                for (j = 0; j < 16; j++) 
 8003f6e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f72:	b29b      	uxth	r3, r3
 8003f74:	3301      	adds	r3, #1
 8003f76:	b29b      	uxth	r3, r3
 8003f78:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003f7a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003f7e:	2b0f      	cmp	r3, #15
 8003f80:	dde9      	ble.n	8003f56 <B5_Aes256_Update+0x34e>
                }
                
                B5_rijndaelDecrypt(ctx, ctx->rk, ctx->Nr, encData, clrData);
 8003f82:	68f9      	ldr	r1, [r7, #12]
 8003f84:	68fb      	ldr	r3, [r7, #12]
 8003f86:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8003f8a:	b21a      	sxth	r2, r3
 8003f8c:	683b      	ldr	r3, [r7, #0]
 8003f8e:	9300      	str	r3, [sp, #0]
 8003f90:	687b      	ldr	r3, [r7, #4]
 8003f92:	68f8      	ldr	r0, [r7, #12]
 8003f94:	f7fe f80b 	bl	8001fae <B5_rijndaelDecrypt>
                for (j = 0; j < 16; j++) 
 8003f98:	2300      	movs	r3, #0
 8003f9a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003f9c:	e025      	b.n	8003fea <B5_Aes256_Update+0x3e2>
                {
                    clrData[j] ^= ctx->InitVector[j];
 8003f9e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fa2:	683a      	ldr	r2, [r7, #0]
 8003fa4:	4413      	add	r3, r2
 8003fa6:	7819      	ldrb	r1, [r3, #0]
 8003fa8:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fac:	68fa      	ldr	r2, [r7, #12]
 8003fae:	4413      	add	r3, r2
 8003fb0:	f893 20f1 	ldrb.w	r2, [r3, #241]	; 0xf1
 8003fb4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fb8:	6838      	ldr	r0, [r7, #0]
 8003fba:	4403      	add	r3, r0
 8003fbc:	404a      	eors	r2, r1
 8003fbe:	b2d2      	uxtb	r2, r2
 8003fc0:	701a      	strb	r2, [r3, #0]
                    ctx->InitVector[j] = tmp[j];
 8003fc2:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8003fc6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fca:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8003fce:	440a      	add	r2, r1
 8003fd0:	f812 1c18 	ldrb.w	r1, [r2, #-24]
 8003fd4:	68fa      	ldr	r2, [r7, #12]
 8003fd6:	4413      	add	r3, r2
 8003fd8:	460a      	mov	r2, r1
 8003fda:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
                for (j = 0; j < 16; j++) 
 8003fde:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fe2:	b29b      	uxth	r3, r3
 8003fe4:	3301      	adds	r3, #1
 8003fe6:	b29b      	uxth	r3, r3
 8003fe8:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003fea:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8003fee:	2b0f      	cmp	r3, #15
 8003ff0:	ddd5      	ble.n	8003f9e <B5_Aes256_Update+0x396>
                }            
                
                clrData += 16;
 8003ff2:	683b      	ldr	r3, [r7, #0]
 8003ff4:	3310      	adds	r3, #16
 8003ff6:	603b      	str	r3, [r7, #0]
                encData += 16;
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	3310      	adds	r3, #16
 8003ffc:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 8003ffe:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004002:	b29b      	uxth	r3, r3
 8004004:	3301      	adds	r3, #1
 8004006:	b29b      	uxth	r3, r3
 8004008:	84fb      	strh	r3, [r7, #38]	; 0x26
 800400a:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 800400e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8004012:	429a      	cmp	r2, r3
 8004014:	db9c      	blt.n	8003f50 <B5_Aes256_Update+0x348>
            }
            
            break;
 8004016:	e0a4      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        
        case B5_AES256_CFB_ENC:
        {
            for (i = 0; i < nBlk; i++) 
 8004018:	2300      	movs	r3, #0
 800401a:	84fb      	strh	r3, [r7, #38]	; 0x26
 800401c:	e046      	b.n	80040ac <B5_Aes256_Update+0x4a4>
            {
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, tmp);             
 800401e:	68f9      	ldr	r1, [r7, #12]
 8004020:	68fb      	ldr	r3, [r7, #12]
 8004022:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 8004026:	b21a      	sxth	r2, r3
 8004028:	68fb      	ldr	r3, [r7, #12]
 800402a:	f103 00f1 	add.w	r0, r3, #241	; 0xf1
 800402e:	f107 0310 	add.w	r3, r7, #16
 8004032:	9300      	str	r3, [sp, #0]
 8004034:	4603      	mov	r3, r0
 8004036:	68f8      	ldr	r0, [r7, #12]
 8004038:	f7fc fe12 	bl	8000c60 <B5_rijndaelEncrypt>
                for (j = 0; j < 16; j++) 
 800403c:	2300      	movs	r3, #0
 800403e:	84bb      	strh	r3, [r7, #36]	; 0x24
 8004040:	e024      	b.n	800408c <B5_Aes256_Update+0x484>
                {
                    encData[j] = clrData[j] ^ tmp[j];
 8004042:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004046:	683a      	ldr	r2, [r7, #0]
 8004048:	4413      	add	r3, r2
 800404a:	7819      	ldrb	r1, [r3, #0]
 800404c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004050:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8004054:	4413      	add	r3, r2
 8004056:	f813 2c18 	ldrb.w	r2, [r3, #-24]
 800405a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800405e:	6878      	ldr	r0, [r7, #4]
 8004060:	4403      	add	r3, r0
 8004062:	404a      	eors	r2, r1
 8004064:	b2d2      	uxtb	r2, r2
 8004066:	701a      	strb	r2, [r3, #0]
                    ctx->InitVector[j] = encData[j]; 
 8004068:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800406c:	687a      	ldr	r2, [r7, #4]
 800406e:	441a      	add	r2, r3
 8004070:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004074:	7811      	ldrb	r1, [r2, #0]
 8004076:	68fa      	ldr	r2, [r7, #12]
 8004078:	4413      	add	r3, r2
 800407a:	460a      	mov	r2, r1
 800407c:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
                for (j = 0; j < 16; j++) 
 8004080:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004084:	b29b      	uxth	r3, r3
 8004086:	3301      	adds	r3, #1
 8004088:	b29b      	uxth	r3, r3
 800408a:	84bb      	strh	r3, [r7, #36]	; 0x24
 800408c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004090:	2b0f      	cmp	r3, #15
 8004092:	ddd6      	ble.n	8004042 <B5_Aes256_Update+0x43a>
                }      
                
                
                clrData += 16;
 8004094:	683b      	ldr	r3, [r7, #0]
 8004096:	3310      	adds	r3, #16
 8004098:	603b      	str	r3, [r7, #0]
                encData += 16;
 800409a:	687b      	ldr	r3, [r7, #4]
 800409c:	3310      	adds	r3, #16
 800409e:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 80040a0:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80040a4:	b29b      	uxth	r3, r3
 80040a6:	3301      	adds	r3, #1
 80040a8:	b29b      	uxth	r3, r3
 80040aa:	84fb      	strh	r3, [r7, #38]	; 0x26
 80040ac:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 80040b0:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80040b4:	429a      	cmp	r2, r3
 80040b6:	dbb2      	blt.n	800401e <B5_Aes256_Update+0x416>
            }
            
            break;
 80040b8:	e053      	b.n	8004162 <B5_Aes256_Update+0x55a>
        }
        
        
        case B5_AES256_CFB_DEC:
        {
            for (i = 0; i < nBlk; i++) 
 80040ba:	2300      	movs	r3, #0
 80040bc:	84fb      	strh	r3, [r7, #38]	; 0x26
 80040be:	e046      	b.n	800414e <B5_Aes256_Update+0x546>
            {
                B5_rijndaelEncrypt(ctx, ctx->rk, ctx->Nr, ctx->InitVector, tmp);
 80040c0:	68f9      	ldr	r1, [r7, #12]
 80040c2:	68fb      	ldr	r3, [r7, #12]
 80040c4:	f893 30f0 	ldrb.w	r3, [r3, #240]	; 0xf0
 80040c8:	b21a      	sxth	r2, r3
 80040ca:	68fb      	ldr	r3, [r7, #12]
 80040cc:	f103 00f1 	add.w	r0, r3, #241	; 0xf1
 80040d0:	f107 0310 	add.w	r3, r7, #16
 80040d4:	9300      	str	r3, [sp, #0]
 80040d6:	4603      	mov	r3, r0
 80040d8:	68f8      	ldr	r0, [r7, #12]
 80040da:	f7fc fdc1 	bl	8000c60 <B5_rijndaelEncrypt>
                for (j = 0; j < 16; j++) 
 80040de:	2300      	movs	r3, #0
 80040e0:	84bb      	strh	r3, [r7, #36]	; 0x24
 80040e2:	e024      	b.n	800412e <B5_Aes256_Update+0x526>
                {
                    ctx->InitVector[j] = encData[j];
 80040e4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 80040e8:	687a      	ldr	r2, [r7, #4]
 80040ea:	441a      	add	r2, r3
 80040ec:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 80040f0:	7811      	ldrb	r1, [r2, #0]
 80040f2:	68fa      	ldr	r2, [r7, #12]
 80040f4:	4413      	add	r3, r2
 80040f6:	460a      	mov	r2, r1
 80040f8:	f883 20f1 	strb.w	r2, [r3, #241]	; 0xf1
                    clrData[j] = encData[j] ^ tmp[j];
 80040fc:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004100:	687a      	ldr	r2, [r7, #4]
 8004102:	4413      	add	r3, r2
 8004104:	7819      	ldrb	r1, [r3, #0]
 8004106:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800410a:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800410e:	4413      	add	r3, r2
 8004110:	f813 2c18 	ldrb.w	r2, [r3, #-24]
 8004114:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004118:	6838      	ldr	r0, [r7, #0]
 800411a:	4403      	add	r3, r0
 800411c:	404a      	eors	r2, r1
 800411e:	b2d2      	uxtb	r2, r2
 8004120:	701a      	strb	r2, [r3, #0]
                for (j = 0; j < 16; j++) 
 8004122:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004126:	b29b      	uxth	r3, r3
 8004128:	3301      	adds	r3, #1
 800412a:	b29b      	uxth	r3, r3
 800412c:	84bb      	strh	r3, [r7, #36]	; 0x24
 800412e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8004132:	2b0f      	cmp	r3, #15
 8004134:	ddd6      	ble.n	80040e4 <B5_Aes256_Update+0x4dc>
                }            
                
                clrData += 16;
 8004136:	683b      	ldr	r3, [r7, #0]
 8004138:	3310      	adds	r3, #16
 800413a:	603b      	str	r3, [r7, #0]
                encData += 16;
 800413c:	687b      	ldr	r3, [r7, #4]
 800413e:	3310      	adds	r3, #16
 8004140:	607b      	str	r3, [r7, #4]
            for (i = 0; i < nBlk; i++) 
 8004142:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8004146:	b29b      	uxth	r3, r3
 8004148:	3301      	adds	r3, #1
 800414a:	b29b      	uxth	r3, r3
 800414c:	84fb      	strh	r3, [r7, #38]	; 0x26
 800414e:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8004152:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8004156:	429a      	cmp	r2, r3
 8004158:	dbb2      	blt.n	80040c0 <B5_Aes256_Update+0x4b8>
            }
            
            break;
 800415a:	e002      	b.n	8004162 <B5_Aes256_Update+0x55a>
        
        
        default:
        {
            
            return B5_AES256_RES_INVALID_MODE;
 800415c:	f06f 0304 	mvn.w	r3, #4
 8004160:	e000      	b.n	8004164 <B5_Aes256_Update+0x55c>
        }
        
    }
    
    
    return B5_AES256_RES_OK;
 8004162:	2300      	movs	r3, #0
}
 8004164:	4618      	mov	r0, r3
 8004166:	3728      	adds	r7, #40	; 0x28
 8004168:	46bd      	mov	sp, r7
 800416a:	bd80      	pop	{r7, pc}

0800416c <B5_Aes256_Finit>:




int32_t B5_Aes256_Finit (B5_tAesCtx    *ctx)
{
 800416c:	b480      	push	{r7}
 800416e:	b083      	sub	sp, #12
 8004170:	af00      	add	r7, sp, #0
 8004172:	6078      	str	r0, [r7, #4]
    return B5_AES256_RES_OK;
 8004174:	2300      	movs	r3, #0
}
 8004176:	4618      	mov	r0, r3
 8004178:	370c      	adds	r7, #12
 800417a:	46bd      	mov	sp, r7
 800417c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004180:	4770      	bx	lr

08004182 <xor_bb>:
#include "pbkdf2.h"

/** out = x ^ y.
*  out, x and y may alias. */
static  void xor_bb(uint8_t *out, const uint8_t *x, const uint8_t *y, size_t len)
{
 8004182:	b480      	push	{r7}
 8004184:	b087      	sub	sp, #28
 8004186:	af00      	add	r7, sp, #0
 8004188:	60f8      	str	r0, [r7, #12]
 800418a:	60b9      	str	r1, [r7, #8]
 800418c:	607a      	str	r2, [r7, #4]
 800418e:	603b      	str	r3, [r7, #0]
	size_t i;
	for (i = 0; i < len; i++)
 8004190:	2300      	movs	r3, #0
 8004192:	617b      	str	r3, [r7, #20]
 8004194:	e010      	b.n	80041b8 <xor_bb+0x36>
		out[i] = x[i] ^ y[i];
 8004196:	68ba      	ldr	r2, [r7, #8]
 8004198:	697b      	ldr	r3, [r7, #20]
 800419a:	4413      	add	r3, r2
 800419c:	7819      	ldrb	r1, [r3, #0]
 800419e:	687a      	ldr	r2, [r7, #4]
 80041a0:	697b      	ldr	r3, [r7, #20]
 80041a2:	4413      	add	r3, r2
 80041a4:	781a      	ldrb	r2, [r3, #0]
 80041a6:	68f8      	ldr	r0, [r7, #12]
 80041a8:	697b      	ldr	r3, [r7, #20]
 80041aa:	4403      	add	r3, r0
 80041ac:	404a      	eors	r2, r1
 80041ae:	b2d2      	uxtb	r2, r2
 80041b0:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < len; i++)
 80041b2:	697b      	ldr	r3, [r7, #20]
 80041b4:	3301      	adds	r3, #1
 80041b6:	617b      	str	r3, [r7, #20]
 80041b8:	697a      	ldr	r2, [r7, #20]
 80041ba:	683b      	ldr	r3, [r7, #0]
 80041bc:	429a      	cmp	r2, r3
 80041be:	d3ea      	bcc.n	8004196 <xor_bb+0x14>
}
 80041c0:	bf00      	nop
 80041c2:	371c      	adds	r7, #28
 80041c4:	46bd      	mov	sp, r7
 80041c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041ca:	4770      	bx	lr

080041cc <F>:
static void F(const B5_tHmacSha256Ctx *startctx,
	uint32_t counter,
	const uint8_t *salt, size_t nsalt,
	uint32_t iterations,
	uint8_t *out)
{
 80041cc:	b5b0      	push	{r4, r5, r7, lr}
 80041ce:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
 80041d2:	af00      	add	r7, sp, #0
 80041d4:	f107 040c 	add.w	r4, r7, #12
 80041d8:	6020      	str	r0, [r4, #0]
 80041da:	f107 0008 	add.w	r0, r7, #8
 80041de:	6001      	str	r1, [r0, #0]
 80041e0:	1d39      	adds	r1, r7, #4
 80041e2:	600a      	str	r2, [r1, #0]
 80041e4:	463a      	mov	r2, r7
 80041e6:	6013      	str	r3, [r2, #0]
	uint8_t U[B5_SHA256_DIGEST_SIZE];
	B5_tHmacSha256Ctx ctx = *startctx;
 80041e8:	f107 0214 	add.w	r2, r7, #20
 80041ec:	f107 030c 	add.w	r3, r7, #12
 80041f0:	681b      	ldr	r3, [r3, #0]
 80041f2:	4610      	mov	r0, r2
 80041f4:	4619      	mov	r1, r3
 80041f6:	f44f 73f4 	mov.w	r3, #488	; 0x1e8
 80041fa:	461a      	mov	r2, r3
 80041fc:	f016 fed3 	bl	801afa6 <memcpy>
	uint8_t countbuf[4];
	uint32_t i;
	countbuf[0] = ((counter >> 3 * 8) & 0xFF);
 8004200:	f107 0308 	add.w	r3, r7, #8
 8004204:	681b      	ldr	r3, [r3, #0]
 8004206:	0e1b      	lsrs	r3, r3, #24
 8004208:	b2da      	uxtb	r2, r3
 800420a:	f107 0310 	add.w	r3, r7, #16
 800420e:	701a      	strb	r2, [r3, #0]
	countbuf[1] = ((counter >> 2 * 8) & 0xFF);
 8004210:	f107 0308 	add.w	r3, r7, #8
 8004214:	681b      	ldr	r3, [r3, #0]
 8004216:	0c1b      	lsrs	r3, r3, #16
 8004218:	b2da      	uxtb	r2, r3
 800421a:	f107 0310 	add.w	r3, r7, #16
 800421e:	705a      	strb	r2, [r3, #1]
	countbuf[2] = ((counter >> 1 * 8) & 0xFF);
 8004220:	f107 0308 	add.w	r3, r7, #8
 8004224:	681b      	ldr	r3, [r3, #0]
 8004226:	0a1b      	lsrs	r3, r3, #8
 8004228:	b2da      	uxtb	r2, r3
 800422a:	f107 0310 	add.w	r3, r7, #16
 800422e:	709a      	strb	r2, [r3, #2]
	countbuf[3] = (counter & 0xFF);
 8004230:	f107 0308 	add.w	r3, r7, #8
 8004234:	681b      	ldr	r3, [r3, #0]
 8004236:	b2da      	uxtb	r2, r3
 8004238:	f107 0310 	add.w	r3, r7, #16
 800423c:	70da      	strb	r2, [r3, #3]

	/* First iteration:
	*   U_1 = PRF(P, S || INT_32_BE(i))
	*/
	
	B5_HmacSha256_Update(&ctx, salt, nsalt);
 800423e:	463b      	mov	r3, r7
 8004240:	681a      	ldr	r2, [r3, #0]
 8004242:	1d3b      	adds	r3, r7, #4
 8004244:	f107 0014 	add.w	r0, r7, #20
 8004248:	6819      	ldr	r1, [r3, #0]
 800424a:	f002 fbe5 	bl	8006a18 <B5_HmacSha256_Update>
	B5_HmacSha256_Update(&ctx, countbuf, sizeof(countbuf));
 800424e:	f107 0110 	add.w	r1, r7, #16
 8004252:	f107 0314 	add.w	r3, r7, #20
 8004256:	2204      	movs	r2, #4
 8004258:	4618      	mov	r0, r3
 800425a:	f002 fbdd 	bl	8006a18 <B5_HmacSha256_Update>
	B5_HmacSha256_Finit(&ctx, U);
 800425e:	f507 72fe 	add.w	r2, r7, #508	; 0x1fc
 8004262:	f107 0314 	add.w	r3, r7, #20
 8004266:	4611      	mov	r1, r2
 8004268:	4618      	mov	r0, r3
 800426a:	f002 fbfa 	bl	8006a62 <B5_HmacSha256_Finit>
	memcpy(out, U, B5_SHA256_DIGEST_SIZE);
 800426e:	f8d7 3234 	ldr.w	r3, [r7, #564]	; 0x234
 8004272:	461d      	mov	r5, r3
 8004274:	f507 74fe 	add.w	r4, r7, #508	; 0x1fc
 8004278:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800427a:	6028      	str	r0, [r5, #0]
 800427c:	6069      	str	r1, [r5, #4]
 800427e:	60aa      	str	r2, [r5, #8]
 8004280:	60eb      	str	r3, [r5, #12]
 8004282:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8004284:	6128      	str	r0, [r5, #16]
 8004286:	6169      	str	r1, [r5, #20]
 8004288:	61aa      	str	r2, [r5, #24]
 800428a:	61eb      	str	r3, [r5, #28]

	/* Subsequent iterations:
	*   U_c = PRF(P, U_{c-1})
	*/
	for (i = 1; i < iterations; i++)
 800428c:	2301      	movs	r3, #1
 800428e:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
 8004292:	e029      	b.n	80042e8 <F+0x11c>
	{
		ctx = *startctx;
 8004294:	f107 0214 	add.w	r2, r7, #20
 8004298:	f107 030c 	add.w	r3, r7, #12
 800429c:	681b      	ldr	r3, [r3, #0]
 800429e:	4610      	mov	r0, r2
 80042a0:	4619      	mov	r1, r3
 80042a2:	f44f 73f4 	mov.w	r3, #488	; 0x1e8
 80042a6:	461a      	mov	r2, r3
 80042a8:	f016 fe7d 	bl	801afa6 <memcpy>
		B5_HmacSha256_Update(&ctx, U, B5_SHA256_DIGEST_SIZE);
 80042ac:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
 80042b0:	f107 0314 	add.w	r3, r7, #20
 80042b4:	2220      	movs	r2, #32
 80042b6:	4618      	mov	r0, r3
 80042b8:	f002 fbae 	bl	8006a18 <B5_HmacSha256_Update>
		B5_HmacSha256_Finit(&ctx, U);
 80042bc:	f507 72fe 	add.w	r2, r7, #508	; 0x1fc
 80042c0:	f107 0314 	add.w	r3, r7, #20
 80042c4:	4611      	mov	r1, r2
 80042c6:	4618      	mov	r0, r3
 80042c8:	f002 fbcb 	bl	8006a62 <B5_HmacSha256_Finit>
		xor_bb(out, out, U, B5_SHA256_DIGEST_SIZE);
 80042cc:	f507 72fe 	add.w	r2, r7, #508	; 0x1fc
 80042d0:	2320      	movs	r3, #32
 80042d2:	f8d7 1234 	ldr.w	r1, [r7, #564]	; 0x234
 80042d6:	f8d7 0234 	ldr.w	r0, [r7, #564]	; 0x234
 80042da:	f7ff ff52 	bl	8004182 <xor_bb>
	for (i = 1; i < iterations; i++)
 80042de:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 80042e2:	3301      	adds	r3, #1
 80042e4:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
 80042e8:	f8d7 221c 	ldr.w	r2, [r7, #540]	; 0x21c
 80042ec:	f8d7 3230 	ldr.w	r3, [r7, #560]	; 0x230
 80042f0:	429a      	cmp	r2, r3
 80042f2:	d3cf      	bcc.n	8004294 <F+0xc8>
	}
}
 80042f4:	bf00      	nop
 80042f6:	f507 7708 	add.w	r7, r7, #544	; 0x220
 80042fa:	46bd      	mov	sp, r7
 80042fc:	bdb0      	pop	{r4, r5, r7, pc}

080042fe <PBKDF2HmacSha256>:
void PBKDF2HmacSha256(
	const uint8_t *pw, size_t npw,
	const uint8_t *salt, size_t nsalt,
	uint32_t iterations,
	uint8_t *out, size_t nout)
{
 80042fe:	b590      	push	{r4, r7, lr}
 8004300:	f5ad 7d0b 	sub.w	sp, sp, #556	; 0x22c
 8004304:	af02      	add	r7, sp, #8
 8004306:	f107 040c 	add.w	r4, r7, #12
 800430a:	6020      	str	r0, [r4, #0]
 800430c:	f107 0008 	add.w	r0, r7, #8
 8004310:	6001      	str	r1, [r0, #0]
 8004312:	1d39      	adds	r1, r7, #4
 8004314:	600a      	str	r2, [r1, #0]
 8004316:	463a      	mov	r2, r7
 8004318:	6013      	str	r3, [r2, #0]
	uint32_t counter = 1;
 800431a:	2301      	movs	r3, #1
 800431c:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
	uint8_t block[B5_SHA256_DIGEST_SIZE];
	size_t taken;

	/* Starting point for inner loop. */
	B5_tHmacSha256Ctx ctx;
	B5_HmacSha256_Init(&ctx, pw, (int16_t)npw);
 8004320:	f107 0308 	add.w	r3, r7, #8
 8004324:	681b      	ldr	r3, [r3, #0]
 8004326:	b21a      	sxth	r2, r3
 8004328:	f107 030c 	add.w	r3, r7, #12
 800432c:	f107 0010 	add.w	r0, r7, #16
 8004330:	6819      	ldr	r1, [r3, #0]
 8004332:	f002 faeb 	bl	800690c <B5_HmacSha256_Init>

	while(nout)
 8004336:	e032      	b.n	800439e <PBKDF2HmacSha256+0xa0>
	{
		F(&ctx, counter, salt, nsalt, iterations, block);
 8004338:	463b      	mov	r3, r7
 800433a:	1d3a      	adds	r2, r7, #4
 800433c:	f107 0010 	add.w	r0, r7, #16
 8004340:	f507 71fc 	add.w	r1, r7, #504	; 0x1f8
 8004344:	9101      	str	r1, [sp, #4]
 8004346:	f8d7 1230 	ldr.w	r1, [r7, #560]	; 0x230
 800434a:	9100      	str	r1, [sp, #0]
 800434c:	681b      	ldr	r3, [r3, #0]
 800434e:	6812      	ldr	r2, [r2, #0]
 8004350:	f8d7 121c 	ldr.w	r1, [r7, #540]	; 0x21c
 8004354:	f7ff ff3a 	bl	80041cc <F>
		taken = (nout < B5_SHA256_DIGEST_SIZE)?(nout):(B5_SHA256_DIGEST_SIZE);
 8004358:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 800435c:	2b20      	cmp	r3, #32
 800435e:	bf28      	it	cs
 8004360:	2320      	movcs	r3, #32
 8004362:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
		memcpy(out, block, taken);
 8004366:	f507 73fc 	add.w	r3, r7, #504	; 0x1f8
 800436a:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 800436e:	4619      	mov	r1, r3
 8004370:	f8d7 0234 	ldr.w	r0, [r7, #564]	; 0x234
 8004374:	f016 fe17 	bl	801afa6 <memcpy>
		out += taken;
 8004378:	f8d7 2234 	ldr.w	r2, [r7, #564]	; 0x234
 800437c:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 8004380:	4413      	add	r3, r2
 8004382:	f8c7 3234 	str.w	r3, [r7, #564]	; 0x234
		nout -= taken;
 8004386:	f8d7 2238 	ldr.w	r2, [r7, #568]	; 0x238
 800438a:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 800438e:	1ad3      	subs	r3, r2, r3
 8004390:	f8c7 3238 	str.w	r3, [r7, #568]	; 0x238
		counter++;
 8004394:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 8004398:	3301      	adds	r3, #1
 800439a:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
	while(nout)
 800439e:	f8d7 3238 	ldr.w	r3, [r7, #568]	; 0x238
 80043a2:	2b00      	cmp	r3, #0
 80043a4:	d1c8      	bne.n	8004338 <PBKDF2HmacSha256+0x3a>
	}
 80043a6:	bf00      	nop
 80043a8:	f507 7709 	add.w	r7, r7, #548	; 0x224
 80043ac:	46bd      	mov	sp, r7
 80043ae:	bd90      	pop	{r4, r7, pc}

080043b0 <se3_req_len_data>:
}

#endif

uint16_t se3_req_len_data(uint16_t len_data_and_headers)
{
 80043b0:	b480      	push	{r7}
 80043b2:	b085      	sub	sp, #20
 80043b4:	af00      	add	r7, sp, #0
 80043b6:	4603      	mov	r3, r0
 80043b8:	80fb      	strh	r3, [r7, #6]
    uint16_t nblocks;
    if (len_data_and_headers < SE3_REQ_SIZE_HEADER) {
 80043ba:	88fb      	ldrh	r3, [r7, #6]
 80043bc:	2b0f      	cmp	r3, #15
 80043be:	d801      	bhi.n	80043c4 <se3_req_len_data+0x14>
        return 0;
 80043c0:	2300      	movs	r3, #0
 80043c2:	e01c      	b.n	80043fe <se3_req_len_data+0x4e>
    }
    nblocks = len_data_and_headers/SE3_COMM_BLOCK;
 80043c4:	88fb      	ldrh	r3, [r7, #6]
 80043c6:	0a5b      	lsrs	r3, r3, #9
 80043c8:	81fb      	strh	r3, [r7, #14]
    if (len_data_and_headers % SE3_COMM_BLOCK != 0) {
 80043ca:	88fb      	ldrh	r3, [r7, #6]
 80043cc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80043d0:	b29b      	uxth	r3, r3
 80043d2:	2b00      	cmp	r3, #0
 80043d4:	d002      	beq.n	80043dc <se3_req_len_data+0x2c>
        nblocks++;
 80043d6:	89fb      	ldrh	r3, [r7, #14]
 80043d8:	3301      	adds	r3, #1
 80043da:	81fb      	strh	r3, [r7, #14]
    }
    if (nblocks == 0)return 0;
 80043dc:	89fb      	ldrh	r3, [r7, #14]
 80043de:	2b00      	cmp	r3, #0
 80043e0:	d101      	bne.n	80043e6 <se3_req_len_data+0x36>
 80043e2:	2300      	movs	r3, #0
 80043e4:	e00b      	b.n	80043fe <se3_req_len_data+0x4e>
    return len_data_and_headers - SE3_REQ_SIZE_HEADER - (nblocks - 1)*SE3_REQDATA_SIZE_HEADER;
 80043e6:	89fb      	ldrh	r3, [r7, #14]
 80043e8:	f503 537f 	add.w	r3, r3, #16320	; 0x3fc0
 80043ec:	333f      	adds	r3, #63	; 0x3f
 80043ee:	b29b      	uxth	r3, r3
 80043f0:	009b      	lsls	r3, r3, #2
 80043f2:	b29b      	uxth	r3, r3
 80043f4:	88fa      	ldrh	r2, [r7, #6]
 80043f6:	1ad3      	subs	r3, r2, r3
 80043f8:	b29b      	uxth	r3, r3
 80043fa:	3b10      	subs	r3, #16
 80043fc:	b29b      	uxth	r3, r3
}
 80043fe:	4618      	mov	r0, r3
 8004400:	3714      	adds	r7, #20
 8004402:	46bd      	mov	sp, r7
 8004404:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004408:	4770      	bx	lr
	...

0800440c <se3_resp_len_data_and_headers>:
    if (nblocks == 0)return 0;
    return len_data_and_headers - SE3_RESP_SIZE_HEADER - (nblocks - 1)*SE3_RESPDATA_SIZE_HEADER;
}

uint16_t se3_resp_len_data_and_headers(uint16_t len_data)
{
 800440c:	b480      	push	{r7}
 800440e:	b085      	sub	sp, #20
 8004410:	af00      	add	r7, sp, #0
 8004412:	4603      	mov	r3, r0
 8004414:	80fb      	strh	r3, [r7, #6]
    uint16_t ndatablocks;
    if (len_data <= SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER) {
 8004416:	88fb      	ldrh	r3, [r7, #6]
 8004418:	f5b3 7ff8 	cmp.w	r3, #496	; 0x1f0
 800441c:	d803      	bhi.n	8004426 <se3_resp_len_data_and_headers+0x1a>
        return len_data + SE3_RESP_SIZE_HEADER;
 800441e:	88fb      	ldrh	r3, [r7, #6]
 8004420:	3310      	adds	r3, #16
 8004422:	b29b      	uxth	r3, r3
 8004424:	e024      	b.n	8004470 <se3_resp_len_data_and_headers+0x64>
    }
    len_data -= (SE3_COMM_BLOCK - SE3_REQ_SIZE_HEADER);
 8004426:	88fb      	ldrh	r3, [r7, #6]
 8004428:	f5a3 73f8 	sub.w	r3, r3, #496	; 0x1f0
 800442c:	80fb      	strh	r3, [r7, #6]
    ndatablocks = len_data / (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER);
 800442e:	88fb      	ldrh	r3, [r7, #6]
 8004430:	089b      	lsrs	r3, r3, #2
 8004432:	4a12      	ldr	r2, [pc, #72]	; (800447c <se3_resp_len_data_and_headers+0x70>)
 8004434:	fba2 2303 	umull	r2, r3, r2, r3
 8004438:	095b      	lsrs	r3, r3, #5
 800443a:	81fb      	strh	r3, [r7, #14]
    if (len_data % (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER) != 0) {
 800443c:	88fa      	ldrh	r2, [r7, #6]
 800443e:	0893      	lsrs	r3, r2, #2
 8004440:	490e      	ldr	r1, [pc, #56]	; (800447c <se3_resp_len_data_and_headers+0x70>)
 8004442:	fba1 1303 	umull	r1, r3, r1, r3
 8004446:	0959      	lsrs	r1, r3, #5
 8004448:	460b      	mov	r3, r1
 800444a:	01db      	lsls	r3, r3, #7
 800444c:	1a5b      	subs	r3, r3, r1
 800444e:	009b      	lsls	r3, r3, #2
 8004450:	1ad3      	subs	r3, r2, r3
 8004452:	b29b      	uxth	r3, r3
 8004454:	2b00      	cmp	r3, #0
 8004456:	d002      	beq.n	800445e <se3_resp_len_data_and_headers+0x52>
        ndatablocks++;
 8004458:	89fb      	ldrh	r3, [r7, #14]
 800445a:	3301      	adds	r3, #1
 800445c:	81fb      	strh	r3, [r7, #14]
    }
    return SE3_COMM_BLOCK + len_data + ndatablocks*SE3_RESPDATA_SIZE_HEADER;
 800445e:	89fb      	ldrh	r3, [r7, #14]
 8004460:	009b      	lsls	r3, r3, #2
 8004462:	b29a      	uxth	r2, r3
 8004464:	88fb      	ldrh	r3, [r7, #6]
 8004466:	4413      	add	r3, r2
 8004468:	b29b      	uxth	r3, r3
 800446a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800446e:	b29b      	uxth	r3, r3
}
 8004470:	4618      	mov	r0, r3
 8004472:	3714      	adds	r7, #20
 8004474:	46bd      	mov	sp, r7
 8004476:	f85d 7b04 	ldr.w	r7, [sp], #4
 800447a:	4770      	bx	lr
 800447c:	40810205 	.word	0x40810205

08004480 <B5_SHA256_GETUINT32>:

#include "sha256.h"


void B5_SHA256_GETUINT32(uint32_t *n,const uint8_t *b, int32_t i)
{
 8004480:	b480      	push	{r7}
 8004482:	b085      	sub	sp, #20
 8004484:	af00      	add	r7, sp, #0
 8004486:	60f8      	str	r0, [r7, #12]
 8004488:	60b9      	str	r1, [r7, #8]
 800448a:	607a      	str	r2, [r7, #4]
    *n =      ( (uint32_t) b[i    ] << 24 )
 800448c:	687b      	ldr	r3, [r7, #4]
 800448e:	68ba      	ldr	r2, [r7, #8]
 8004490:	4413      	add	r3, r2
 8004492:	781b      	ldrb	r3, [r3, #0]
 8004494:	061a      	lsls	r2, r3, #24
            | ( (uint32_t) b[i + 1] << 16 )
 8004496:	687b      	ldr	r3, [r7, #4]
 8004498:	3301      	adds	r3, #1
 800449a:	68b9      	ldr	r1, [r7, #8]
 800449c:	440b      	add	r3, r1
 800449e:	781b      	ldrb	r3, [r3, #0]
 80044a0:	041b      	lsls	r3, r3, #16
 80044a2:	431a      	orrs	r2, r3
            | ( (uint32_t) b[i + 2] <<  8 )
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	3302      	adds	r3, #2
 80044a8:	68b9      	ldr	r1, [r7, #8]
 80044aa:	440b      	add	r3, r1
 80044ac:	781b      	ldrb	r3, [r3, #0]
 80044ae:	021b      	lsls	r3, r3, #8
 80044b0:	4313      	orrs	r3, r2
            | ( (uint32_t) b[i + 3]       );
 80044b2:	687a      	ldr	r2, [r7, #4]
 80044b4:	3203      	adds	r2, #3
 80044b6:	68b9      	ldr	r1, [r7, #8]
 80044b8:	440a      	add	r2, r1
 80044ba:	7812      	ldrb	r2, [r2, #0]
 80044bc:	431a      	orrs	r2, r3
    *n =      ( (uint32_t) b[i    ] << 24 )
 80044be:	68fb      	ldr	r3, [r7, #12]
 80044c0:	601a      	str	r2, [r3, #0]
}
 80044c2:	bf00      	nop
 80044c4:	3714      	adds	r7, #20
 80044c6:	46bd      	mov	sp, r7
 80044c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80044cc:	4770      	bx	lr

080044ce <B5_SHA256_PUTUINT32>:

void B5_SHA256_PUTUINT32(uint32_t n,uint8_t *b, int32_t i)                       
{                                               
 80044ce:	b480      	push	{r7}
 80044d0:	b085      	sub	sp, #20
 80044d2:	af00      	add	r7, sp, #0
 80044d4:	60f8      	str	r0, [r7, #12]
 80044d6:	60b9      	str	r1, [r7, #8]
 80044d8:	607a      	str	r2, [r7, #4]
    b[i    ] = (uint8_t) ( n >> 24 );      
 80044da:	68fb      	ldr	r3, [r7, #12]
 80044dc:	0e19      	lsrs	r1, r3, #24
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	68ba      	ldr	r2, [r7, #8]
 80044e2:	4413      	add	r3, r2
 80044e4:	b2ca      	uxtb	r2, r1
 80044e6:	701a      	strb	r2, [r3, #0]
    b[i + 1] = (uint8_t) ( n >> 16 );      
 80044e8:	68fb      	ldr	r3, [r7, #12]
 80044ea:	0c19      	lsrs	r1, r3, #16
 80044ec:	687b      	ldr	r3, [r7, #4]
 80044ee:	3301      	adds	r3, #1
 80044f0:	68ba      	ldr	r2, [r7, #8]
 80044f2:	4413      	add	r3, r2
 80044f4:	b2ca      	uxtb	r2, r1
 80044f6:	701a      	strb	r2, [r3, #0]
    b[i + 2] = (uint8_t) ( n >>  8 );      
 80044f8:	68fb      	ldr	r3, [r7, #12]
 80044fa:	0a19      	lsrs	r1, r3, #8
 80044fc:	687b      	ldr	r3, [r7, #4]
 80044fe:	3302      	adds	r3, #2
 8004500:	68ba      	ldr	r2, [r7, #8]
 8004502:	4413      	add	r3, r2
 8004504:	b2ca      	uxtb	r2, r1
 8004506:	701a      	strb	r2, [r3, #0]
    b[i + 3] = (uint8_t) ( n       );
 8004508:	687b      	ldr	r3, [r7, #4]
 800450a:	3303      	adds	r3, #3
 800450c:	68ba      	ldr	r2, [r7, #8]
 800450e:	4413      	add	r3, r2
 8004510:	68fa      	ldr	r2, [r7, #12]
 8004512:	b2d2      	uxtb	r2, r2
 8004514:	701a      	strb	r2, [r3, #0]
}
 8004516:	bf00      	nop
 8004518:	3714      	adds	r7, #20
 800451a:	46bd      	mov	sp, r7
 800451c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004520:	4770      	bx	lr

08004522 <B5_SHA256_P>:
    ctx->W[t] = B5_SHA256_S1(ctx->W[t -  2]) + ctx->W[t -  7] +   \
           B5_SHA256_S0(ctx->W[t - 15]) + ctx->W[t - 16]          \
)

void B5_SHA256_P(uint32_t a,uint32_t b,uint32_t c,uint32_t *d,uint32_t e,uint32_t f,uint32_t g,uint32_t *h,uint32_t x,uint32_t K)
{
 8004522:	b480      	push	{r7}
 8004524:	b087      	sub	sp, #28
 8004526:	af00      	add	r7, sp, #0
 8004528:	60f8      	str	r0, [r7, #12]
 800452a:	60b9      	str	r1, [r7, #8]
 800452c:	607a      	str	r2, [r7, #4]
 800452e:	603b      	str	r3, [r7, #0]
uint32_t temp1, temp2;
    temp1 = *h + B5_SHA256_S3(e) + B5_SHA256_F1(e,f,g) + K + x;      
 8004530:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004532:	681a      	ldr	r2, [r3, #0]
 8004534:	6a3b      	ldr	r3, [r7, #32]
 8004536:	ea4f 11b3 	mov.w	r1, r3, ror #6
 800453a:	6a3b      	ldr	r3, [r7, #32]
 800453c:	ea4f 23f3 	mov.w	r3, r3, ror #11
 8004540:	4059      	eors	r1, r3
 8004542:	6a3b      	ldr	r3, [r7, #32]
 8004544:	ea4f 6373 	mov.w	r3, r3, ror #25
 8004548:	404b      	eors	r3, r1
 800454a:	441a      	add	r2, r3
 800454c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800454e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004550:	4059      	eors	r1, r3
 8004552:	6a3b      	ldr	r3, [r7, #32]
 8004554:	4019      	ands	r1, r3
 8004556:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004558:	404b      	eors	r3, r1
 800455a:	441a      	add	r2, r3
 800455c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800455e:	4413      	add	r3, r2
 8004560:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8004562:	4413      	add	r3, r2
 8004564:	617b      	str	r3, [r7, #20]
    temp2 = B5_SHA256_S2(a) + B5_SHA256_F0(a,b,c);                  
 8004566:	68fb      	ldr	r3, [r7, #12]
 8004568:	ea4f 02b3 	mov.w	r2, r3, ror #2
 800456c:	68fb      	ldr	r3, [r7, #12]
 800456e:	ea4f 3373 	mov.w	r3, r3, ror #13
 8004572:	405a      	eors	r2, r3
 8004574:	68fb      	ldr	r3, [r7, #12]
 8004576:	ea4f 53b3 	mov.w	r3, r3, ror #22
 800457a:	405a      	eors	r2, r3
 800457c:	68f9      	ldr	r1, [r7, #12]
 800457e:	68bb      	ldr	r3, [r7, #8]
 8004580:	4019      	ands	r1, r3
 8004582:	68f8      	ldr	r0, [r7, #12]
 8004584:	68bb      	ldr	r3, [r7, #8]
 8004586:	4318      	orrs	r0, r3
 8004588:	687b      	ldr	r3, [r7, #4]
 800458a:	4003      	ands	r3, r0
 800458c:	430b      	orrs	r3, r1
 800458e:	4413      	add	r3, r2
 8004590:	613b      	str	r3, [r7, #16]
    *d += temp1; *h = temp1 + temp2;        
 8004592:	683b      	ldr	r3, [r7, #0]
 8004594:	681a      	ldr	r2, [r3, #0]
 8004596:	697b      	ldr	r3, [r7, #20]
 8004598:	441a      	add	r2, r3
 800459a:	683b      	ldr	r3, [r7, #0]
 800459c:	601a      	str	r2, [r3, #0]
 800459e:	697a      	ldr	r2, [r7, #20]
 80045a0:	693b      	ldr	r3, [r7, #16]
 80045a2:	441a      	add	r2, r3
 80045a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80045a6:	601a      	str	r2, [r3, #0]
}
 80045a8:	bf00      	nop
 80045aa:	371c      	adds	r7, #28
 80045ac:	46bd      	mov	sp, r7
 80045ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045b2:	4770      	bx	lr

080045b4 <B5_Sha256ProcessBlock>:




static void B5_Sha256ProcessBlock(B5_tSha256Ctx *ctx, const uint8_t *data)
{
 80045b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80045b6:	b093      	sub	sp, #76	; 0x4c
 80045b8:	af06      	add	r7, sp, #24
 80045ba:	60f8      	str	r0, [r7, #12]
 80045bc:	60b9      	str	r1, [r7, #8]
    uint32_t A, B, C, D, E, F, G, H;

    B5_SHA256_GETUINT32( &ctx->W[0],  data,  0 );
 80045be:	68fb      	ldr	r3, [r7, #12]
 80045c0:	3368      	adds	r3, #104	; 0x68
 80045c2:	2200      	movs	r2, #0
 80045c4:	68b9      	ldr	r1, [r7, #8]
 80045c6:	4618      	mov	r0, r3
 80045c8:	f7ff ff5a 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[1],  data,  4 );
 80045cc:	68fb      	ldr	r3, [r7, #12]
 80045ce:	336c      	adds	r3, #108	; 0x6c
 80045d0:	2204      	movs	r2, #4
 80045d2:	68b9      	ldr	r1, [r7, #8]
 80045d4:	4618      	mov	r0, r3
 80045d6:	f7ff ff53 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[2],  data,  8 );
 80045da:	68fb      	ldr	r3, [r7, #12]
 80045dc:	3370      	adds	r3, #112	; 0x70
 80045de:	2208      	movs	r2, #8
 80045e0:	68b9      	ldr	r1, [r7, #8]
 80045e2:	4618      	mov	r0, r3
 80045e4:	f7ff ff4c 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[3],  data, 12 );
 80045e8:	68fb      	ldr	r3, [r7, #12]
 80045ea:	3374      	adds	r3, #116	; 0x74
 80045ec:	220c      	movs	r2, #12
 80045ee:	68b9      	ldr	r1, [r7, #8]
 80045f0:	4618      	mov	r0, r3
 80045f2:	f7ff ff45 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[4],  data, 16 );
 80045f6:	68fb      	ldr	r3, [r7, #12]
 80045f8:	3378      	adds	r3, #120	; 0x78
 80045fa:	2210      	movs	r2, #16
 80045fc:	68b9      	ldr	r1, [r7, #8]
 80045fe:	4618      	mov	r0, r3
 8004600:	f7ff ff3e 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[5],  data, 20 );
 8004604:	68fb      	ldr	r3, [r7, #12]
 8004606:	337c      	adds	r3, #124	; 0x7c
 8004608:	2214      	movs	r2, #20
 800460a:	68b9      	ldr	r1, [r7, #8]
 800460c:	4618      	mov	r0, r3
 800460e:	f7ff ff37 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[6],  data, 24 );
 8004612:	68fb      	ldr	r3, [r7, #12]
 8004614:	3380      	adds	r3, #128	; 0x80
 8004616:	2218      	movs	r2, #24
 8004618:	68b9      	ldr	r1, [r7, #8]
 800461a:	4618      	mov	r0, r3
 800461c:	f7ff ff30 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[7],  data, 28 );
 8004620:	68fb      	ldr	r3, [r7, #12]
 8004622:	3384      	adds	r3, #132	; 0x84
 8004624:	221c      	movs	r2, #28
 8004626:	68b9      	ldr	r1, [r7, #8]
 8004628:	4618      	mov	r0, r3
 800462a:	f7ff ff29 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[8],  data, 32 );
 800462e:	68fb      	ldr	r3, [r7, #12]
 8004630:	3388      	adds	r3, #136	; 0x88
 8004632:	2220      	movs	r2, #32
 8004634:	68b9      	ldr	r1, [r7, #8]
 8004636:	4618      	mov	r0, r3
 8004638:	f7ff ff22 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[9],  data, 36 );
 800463c:	68fb      	ldr	r3, [r7, #12]
 800463e:	338c      	adds	r3, #140	; 0x8c
 8004640:	2224      	movs	r2, #36	; 0x24
 8004642:	68b9      	ldr	r1, [r7, #8]
 8004644:	4618      	mov	r0, r3
 8004646:	f7ff ff1b 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[10], data, 40 );
 800464a:	68fb      	ldr	r3, [r7, #12]
 800464c:	3390      	adds	r3, #144	; 0x90
 800464e:	2228      	movs	r2, #40	; 0x28
 8004650:	68b9      	ldr	r1, [r7, #8]
 8004652:	4618      	mov	r0, r3
 8004654:	f7ff ff14 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[11], data, 44 );
 8004658:	68fb      	ldr	r3, [r7, #12]
 800465a:	3394      	adds	r3, #148	; 0x94
 800465c:	222c      	movs	r2, #44	; 0x2c
 800465e:	68b9      	ldr	r1, [r7, #8]
 8004660:	4618      	mov	r0, r3
 8004662:	f7ff ff0d 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[12], data, 48 );
 8004666:	68fb      	ldr	r3, [r7, #12]
 8004668:	3398      	adds	r3, #152	; 0x98
 800466a:	2230      	movs	r2, #48	; 0x30
 800466c:	68b9      	ldr	r1, [r7, #8]
 800466e:	4618      	mov	r0, r3
 8004670:	f7ff ff06 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[13], data, 52 );
 8004674:	68fb      	ldr	r3, [r7, #12]
 8004676:	339c      	adds	r3, #156	; 0x9c
 8004678:	2234      	movs	r2, #52	; 0x34
 800467a:	68b9      	ldr	r1, [r7, #8]
 800467c:	4618      	mov	r0, r3
 800467e:	f7ff feff 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[14], data, 56 );
 8004682:	68fb      	ldr	r3, [r7, #12]
 8004684:	33a0      	adds	r3, #160	; 0xa0
 8004686:	2238      	movs	r2, #56	; 0x38
 8004688:	68b9      	ldr	r1, [r7, #8]
 800468a:	4618      	mov	r0, r3
 800468c:	f7ff fef8 	bl	8004480 <B5_SHA256_GETUINT32>
    B5_SHA256_GETUINT32( &ctx->W[15], data, 60 );
 8004690:	68fb      	ldr	r3, [r7, #12]
 8004692:	33a4      	adds	r3, #164	; 0xa4
 8004694:	223c      	movs	r2, #60	; 0x3c
 8004696:	68b9      	ldr	r1, [r7, #8]
 8004698:	4618      	mov	r0, r3
 800469a:	f7ff fef1 	bl	8004480 <B5_SHA256_GETUINT32>


    A = ctx->state[0];
 800469e:	68fb      	ldr	r3, [r7, #12]
 80046a0:	689b      	ldr	r3, [r3, #8]
 80046a2:	62fb      	str	r3, [r7, #44]	; 0x2c
    B = ctx->state[1];
 80046a4:	68fb      	ldr	r3, [r7, #12]
 80046a6:	68db      	ldr	r3, [r3, #12]
 80046a8:	62bb      	str	r3, [r7, #40]	; 0x28
    C = ctx->state[2];
 80046aa:	68fb      	ldr	r3, [r7, #12]
 80046ac:	691b      	ldr	r3, [r3, #16]
 80046ae:	627b      	str	r3, [r7, #36]	; 0x24
    D = ctx->state[3];
 80046b0:	68fb      	ldr	r3, [r7, #12]
 80046b2:	695b      	ldr	r3, [r3, #20]
 80046b4:	623b      	str	r3, [r7, #32]
    E = ctx->state[4];
 80046b6:	68fb      	ldr	r3, [r7, #12]
 80046b8:	699b      	ldr	r3, [r3, #24]
 80046ba:	61fb      	str	r3, [r7, #28]
    F = ctx->state[5];
 80046bc:	68fb      	ldr	r3, [r7, #12]
 80046be:	69db      	ldr	r3, [r3, #28]
 80046c0:	61bb      	str	r3, [r7, #24]
    G = ctx->state[6];
 80046c2:	68fb      	ldr	r3, [r7, #12]
 80046c4:	6a1b      	ldr	r3, [r3, #32]
 80046c6:	617b      	str	r3, [r7, #20]
    H = ctx->state[7];
 80046c8:	68fb      	ldr	r3, [r7, #12]
 80046ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80046cc:	613b      	str	r3, [r7, #16]


    B5_SHA256_P( A, B, C, &D, E, F, G, &H, ctx->W[ 0], 0x428A2F98 );
 80046ce:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 80046d0:	6abe      	ldr	r6, [r7, #40]	; 0x28
 80046d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046d4:	607b      	str	r3, [r7, #4]
 80046d6:	69fb      	ldr	r3, [r7, #28]
 80046d8:	69ba      	ldr	r2, [r7, #24]
 80046da:	6979      	ldr	r1, [r7, #20]
 80046dc:	68f8      	ldr	r0, [r7, #12]
 80046de:	6e80      	ldr	r0, [r0, #104]	; 0x68
 80046e0:	f107 0c20 	add.w	ip, r7, #32
 80046e4:	4c9c      	ldr	r4, [pc, #624]	; (8004958 <B5_Sha256ProcessBlock+0x3a4>)
 80046e6:	9405      	str	r4, [sp, #20]
 80046e8:	9004      	str	r0, [sp, #16]
 80046ea:	f107 0010 	add.w	r0, r7, #16
 80046ee:	9003      	str	r0, [sp, #12]
 80046f0:	9102      	str	r1, [sp, #8]
 80046f2:	9201      	str	r2, [sp, #4]
 80046f4:	9300      	str	r3, [sp, #0]
 80046f6:	4663      	mov	r3, ip
 80046f8:	687a      	ldr	r2, [r7, #4]
 80046fa:	4631      	mov	r1, r6
 80046fc:	4628      	mov	r0, r5
 80046fe:	f7ff ff10 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, ctx->W[ 1], 0x71374491 );
 8004702:	693d      	ldr	r5, [r7, #16]
 8004704:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8004706:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004708:	607b      	str	r3, [r7, #4]
 800470a:	6a3b      	ldr	r3, [r7, #32]
 800470c:	69fa      	ldr	r2, [r7, #28]
 800470e:	69b9      	ldr	r1, [r7, #24]
 8004710:	68f8      	ldr	r0, [r7, #12]
 8004712:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8004714:	f107 0c24 	add.w	ip, r7, #36	; 0x24
 8004718:	4c90      	ldr	r4, [pc, #576]	; (800495c <B5_Sha256ProcessBlock+0x3a8>)
 800471a:	9405      	str	r4, [sp, #20]
 800471c:	9004      	str	r0, [sp, #16]
 800471e:	f107 0014 	add.w	r0, r7, #20
 8004722:	9003      	str	r0, [sp, #12]
 8004724:	9102      	str	r1, [sp, #8]
 8004726:	9201      	str	r2, [sp, #4]
 8004728:	9300      	str	r3, [sp, #0]
 800472a:	4663      	mov	r3, ip
 800472c:	687a      	ldr	r2, [r7, #4]
 800472e:	4631      	mov	r1, r6
 8004730:	4628      	mov	r0, r5
 8004732:	f7ff fef6 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, ctx->W[ 2], 0xB5C0FBCF );
 8004736:	697d      	ldr	r5, [r7, #20]
 8004738:	693e      	ldr	r6, [r7, #16]
 800473a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800473c:	607b      	str	r3, [r7, #4]
 800473e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004740:	6a3a      	ldr	r2, [r7, #32]
 8004742:	69f9      	ldr	r1, [r7, #28]
 8004744:	68f8      	ldr	r0, [r7, #12]
 8004746:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004748:	f107 0c28 	add.w	ip, r7, #40	; 0x28
 800474c:	4c84      	ldr	r4, [pc, #528]	; (8004960 <B5_Sha256ProcessBlock+0x3ac>)
 800474e:	9405      	str	r4, [sp, #20]
 8004750:	9004      	str	r0, [sp, #16]
 8004752:	f107 0018 	add.w	r0, r7, #24
 8004756:	9003      	str	r0, [sp, #12]
 8004758:	9102      	str	r1, [sp, #8]
 800475a:	9201      	str	r2, [sp, #4]
 800475c:	9300      	str	r3, [sp, #0]
 800475e:	4663      	mov	r3, ip
 8004760:	687a      	ldr	r2, [r7, #4]
 8004762:	4631      	mov	r1, r6
 8004764:	4628      	mov	r0, r5
 8004766:	f7ff fedc 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, ctx->W[ 3], 0xE9B5DBA5 );
 800476a:	69bd      	ldr	r5, [r7, #24]
 800476c:	697e      	ldr	r6, [r7, #20]
 800476e:	693b      	ldr	r3, [r7, #16]
 8004770:	607b      	str	r3, [r7, #4]
 8004772:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004774:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004776:	6a39      	ldr	r1, [r7, #32]
 8004778:	68f8      	ldr	r0, [r7, #12]
 800477a:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800477c:	f107 0c2c 	add.w	ip, r7, #44	; 0x2c
 8004780:	4c78      	ldr	r4, [pc, #480]	; (8004964 <B5_Sha256ProcessBlock+0x3b0>)
 8004782:	9405      	str	r4, [sp, #20]
 8004784:	9004      	str	r0, [sp, #16]
 8004786:	f107 001c 	add.w	r0, r7, #28
 800478a:	9003      	str	r0, [sp, #12]
 800478c:	9102      	str	r1, [sp, #8]
 800478e:	9201      	str	r2, [sp, #4]
 8004790:	9300      	str	r3, [sp, #0]
 8004792:	4663      	mov	r3, ip
 8004794:	687a      	ldr	r2, [r7, #4]
 8004796:	4631      	mov	r1, r6
 8004798:	4628      	mov	r0, r5
 800479a:	f7ff fec2 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, ctx->W[ 4], 0x3956C25B );
 800479e:	69fd      	ldr	r5, [r7, #28]
 80047a0:	69be      	ldr	r6, [r7, #24]
 80047a2:	697b      	ldr	r3, [r7, #20]
 80047a4:	607b      	str	r3, [r7, #4]
 80047a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80047a8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80047aa:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80047ac:	68f8      	ldr	r0, [r7, #12]
 80047ae:	6f80      	ldr	r0, [r0, #120]	; 0x78
 80047b0:	f107 0c10 	add.w	ip, r7, #16
 80047b4:	4c6c      	ldr	r4, [pc, #432]	; (8004968 <B5_Sha256ProcessBlock+0x3b4>)
 80047b6:	9405      	str	r4, [sp, #20]
 80047b8:	9004      	str	r0, [sp, #16]
 80047ba:	f107 0020 	add.w	r0, r7, #32
 80047be:	9003      	str	r0, [sp, #12]
 80047c0:	9102      	str	r1, [sp, #8]
 80047c2:	9201      	str	r2, [sp, #4]
 80047c4:	9300      	str	r3, [sp, #0]
 80047c6:	4663      	mov	r3, ip
 80047c8:	687a      	ldr	r2, [r7, #4]
 80047ca:	4631      	mov	r1, r6
 80047cc:	4628      	mov	r0, r5
 80047ce:	f7ff fea8 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, ctx->W[ 5], 0x59F111F1 );
 80047d2:	6a3d      	ldr	r5, [r7, #32]
 80047d4:	69fe      	ldr	r6, [r7, #28]
 80047d6:	69bb      	ldr	r3, [r7, #24]
 80047d8:	607b      	str	r3, [r7, #4]
 80047da:	693b      	ldr	r3, [r7, #16]
 80047dc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80047de:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80047e0:	68f8      	ldr	r0, [r7, #12]
 80047e2:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 80047e4:	f107 0c14 	add.w	ip, r7, #20
 80047e8:	4c60      	ldr	r4, [pc, #384]	; (800496c <B5_Sha256ProcessBlock+0x3b8>)
 80047ea:	9405      	str	r4, [sp, #20]
 80047ec:	9004      	str	r0, [sp, #16]
 80047ee:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80047f2:	9003      	str	r0, [sp, #12]
 80047f4:	9102      	str	r1, [sp, #8]
 80047f6:	9201      	str	r2, [sp, #4]
 80047f8:	9300      	str	r3, [sp, #0]
 80047fa:	4663      	mov	r3, ip
 80047fc:	687a      	ldr	r2, [r7, #4]
 80047fe:	4631      	mov	r1, r6
 8004800:	4628      	mov	r0, r5
 8004802:	f7ff fe8e 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, ctx->W[ 6], 0x923F82A4 );
 8004806:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 8004808:	6a3e      	ldr	r6, [r7, #32]
 800480a:	69fb      	ldr	r3, [r7, #28]
 800480c:	607b      	str	r3, [r7, #4]
 800480e:	697b      	ldr	r3, [r7, #20]
 8004810:	693a      	ldr	r2, [r7, #16]
 8004812:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004814:	68f8      	ldr	r0, [r7, #12]
 8004816:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800481a:	f107 0c18 	add.w	ip, r7, #24
 800481e:	4c54      	ldr	r4, [pc, #336]	; (8004970 <B5_Sha256ProcessBlock+0x3bc>)
 8004820:	9405      	str	r4, [sp, #20]
 8004822:	9004      	str	r0, [sp, #16]
 8004824:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8004828:	9003      	str	r0, [sp, #12]
 800482a:	9102      	str	r1, [sp, #8]
 800482c:	9201      	str	r2, [sp, #4]
 800482e:	9300      	str	r3, [sp, #0]
 8004830:	4663      	mov	r3, ip
 8004832:	687a      	ldr	r2, [r7, #4]
 8004834:	4631      	mov	r1, r6
 8004836:	4628      	mov	r0, r5
 8004838:	f7ff fe73 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, ctx->W[ 7], 0xAB1C5ED5 );
 800483c:	6abd      	ldr	r5, [r7, #40]	; 0x28
 800483e:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8004840:	6a3b      	ldr	r3, [r7, #32]
 8004842:	607b      	str	r3, [r7, #4]
 8004844:	69bb      	ldr	r3, [r7, #24]
 8004846:	697a      	ldr	r2, [r7, #20]
 8004848:	6939      	ldr	r1, [r7, #16]
 800484a:	68f8      	ldr	r0, [r7, #12]
 800484c:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004850:	f107 0c1c 	add.w	ip, r7, #28
 8004854:	4c47      	ldr	r4, [pc, #284]	; (8004974 <B5_Sha256ProcessBlock+0x3c0>)
 8004856:	9405      	str	r4, [sp, #20]
 8004858:	9004      	str	r0, [sp, #16]
 800485a:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 800485e:	9003      	str	r0, [sp, #12]
 8004860:	9102      	str	r1, [sp, #8]
 8004862:	9201      	str	r2, [sp, #4]
 8004864:	9300      	str	r3, [sp, #0]
 8004866:	4663      	mov	r3, ip
 8004868:	687a      	ldr	r2, [r7, #4]
 800486a:	4631      	mov	r1, r6
 800486c:	4628      	mov	r0, r5
 800486e:	f7ff fe58 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, ctx->W[ 8], 0xD807AA98 );
 8004872:	6afd      	ldr	r5, [r7, #44]	; 0x2c
 8004874:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8004876:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004878:	607b      	str	r3, [r7, #4]
 800487a:	69fb      	ldr	r3, [r7, #28]
 800487c:	69ba      	ldr	r2, [r7, #24]
 800487e:	6979      	ldr	r1, [r7, #20]
 8004880:	68f8      	ldr	r0, [r7, #12]
 8004882:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004886:	f107 0c20 	add.w	ip, r7, #32
 800488a:	4c3b      	ldr	r4, [pc, #236]	; (8004978 <B5_Sha256ProcessBlock+0x3c4>)
 800488c:	9405      	str	r4, [sp, #20]
 800488e:	9004      	str	r0, [sp, #16]
 8004890:	f107 0010 	add.w	r0, r7, #16
 8004894:	9003      	str	r0, [sp, #12]
 8004896:	9102      	str	r1, [sp, #8]
 8004898:	9201      	str	r2, [sp, #4]
 800489a:	9300      	str	r3, [sp, #0]
 800489c:	4663      	mov	r3, ip
 800489e:	687a      	ldr	r2, [r7, #4]
 80048a0:	4631      	mov	r1, r6
 80048a2:	4628      	mov	r0, r5
 80048a4:	f7ff fe3d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, ctx->W[ 9], 0x12835B01 );
 80048a8:	693d      	ldr	r5, [r7, #16]
 80048aa:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 80048ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80048ae:	607b      	str	r3, [r7, #4]
 80048b0:	6a3b      	ldr	r3, [r7, #32]
 80048b2:	69fa      	ldr	r2, [r7, #28]
 80048b4:	69b9      	ldr	r1, [r7, #24]
 80048b6:	68f8      	ldr	r0, [r7, #12]
 80048b8:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 80048bc:	f107 0c24 	add.w	ip, r7, #36	; 0x24
 80048c0:	4c2e      	ldr	r4, [pc, #184]	; (800497c <B5_Sha256ProcessBlock+0x3c8>)
 80048c2:	9405      	str	r4, [sp, #20]
 80048c4:	9004      	str	r0, [sp, #16]
 80048c6:	f107 0014 	add.w	r0, r7, #20
 80048ca:	9003      	str	r0, [sp, #12]
 80048cc:	9102      	str	r1, [sp, #8]
 80048ce:	9201      	str	r2, [sp, #4]
 80048d0:	9300      	str	r3, [sp, #0]
 80048d2:	4663      	mov	r3, ip
 80048d4:	687a      	ldr	r2, [r7, #4]
 80048d6:	4631      	mov	r1, r6
 80048d8:	4628      	mov	r0, r5
 80048da:	f7ff fe22 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, ctx->W[10], 0x243185BE );
 80048de:	697d      	ldr	r5, [r7, #20]
 80048e0:	693e      	ldr	r6, [r7, #16]
 80048e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80048e4:	607b      	str	r3, [r7, #4]
 80048e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80048e8:	6a3a      	ldr	r2, [r7, #32]
 80048ea:	69f9      	ldr	r1, [r7, #28]
 80048ec:	68f8      	ldr	r0, [r7, #12]
 80048ee:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 80048f2:	f107 0c28 	add.w	ip, r7, #40	; 0x28
 80048f6:	4c22      	ldr	r4, [pc, #136]	; (8004980 <B5_Sha256ProcessBlock+0x3cc>)
 80048f8:	9405      	str	r4, [sp, #20]
 80048fa:	9004      	str	r0, [sp, #16]
 80048fc:	f107 0018 	add.w	r0, r7, #24
 8004900:	9003      	str	r0, [sp, #12]
 8004902:	9102      	str	r1, [sp, #8]
 8004904:	9201      	str	r2, [sp, #4]
 8004906:	9300      	str	r3, [sp, #0]
 8004908:	4663      	mov	r3, ip
 800490a:	687a      	ldr	r2, [r7, #4]
 800490c:	4631      	mov	r1, r6
 800490e:	4628      	mov	r0, r5
 8004910:	f7ff fe07 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, ctx->W[11], 0x550C7DC3 );
 8004914:	69bd      	ldr	r5, [r7, #24]
 8004916:	697e      	ldr	r6, [r7, #20]
 8004918:	693b      	ldr	r3, [r7, #16]
 800491a:	607b      	str	r3, [r7, #4]
 800491c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800491e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004920:	6a39      	ldr	r1, [r7, #32]
 8004922:	68f8      	ldr	r0, [r7, #12]
 8004924:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 8004928:	f107 0c2c 	add.w	ip, r7, #44	; 0x2c
 800492c:	4c15      	ldr	r4, [pc, #84]	; (8004984 <B5_Sha256ProcessBlock+0x3d0>)
 800492e:	9405      	str	r4, [sp, #20]
 8004930:	9004      	str	r0, [sp, #16]
 8004932:	f107 001c 	add.w	r0, r7, #28
 8004936:	9003      	str	r0, [sp, #12]
 8004938:	9102      	str	r1, [sp, #8]
 800493a:	9201      	str	r2, [sp, #4]
 800493c:	9300      	str	r3, [sp, #0]
 800493e:	4663      	mov	r3, ip
 8004940:	687a      	ldr	r2, [r7, #4]
 8004942:	4631      	mov	r1, r6
 8004944:	4628      	mov	r0, r5
 8004946:	f7ff fdec 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, ctx->W[12], 0x72BE5D74 );
 800494a:	69fd      	ldr	r5, [r7, #28]
 800494c:	69be      	ldr	r6, [r7, #24]
 800494e:	697b      	ldr	r3, [r7, #20]
 8004950:	607b      	str	r3, [r7, #4]
 8004952:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004954:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004956:	e017      	b.n	8004988 <B5_Sha256ProcessBlock+0x3d4>
 8004958:	428a2f98 	.word	0x428a2f98
 800495c:	71374491 	.word	0x71374491
 8004960:	b5c0fbcf 	.word	0xb5c0fbcf
 8004964:	e9b5dba5 	.word	0xe9b5dba5
 8004968:	3956c25b 	.word	0x3956c25b
 800496c:	59f111f1 	.word	0x59f111f1
 8004970:	923f82a4 	.word	0x923f82a4
 8004974:	ab1c5ed5 	.word	0xab1c5ed5
 8004978:	d807aa98 	.word	0xd807aa98
 800497c:	12835b01 	.word	0x12835b01
 8004980:	243185be 	.word	0x243185be
 8004984:	550c7dc3 	.word	0x550c7dc3
 8004988:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800498a:	68f8      	ldr	r0, [r7, #12]
 800498c:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 8004990:	f107 0c10 	add.w	ip, r7, #16
 8004994:	4caa      	ldr	r4, [pc, #680]	; (8004c40 <B5_Sha256ProcessBlock+0x68c>)
 8004996:	9405      	str	r4, [sp, #20]
 8004998:	9004      	str	r0, [sp, #16]
 800499a:	f107 0020 	add.w	r0, r7, #32
 800499e:	9003      	str	r0, [sp, #12]
 80049a0:	9102      	str	r1, [sp, #8]
 80049a2:	9201      	str	r2, [sp, #4]
 80049a4:	9300      	str	r3, [sp, #0]
 80049a6:	4663      	mov	r3, ip
 80049a8:	687a      	ldr	r2, [r7, #4]
 80049aa:	4631      	mov	r1, r6
 80049ac:	4628      	mov	r0, r5
 80049ae:	f7ff fdb8 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, ctx->W[13], 0x80DEB1FE );
 80049b2:	6a3d      	ldr	r5, [r7, #32]
 80049b4:	69fe      	ldr	r6, [r7, #28]
 80049b6:	69bb      	ldr	r3, [r7, #24]
 80049b8:	607b      	str	r3, [r7, #4]
 80049ba:	693b      	ldr	r3, [r7, #16]
 80049bc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80049be:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80049c0:	68f8      	ldr	r0, [r7, #12]
 80049c2:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 80049c6:	f107 0c14 	add.w	ip, r7, #20
 80049ca:	4c9e      	ldr	r4, [pc, #632]	; (8004c44 <B5_Sha256ProcessBlock+0x690>)
 80049cc:	9405      	str	r4, [sp, #20]
 80049ce:	9004      	str	r0, [sp, #16]
 80049d0:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80049d4:	9003      	str	r0, [sp, #12]
 80049d6:	9102      	str	r1, [sp, #8]
 80049d8:	9201      	str	r2, [sp, #4]
 80049da:	9300      	str	r3, [sp, #0]
 80049dc:	4663      	mov	r3, ip
 80049de:	687a      	ldr	r2, [r7, #4]
 80049e0:	4631      	mov	r1, r6
 80049e2:	4628      	mov	r0, r5
 80049e4:	f7ff fd9d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, ctx->W[14], 0x9BDC06A7 );
 80049e8:	6a7d      	ldr	r5, [r7, #36]	; 0x24
 80049ea:	6a3e      	ldr	r6, [r7, #32]
 80049ec:	69fb      	ldr	r3, [r7, #28]
 80049ee:	607b      	str	r3, [r7, #4]
 80049f0:	697b      	ldr	r3, [r7, #20]
 80049f2:	693a      	ldr	r2, [r7, #16]
 80049f4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80049f6:	68f8      	ldr	r0, [r7, #12]
 80049f8:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 80049fc:	f107 0c18 	add.w	ip, r7, #24
 8004a00:	4c91      	ldr	r4, [pc, #580]	; (8004c48 <B5_Sha256ProcessBlock+0x694>)
 8004a02:	9405      	str	r4, [sp, #20]
 8004a04:	9004      	str	r0, [sp, #16]
 8004a06:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8004a0a:	9003      	str	r0, [sp, #12]
 8004a0c:	9102      	str	r1, [sp, #8]
 8004a0e:	9201      	str	r2, [sp, #4]
 8004a10:	9300      	str	r3, [sp, #0]
 8004a12:	4663      	mov	r3, ip
 8004a14:	687a      	ldr	r2, [r7, #4]
 8004a16:	4631      	mov	r1, r6
 8004a18:	4628      	mov	r0, r5
 8004a1a:	f7ff fd82 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, ctx->W[15], 0xC19BF174 );
 8004a1e:	6abd      	ldr	r5, [r7, #40]	; 0x28
 8004a20:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8004a22:	6a3b      	ldr	r3, [r7, #32]
 8004a24:	607b      	str	r3, [r7, #4]
 8004a26:	69bb      	ldr	r3, [r7, #24]
 8004a28:	697a      	ldr	r2, [r7, #20]
 8004a2a:	6939      	ldr	r1, [r7, #16]
 8004a2c:	68f8      	ldr	r0, [r7, #12]
 8004a2e:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004a32:	f107 0c1c 	add.w	ip, r7, #28
 8004a36:	4c85      	ldr	r4, [pc, #532]	; (8004c4c <B5_Sha256ProcessBlock+0x698>)
 8004a38:	9405      	str	r4, [sp, #20]
 8004a3a:	9004      	str	r0, [sp, #16]
 8004a3c:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8004a40:	9003      	str	r0, [sp, #12]
 8004a42:	9102      	str	r1, [sp, #8]
 8004a44:	9201      	str	r2, [sp, #4]
 8004a46:	9300      	str	r3, [sp, #0]
 8004a48:	4663      	mov	r3, ip
 8004a4a:	687a      	ldr	r2, [r7, #4]
 8004a4c:	4631      	mov	r1, r6
 8004a4e:	4628      	mov	r0, r5
 8004a50:	f7ff fd67 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(16), 0xE49B69C1 );
 8004a54:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8004a56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004a58:	607b      	str	r3, [r7, #4]
 8004a5a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004a5c:	603a      	str	r2, [r7, #0]
 8004a5e:	69fb      	ldr	r3, [r7, #28]
 8004a60:	69ba      	ldr	r2, [r7, #24]
 8004a62:	6979      	ldr	r1, [r7, #20]
 8004a64:	68f8      	ldr	r0, [r7, #12]
 8004a66:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 8004a6a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004a6e:	68f8      	ldr	r0, [r7, #12]
 8004a70:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 8004a74:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004a78:	4044      	eors	r4, r0
 8004a7a:	68f8      	ldr	r0, [r7, #12]
 8004a7c:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 8004a80:	0a80      	lsrs	r0, r0, #10
 8004a82:	4044      	eors	r4, r0
 8004a84:	68f8      	ldr	r0, [r7, #12]
 8004a86:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 8004a8a:	4404      	add	r4, r0
 8004a8c:	68f8      	ldr	r0, [r7, #12]
 8004a8e:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8004a90:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004a94:	68f8      	ldr	r0, [r7, #12]
 8004a96:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8004a98:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004a9c:	4045      	eors	r5, r0
 8004a9e:	68f8      	ldr	r0, [r7, #12]
 8004aa0:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8004aa2:	08c0      	lsrs	r0, r0, #3
 8004aa4:	4068      	eors	r0, r5
 8004aa6:	4404      	add	r4, r0
 8004aa8:	68f8      	ldr	r0, [r7, #12]
 8004aaa:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8004aac:	4404      	add	r4, r0
 8004aae:	68f8      	ldr	r0, [r7, #12]
 8004ab0:	f8c0 40a8 	str.w	r4, [r0, #168]	; 0xa8
 8004ab4:	68f8      	ldr	r0, [r7, #12]
 8004ab6:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8004aba:	f107 0520 	add.w	r5, r7, #32
 8004abe:	4c64      	ldr	r4, [pc, #400]	; (8004c50 <B5_Sha256ProcessBlock+0x69c>)
 8004ac0:	9405      	str	r4, [sp, #20]
 8004ac2:	9004      	str	r0, [sp, #16]
 8004ac4:	f107 0010 	add.w	r0, r7, #16
 8004ac8:	9003      	str	r0, [sp, #12]
 8004aca:	9102      	str	r1, [sp, #8]
 8004acc:	9201      	str	r2, [sp, #4]
 8004ace:	9300      	str	r3, [sp, #0]
 8004ad0:	462b      	mov	r3, r5
 8004ad2:	683a      	ldr	r2, [r7, #0]
 8004ad4:	6879      	ldr	r1, [r7, #4]
 8004ad6:	4630      	mov	r0, r6
 8004ad8:	f7ff fd23 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(17), 0xEFBE4786 );
 8004adc:	693e      	ldr	r6, [r7, #16]
 8004ade:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004ae0:	607b      	str	r3, [r7, #4]
 8004ae2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004ae4:	603a      	str	r2, [r7, #0]
 8004ae6:	6a3b      	ldr	r3, [r7, #32]
 8004ae8:	69fa      	ldr	r2, [r7, #28]
 8004aea:	69b9      	ldr	r1, [r7, #24]
 8004aec:	68f8      	ldr	r0, [r7, #12]
 8004aee:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004af2:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004af6:	68f8      	ldr	r0, [r7, #12]
 8004af8:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004afc:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004b00:	4044      	eors	r4, r0
 8004b02:	68f8      	ldr	r0, [r7, #12]
 8004b04:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004b08:	0a80      	lsrs	r0, r0, #10
 8004b0a:	4044      	eors	r4, r0
 8004b0c:	68f8      	ldr	r0, [r7, #12]
 8004b0e:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8004b12:	4404      	add	r4, r0
 8004b14:	68f8      	ldr	r0, [r7, #12]
 8004b16:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004b18:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004b1c:	68f8      	ldr	r0, [r7, #12]
 8004b1e:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004b20:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004b24:	4045      	eors	r5, r0
 8004b26:	68f8      	ldr	r0, [r7, #12]
 8004b28:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004b2a:	08c0      	lsrs	r0, r0, #3
 8004b2c:	4068      	eors	r0, r5
 8004b2e:	4404      	add	r4, r0
 8004b30:	68f8      	ldr	r0, [r7, #12]
 8004b32:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8004b34:	4404      	add	r4, r0
 8004b36:	68f8      	ldr	r0, [r7, #12]
 8004b38:	f8c0 40ac 	str.w	r4, [r0, #172]	; 0xac
 8004b3c:	68f8      	ldr	r0, [r7, #12]
 8004b3e:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8004b42:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8004b46:	4c43      	ldr	r4, [pc, #268]	; (8004c54 <B5_Sha256ProcessBlock+0x6a0>)
 8004b48:	9405      	str	r4, [sp, #20]
 8004b4a:	9004      	str	r0, [sp, #16]
 8004b4c:	f107 0014 	add.w	r0, r7, #20
 8004b50:	9003      	str	r0, [sp, #12]
 8004b52:	9102      	str	r1, [sp, #8]
 8004b54:	9201      	str	r2, [sp, #4]
 8004b56:	9300      	str	r3, [sp, #0]
 8004b58:	462b      	mov	r3, r5
 8004b5a:	683a      	ldr	r2, [r7, #0]
 8004b5c:	6879      	ldr	r1, [r7, #4]
 8004b5e:	4630      	mov	r0, r6
 8004b60:	f7ff fcdf 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(18), 0x0FC19DC6 );
 8004b64:	697e      	ldr	r6, [r7, #20]
 8004b66:	693b      	ldr	r3, [r7, #16]
 8004b68:	607b      	str	r3, [r7, #4]
 8004b6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004b6c:	603a      	str	r2, [r7, #0]
 8004b6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004b70:	6a3a      	ldr	r2, [r7, #32]
 8004b72:	69f9      	ldr	r1, [r7, #28]
 8004b74:	68f8      	ldr	r0, [r7, #12]
 8004b76:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8004b7a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004b7e:	68f8      	ldr	r0, [r7, #12]
 8004b80:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8004b84:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004b88:	4044      	eors	r4, r0
 8004b8a:	68f8      	ldr	r0, [r7, #12]
 8004b8c:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8004b90:	0a80      	lsrs	r0, r0, #10
 8004b92:	4044      	eors	r4, r0
 8004b94:	68f8      	ldr	r0, [r7, #12]
 8004b96:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 8004b9a:	4404      	add	r4, r0
 8004b9c:	68f8      	ldr	r0, [r7, #12]
 8004b9e:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8004ba0:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004ba4:	68f8      	ldr	r0, [r7, #12]
 8004ba6:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8004ba8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004bac:	4045      	eors	r5, r0
 8004bae:	68f8      	ldr	r0, [r7, #12]
 8004bb0:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8004bb2:	08c0      	lsrs	r0, r0, #3
 8004bb4:	4068      	eors	r0, r5
 8004bb6:	4404      	add	r4, r0
 8004bb8:	68f8      	ldr	r0, [r7, #12]
 8004bba:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8004bbc:	4404      	add	r4, r0
 8004bbe:	68f8      	ldr	r0, [r7, #12]
 8004bc0:	f8c0 40b0 	str.w	r4, [r0, #176]	; 0xb0
 8004bc4:	68f8      	ldr	r0, [r7, #12]
 8004bc6:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8004bca:	f107 0528 	add.w	r5, r7, #40	; 0x28
 8004bce:	4c22      	ldr	r4, [pc, #136]	; (8004c58 <B5_Sha256ProcessBlock+0x6a4>)
 8004bd0:	9405      	str	r4, [sp, #20]
 8004bd2:	9004      	str	r0, [sp, #16]
 8004bd4:	f107 0018 	add.w	r0, r7, #24
 8004bd8:	9003      	str	r0, [sp, #12]
 8004bda:	9102      	str	r1, [sp, #8]
 8004bdc:	9201      	str	r2, [sp, #4]
 8004bde:	9300      	str	r3, [sp, #0]
 8004be0:	462b      	mov	r3, r5
 8004be2:	683a      	ldr	r2, [r7, #0]
 8004be4:	6879      	ldr	r1, [r7, #4]
 8004be6:	4630      	mov	r0, r6
 8004be8:	f7ff fc9b 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(19), 0x240CA1CC );
 8004bec:	69be      	ldr	r6, [r7, #24]
 8004bee:	697b      	ldr	r3, [r7, #20]
 8004bf0:	607b      	str	r3, [r7, #4]
 8004bf2:	693a      	ldr	r2, [r7, #16]
 8004bf4:	603a      	str	r2, [r7, #0]
 8004bf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004bf8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004bfa:	6a39      	ldr	r1, [r7, #32]
 8004bfc:	68f8      	ldr	r0, [r7, #12]
 8004bfe:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8004c02:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004c06:	68f8      	ldr	r0, [r7, #12]
 8004c08:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8004c0c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004c10:	4044      	eors	r4, r0
 8004c12:	68f8      	ldr	r0, [r7, #12]
 8004c14:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8004c18:	0a80      	lsrs	r0, r0, #10
 8004c1a:	4044      	eors	r4, r0
 8004c1c:	68f8      	ldr	r0, [r7, #12]
 8004c1e:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 8004c22:	4404      	add	r4, r0
 8004c24:	68f8      	ldr	r0, [r7, #12]
 8004c26:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8004c28:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004c2c:	68f8      	ldr	r0, [r7, #12]
 8004c2e:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8004c30:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004c34:	4045      	eors	r5, r0
 8004c36:	68f8      	ldr	r0, [r7, #12]
 8004c38:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8004c3a:	08c0      	lsrs	r0, r0, #3
 8004c3c:	4068      	eors	r0, r5
 8004c3e:	e00d      	b.n	8004c5c <B5_Sha256ProcessBlock+0x6a8>
 8004c40:	72be5d74 	.word	0x72be5d74
 8004c44:	80deb1fe 	.word	0x80deb1fe
 8004c48:	9bdc06a7 	.word	0x9bdc06a7
 8004c4c:	c19bf174 	.word	0xc19bf174
 8004c50:	e49b69c1 	.word	0xe49b69c1
 8004c54:	efbe4786 	.word	0xefbe4786
 8004c58:	0fc19dc6 	.word	0x0fc19dc6
 8004c5c:	4404      	add	r4, r0
 8004c5e:	68f8      	ldr	r0, [r7, #12]
 8004c60:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8004c62:	4404      	add	r4, r0
 8004c64:	68f8      	ldr	r0, [r7, #12]
 8004c66:	f8c0 40b4 	str.w	r4, [r0, #180]	; 0xb4
 8004c6a:	68f8      	ldr	r0, [r7, #12]
 8004c6c:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 8004c70:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8004c74:	4cb5      	ldr	r4, [pc, #724]	; (8004f4c <B5_Sha256ProcessBlock+0x998>)
 8004c76:	9405      	str	r4, [sp, #20]
 8004c78:	9004      	str	r0, [sp, #16]
 8004c7a:	f107 001c 	add.w	r0, r7, #28
 8004c7e:	9003      	str	r0, [sp, #12]
 8004c80:	9102      	str	r1, [sp, #8]
 8004c82:	9201      	str	r2, [sp, #4]
 8004c84:	9300      	str	r3, [sp, #0]
 8004c86:	462b      	mov	r3, r5
 8004c88:	683a      	ldr	r2, [r7, #0]
 8004c8a:	6879      	ldr	r1, [r7, #4]
 8004c8c:	4630      	mov	r0, r6
 8004c8e:	f7ff fc48 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(20), 0x2DE92C6F );
 8004c92:	69fe      	ldr	r6, [r7, #28]
 8004c94:	69bb      	ldr	r3, [r7, #24]
 8004c96:	607b      	str	r3, [r7, #4]
 8004c98:	697a      	ldr	r2, [r7, #20]
 8004c9a:	603a      	str	r2, [r7, #0]
 8004c9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004c9e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004ca0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8004ca2:	68f8      	ldr	r0, [r7, #12]
 8004ca4:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8004ca8:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004cac:	68f8      	ldr	r0, [r7, #12]
 8004cae:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8004cb2:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004cb6:	4044      	eors	r4, r0
 8004cb8:	68f8      	ldr	r0, [r7, #12]
 8004cba:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8004cbe:	0a80      	lsrs	r0, r0, #10
 8004cc0:	4044      	eors	r4, r0
 8004cc2:	68f8      	ldr	r0, [r7, #12]
 8004cc4:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 8004cc8:	4404      	add	r4, r0
 8004cca:	68f8      	ldr	r0, [r7, #12]
 8004ccc:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8004cce:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004cd2:	68f8      	ldr	r0, [r7, #12]
 8004cd4:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8004cd6:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004cda:	4045      	eors	r5, r0
 8004cdc:	68f8      	ldr	r0, [r7, #12]
 8004cde:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8004ce0:	08c0      	lsrs	r0, r0, #3
 8004ce2:	4068      	eors	r0, r5
 8004ce4:	4404      	add	r4, r0
 8004ce6:	68f8      	ldr	r0, [r7, #12]
 8004ce8:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8004cea:	4404      	add	r4, r0
 8004cec:	68f8      	ldr	r0, [r7, #12]
 8004cee:	f8c0 40b8 	str.w	r4, [r0, #184]	; 0xb8
 8004cf2:	68f8      	ldr	r0, [r7, #12]
 8004cf4:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8004cf8:	f107 0510 	add.w	r5, r7, #16
 8004cfc:	4c94      	ldr	r4, [pc, #592]	; (8004f50 <B5_Sha256ProcessBlock+0x99c>)
 8004cfe:	9405      	str	r4, [sp, #20]
 8004d00:	9004      	str	r0, [sp, #16]
 8004d02:	f107 0020 	add.w	r0, r7, #32
 8004d06:	9003      	str	r0, [sp, #12]
 8004d08:	9102      	str	r1, [sp, #8]
 8004d0a:	9201      	str	r2, [sp, #4]
 8004d0c:	9300      	str	r3, [sp, #0]
 8004d0e:	462b      	mov	r3, r5
 8004d10:	683a      	ldr	r2, [r7, #0]
 8004d12:	6879      	ldr	r1, [r7, #4]
 8004d14:	4630      	mov	r0, r6
 8004d16:	f7ff fc04 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(21), 0x4A7484AA );
 8004d1a:	6a3e      	ldr	r6, [r7, #32]
 8004d1c:	69fb      	ldr	r3, [r7, #28]
 8004d1e:	607b      	str	r3, [r7, #4]
 8004d20:	69ba      	ldr	r2, [r7, #24]
 8004d22:	603a      	str	r2, [r7, #0]
 8004d24:	693b      	ldr	r3, [r7, #16]
 8004d26:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004d28:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8004d2a:	68f8      	ldr	r0, [r7, #12]
 8004d2c:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 8004d30:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004d34:	68f8      	ldr	r0, [r7, #12]
 8004d36:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 8004d3a:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004d3e:	4044      	eors	r4, r0
 8004d40:	68f8      	ldr	r0, [r7, #12]
 8004d42:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 8004d46:	0a80      	lsrs	r0, r0, #10
 8004d48:	4044      	eors	r4, r0
 8004d4a:	68f8      	ldr	r0, [r7, #12]
 8004d4c:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 8004d50:	4404      	add	r4, r0
 8004d52:	68f8      	ldr	r0, [r7, #12]
 8004d54:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8004d58:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004d5c:	68f8      	ldr	r0, [r7, #12]
 8004d5e:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8004d62:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004d66:	4045      	eors	r5, r0
 8004d68:	68f8      	ldr	r0, [r7, #12]
 8004d6a:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8004d6e:	08c0      	lsrs	r0, r0, #3
 8004d70:	4068      	eors	r0, r5
 8004d72:	4404      	add	r4, r0
 8004d74:	68f8      	ldr	r0, [r7, #12]
 8004d76:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8004d78:	4404      	add	r4, r0
 8004d7a:	68f8      	ldr	r0, [r7, #12]
 8004d7c:	f8c0 40bc 	str.w	r4, [r0, #188]	; 0xbc
 8004d80:	68f8      	ldr	r0, [r7, #12]
 8004d82:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8004d86:	f107 0514 	add.w	r5, r7, #20
 8004d8a:	4c72      	ldr	r4, [pc, #456]	; (8004f54 <B5_Sha256ProcessBlock+0x9a0>)
 8004d8c:	9405      	str	r4, [sp, #20]
 8004d8e:	9004      	str	r0, [sp, #16]
 8004d90:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8004d94:	9003      	str	r0, [sp, #12]
 8004d96:	9102      	str	r1, [sp, #8]
 8004d98:	9201      	str	r2, [sp, #4]
 8004d9a:	9300      	str	r3, [sp, #0]
 8004d9c:	462b      	mov	r3, r5
 8004d9e:	683a      	ldr	r2, [r7, #0]
 8004da0:	6879      	ldr	r1, [r7, #4]
 8004da2:	4630      	mov	r0, r6
 8004da4:	f7ff fbbd 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(22), 0x5CB0A9DC );
 8004da8:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8004daa:	6a3b      	ldr	r3, [r7, #32]
 8004dac:	607b      	str	r3, [r7, #4]
 8004dae:	69fa      	ldr	r2, [r7, #28]
 8004db0:	603a      	str	r2, [r7, #0]
 8004db2:	697b      	ldr	r3, [r7, #20]
 8004db4:	693a      	ldr	r2, [r7, #16]
 8004db6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004db8:	68f8      	ldr	r0, [r7, #12]
 8004dba:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8004dbe:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004dc2:	68f8      	ldr	r0, [r7, #12]
 8004dc4:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8004dc8:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004dcc:	4044      	eors	r4, r0
 8004dce:	68f8      	ldr	r0, [r7, #12]
 8004dd0:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8004dd4:	0a80      	lsrs	r0, r0, #10
 8004dd6:	4044      	eors	r4, r0
 8004dd8:	68f8      	ldr	r0, [r7, #12]
 8004dda:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8004dde:	4404      	add	r4, r0
 8004de0:	68f8      	ldr	r0, [r7, #12]
 8004de2:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004de6:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004dea:	68f8      	ldr	r0, [r7, #12]
 8004dec:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004df0:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004df4:	4045      	eors	r5, r0
 8004df6:	68f8      	ldr	r0, [r7, #12]
 8004df8:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004dfc:	08c0      	lsrs	r0, r0, #3
 8004dfe:	4068      	eors	r0, r5
 8004e00:	4404      	add	r4, r0
 8004e02:	68f8      	ldr	r0, [r7, #12]
 8004e04:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8004e08:	4404      	add	r4, r0
 8004e0a:	68f8      	ldr	r0, [r7, #12]
 8004e0c:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
 8004e10:	68f8      	ldr	r0, [r7, #12]
 8004e12:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 8004e16:	f107 0518 	add.w	r5, r7, #24
 8004e1a:	4c4f      	ldr	r4, [pc, #316]	; (8004f58 <B5_Sha256ProcessBlock+0x9a4>)
 8004e1c:	9405      	str	r4, [sp, #20]
 8004e1e:	9004      	str	r0, [sp, #16]
 8004e20:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8004e24:	9003      	str	r0, [sp, #12]
 8004e26:	9102      	str	r1, [sp, #8]
 8004e28:	9201      	str	r2, [sp, #4]
 8004e2a:	9300      	str	r3, [sp, #0]
 8004e2c:	462b      	mov	r3, r5
 8004e2e:	683a      	ldr	r2, [r7, #0]
 8004e30:	6879      	ldr	r1, [r7, #4]
 8004e32:	4630      	mov	r0, r6
 8004e34:	f7ff fb75 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(23), 0x76F988DA );
 8004e38:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8004e3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004e3c:	607b      	str	r3, [r7, #4]
 8004e3e:	6a3a      	ldr	r2, [r7, #32]
 8004e40:	603a      	str	r2, [r7, #0]
 8004e42:	69bb      	ldr	r3, [r7, #24]
 8004e44:	697a      	ldr	r2, [r7, #20]
 8004e46:	6939      	ldr	r1, [r7, #16]
 8004e48:	68f8      	ldr	r0, [r7, #12]
 8004e4a:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8004e4e:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004e52:	68f8      	ldr	r0, [r7, #12]
 8004e54:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8004e58:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004e5c:	4044      	eors	r4, r0
 8004e5e:	68f8      	ldr	r0, [r7, #12]
 8004e60:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8004e64:	0a80      	lsrs	r0, r0, #10
 8004e66:	4044      	eors	r4, r0
 8004e68:	68f8      	ldr	r0, [r7, #12]
 8004e6a:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8004e6e:	4404      	add	r4, r0
 8004e70:	68f8      	ldr	r0, [r7, #12]
 8004e72:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004e76:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004e7a:	68f8      	ldr	r0, [r7, #12]
 8004e7c:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004e80:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004e84:	4045      	eors	r5, r0
 8004e86:	68f8      	ldr	r0, [r7, #12]
 8004e88:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004e8c:	08c0      	lsrs	r0, r0, #3
 8004e8e:	4068      	eors	r0, r5
 8004e90:	4404      	add	r4, r0
 8004e92:	68f8      	ldr	r0, [r7, #12]
 8004e94:	f8d0 0084 	ldr.w	r0, [r0, #132]	; 0x84
 8004e98:	4404      	add	r4, r0
 8004e9a:	68f8      	ldr	r0, [r7, #12]
 8004e9c:	f8c0 40c4 	str.w	r4, [r0, #196]	; 0xc4
 8004ea0:	68f8      	ldr	r0, [r7, #12]
 8004ea2:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8004ea6:	f107 051c 	add.w	r5, r7, #28
 8004eaa:	4c2c      	ldr	r4, [pc, #176]	; (8004f5c <B5_Sha256ProcessBlock+0x9a8>)
 8004eac:	9405      	str	r4, [sp, #20]
 8004eae:	9004      	str	r0, [sp, #16]
 8004eb0:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8004eb4:	9003      	str	r0, [sp, #12]
 8004eb6:	9102      	str	r1, [sp, #8]
 8004eb8:	9201      	str	r2, [sp, #4]
 8004eba:	9300      	str	r3, [sp, #0]
 8004ebc:	462b      	mov	r3, r5
 8004ebe:	683a      	ldr	r2, [r7, #0]
 8004ec0:	6879      	ldr	r1, [r7, #4]
 8004ec2:	4630      	mov	r0, r6
 8004ec4:	f7ff fb2d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(24), 0x983E5152 );
 8004ec8:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8004eca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004ecc:	607b      	str	r3, [r7, #4]
 8004ece:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8004ed0:	603a      	str	r2, [r7, #0]
 8004ed2:	69fb      	ldr	r3, [r7, #28]
 8004ed4:	69ba      	ldr	r2, [r7, #24]
 8004ed6:	6979      	ldr	r1, [r7, #20]
 8004ed8:	68f8      	ldr	r0, [r7, #12]
 8004eda:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 8004ede:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004ee2:	68f8      	ldr	r0, [r7, #12]
 8004ee4:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 8004ee8:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004eec:	4044      	eors	r4, r0
 8004eee:	68f8      	ldr	r0, [r7, #12]
 8004ef0:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 8004ef4:	0a80      	lsrs	r0, r0, #10
 8004ef6:	4044      	eors	r4, r0
 8004ef8:	68f8      	ldr	r0, [r7, #12]
 8004efa:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8004efe:	4404      	add	r4, r0
 8004f00:	68f8      	ldr	r0, [r7, #12]
 8004f02:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 8004f06:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004f0a:	68f8      	ldr	r0, [r7, #12]
 8004f0c:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 8004f10:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004f14:	4045      	eors	r5, r0
 8004f16:	68f8      	ldr	r0, [r7, #12]
 8004f18:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 8004f1c:	08c0      	lsrs	r0, r0, #3
 8004f1e:	4068      	eors	r0, r5
 8004f20:	4404      	add	r4, r0
 8004f22:	68f8      	ldr	r0, [r7, #12]
 8004f24:	f8d0 0088 	ldr.w	r0, [r0, #136]	; 0x88
 8004f28:	4404      	add	r4, r0
 8004f2a:	68f8      	ldr	r0, [r7, #12]
 8004f2c:	f8c0 40c8 	str.w	r4, [r0, #200]	; 0xc8
 8004f30:	68f8      	ldr	r0, [r7, #12]
 8004f32:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 8004f36:	f107 0520 	add.w	r5, r7, #32
 8004f3a:	4c09      	ldr	r4, [pc, #36]	; (8004f60 <B5_Sha256ProcessBlock+0x9ac>)
 8004f3c:	9405      	str	r4, [sp, #20]
 8004f3e:	9004      	str	r0, [sp, #16]
 8004f40:	f107 0010 	add.w	r0, r7, #16
 8004f44:	9003      	str	r0, [sp, #12]
 8004f46:	9102      	str	r1, [sp, #8]
 8004f48:	e00c      	b.n	8004f64 <B5_Sha256ProcessBlock+0x9b0>
 8004f4a:	bf00      	nop
 8004f4c:	240ca1cc 	.word	0x240ca1cc
 8004f50:	2de92c6f 	.word	0x2de92c6f
 8004f54:	4a7484aa 	.word	0x4a7484aa
 8004f58:	5cb0a9dc 	.word	0x5cb0a9dc
 8004f5c:	76f988da 	.word	0x76f988da
 8004f60:	983e5152 	.word	0x983e5152
 8004f64:	9201      	str	r2, [sp, #4]
 8004f66:	9300      	str	r3, [sp, #0]
 8004f68:	462b      	mov	r3, r5
 8004f6a:	683a      	ldr	r2, [r7, #0]
 8004f6c:	6879      	ldr	r1, [r7, #4]
 8004f6e:	4630      	mov	r0, r6
 8004f70:	f7ff fad7 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(25), 0xA831C66D );
 8004f74:	693e      	ldr	r6, [r7, #16]
 8004f76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004f78:	607b      	str	r3, [r7, #4]
 8004f7a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004f7c:	603a      	str	r2, [r7, #0]
 8004f7e:	6a3b      	ldr	r3, [r7, #32]
 8004f80:	69fa      	ldr	r2, [r7, #28]
 8004f82:	69b9      	ldr	r1, [r7, #24]
 8004f84:	68f8      	ldr	r0, [r7, #12]
 8004f86:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8004f8a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8004f8e:	68f8      	ldr	r0, [r7, #12]
 8004f90:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8004f94:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8004f98:	4044      	eors	r4, r0
 8004f9a:	68f8      	ldr	r0, [r7, #12]
 8004f9c:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8004fa0:	0a80      	lsrs	r0, r0, #10
 8004fa2:	4044      	eors	r4, r0
 8004fa4:	68f8      	ldr	r0, [r7, #12]
 8004fa6:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8004faa:	4404      	add	r4, r0
 8004fac:	68f8      	ldr	r0, [r7, #12]
 8004fae:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8004fb2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8004fb6:	68f8      	ldr	r0, [r7, #12]
 8004fb8:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8004fbc:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8004fc0:	4045      	eors	r5, r0
 8004fc2:	68f8      	ldr	r0, [r7, #12]
 8004fc4:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8004fc8:	08c0      	lsrs	r0, r0, #3
 8004fca:	4068      	eors	r0, r5
 8004fcc:	4404      	add	r4, r0
 8004fce:	68f8      	ldr	r0, [r7, #12]
 8004fd0:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
 8004fd4:	4404      	add	r4, r0
 8004fd6:	68f8      	ldr	r0, [r7, #12]
 8004fd8:	f8c0 40cc 	str.w	r4, [r0, #204]	; 0xcc
 8004fdc:	68f8      	ldr	r0, [r7, #12]
 8004fde:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 8004fe2:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8004fe6:	4cb8      	ldr	r4, [pc, #736]	; (80052c8 <B5_Sha256ProcessBlock+0xd14>)
 8004fe8:	9405      	str	r4, [sp, #20]
 8004fea:	9004      	str	r0, [sp, #16]
 8004fec:	f107 0014 	add.w	r0, r7, #20
 8004ff0:	9003      	str	r0, [sp, #12]
 8004ff2:	9102      	str	r1, [sp, #8]
 8004ff4:	9201      	str	r2, [sp, #4]
 8004ff6:	9300      	str	r3, [sp, #0]
 8004ff8:	462b      	mov	r3, r5
 8004ffa:	683a      	ldr	r2, [r7, #0]
 8004ffc:	6879      	ldr	r1, [r7, #4]
 8004ffe:	4630      	mov	r0, r6
 8005000:	f7ff fa8f 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(26), 0xB00327C8 );
 8005004:	697e      	ldr	r6, [r7, #20]
 8005006:	693b      	ldr	r3, [r7, #16]
 8005008:	607b      	str	r3, [r7, #4]
 800500a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800500c:	603a      	str	r2, [r7, #0]
 800500e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005010:	6a3a      	ldr	r2, [r7, #32]
 8005012:	69f9      	ldr	r1, [r7, #28]
 8005014:	68f8      	ldr	r0, [r7, #12]
 8005016:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 800501a:	ea4f 4470 	mov.w	r4, r0, ror #17
 800501e:	68f8      	ldr	r0, [r7, #12]
 8005020:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 8005024:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005028:	4044      	eors	r4, r0
 800502a:	68f8      	ldr	r0, [r7, #12]
 800502c:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 8005030:	0a80      	lsrs	r0, r0, #10
 8005032:	4044      	eors	r4, r0
 8005034:	68f8      	ldr	r0, [r7, #12]
 8005036:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 800503a:	4404      	add	r4, r0
 800503c:	68f8      	ldr	r0, [r7, #12]
 800503e:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 8005042:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005046:	68f8      	ldr	r0, [r7, #12]
 8005048:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 800504c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005050:	4045      	eors	r5, r0
 8005052:	68f8      	ldr	r0, [r7, #12]
 8005054:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 8005058:	08c0      	lsrs	r0, r0, #3
 800505a:	4068      	eors	r0, r5
 800505c:	4404      	add	r4, r0
 800505e:	68f8      	ldr	r0, [r7, #12]
 8005060:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
 8005064:	4404      	add	r4, r0
 8005066:	68f8      	ldr	r0, [r7, #12]
 8005068:	f8c0 40d0 	str.w	r4, [r0, #208]	; 0xd0
 800506c:	68f8      	ldr	r0, [r7, #12]
 800506e:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 8005072:	f107 0528 	add.w	r5, r7, #40	; 0x28
 8005076:	4c95      	ldr	r4, [pc, #596]	; (80052cc <B5_Sha256ProcessBlock+0xd18>)
 8005078:	9405      	str	r4, [sp, #20]
 800507a:	9004      	str	r0, [sp, #16]
 800507c:	f107 0018 	add.w	r0, r7, #24
 8005080:	9003      	str	r0, [sp, #12]
 8005082:	9102      	str	r1, [sp, #8]
 8005084:	9201      	str	r2, [sp, #4]
 8005086:	9300      	str	r3, [sp, #0]
 8005088:	462b      	mov	r3, r5
 800508a:	683a      	ldr	r2, [r7, #0]
 800508c:	6879      	ldr	r1, [r7, #4]
 800508e:	4630      	mov	r0, r6
 8005090:	f7ff fa47 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(27), 0xBF597FC7 );
 8005094:	69be      	ldr	r6, [r7, #24]
 8005096:	697b      	ldr	r3, [r7, #20]
 8005098:	607b      	str	r3, [r7, #4]
 800509a:	693a      	ldr	r2, [r7, #16]
 800509c:	603a      	str	r2, [r7, #0]
 800509e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80050a0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80050a2:	6a39      	ldr	r1, [r7, #32]
 80050a4:	68f8      	ldr	r0, [r7, #12]
 80050a6:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 80050aa:	ea4f 4470 	mov.w	r4, r0, ror #17
 80050ae:	68f8      	ldr	r0, [r7, #12]
 80050b0:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 80050b4:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80050b8:	4044      	eors	r4, r0
 80050ba:	68f8      	ldr	r0, [r7, #12]
 80050bc:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 80050c0:	0a80      	lsrs	r0, r0, #10
 80050c2:	4044      	eors	r4, r0
 80050c4:	68f8      	ldr	r0, [r7, #12]
 80050c6:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 80050ca:	4404      	add	r4, r0
 80050cc:	68f8      	ldr	r0, [r7, #12]
 80050ce:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 80050d2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80050d6:	68f8      	ldr	r0, [r7, #12]
 80050d8:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 80050dc:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80050e0:	4045      	eors	r5, r0
 80050e2:	68f8      	ldr	r0, [r7, #12]
 80050e4:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 80050e8:	08c0      	lsrs	r0, r0, #3
 80050ea:	4068      	eors	r0, r5
 80050ec:	4404      	add	r4, r0
 80050ee:	68f8      	ldr	r0, [r7, #12]
 80050f0:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
 80050f4:	4404      	add	r4, r0
 80050f6:	68f8      	ldr	r0, [r7, #12]
 80050f8:	f8c0 40d4 	str.w	r4, [r0, #212]	; 0xd4
 80050fc:	68f8      	ldr	r0, [r7, #12]
 80050fe:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 8005102:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8005106:	4c72      	ldr	r4, [pc, #456]	; (80052d0 <B5_Sha256ProcessBlock+0xd1c>)
 8005108:	9405      	str	r4, [sp, #20]
 800510a:	9004      	str	r0, [sp, #16]
 800510c:	f107 001c 	add.w	r0, r7, #28
 8005110:	9003      	str	r0, [sp, #12]
 8005112:	9102      	str	r1, [sp, #8]
 8005114:	9201      	str	r2, [sp, #4]
 8005116:	9300      	str	r3, [sp, #0]
 8005118:	462b      	mov	r3, r5
 800511a:	683a      	ldr	r2, [r7, #0]
 800511c:	6879      	ldr	r1, [r7, #4]
 800511e:	4630      	mov	r0, r6
 8005120:	f7ff f9ff 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(28), 0xC6E00BF3 );
 8005124:	69fe      	ldr	r6, [r7, #28]
 8005126:	69bb      	ldr	r3, [r7, #24]
 8005128:	607b      	str	r3, [r7, #4]
 800512a:	697a      	ldr	r2, [r7, #20]
 800512c:	603a      	str	r2, [r7, #0]
 800512e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005130:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005132:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8005134:	68f8      	ldr	r0, [r7, #12]
 8005136:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 800513a:	ea4f 4470 	mov.w	r4, r0, ror #17
 800513e:	68f8      	ldr	r0, [r7, #12]
 8005140:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 8005144:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005148:	4044      	eors	r4, r0
 800514a:	68f8      	ldr	r0, [r7, #12]
 800514c:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 8005150:	0a80      	lsrs	r0, r0, #10
 8005152:	4044      	eors	r4, r0
 8005154:	68f8      	ldr	r0, [r7, #12]
 8005156:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 800515a:	4404      	add	r4, r0
 800515c:	68f8      	ldr	r0, [r7, #12]
 800515e:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 8005162:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005166:	68f8      	ldr	r0, [r7, #12]
 8005168:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 800516c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005170:	4045      	eors	r5, r0
 8005172:	68f8      	ldr	r0, [r7, #12]
 8005174:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 8005178:	08c0      	lsrs	r0, r0, #3
 800517a:	4068      	eors	r0, r5
 800517c:	4404      	add	r4, r0
 800517e:	68f8      	ldr	r0, [r7, #12]
 8005180:	f8d0 0098 	ldr.w	r0, [r0, #152]	; 0x98
 8005184:	4404      	add	r4, r0
 8005186:	68f8      	ldr	r0, [r7, #12]
 8005188:	f8c0 40d8 	str.w	r4, [r0, #216]	; 0xd8
 800518c:	68f8      	ldr	r0, [r7, #12]
 800518e:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005192:	f107 0510 	add.w	r5, r7, #16
 8005196:	4c4f      	ldr	r4, [pc, #316]	; (80052d4 <B5_Sha256ProcessBlock+0xd20>)
 8005198:	9405      	str	r4, [sp, #20]
 800519a:	9004      	str	r0, [sp, #16]
 800519c:	f107 0020 	add.w	r0, r7, #32
 80051a0:	9003      	str	r0, [sp, #12]
 80051a2:	9102      	str	r1, [sp, #8]
 80051a4:	9201      	str	r2, [sp, #4]
 80051a6:	9300      	str	r3, [sp, #0]
 80051a8:	462b      	mov	r3, r5
 80051aa:	683a      	ldr	r2, [r7, #0]
 80051ac:	6879      	ldr	r1, [r7, #4]
 80051ae:	4630      	mov	r0, r6
 80051b0:	f7ff f9b7 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(29), 0xD5A79147 );
 80051b4:	6a3e      	ldr	r6, [r7, #32]
 80051b6:	69fb      	ldr	r3, [r7, #28]
 80051b8:	607b      	str	r3, [r7, #4]
 80051ba:	69ba      	ldr	r2, [r7, #24]
 80051bc:	603a      	str	r2, [r7, #0]
 80051be:	693b      	ldr	r3, [r7, #16]
 80051c0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80051c2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80051c4:	68f8      	ldr	r0, [r7, #12]
 80051c6:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 80051ca:	ea4f 4470 	mov.w	r4, r0, ror #17
 80051ce:	68f8      	ldr	r0, [r7, #12]
 80051d0:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 80051d4:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80051d8:	4044      	eors	r4, r0
 80051da:	68f8      	ldr	r0, [r7, #12]
 80051dc:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 80051e0:	0a80      	lsrs	r0, r0, #10
 80051e2:	4044      	eors	r4, r0
 80051e4:	68f8      	ldr	r0, [r7, #12]
 80051e6:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 80051ea:	4404      	add	r4, r0
 80051ec:	68f8      	ldr	r0, [r7, #12]
 80051ee:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 80051f2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80051f6:	68f8      	ldr	r0, [r7, #12]
 80051f8:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 80051fc:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005200:	4045      	eors	r5, r0
 8005202:	68f8      	ldr	r0, [r7, #12]
 8005204:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 8005208:	08c0      	lsrs	r0, r0, #3
 800520a:	4068      	eors	r0, r5
 800520c:	4404      	add	r4, r0
 800520e:	68f8      	ldr	r0, [r7, #12]
 8005210:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
 8005214:	4404      	add	r4, r0
 8005216:	68f8      	ldr	r0, [r7, #12]
 8005218:	f8c0 40dc 	str.w	r4, [r0, #220]	; 0xdc
 800521c:	68f8      	ldr	r0, [r7, #12]
 800521e:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005222:	f107 0514 	add.w	r5, r7, #20
 8005226:	4c2c      	ldr	r4, [pc, #176]	; (80052d8 <B5_Sha256ProcessBlock+0xd24>)
 8005228:	9405      	str	r4, [sp, #20]
 800522a:	9004      	str	r0, [sp, #16]
 800522c:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8005230:	9003      	str	r0, [sp, #12]
 8005232:	9102      	str	r1, [sp, #8]
 8005234:	9201      	str	r2, [sp, #4]
 8005236:	9300      	str	r3, [sp, #0]
 8005238:	462b      	mov	r3, r5
 800523a:	683a      	ldr	r2, [r7, #0]
 800523c:	6879      	ldr	r1, [r7, #4]
 800523e:	4630      	mov	r0, r6
 8005240:	f7ff f96f 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(30), 0x06CA6351 );
 8005244:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8005246:	6a3b      	ldr	r3, [r7, #32]
 8005248:	607b      	str	r3, [r7, #4]
 800524a:	69fa      	ldr	r2, [r7, #28]
 800524c:	603a      	str	r2, [r7, #0]
 800524e:	697b      	ldr	r3, [r7, #20]
 8005250:	693a      	ldr	r2, [r7, #16]
 8005252:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005254:	68f8      	ldr	r0, [r7, #12]
 8005256:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 800525a:	ea4f 4470 	mov.w	r4, r0, ror #17
 800525e:	68f8      	ldr	r0, [r7, #12]
 8005260:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005264:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005268:	4044      	eors	r4, r0
 800526a:	68f8      	ldr	r0, [r7, #12]
 800526c:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005270:	0a80      	lsrs	r0, r0, #10
 8005272:	4044      	eors	r4, r0
 8005274:	68f8      	ldr	r0, [r7, #12]
 8005276:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 800527a:	4404      	add	r4, r0
 800527c:	68f8      	ldr	r0, [r7, #12]
 800527e:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8005282:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005286:	68f8      	ldr	r0, [r7, #12]
 8005288:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 800528c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005290:	4045      	eors	r5, r0
 8005292:	68f8      	ldr	r0, [r7, #12]
 8005294:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8005298:	08c0      	lsrs	r0, r0, #3
 800529a:	4068      	eors	r0, r5
 800529c:	4404      	add	r4, r0
 800529e:	68f8      	ldr	r0, [r7, #12]
 80052a0:	f8d0 00a0 	ldr.w	r0, [r0, #160]	; 0xa0
 80052a4:	4404      	add	r4, r0
 80052a6:	68f8      	ldr	r0, [r7, #12]
 80052a8:	f8c0 40e0 	str.w	r4, [r0, #224]	; 0xe0
 80052ac:	68f8      	ldr	r0, [r7, #12]
 80052ae:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 80052b2:	f107 0518 	add.w	r5, r7, #24
 80052b6:	4c09      	ldr	r4, [pc, #36]	; (80052dc <B5_Sha256ProcessBlock+0xd28>)
 80052b8:	9405      	str	r4, [sp, #20]
 80052ba:	9004      	str	r0, [sp, #16]
 80052bc:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80052c0:	9003      	str	r0, [sp, #12]
 80052c2:	9102      	str	r1, [sp, #8]
 80052c4:	e00c      	b.n	80052e0 <B5_Sha256ProcessBlock+0xd2c>
 80052c6:	bf00      	nop
 80052c8:	a831c66d 	.word	0xa831c66d
 80052cc:	b00327c8 	.word	0xb00327c8
 80052d0:	bf597fc7 	.word	0xbf597fc7
 80052d4:	c6e00bf3 	.word	0xc6e00bf3
 80052d8:	d5a79147 	.word	0xd5a79147
 80052dc:	06ca6351 	.word	0x06ca6351
 80052e0:	9201      	str	r2, [sp, #4]
 80052e2:	9300      	str	r3, [sp, #0]
 80052e4:	462b      	mov	r3, r5
 80052e6:	683a      	ldr	r2, [r7, #0]
 80052e8:	6879      	ldr	r1, [r7, #4]
 80052ea:	4630      	mov	r0, r6
 80052ec:	f7ff f919 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(31), 0x14292967 );
 80052f0:	6abe      	ldr	r6, [r7, #40]	; 0x28
 80052f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80052f4:	607b      	str	r3, [r7, #4]
 80052f6:	6a3a      	ldr	r2, [r7, #32]
 80052f8:	603a      	str	r2, [r7, #0]
 80052fa:	69bb      	ldr	r3, [r7, #24]
 80052fc:	697a      	ldr	r2, [r7, #20]
 80052fe:	6939      	ldr	r1, [r7, #16]
 8005300:	68f8      	ldr	r0, [r7, #12]
 8005302:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005306:	ea4f 4470 	mov.w	r4, r0, ror #17
 800530a:	68f8      	ldr	r0, [r7, #12]
 800530c:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005310:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005314:	4044      	eors	r4, r0
 8005316:	68f8      	ldr	r0, [r7, #12]
 8005318:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 800531c:	0a80      	lsrs	r0, r0, #10
 800531e:	4044      	eors	r4, r0
 8005320:	68f8      	ldr	r0, [r7, #12]
 8005322:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 8005326:	4404      	add	r4, r0
 8005328:	68f8      	ldr	r0, [r7, #12]
 800532a:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 800532e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005332:	68f8      	ldr	r0, [r7, #12]
 8005334:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8005338:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800533c:	4045      	eors	r5, r0
 800533e:	68f8      	ldr	r0, [r7, #12]
 8005340:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 8005344:	08c0      	lsrs	r0, r0, #3
 8005346:	4068      	eors	r0, r5
 8005348:	4404      	add	r4, r0
 800534a:	68f8      	ldr	r0, [r7, #12]
 800534c:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
 8005350:	4404      	add	r4, r0
 8005352:	68f8      	ldr	r0, [r7, #12]
 8005354:	f8c0 40e4 	str.w	r4, [r0, #228]	; 0xe4
 8005358:	68f8      	ldr	r0, [r7, #12]
 800535a:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 800535e:	f107 051c 	add.w	r5, r7, #28
 8005362:	4cb8      	ldr	r4, [pc, #736]	; (8005644 <B5_Sha256ProcessBlock+0x1090>)
 8005364:	9405      	str	r4, [sp, #20]
 8005366:	9004      	str	r0, [sp, #16]
 8005368:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 800536c:	9003      	str	r0, [sp, #12]
 800536e:	9102      	str	r1, [sp, #8]
 8005370:	9201      	str	r2, [sp, #4]
 8005372:	9300      	str	r3, [sp, #0]
 8005374:	462b      	mov	r3, r5
 8005376:	683a      	ldr	r2, [r7, #0]
 8005378:	6879      	ldr	r1, [r7, #4]
 800537a:	4630      	mov	r0, r6
 800537c:	f7ff f8d1 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(32), 0x27B70A85 );
 8005380:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8005382:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005384:	607b      	str	r3, [r7, #4]
 8005386:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005388:	603a      	str	r2, [r7, #0]
 800538a:	69fb      	ldr	r3, [r7, #28]
 800538c:	69ba      	ldr	r2, [r7, #24]
 800538e:	6979      	ldr	r1, [r7, #20]
 8005390:	68f8      	ldr	r0, [r7, #12]
 8005392:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 8005396:	ea4f 4470 	mov.w	r4, r0, ror #17
 800539a:	68f8      	ldr	r0, [r7, #12]
 800539c:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 80053a0:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80053a4:	4044      	eors	r4, r0
 80053a6:	68f8      	ldr	r0, [r7, #12]
 80053a8:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 80053ac:	0a80      	lsrs	r0, r0, #10
 80053ae:	4044      	eors	r4, r0
 80053b0:	68f8      	ldr	r0, [r7, #12]
 80053b2:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 80053b6:	4404      	add	r4, r0
 80053b8:	68f8      	ldr	r0, [r7, #12]
 80053ba:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 80053be:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80053c2:	68f8      	ldr	r0, [r7, #12]
 80053c4:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 80053c8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80053cc:	4045      	eors	r5, r0
 80053ce:	68f8      	ldr	r0, [r7, #12]
 80053d0:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 80053d4:	08c0      	lsrs	r0, r0, #3
 80053d6:	4068      	eors	r0, r5
 80053d8:	4404      	add	r4, r0
 80053da:	68f8      	ldr	r0, [r7, #12]
 80053dc:	f8d0 00a8 	ldr.w	r0, [r0, #168]	; 0xa8
 80053e0:	4404      	add	r4, r0
 80053e2:	68f8      	ldr	r0, [r7, #12]
 80053e4:	f8c0 40e8 	str.w	r4, [r0, #232]	; 0xe8
 80053e8:	68f8      	ldr	r0, [r7, #12]
 80053ea:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 80053ee:	f107 0520 	add.w	r5, r7, #32
 80053f2:	4c95      	ldr	r4, [pc, #596]	; (8005648 <B5_Sha256ProcessBlock+0x1094>)
 80053f4:	9405      	str	r4, [sp, #20]
 80053f6:	9004      	str	r0, [sp, #16]
 80053f8:	f107 0010 	add.w	r0, r7, #16
 80053fc:	9003      	str	r0, [sp, #12]
 80053fe:	9102      	str	r1, [sp, #8]
 8005400:	9201      	str	r2, [sp, #4]
 8005402:	9300      	str	r3, [sp, #0]
 8005404:	462b      	mov	r3, r5
 8005406:	683a      	ldr	r2, [r7, #0]
 8005408:	6879      	ldr	r1, [r7, #4]
 800540a:	4630      	mov	r0, r6
 800540c:	f7ff f889 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(33), 0x2E1B2138 );
 8005410:	693e      	ldr	r6, [r7, #16]
 8005412:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005414:	607b      	str	r3, [r7, #4]
 8005416:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005418:	603a      	str	r2, [r7, #0]
 800541a:	6a3b      	ldr	r3, [r7, #32]
 800541c:	69fa      	ldr	r2, [r7, #28]
 800541e:	69b9      	ldr	r1, [r7, #24]
 8005420:	68f8      	ldr	r0, [r7, #12]
 8005422:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005426:	ea4f 4470 	mov.w	r4, r0, ror #17
 800542a:	68f8      	ldr	r0, [r7, #12]
 800542c:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005430:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005434:	4044      	eors	r4, r0
 8005436:	68f8      	ldr	r0, [r7, #12]
 8005438:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 800543c:	0a80      	lsrs	r0, r0, #10
 800543e:	4044      	eors	r4, r0
 8005440:	68f8      	ldr	r0, [r7, #12]
 8005442:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 8005446:	4404      	add	r4, r0
 8005448:	68f8      	ldr	r0, [r7, #12]
 800544a:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 800544e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005452:	68f8      	ldr	r0, [r7, #12]
 8005454:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8005458:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800545c:	4045      	eors	r5, r0
 800545e:	68f8      	ldr	r0, [r7, #12]
 8005460:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8005464:	08c0      	lsrs	r0, r0, #3
 8005466:	4068      	eors	r0, r5
 8005468:	4404      	add	r4, r0
 800546a:	68f8      	ldr	r0, [r7, #12]
 800546c:	f8d0 00ac 	ldr.w	r0, [r0, #172]	; 0xac
 8005470:	4404      	add	r4, r0
 8005472:	68f8      	ldr	r0, [r7, #12]
 8005474:	f8c0 40ec 	str.w	r4, [r0, #236]	; 0xec
 8005478:	68f8      	ldr	r0, [r7, #12]
 800547a:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800547e:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8005482:	4c72      	ldr	r4, [pc, #456]	; (800564c <B5_Sha256ProcessBlock+0x1098>)
 8005484:	9405      	str	r4, [sp, #20]
 8005486:	9004      	str	r0, [sp, #16]
 8005488:	f107 0014 	add.w	r0, r7, #20
 800548c:	9003      	str	r0, [sp, #12]
 800548e:	9102      	str	r1, [sp, #8]
 8005490:	9201      	str	r2, [sp, #4]
 8005492:	9300      	str	r3, [sp, #0]
 8005494:	462b      	mov	r3, r5
 8005496:	683a      	ldr	r2, [r7, #0]
 8005498:	6879      	ldr	r1, [r7, #4]
 800549a:	4630      	mov	r0, r6
 800549c:	f7ff f841 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(34), 0x4D2C6DFC );
 80054a0:	697e      	ldr	r6, [r7, #20]
 80054a2:	693b      	ldr	r3, [r7, #16]
 80054a4:	607b      	str	r3, [r7, #4]
 80054a6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80054a8:	603a      	str	r2, [r7, #0]
 80054aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80054ac:	6a3a      	ldr	r2, [r7, #32]
 80054ae:	69f9      	ldr	r1, [r7, #28]
 80054b0:	68f8      	ldr	r0, [r7, #12]
 80054b2:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 80054b6:	ea4f 4470 	mov.w	r4, r0, ror #17
 80054ba:	68f8      	ldr	r0, [r7, #12]
 80054bc:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 80054c0:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80054c4:	4044      	eors	r4, r0
 80054c6:	68f8      	ldr	r0, [r7, #12]
 80054c8:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 80054cc:	0a80      	lsrs	r0, r0, #10
 80054ce:	4044      	eors	r4, r0
 80054d0:	68f8      	ldr	r0, [r7, #12]
 80054d2:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 80054d6:	4404      	add	r4, r0
 80054d8:	68f8      	ldr	r0, [r7, #12]
 80054da:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 80054de:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80054e2:	68f8      	ldr	r0, [r7, #12]
 80054e4:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 80054e8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80054ec:	4045      	eors	r5, r0
 80054ee:	68f8      	ldr	r0, [r7, #12]
 80054f0:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 80054f4:	08c0      	lsrs	r0, r0, #3
 80054f6:	4068      	eors	r0, r5
 80054f8:	4404      	add	r4, r0
 80054fa:	68f8      	ldr	r0, [r7, #12]
 80054fc:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
 8005500:	4404      	add	r4, r0
 8005502:	68f8      	ldr	r0, [r7, #12]
 8005504:	f8c0 40f0 	str.w	r4, [r0, #240]	; 0xf0
 8005508:	68f8      	ldr	r0, [r7, #12]
 800550a:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 800550e:	f107 0528 	add.w	r5, r7, #40	; 0x28
 8005512:	4c4f      	ldr	r4, [pc, #316]	; (8005650 <B5_Sha256ProcessBlock+0x109c>)
 8005514:	9405      	str	r4, [sp, #20]
 8005516:	9004      	str	r0, [sp, #16]
 8005518:	f107 0018 	add.w	r0, r7, #24
 800551c:	9003      	str	r0, [sp, #12]
 800551e:	9102      	str	r1, [sp, #8]
 8005520:	9201      	str	r2, [sp, #4]
 8005522:	9300      	str	r3, [sp, #0]
 8005524:	462b      	mov	r3, r5
 8005526:	683a      	ldr	r2, [r7, #0]
 8005528:	6879      	ldr	r1, [r7, #4]
 800552a:	4630      	mov	r0, r6
 800552c:	f7fe fff9 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(35), 0x53380D13 );
 8005530:	69be      	ldr	r6, [r7, #24]
 8005532:	697b      	ldr	r3, [r7, #20]
 8005534:	607b      	str	r3, [r7, #4]
 8005536:	693a      	ldr	r2, [r7, #16]
 8005538:	603a      	str	r2, [r7, #0]
 800553a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800553c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800553e:	6a39      	ldr	r1, [r7, #32]
 8005540:	68f8      	ldr	r0, [r7, #12]
 8005542:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005546:	ea4f 4470 	mov.w	r4, r0, ror #17
 800554a:	68f8      	ldr	r0, [r7, #12]
 800554c:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005550:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005554:	4044      	eors	r4, r0
 8005556:	68f8      	ldr	r0, [r7, #12]
 8005558:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800555c:	0a80      	lsrs	r0, r0, #10
 800555e:	4044      	eors	r4, r0
 8005560:	68f8      	ldr	r0, [r7, #12]
 8005562:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005566:	4404      	add	r4, r0
 8005568:	68f8      	ldr	r0, [r7, #12]
 800556a:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 800556e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005572:	68f8      	ldr	r0, [r7, #12]
 8005574:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8005578:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800557c:	4045      	eors	r5, r0
 800557e:	68f8      	ldr	r0, [r7, #12]
 8005580:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8005584:	08c0      	lsrs	r0, r0, #3
 8005586:	4068      	eors	r0, r5
 8005588:	4404      	add	r4, r0
 800558a:	68f8      	ldr	r0, [r7, #12]
 800558c:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
 8005590:	4404      	add	r4, r0
 8005592:	68f8      	ldr	r0, [r7, #12]
 8005594:	f8c0 40f4 	str.w	r4, [r0, #244]	; 0xf4
 8005598:	68f8      	ldr	r0, [r7, #12]
 800559a:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 800559e:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 80055a2:	4c2c      	ldr	r4, [pc, #176]	; (8005654 <B5_Sha256ProcessBlock+0x10a0>)
 80055a4:	9405      	str	r4, [sp, #20]
 80055a6:	9004      	str	r0, [sp, #16]
 80055a8:	f107 001c 	add.w	r0, r7, #28
 80055ac:	9003      	str	r0, [sp, #12]
 80055ae:	9102      	str	r1, [sp, #8]
 80055b0:	9201      	str	r2, [sp, #4]
 80055b2:	9300      	str	r3, [sp, #0]
 80055b4:	462b      	mov	r3, r5
 80055b6:	683a      	ldr	r2, [r7, #0]
 80055b8:	6879      	ldr	r1, [r7, #4]
 80055ba:	4630      	mov	r0, r6
 80055bc:	f7fe ffb1 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(36), 0x650A7354 );
 80055c0:	69fe      	ldr	r6, [r7, #28]
 80055c2:	69bb      	ldr	r3, [r7, #24]
 80055c4:	607b      	str	r3, [r7, #4]
 80055c6:	697a      	ldr	r2, [r7, #20]
 80055c8:	603a      	str	r2, [r7, #0]
 80055ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80055cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80055ce:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80055d0:	68f8      	ldr	r0, [r7, #12]
 80055d2:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 80055d6:	ea4f 4470 	mov.w	r4, r0, ror #17
 80055da:	68f8      	ldr	r0, [r7, #12]
 80055dc:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 80055e0:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80055e4:	4044      	eors	r4, r0
 80055e6:	68f8      	ldr	r0, [r7, #12]
 80055e8:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 80055ec:	0a80      	lsrs	r0, r0, #10
 80055ee:	4044      	eors	r4, r0
 80055f0:	68f8      	ldr	r0, [r7, #12]
 80055f2:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 80055f6:	4404      	add	r4, r0
 80055f8:	68f8      	ldr	r0, [r7, #12]
 80055fa:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 80055fe:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005602:	68f8      	ldr	r0, [r7, #12]
 8005604:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8005608:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800560c:	4045      	eors	r5, r0
 800560e:	68f8      	ldr	r0, [r7, #12]
 8005610:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 8005614:	08c0      	lsrs	r0, r0, #3
 8005616:	4068      	eors	r0, r5
 8005618:	4404      	add	r4, r0
 800561a:	68f8      	ldr	r0, [r7, #12]
 800561c:	f8d0 00b8 	ldr.w	r0, [r0, #184]	; 0xb8
 8005620:	4404      	add	r4, r0
 8005622:	68f8      	ldr	r0, [r7, #12]
 8005624:	f8c0 40f8 	str.w	r4, [r0, #248]	; 0xf8
 8005628:	68f8      	ldr	r0, [r7, #12]
 800562a:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 800562e:	f107 0510 	add.w	r5, r7, #16
 8005632:	4c09      	ldr	r4, [pc, #36]	; (8005658 <B5_Sha256ProcessBlock+0x10a4>)
 8005634:	9405      	str	r4, [sp, #20]
 8005636:	9004      	str	r0, [sp, #16]
 8005638:	f107 0020 	add.w	r0, r7, #32
 800563c:	9003      	str	r0, [sp, #12]
 800563e:	9102      	str	r1, [sp, #8]
 8005640:	e00c      	b.n	800565c <B5_Sha256ProcessBlock+0x10a8>
 8005642:	bf00      	nop
 8005644:	14292967 	.word	0x14292967
 8005648:	27b70a85 	.word	0x27b70a85
 800564c:	2e1b2138 	.word	0x2e1b2138
 8005650:	4d2c6dfc 	.word	0x4d2c6dfc
 8005654:	53380d13 	.word	0x53380d13
 8005658:	650a7354 	.word	0x650a7354
 800565c:	9201      	str	r2, [sp, #4]
 800565e:	9300      	str	r3, [sp, #0]
 8005660:	462b      	mov	r3, r5
 8005662:	683a      	ldr	r2, [r7, #0]
 8005664:	6879      	ldr	r1, [r7, #4]
 8005666:	4630      	mov	r0, r6
 8005668:	f7fe ff5b 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(37), 0x766A0ABB );
 800566c:	6a3e      	ldr	r6, [r7, #32]
 800566e:	69fb      	ldr	r3, [r7, #28]
 8005670:	607b      	str	r3, [r7, #4]
 8005672:	69ba      	ldr	r2, [r7, #24]
 8005674:	603a      	str	r2, [r7, #0]
 8005676:	693b      	ldr	r3, [r7, #16]
 8005678:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800567a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800567c:	68f8      	ldr	r0, [r7, #12]
 800567e:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005682:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005686:	68f8      	ldr	r0, [r7, #12]
 8005688:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 800568c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005690:	4044      	eors	r4, r0
 8005692:	68f8      	ldr	r0, [r7, #12]
 8005694:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005698:	0a80      	lsrs	r0, r0, #10
 800569a:	4044      	eors	r4, r0
 800569c:	68f8      	ldr	r0, [r7, #12]
 800569e:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 80056a2:	4404      	add	r4, r0
 80056a4:	68f8      	ldr	r0, [r7, #12]
 80056a6:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 80056aa:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80056ae:	68f8      	ldr	r0, [r7, #12]
 80056b0:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 80056b4:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80056b8:	4045      	eors	r5, r0
 80056ba:	68f8      	ldr	r0, [r7, #12]
 80056bc:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 80056c0:	08c0      	lsrs	r0, r0, #3
 80056c2:	4068      	eors	r0, r5
 80056c4:	4404      	add	r4, r0
 80056c6:	68f8      	ldr	r0, [r7, #12]
 80056c8:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
 80056cc:	4404      	add	r4, r0
 80056ce:	68f8      	ldr	r0, [r7, #12]
 80056d0:	f8c0 40fc 	str.w	r4, [r0, #252]	; 0xfc
 80056d4:	68f8      	ldr	r0, [r7, #12]
 80056d6:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 80056da:	f107 0514 	add.w	r5, r7, #20
 80056de:	4cb8      	ldr	r4, [pc, #736]	; (80059c0 <B5_Sha256ProcessBlock+0x140c>)
 80056e0:	9405      	str	r4, [sp, #20]
 80056e2:	9004      	str	r0, [sp, #16]
 80056e4:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80056e8:	9003      	str	r0, [sp, #12]
 80056ea:	9102      	str	r1, [sp, #8]
 80056ec:	9201      	str	r2, [sp, #4]
 80056ee:	9300      	str	r3, [sp, #0]
 80056f0:	462b      	mov	r3, r5
 80056f2:	683a      	ldr	r2, [r7, #0]
 80056f4:	6879      	ldr	r1, [r7, #4]
 80056f6:	4630      	mov	r0, r6
 80056f8:	f7fe ff13 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(38), 0x81C2C92E );
 80056fc:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80056fe:	6a3b      	ldr	r3, [r7, #32]
 8005700:	607b      	str	r3, [r7, #4]
 8005702:	69fa      	ldr	r2, [r7, #28]
 8005704:	603a      	str	r2, [r7, #0]
 8005706:	697b      	ldr	r3, [r7, #20]
 8005708:	693a      	ldr	r2, [r7, #16]
 800570a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800570c:	68f8      	ldr	r0, [r7, #12]
 800570e:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005712:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005716:	68f8      	ldr	r0, [r7, #12]
 8005718:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 800571c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005720:	4044      	eors	r4, r0
 8005722:	68f8      	ldr	r0, [r7, #12]
 8005724:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005728:	0a80      	lsrs	r0, r0, #10
 800572a:	4044      	eors	r4, r0
 800572c:	68f8      	ldr	r0, [r7, #12]
 800572e:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005732:	4404      	add	r4, r0
 8005734:	68f8      	ldr	r0, [r7, #12]
 8005736:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 800573a:	ea4f 15f0 	mov.w	r5, r0, ror #7
 800573e:	68f8      	ldr	r0, [r7, #12]
 8005740:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8005744:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005748:	4045      	eors	r5, r0
 800574a:	68f8      	ldr	r0, [r7, #12]
 800574c:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 8005750:	08c0      	lsrs	r0, r0, #3
 8005752:	4068      	eors	r0, r5
 8005754:	4404      	add	r4, r0
 8005756:	68f8      	ldr	r0, [r7, #12]
 8005758:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
 800575c:	4404      	add	r4, r0
 800575e:	68f8      	ldr	r0, [r7, #12]
 8005760:	f8c0 4100 	str.w	r4, [r0, #256]	; 0x100
 8005764:	68f8      	ldr	r0, [r7, #12]
 8005766:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 800576a:	f107 0518 	add.w	r5, r7, #24
 800576e:	4c95      	ldr	r4, [pc, #596]	; (80059c4 <B5_Sha256ProcessBlock+0x1410>)
 8005770:	9405      	str	r4, [sp, #20]
 8005772:	9004      	str	r0, [sp, #16]
 8005774:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8005778:	9003      	str	r0, [sp, #12]
 800577a:	9102      	str	r1, [sp, #8]
 800577c:	9201      	str	r2, [sp, #4]
 800577e:	9300      	str	r3, [sp, #0]
 8005780:	462b      	mov	r3, r5
 8005782:	683a      	ldr	r2, [r7, #0]
 8005784:	6879      	ldr	r1, [r7, #4]
 8005786:	4630      	mov	r0, r6
 8005788:	f7fe fecb 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(39), 0x92722C85 );
 800578c:	6abe      	ldr	r6, [r7, #40]	; 0x28
 800578e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005790:	607b      	str	r3, [r7, #4]
 8005792:	6a3a      	ldr	r2, [r7, #32]
 8005794:	603a      	str	r2, [r7, #0]
 8005796:	69bb      	ldr	r3, [r7, #24]
 8005798:	697a      	ldr	r2, [r7, #20]
 800579a:	6939      	ldr	r1, [r7, #16]
 800579c:	68f8      	ldr	r0, [r7, #12]
 800579e:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 80057a2:	ea4f 4470 	mov.w	r4, r0, ror #17
 80057a6:	68f8      	ldr	r0, [r7, #12]
 80057a8:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 80057ac:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80057b0:	4044      	eors	r4, r0
 80057b2:	68f8      	ldr	r0, [r7, #12]
 80057b4:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 80057b8:	0a80      	lsrs	r0, r0, #10
 80057ba:	4044      	eors	r4, r0
 80057bc:	68f8      	ldr	r0, [r7, #12]
 80057be:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 80057c2:	4404      	add	r4, r0
 80057c4:	68f8      	ldr	r0, [r7, #12]
 80057c6:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 80057ca:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80057ce:	68f8      	ldr	r0, [r7, #12]
 80057d0:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 80057d4:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80057d8:	4045      	eors	r5, r0
 80057da:	68f8      	ldr	r0, [r7, #12]
 80057dc:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 80057e0:	08c0      	lsrs	r0, r0, #3
 80057e2:	4068      	eors	r0, r5
 80057e4:	4404      	add	r4, r0
 80057e6:	68f8      	ldr	r0, [r7, #12]
 80057e8:	f8d0 00c4 	ldr.w	r0, [r0, #196]	; 0xc4
 80057ec:	4404      	add	r4, r0
 80057ee:	68f8      	ldr	r0, [r7, #12]
 80057f0:	f8c0 4104 	str.w	r4, [r0, #260]	; 0x104
 80057f4:	68f8      	ldr	r0, [r7, #12]
 80057f6:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 80057fa:	f107 051c 	add.w	r5, r7, #28
 80057fe:	4c72      	ldr	r4, [pc, #456]	; (80059c8 <B5_Sha256ProcessBlock+0x1414>)
 8005800:	9405      	str	r4, [sp, #20]
 8005802:	9004      	str	r0, [sp, #16]
 8005804:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8005808:	9003      	str	r0, [sp, #12]
 800580a:	9102      	str	r1, [sp, #8]
 800580c:	9201      	str	r2, [sp, #4]
 800580e:	9300      	str	r3, [sp, #0]
 8005810:	462b      	mov	r3, r5
 8005812:	683a      	ldr	r2, [r7, #0]
 8005814:	6879      	ldr	r1, [r7, #4]
 8005816:	4630      	mov	r0, r6
 8005818:	f7fe fe83 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(40), 0xA2BFE8A1 );
 800581c:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 800581e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005820:	607b      	str	r3, [r7, #4]
 8005822:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005824:	603a      	str	r2, [r7, #0]
 8005826:	69fb      	ldr	r3, [r7, #28]
 8005828:	69ba      	ldr	r2, [r7, #24]
 800582a:	6979      	ldr	r1, [r7, #20]
 800582c:	68f8      	ldr	r0, [r7, #12]
 800582e:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005832:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005836:	68f8      	ldr	r0, [r7, #12]
 8005838:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 800583c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005840:	4044      	eors	r4, r0
 8005842:	68f8      	ldr	r0, [r7, #12]
 8005844:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005848:	0a80      	lsrs	r0, r0, #10
 800584a:	4044      	eors	r4, r0
 800584c:	68f8      	ldr	r0, [r7, #12]
 800584e:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005852:	4404      	add	r4, r0
 8005854:	68f8      	ldr	r0, [r7, #12]
 8005856:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 800585a:	ea4f 15f0 	mov.w	r5, r0, ror #7
 800585e:	68f8      	ldr	r0, [r7, #12]
 8005860:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 8005864:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005868:	4045      	eors	r5, r0
 800586a:	68f8      	ldr	r0, [r7, #12]
 800586c:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 8005870:	08c0      	lsrs	r0, r0, #3
 8005872:	4068      	eors	r0, r5
 8005874:	4404      	add	r4, r0
 8005876:	68f8      	ldr	r0, [r7, #12]
 8005878:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
 800587c:	4404      	add	r4, r0
 800587e:	68f8      	ldr	r0, [r7, #12]
 8005880:	f8c0 4108 	str.w	r4, [r0, #264]	; 0x108
 8005884:	68f8      	ldr	r0, [r7, #12]
 8005886:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 800588a:	f107 0520 	add.w	r5, r7, #32
 800588e:	4c4f      	ldr	r4, [pc, #316]	; (80059cc <B5_Sha256ProcessBlock+0x1418>)
 8005890:	9405      	str	r4, [sp, #20]
 8005892:	9004      	str	r0, [sp, #16]
 8005894:	f107 0010 	add.w	r0, r7, #16
 8005898:	9003      	str	r0, [sp, #12]
 800589a:	9102      	str	r1, [sp, #8]
 800589c:	9201      	str	r2, [sp, #4]
 800589e:	9300      	str	r3, [sp, #0]
 80058a0:	462b      	mov	r3, r5
 80058a2:	683a      	ldr	r2, [r7, #0]
 80058a4:	6879      	ldr	r1, [r7, #4]
 80058a6:	4630      	mov	r0, r6
 80058a8:	f7fe fe3b 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(41), 0xA81A664B );
 80058ac:	693e      	ldr	r6, [r7, #16]
 80058ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80058b0:	607b      	str	r3, [r7, #4]
 80058b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80058b4:	603a      	str	r2, [r7, #0]
 80058b6:	6a3b      	ldr	r3, [r7, #32]
 80058b8:	69fa      	ldr	r2, [r7, #28]
 80058ba:	69b9      	ldr	r1, [r7, #24]
 80058bc:	68f8      	ldr	r0, [r7, #12]
 80058be:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 80058c2:	ea4f 4470 	mov.w	r4, r0, ror #17
 80058c6:	68f8      	ldr	r0, [r7, #12]
 80058c8:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 80058cc:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80058d0:	4044      	eors	r4, r0
 80058d2:	68f8      	ldr	r0, [r7, #12]
 80058d4:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 80058d8:	0a80      	lsrs	r0, r0, #10
 80058da:	4044      	eors	r4, r0
 80058dc:	68f8      	ldr	r0, [r7, #12]
 80058de:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 80058e2:	4404      	add	r4, r0
 80058e4:	68f8      	ldr	r0, [r7, #12]
 80058e6:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 80058ea:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80058ee:	68f8      	ldr	r0, [r7, #12]
 80058f0:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 80058f4:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80058f8:	4045      	eors	r5, r0
 80058fa:	68f8      	ldr	r0, [r7, #12]
 80058fc:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 8005900:	08c0      	lsrs	r0, r0, #3
 8005902:	4068      	eors	r0, r5
 8005904:	4404      	add	r4, r0
 8005906:	68f8      	ldr	r0, [r7, #12]
 8005908:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 800590c:	4404      	add	r4, r0
 800590e:	68f8      	ldr	r0, [r7, #12]
 8005910:	f8c0 410c 	str.w	r4, [r0, #268]	; 0x10c
 8005914:	68f8      	ldr	r0, [r7, #12]
 8005916:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 800591a:	f107 0524 	add.w	r5, r7, #36	; 0x24
 800591e:	4c2c      	ldr	r4, [pc, #176]	; (80059d0 <B5_Sha256ProcessBlock+0x141c>)
 8005920:	9405      	str	r4, [sp, #20]
 8005922:	9004      	str	r0, [sp, #16]
 8005924:	f107 0014 	add.w	r0, r7, #20
 8005928:	9003      	str	r0, [sp, #12]
 800592a:	9102      	str	r1, [sp, #8]
 800592c:	9201      	str	r2, [sp, #4]
 800592e:	9300      	str	r3, [sp, #0]
 8005930:	462b      	mov	r3, r5
 8005932:	683a      	ldr	r2, [r7, #0]
 8005934:	6879      	ldr	r1, [r7, #4]
 8005936:	4630      	mov	r0, r6
 8005938:	f7fe fdf3 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(42), 0xC24B8B70 );
 800593c:	697e      	ldr	r6, [r7, #20]
 800593e:	693b      	ldr	r3, [r7, #16]
 8005940:	607b      	str	r3, [r7, #4]
 8005942:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005944:	603a      	str	r2, [r7, #0]
 8005946:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005948:	6a3a      	ldr	r2, [r7, #32]
 800594a:	69f9      	ldr	r1, [r7, #28]
 800594c:	68f8      	ldr	r0, [r7, #12]
 800594e:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 8005952:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005956:	68f8      	ldr	r0, [r7, #12]
 8005958:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 800595c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005960:	4044      	eors	r4, r0
 8005962:	68f8      	ldr	r0, [r7, #12]
 8005964:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 8005968:	0a80      	lsrs	r0, r0, #10
 800596a:	4044      	eors	r4, r0
 800596c:	68f8      	ldr	r0, [r7, #12]
 800596e:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005972:	4404      	add	r4, r0
 8005974:	68f8      	ldr	r0, [r7, #12]
 8005976:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 800597a:	ea4f 15f0 	mov.w	r5, r0, ror #7
 800597e:	68f8      	ldr	r0, [r7, #12]
 8005980:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 8005984:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005988:	4045      	eors	r5, r0
 800598a:	68f8      	ldr	r0, [r7, #12]
 800598c:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 8005990:	08c0      	lsrs	r0, r0, #3
 8005992:	4068      	eors	r0, r5
 8005994:	4404      	add	r4, r0
 8005996:	68f8      	ldr	r0, [r7, #12]
 8005998:	f8d0 00d0 	ldr.w	r0, [r0, #208]	; 0xd0
 800599c:	4404      	add	r4, r0
 800599e:	68f8      	ldr	r0, [r7, #12]
 80059a0:	f8c0 4110 	str.w	r4, [r0, #272]	; 0x110
 80059a4:	68f8      	ldr	r0, [r7, #12]
 80059a6:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 80059aa:	f107 0528 	add.w	r5, r7, #40	; 0x28
 80059ae:	4c09      	ldr	r4, [pc, #36]	; (80059d4 <B5_Sha256ProcessBlock+0x1420>)
 80059b0:	9405      	str	r4, [sp, #20]
 80059b2:	9004      	str	r0, [sp, #16]
 80059b4:	f107 0018 	add.w	r0, r7, #24
 80059b8:	9003      	str	r0, [sp, #12]
 80059ba:	9102      	str	r1, [sp, #8]
 80059bc:	e00c      	b.n	80059d8 <B5_Sha256ProcessBlock+0x1424>
 80059be:	bf00      	nop
 80059c0:	766a0abb 	.word	0x766a0abb
 80059c4:	81c2c92e 	.word	0x81c2c92e
 80059c8:	92722c85 	.word	0x92722c85
 80059cc:	a2bfe8a1 	.word	0xa2bfe8a1
 80059d0:	a81a664b 	.word	0xa81a664b
 80059d4:	c24b8b70 	.word	0xc24b8b70
 80059d8:	9201      	str	r2, [sp, #4]
 80059da:	9300      	str	r3, [sp, #0]
 80059dc:	462b      	mov	r3, r5
 80059de:	683a      	ldr	r2, [r7, #0]
 80059e0:	6879      	ldr	r1, [r7, #4]
 80059e2:	4630      	mov	r0, r6
 80059e4:	f7fe fd9d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(43), 0xC76C51A3 );
 80059e8:	69be      	ldr	r6, [r7, #24]
 80059ea:	697b      	ldr	r3, [r7, #20]
 80059ec:	607b      	str	r3, [r7, #4]
 80059ee:	693a      	ldr	r2, [r7, #16]
 80059f0:	603a      	str	r2, [r7, #0]
 80059f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80059f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80059f6:	6a39      	ldr	r1, [r7, #32]
 80059f8:	68f8      	ldr	r0, [r7, #12]
 80059fa:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 80059fe:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005a02:	68f8      	ldr	r0, [r7, #12]
 8005a04:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 8005a08:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005a0c:	4044      	eors	r4, r0
 8005a0e:	68f8      	ldr	r0, [r7, #12]
 8005a10:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 8005a14:	0a80      	lsrs	r0, r0, #10
 8005a16:	4044      	eors	r4, r0
 8005a18:	68f8      	ldr	r0, [r7, #12]
 8005a1a:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005a1e:	4404      	add	r4, r0
 8005a20:	68f8      	ldr	r0, [r7, #12]
 8005a22:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005a26:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005a2a:	68f8      	ldr	r0, [r7, #12]
 8005a2c:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005a30:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005a34:	4045      	eors	r5, r0
 8005a36:	68f8      	ldr	r0, [r7, #12]
 8005a38:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005a3c:	08c0      	lsrs	r0, r0, #3
 8005a3e:	4068      	eors	r0, r5
 8005a40:	4404      	add	r4, r0
 8005a42:	68f8      	ldr	r0, [r7, #12]
 8005a44:	f8d0 00d4 	ldr.w	r0, [r0, #212]	; 0xd4
 8005a48:	4404      	add	r4, r0
 8005a4a:	68f8      	ldr	r0, [r7, #12]
 8005a4c:	f8c0 4114 	str.w	r4, [r0, #276]	; 0x114
 8005a50:	68f8      	ldr	r0, [r7, #12]
 8005a52:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8005a56:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8005a5a:	4cb8      	ldr	r4, [pc, #736]	; (8005d3c <B5_Sha256ProcessBlock+0x1788>)
 8005a5c:	9405      	str	r4, [sp, #20]
 8005a5e:	9004      	str	r0, [sp, #16]
 8005a60:	f107 001c 	add.w	r0, r7, #28
 8005a64:	9003      	str	r0, [sp, #12]
 8005a66:	9102      	str	r1, [sp, #8]
 8005a68:	9201      	str	r2, [sp, #4]
 8005a6a:	9300      	str	r3, [sp, #0]
 8005a6c:	462b      	mov	r3, r5
 8005a6e:	683a      	ldr	r2, [r7, #0]
 8005a70:	6879      	ldr	r1, [r7, #4]
 8005a72:	4630      	mov	r0, r6
 8005a74:	f7fe fd55 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(44), 0xD192E819 );
 8005a78:	69fe      	ldr	r6, [r7, #28]
 8005a7a:	69bb      	ldr	r3, [r7, #24]
 8005a7c:	607b      	str	r3, [r7, #4]
 8005a7e:	697a      	ldr	r2, [r7, #20]
 8005a80:	603a      	str	r2, [r7, #0]
 8005a82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005a84:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005a86:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8005a88:	68f8      	ldr	r0, [r7, #12]
 8005a8a:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8005a8e:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005a92:	68f8      	ldr	r0, [r7, #12]
 8005a94:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8005a98:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005a9c:	4044      	eors	r4, r0
 8005a9e:	68f8      	ldr	r0, [r7, #12]
 8005aa0:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8005aa4:	0a80      	lsrs	r0, r0, #10
 8005aa6:	4044      	eors	r4, r0
 8005aa8:	68f8      	ldr	r0, [r7, #12]
 8005aaa:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 8005aae:	4404      	add	r4, r0
 8005ab0:	68f8      	ldr	r0, [r7, #12]
 8005ab2:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005ab6:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005aba:	68f8      	ldr	r0, [r7, #12]
 8005abc:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005ac0:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005ac4:	4045      	eors	r5, r0
 8005ac6:	68f8      	ldr	r0, [r7, #12]
 8005ac8:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005acc:	08c0      	lsrs	r0, r0, #3
 8005ace:	4068      	eors	r0, r5
 8005ad0:	4404      	add	r4, r0
 8005ad2:	68f8      	ldr	r0, [r7, #12]
 8005ad4:	f8d0 00d8 	ldr.w	r0, [r0, #216]	; 0xd8
 8005ad8:	4404      	add	r4, r0
 8005ada:	68f8      	ldr	r0, [r7, #12]
 8005adc:	f8c0 4118 	str.w	r4, [r0, #280]	; 0x118
 8005ae0:	68f8      	ldr	r0, [r7, #12]
 8005ae2:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8005ae6:	f107 0510 	add.w	r5, r7, #16
 8005aea:	4c95      	ldr	r4, [pc, #596]	; (8005d40 <B5_Sha256ProcessBlock+0x178c>)
 8005aec:	9405      	str	r4, [sp, #20]
 8005aee:	9004      	str	r0, [sp, #16]
 8005af0:	f107 0020 	add.w	r0, r7, #32
 8005af4:	9003      	str	r0, [sp, #12]
 8005af6:	9102      	str	r1, [sp, #8]
 8005af8:	9201      	str	r2, [sp, #4]
 8005afa:	9300      	str	r3, [sp, #0]
 8005afc:	462b      	mov	r3, r5
 8005afe:	683a      	ldr	r2, [r7, #0]
 8005b00:	6879      	ldr	r1, [r7, #4]
 8005b02:	4630      	mov	r0, r6
 8005b04:	f7fe fd0d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(45), 0xD6990624 );
 8005b08:	6a3e      	ldr	r6, [r7, #32]
 8005b0a:	69fb      	ldr	r3, [r7, #28]
 8005b0c:	607b      	str	r3, [r7, #4]
 8005b0e:	69ba      	ldr	r2, [r7, #24]
 8005b10:	603a      	str	r2, [r7, #0]
 8005b12:	693b      	ldr	r3, [r7, #16]
 8005b14:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005b16:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005b18:	68f8      	ldr	r0, [r7, #12]
 8005b1a:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8005b1e:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005b22:	68f8      	ldr	r0, [r7, #12]
 8005b24:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8005b28:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005b2c:	4044      	eors	r4, r0
 8005b2e:	68f8      	ldr	r0, [r7, #12]
 8005b30:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8005b34:	0a80      	lsrs	r0, r0, #10
 8005b36:	4044      	eors	r4, r0
 8005b38:	68f8      	ldr	r0, [r7, #12]
 8005b3a:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005b3e:	4404      	add	r4, r0
 8005b40:	68f8      	ldr	r0, [r7, #12]
 8005b42:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 8005b46:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005b4a:	68f8      	ldr	r0, [r7, #12]
 8005b4c:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 8005b50:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005b54:	4045      	eors	r5, r0
 8005b56:	68f8      	ldr	r0, [r7, #12]
 8005b58:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 8005b5c:	08c0      	lsrs	r0, r0, #3
 8005b5e:	4068      	eors	r0, r5
 8005b60:	4404      	add	r4, r0
 8005b62:	68f8      	ldr	r0, [r7, #12]
 8005b64:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
 8005b68:	4404      	add	r4, r0
 8005b6a:	68f8      	ldr	r0, [r7, #12]
 8005b6c:	f8c0 411c 	str.w	r4, [r0, #284]	; 0x11c
 8005b70:	68f8      	ldr	r0, [r7, #12]
 8005b72:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8005b76:	f107 0514 	add.w	r5, r7, #20
 8005b7a:	4c72      	ldr	r4, [pc, #456]	; (8005d44 <B5_Sha256ProcessBlock+0x1790>)
 8005b7c:	9405      	str	r4, [sp, #20]
 8005b7e:	9004      	str	r0, [sp, #16]
 8005b80:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8005b84:	9003      	str	r0, [sp, #12]
 8005b86:	9102      	str	r1, [sp, #8]
 8005b88:	9201      	str	r2, [sp, #4]
 8005b8a:	9300      	str	r3, [sp, #0]
 8005b8c:	462b      	mov	r3, r5
 8005b8e:	683a      	ldr	r2, [r7, #0]
 8005b90:	6879      	ldr	r1, [r7, #4]
 8005b92:	4630      	mov	r0, r6
 8005b94:	f7fe fcc5 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(46), 0xF40E3585 );
 8005b98:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8005b9a:	6a3b      	ldr	r3, [r7, #32]
 8005b9c:	607b      	str	r3, [r7, #4]
 8005b9e:	69fa      	ldr	r2, [r7, #28]
 8005ba0:	603a      	str	r2, [r7, #0]
 8005ba2:	697b      	ldr	r3, [r7, #20]
 8005ba4:	693a      	ldr	r2, [r7, #16]
 8005ba6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005ba8:	68f8      	ldr	r0, [r7, #12]
 8005baa:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8005bae:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005bb2:	68f8      	ldr	r0, [r7, #12]
 8005bb4:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8005bb8:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005bbc:	4044      	eors	r4, r0
 8005bbe:	68f8      	ldr	r0, [r7, #12]
 8005bc0:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8005bc4:	0a80      	lsrs	r0, r0, #10
 8005bc6:	4044      	eors	r4, r0
 8005bc8:	68f8      	ldr	r0, [r7, #12]
 8005bca:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 8005bce:	4404      	add	r4, r0
 8005bd0:	68f8      	ldr	r0, [r7, #12]
 8005bd2:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005bd6:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005bda:	68f8      	ldr	r0, [r7, #12]
 8005bdc:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005be0:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005be4:	4045      	eors	r5, r0
 8005be6:	68f8      	ldr	r0, [r7, #12]
 8005be8:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005bec:	08c0      	lsrs	r0, r0, #3
 8005bee:	4068      	eors	r0, r5
 8005bf0:	4404      	add	r4, r0
 8005bf2:	68f8      	ldr	r0, [r7, #12]
 8005bf4:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
 8005bf8:	4404      	add	r4, r0
 8005bfa:	68f8      	ldr	r0, [r7, #12]
 8005bfc:	f8c0 4120 	str.w	r4, [r0, #288]	; 0x120
 8005c00:	68f8      	ldr	r0, [r7, #12]
 8005c02:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 8005c06:	f107 0518 	add.w	r5, r7, #24
 8005c0a:	4c4f      	ldr	r4, [pc, #316]	; (8005d48 <B5_Sha256ProcessBlock+0x1794>)
 8005c0c:	9405      	str	r4, [sp, #20]
 8005c0e:	9004      	str	r0, [sp, #16]
 8005c10:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8005c14:	9003      	str	r0, [sp, #12]
 8005c16:	9102      	str	r1, [sp, #8]
 8005c18:	9201      	str	r2, [sp, #4]
 8005c1a:	9300      	str	r3, [sp, #0]
 8005c1c:	462b      	mov	r3, r5
 8005c1e:	683a      	ldr	r2, [r7, #0]
 8005c20:	6879      	ldr	r1, [r7, #4]
 8005c22:	4630      	mov	r0, r6
 8005c24:	f7fe fc7d 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(47), 0x106AA070 );
 8005c28:	6abe      	ldr	r6, [r7, #40]	; 0x28
 8005c2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005c2c:	607b      	str	r3, [r7, #4]
 8005c2e:	6a3a      	ldr	r2, [r7, #32]
 8005c30:	603a      	str	r2, [r7, #0]
 8005c32:	69bb      	ldr	r3, [r7, #24]
 8005c34:	697a      	ldr	r2, [r7, #20]
 8005c36:	6939      	ldr	r1, [r7, #16]
 8005c38:	68f8      	ldr	r0, [r7, #12]
 8005c3a:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8005c3e:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005c42:	68f8      	ldr	r0, [r7, #12]
 8005c44:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8005c48:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005c4c:	4044      	eors	r4, r0
 8005c4e:	68f8      	ldr	r0, [r7, #12]
 8005c50:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8005c54:	0a80      	lsrs	r0, r0, #10
 8005c56:	4044      	eors	r4, r0
 8005c58:	68f8      	ldr	r0, [r7, #12]
 8005c5a:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 8005c5e:	4404      	add	r4, r0
 8005c60:	68f8      	ldr	r0, [r7, #12]
 8005c62:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 8005c66:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005c6a:	68f8      	ldr	r0, [r7, #12]
 8005c6c:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 8005c70:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005c74:	4045      	eors	r5, r0
 8005c76:	68f8      	ldr	r0, [r7, #12]
 8005c78:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 8005c7c:	08c0      	lsrs	r0, r0, #3
 8005c7e:	4068      	eors	r0, r5
 8005c80:	4404      	add	r4, r0
 8005c82:	68f8      	ldr	r0, [r7, #12]
 8005c84:	f8d0 00e4 	ldr.w	r0, [r0, #228]	; 0xe4
 8005c88:	4404      	add	r4, r0
 8005c8a:	68f8      	ldr	r0, [r7, #12]
 8005c8c:	f8c0 4124 	str.w	r4, [r0, #292]	; 0x124
 8005c90:	68f8      	ldr	r0, [r7, #12]
 8005c92:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8005c96:	f107 051c 	add.w	r5, r7, #28
 8005c9a:	4c2c      	ldr	r4, [pc, #176]	; (8005d4c <B5_Sha256ProcessBlock+0x1798>)
 8005c9c:	9405      	str	r4, [sp, #20]
 8005c9e:	9004      	str	r0, [sp, #16]
 8005ca0:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8005ca4:	9003      	str	r0, [sp, #12]
 8005ca6:	9102      	str	r1, [sp, #8]
 8005ca8:	9201      	str	r2, [sp, #4]
 8005caa:	9300      	str	r3, [sp, #0]
 8005cac:	462b      	mov	r3, r5
 8005cae:	683a      	ldr	r2, [r7, #0]
 8005cb0:	6879      	ldr	r1, [r7, #4]
 8005cb2:	4630      	mov	r0, r6
 8005cb4:	f7fe fc35 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(48), 0x19A4C116 );
 8005cb8:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8005cba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005cbc:	607b      	str	r3, [r7, #4]
 8005cbe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005cc0:	603a      	str	r2, [r7, #0]
 8005cc2:	69fb      	ldr	r3, [r7, #28]
 8005cc4:	69ba      	ldr	r2, [r7, #24]
 8005cc6:	6979      	ldr	r1, [r7, #20]
 8005cc8:	68f8      	ldr	r0, [r7, #12]
 8005cca:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 8005cce:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005cd2:	68f8      	ldr	r0, [r7, #12]
 8005cd4:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 8005cd8:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005cdc:	4044      	eors	r4, r0
 8005cde:	68f8      	ldr	r0, [r7, #12]
 8005ce0:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 8005ce4:	0a80      	lsrs	r0, r0, #10
 8005ce6:	4044      	eors	r4, r0
 8005ce8:	68f8      	ldr	r0, [r7, #12]
 8005cea:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 8005cee:	4404      	add	r4, r0
 8005cf0:	68f8      	ldr	r0, [r7, #12]
 8005cf2:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005cf6:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005cfa:	68f8      	ldr	r0, [r7, #12]
 8005cfc:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005d00:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005d04:	4045      	eors	r5, r0
 8005d06:	68f8      	ldr	r0, [r7, #12]
 8005d08:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005d0c:	08c0      	lsrs	r0, r0, #3
 8005d0e:	4068      	eors	r0, r5
 8005d10:	4404      	add	r4, r0
 8005d12:	68f8      	ldr	r0, [r7, #12]
 8005d14:	f8d0 00e8 	ldr.w	r0, [r0, #232]	; 0xe8
 8005d18:	4404      	add	r4, r0
 8005d1a:	68f8      	ldr	r0, [r7, #12]
 8005d1c:	f8c0 4128 	str.w	r4, [r0, #296]	; 0x128
 8005d20:	68f8      	ldr	r0, [r7, #12]
 8005d22:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 8005d26:	f107 0520 	add.w	r5, r7, #32
 8005d2a:	4c09      	ldr	r4, [pc, #36]	; (8005d50 <B5_Sha256ProcessBlock+0x179c>)
 8005d2c:	9405      	str	r4, [sp, #20]
 8005d2e:	9004      	str	r0, [sp, #16]
 8005d30:	f107 0010 	add.w	r0, r7, #16
 8005d34:	9003      	str	r0, [sp, #12]
 8005d36:	9102      	str	r1, [sp, #8]
 8005d38:	e00c      	b.n	8005d54 <B5_Sha256ProcessBlock+0x17a0>
 8005d3a:	bf00      	nop
 8005d3c:	c76c51a3 	.word	0xc76c51a3
 8005d40:	d192e819 	.word	0xd192e819
 8005d44:	d6990624 	.word	0xd6990624
 8005d48:	f40e3585 	.word	0xf40e3585
 8005d4c:	106aa070 	.word	0x106aa070
 8005d50:	19a4c116 	.word	0x19a4c116
 8005d54:	9201      	str	r2, [sp, #4]
 8005d56:	9300      	str	r3, [sp, #0]
 8005d58:	462b      	mov	r3, r5
 8005d5a:	683a      	ldr	r2, [r7, #0]
 8005d5c:	6879      	ldr	r1, [r7, #4]
 8005d5e:	4630      	mov	r0, r6
 8005d60:	f7fe fbdf 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(49), 0x1E376C08 );
 8005d64:	693e      	ldr	r6, [r7, #16]
 8005d66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005d68:	607b      	str	r3, [r7, #4]
 8005d6a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005d6c:	603a      	str	r2, [r7, #0]
 8005d6e:	6a3b      	ldr	r3, [r7, #32]
 8005d70:	69fa      	ldr	r2, [r7, #28]
 8005d72:	69b9      	ldr	r1, [r7, #24]
 8005d74:	68f8      	ldr	r0, [r7, #12]
 8005d76:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8005d7a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005d7e:	68f8      	ldr	r0, [r7, #12]
 8005d80:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8005d84:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005d88:	4044      	eors	r4, r0
 8005d8a:	68f8      	ldr	r0, [r7, #12]
 8005d8c:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8005d90:	0a80      	lsrs	r0, r0, #10
 8005d92:	4044      	eors	r4, r0
 8005d94:	68f8      	ldr	r0, [r7, #12]
 8005d96:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8005d9a:	4404      	add	r4, r0
 8005d9c:	68f8      	ldr	r0, [r7, #12]
 8005d9e:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 8005da2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005da6:	68f8      	ldr	r0, [r7, #12]
 8005da8:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 8005dac:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005db0:	4045      	eors	r5, r0
 8005db2:	68f8      	ldr	r0, [r7, #12]
 8005db4:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 8005db8:	08c0      	lsrs	r0, r0, #3
 8005dba:	4068      	eors	r0, r5
 8005dbc:	4404      	add	r4, r0
 8005dbe:	68f8      	ldr	r0, [r7, #12]
 8005dc0:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005dc4:	4404      	add	r4, r0
 8005dc6:	68f8      	ldr	r0, [r7, #12]
 8005dc8:	f8c0 412c 	str.w	r4, [r0, #300]	; 0x12c
 8005dcc:	68f8      	ldr	r0, [r7, #12]
 8005dce:	f8d0 012c 	ldr.w	r0, [r0, #300]	; 0x12c
 8005dd2:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8005dd6:	4cb8      	ldr	r4, [pc, #736]	; (80060b8 <B5_Sha256ProcessBlock+0x1b04>)
 8005dd8:	9405      	str	r4, [sp, #20]
 8005dda:	9004      	str	r0, [sp, #16]
 8005ddc:	f107 0014 	add.w	r0, r7, #20
 8005de0:	9003      	str	r0, [sp, #12]
 8005de2:	9102      	str	r1, [sp, #8]
 8005de4:	9201      	str	r2, [sp, #4]
 8005de6:	9300      	str	r3, [sp, #0]
 8005de8:	462b      	mov	r3, r5
 8005dea:	683a      	ldr	r2, [r7, #0]
 8005dec:	6879      	ldr	r1, [r7, #4]
 8005dee:	4630      	mov	r0, r6
 8005df0:	f7fe fb97 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(50), 0x2748774C );
 8005df4:	697e      	ldr	r6, [r7, #20]
 8005df6:	693b      	ldr	r3, [r7, #16]
 8005df8:	607b      	str	r3, [r7, #4]
 8005dfa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005dfc:	603a      	str	r2, [r7, #0]
 8005dfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005e00:	6a3a      	ldr	r2, [r7, #32]
 8005e02:	69f9      	ldr	r1, [r7, #28]
 8005e04:	68f8      	ldr	r0, [r7, #12]
 8005e06:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 8005e0a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005e0e:	68f8      	ldr	r0, [r7, #12]
 8005e10:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 8005e14:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005e18:	4044      	eors	r4, r0
 8005e1a:	68f8      	ldr	r0, [r7, #12]
 8005e1c:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 8005e20:	0a80      	lsrs	r0, r0, #10
 8005e22:	4044      	eors	r4, r0
 8005e24:	68f8      	ldr	r0, [r7, #12]
 8005e26:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8005e2a:	4404      	add	r4, r0
 8005e2c:	68f8      	ldr	r0, [r7, #12]
 8005e2e:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005e32:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005e36:	68f8      	ldr	r0, [r7, #12]
 8005e38:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005e3c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005e40:	4045      	eors	r5, r0
 8005e42:	68f8      	ldr	r0, [r7, #12]
 8005e44:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005e48:	08c0      	lsrs	r0, r0, #3
 8005e4a:	4068      	eors	r0, r5
 8005e4c:	4404      	add	r4, r0
 8005e4e:	68f8      	ldr	r0, [r7, #12]
 8005e50:	f8d0 00f0 	ldr.w	r0, [r0, #240]	; 0xf0
 8005e54:	4404      	add	r4, r0
 8005e56:	68f8      	ldr	r0, [r7, #12]
 8005e58:	f8c0 4130 	str.w	r4, [r0, #304]	; 0x130
 8005e5c:	68f8      	ldr	r0, [r7, #12]
 8005e5e:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 8005e62:	f107 0528 	add.w	r5, r7, #40	; 0x28
 8005e66:	4c95      	ldr	r4, [pc, #596]	; (80060bc <B5_Sha256ProcessBlock+0x1b08>)
 8005e68:	9405      	str	r4, [sp, #20]
 8005e6a:	9004      	str	r0, [sp, #16]
 8005e6c:	f107 0018 	add.w	r0, r7, #24
 8005e70:	9003      	str	r0, [sp, #12]
 8005e72:	9102      	str	r1, [sp, #8]
 8005e74:	9201      	str	r2, [sp, #4]
 8005e76:	9300      	str	r3, [sp, #0]
 8005e78:	462b      	mov	r3, r5
 8005e7a:	683a      	ldr	r2, [r7, #0]
 8005e7c:	6879      	ldr	r1, [r7, #4]
 8005e7e:	4630      	mov	r0, r6
 8005e80:	f7fe fb4f 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(51), 0x34B0BCB5 );
 8005e84:	69be      	ldr	r6, [r7, #24]
 8005e86:	697b      	ldr	r3, [r7, #20]
 8005e88:	607b      	str	r3, [r7, #4]
 8005e8a:	693a      	ldr	r2, [r7, #16]
 8005e8c:	603a      	str	r2, [r7, #0]
 8005e8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005e90:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005e92:	6a39      	ldr	r1, [r7, #32]
 8005e94:	68f8      	ldr	r0, [r7, #12]
 8005e96:	f8d0 012c 	ldr.w	r0, [r0, #300]	; 0x12c
 8005e9a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005e9e:	68f8      	ldr	r0, [r7, #12]
 8005ea0:	f8d0 012c 	ldr.w	r0, [r0, #300]	; 0x12c
 8005ea4:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005ea8:	4044      	eors	r4, r0
 8005eaa:	68f8      	ldr	r0, [r7, #12]
 8005eac:	f8d0 012c 	ldr.w	r0, [r0, #300]	; 0x12c
 8005eb0:	0a80      	lsrs	r0, r0, #10
 8005eb2:	4044      	eors	r4, r0
 8005eb4:	68f8      	ldr	r0, [r7, #12]
 8005eb6:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8005eba:	4404      	add	r4, r0
 8005ebc:	68f8      	ldr	r0, [r7, #12]
 8005ebe:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005ec2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005ec6:	68f8      	ldr	r0, [r7, #12]
 8005ec8:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005ecc:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005ed0:	4045      	eors	r5, r0
 8005ed2:	68f8      	ldr	r0, [r7, #12]
 8005ed4:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005ed8:	08c0      	lsrs	r0, r0, #3
 8005eda:	4068      	eors	r0, r5
 8005edc:	4404      	add	r4, r0
 8005ede:	68f8      	ldr	r0, [r7, #12]
 8005ee0:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
 8005ee4:	4404      	add	r4, r0
 8005ee6:	68f8      	ldr	r0, [r7, #12]
 8005ee8:	f8c0 4134 	str.w	r4, [r0, #308]	; 0x134
 8005eec:	68f8      	ldr	r0, [r7, #12]
 8005eee:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
 8005ef2:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8005ef6:	4c72      	ldr	r4, [pc, #456]	; (80060c0 <B5_Sha256ProcessBlock+0x1b0c>)
 8005ef8:	9405      	str	r4, [sp, #20]
 8005efa:	9004      	str	r0, [sp, #16]
 8005efc:	f107 001c 	add.w	r0, r7, #28
 8005f00:	9003      	str	r0, [sp, #12]
 8005f02:	9102      	str	r1, [sp, #8]
 8005f04:	9201      	str	r2, [sp, #4]
 8005f06:	9300      	str	r3, [sp, #0]
 8005f08:	462b      	mov	r3, r5
 8005f0a:	683a      	ldr	r2, [r7, #0]
 8005f0c:	6879      	ldr	r1, [r7, #4]
 8005f0e:	4630      	mov	r0, r6
 8005f10:	f7fe fb07 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(52), 0x391C0CB3 );
 8005f14:	69fe      	ldr	r6, [r7, #28]
 8005f16:	69bb      	ldr	r3, [r7, #24]
 8005f18:	607b      	str	r3, [r7, #4]
 8005f1a:	697a      	ldr	r2, [r7, #20]
 8005f1c:	603a      	str	r2, [r7, #0]
 8005f1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005f20:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005f22:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8005f24:	68f8      	ldr	r0, [r7, #12]
 8005f26:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 8005f2a:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005f2e:	68f8      	ldr	r0, [r7, #12]
 8005f30:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 8005f34:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005f38:	4044      	eors	r4, r0
 8005f3a:	68f8      	ldr	r0, [r7, #12]
 8005f3c:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 8005f40:	0a80      	lsrs	r0, r0, #10
 8005f42:	4044      	eors	r4, r0
 8005f44:	68f8      	ldr	r0, [r7, #12]
 8005f46:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8005f4a:	4404      	add	r4, r0
 8005f4c:	68f8      	ldr	r0, [r7, #12]
 8005f4e:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 8005f52:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005f56:	68f8      	ldr	r0, [r7, #12]
 8005f58:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 8005f5c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005f60:	4045      	eors	r5, r0
 8005f62:	68f8      	ldr	r0, [r7, #12]
 8005f64:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 8005f68:	08c0      	lsrs	r0, r0, #3
 8005f6a:	4068      	eors	r0, r5
 8005f6c:	4404      	add	r4, r0
 8005f6e:	68f8      	ldr	r0, [r7, #12]
 8005f70:	f8d0 00f8 	ldr.w	r0, [r0, #248]	; 0xf8
 8005f74:	4404      	add	r4, r0
 8005f76:	68f8      	ldr	r0, [r7, #12]
 8005f78:	f8c0 4138 	str.w	r4, [r0, #312]	; 0x138
 8005f7c:	68f8      	ldr	r0, [r7, #12]
 8005f7e:	f8d0 0138 	ldr.w	r0, [r0, #312]	; 0x138
 8005f82:	f107 0510 	add.w	r5, r7, #16
 8005f86:	4c4f      	ldr	r4, [pc, #316]	; (80060c4 <B5_Sha256ProcessBlock+0x1b10>)
 8005f88:	9405      	str	r4, [sp, #20]
 8005f8a:	9004      	str	r0, [sp, #16]
 8005f8c:	f107 0020 	add.w	r0, r7, #32
 8005f90:	9003      	str	r0, [sp, #12]
 8005f92:	9102      	str	r1, [sp, #8]
 8005f94:	9201      	str	r2, [sp, #4]
 8005f96:	9300      	str	r3, [sp, #0]
 8005f98:	462b      	mov	r3, r5
 8005f9a:	683a      	ldr	r2, [r7, #0]
 8005f9c:	6879      	ldr	r1, [r7, #4]
 8005f9e:	4630      	mov	r0, r6
 8005fa0:	f7fe fabf 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(53), 0x4ED8AA4A );
 8005fa4:	6a3e      	ldr	r6, [r7, #32]
 8005fa6:	69fb      	ldr	r3, [r7, #28]
 8005fa8:	607b      	str	r3, [r7, #4]
 8005faa:	69ba      	ldr	r2, [r7, #24]
 8005fac:	603a      	str	r2, [r7, #0]
 8005fae:	693b      	ldr	r3, [r7, #16]
 8005fb0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005fb2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005fb4:	68f8      	ldr	r0, [r7, #12]
 8005fb6:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
 8005fba:	ea4f 4470 	mov.w	r4, r0, ror #17
 8005fbe:	68f8      	ldr	r0, [r7, #12]
 8005fc0:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
 8005fc4:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8005fc8:	4044      	eors	r4, r0
 8005fca:	68f8      	ldr	r0, [r7, #12]
 8005fcc:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
 8005fd0:	0a80      	lsrs	r0, r0, #10
 8005fd2:	4044      	eors	r4, r0
 8005fd4:	68f8      	ldr	r0, [r7, #12]
 8005fd6:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 8005fda:	4404      	add	r4, r0
 8005fdc:	68f8      	ldr	r0, [r7, #12]
 8005fde:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005fe2:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8005fe6:	68f8      	ldr	r0, [r7, #12]
 8005fe8:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005fec:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8005ff0:	4045      	eors	r5, r0
 8005ff2:	68f8      	ldr	r0, [r7, #12]
 8005ff4:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8005ff8:	08c0      	lsrs	r0, r0, #3
 8005ffa:	4068      	eors	r0, r5
 8005ffc:	4404      	add	r4, r0
 8005ffe:	68f8      	ldr	r0, [r7, #12]
 8006000:	f8d0 00fc 	ldr.w	r0, [r0, #252]	; 0xfc
 8006004:	4404      	add	r4, r0
 8006006:	68f8      	ldr	r0, [r7, #12]
 8006008:	f8c0 413c 	str.w	r4, [r0, #316]	; 0x13c
 800600c:	68f8      	ldr	r0, [r7, #12]
 800600e:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
 8006012:	f107 0514 	add.w	r5, r7, #20
 8006016:	4c2c      	ldr	r4, [pc, #176]	; (80060c8 <B5_Sha256ProcessBlock+0x1b14>)
 8006018:	9405      	str	r4, [sp, #20]
 800601a:	9004      	str	r0, [sp, #16]
 800601c:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8006020:	9003      	str	r0, [sp, #12]
 8006022:	9102      	str	r1, [sp, #8]
 8006024:	9201      	str	r2, [sp, #4]
 8006026:	9300      	str	r3, [sp, #0]
 8006028:	462b      	mov	r3, r5
 800602a:	683a      	ldr	r2, [r7, #0]
 800602c:	6879      	ldr	r1, [r7, #4]
 800602e:	4630      	mov	r0, r6
 8006030:	f7fe fa77 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(54), 0x5B9CCA4F );
 8006034:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 8006036:	6a3b      	ldr	r3, [r7, #32]
 8006038:	607b      	str	r3, [r7, #4]
 800603a:	69fa      	ldr	r2, [r7, #28]
 800603c:	603a      	str	r2, [r7, #0]
 800603e:	697b      	ldr	r3, [r7, #20]
 8006040:	693a      	ldr	r2, [r7, #16]
 8006042:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8006044:	68f8      	ldr	r0, [r7, #12]
 8006046:	f8d0 0138 	ldr.w	r0, [r0, #312]	; 0x138
 800604a:	ea4f 4470 	mov.w	r4, r0, ror #17
 800604e:	68f8      	ldr	r0, [r7, #12]
 8006050:	f8d0 0138 	ldr.w	r0, [r0, #312]	; 0x138
 8006054:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006058:	4044      	eors	r4, r0
 800605a:	68f8      	ldr	r0, [r7, #12]
 800605c:	f8d0 0138 	ldr.w	r0, [r0, #312]	; 0x138
 8006060:	0a80      	lsrs	r0, r0, #10
 8006062:	4044      	eors	r4, r0
 8006064:	68f8      	ldr	r0, [r7, #12]
 8006066:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 800606a:	4404      	add	r4, r0
 800606c:	68f8      	ldr	r0, [r7, #12]
 800606e:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 8006072:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8006076:	68f8      	ldr	r0, [r7, #12]
 8006078:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 800607c:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8006080:	4045      	eors	r5, r0
 8006082:	68f8      	ldr	r0, [r7, #12]
 8006084:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 8006088:	08c0      	lsrs	r0, r0, #3
 800608a:	4068      	eors	r0, r5
 800608c:	4404      	add	r4, r0
 800608e:	68f8      	ldr	r0, [r7, #12]
 8006090:	f8d0 0100 	ldr.w	r0, [r0, #256]	; 0x100
 8006094:	4404      	add	r4, r0
 8006096:	68f8      	ldr	r0, [r7, #12]
 8006098:	f8c0 4140 	str.w	r4, [r0, #320]	; 0x140
 800609c:	68f8      	ldr	r0, [r7, #12]
 800609e:	f8d0 0140 	ldr.w	r0, [r0, #320]	; 0x140
 80060a2:	f107 0518 	add.w	r5, r7, #24
 80060a6:	4c09      	ldr	r4, [pc, #36]	; (80060cc <B5_Sha256ProcessBlock+0x1b18>)
 80060a8:	9405      	str	r4, [sp, #20]
 80060aa:	9004      	str	r0, [sp, #16]
 80060ac:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80060b0:	9003      	str	r0, [sp, #12]
 80060b2:	9102      	str	r1, [sp, #8]
 80060b4:	e00c      	b.n	80060d0 <B5_Sha256ProcessBlock+0x1b1c>
 80060b6:	bf00      	nop
 80060b8:	1e376c08 	.word	0x1e376c08
 80060bc:	2748774c 	.word	0x2748774c
 80060c0:	34b0bcb5 	.word	0x34b0bcb5
 80060c4:	391c0cb3 	.word	0x391c0cb3
 80060c8:	4ed8aa4a 	.word	0x4ed8aa4a
 80060cc:	5b9cca4f 	.word	0x5b9cca4f
 80060d0:	9201      	str	r2, [sp, #4]
 80060d2:	9300      	str	r3, [sp, #0]
 80060d4:	462b      	mov	r3, r5
 80060d6:	683a      	ldr	r2, [r7, #0]
 80060d8:	6879      	ldr	r1, [r7, #4]
 80060da:	4630      	mov	r0, r6
 80060dc:	f7fe fa21 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(55), 0x682E6FF3 );
 80060e0:	6abe      	ldr	r6, [r7, #40]	; 0x28
 80060e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80060e4:	607b      	str	r3, [r7, #4]
 80060e6:	6a3a      	ldr	r2, [r7, #32]
 80060e8:	603a      	str	r2, [r7, #0]
 80060ea:	69bb      	ldr	r3, [r7, #24]
 80060ec:	697a      	ldr	r2, [r7, #20]
 80060ee:	6939      	ldr	r1, [r7, #16]
 80060f0:	68f8      	ldr	r0, [r7, #12]
 80060f2:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
 80060f6:	ea4f 4470 	mov.w	r4, r0, ror #17
 80060fa:	68f8      	ldr	r0, [r7, #12]
 80060fc:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
 8006100:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006104:	4044      	eors	r4, r0
 8006106:	68f8      	ldr	r0, [r7, #12]
 8006108:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
 800610c:	0a80      	lsrs	r0, r0, #10
 800610e:	4044      	eors	r4, r0
 8006110:	68f8      	ldr	r0, [r7, #12]
 8006112:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 8006116:	4404      	add	r4, r0
 8006118:	68f8      	ldr	r0, [r7, #12]
 800611a:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 800611e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8006122:	68f8      	ldr	r0, [r7, #12]
 8006124:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 8006128:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800612c:	4045      	eors	r5, r0
 800612e:	68f8      	ldr	r0, [r7, #12]
 8006130:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 8006134:	08c0      	lsrs	r0, r0, #3
 8006136:	4068      	eors	r0, r5
 8006138:	4404      	add	r4, r0
 800613a:	68f8      	ldr	r0, [r7, #12]
 800613c:	f8d0 0104 	ldr.w	r0, [r0, #260]	; 0x104
 8006140:	4404      	add	r4, r0
 8006142:	68f8      	ldr	r0, [r7, #12]
 8006144:	f8c0 4144 	str.w	r4, [r0, #324]	; 0x144
 8006148:	68f8      	ldr	r0, [r7, #12]
 800614a:	f8d0 0144 	ldr.w	r0, [r0, #324]	; 0x144
 800614e:	f107 051c 	add.w	r5, r7, #28
 8006152:	4cb8      	ldr	r4, [pc, #736]	; (8006434 <B5_Sha256ProcessBlock+0x1e80>)
 8006154:	9405      	str	r4, [sp, #20]
 8006156:	9004      	str	r0, [sp, #16]
 8006158:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 800615c:	9003      	str	r0, [sp, #12]
 800615e:	9102      	str	r1, [sp, #8]
 8006160:	9201      	str	r2, [sp, #4]
 8006162:	9300      	str	r3, [sp, #0]
 8006164:	462b      	mov	r3, r5
 8006166:	683a      	ldr	r2, [r7, #0]
 8006168:	6879      	ldr	r1, [r7, #4]
 800616a:	4630      	mov	r0, r6
 800616c:	f7fe f9d9 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( A, B, C, &D, E, F, G, &H, B5_SHA256_R(56), 0x748F82EE );
 8006170:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 8006172:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006174:	607b      	str	r3, [r7, #4]
 8006176:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8006178:	603a      	str	r2, [r7, #0]
 800617a:	69fb      	ldr	r3, [r7, #28]
 800617c:	69ba      	ldr	r2, [r7, #24]
 800617e:	6979      	ldr	r1, [r7, #20]
 8006180:	68f8      	ldr	r0, [r7, #12]
 8006182:	f8d0 0140 	ldr.w	r0, [r0, #320]	; 0x140
 8006186:	ea4f 4470 	mov.w	r4, r0, ror #17
 800618a:	68f8      	ldr	r0, [r7, #12]
 800618c:	f8d0 0140 	ldr.w	r0, [r0, #320]	; 0x140
 8006190:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006194:	4044      	eors	r4, r0
 8006196:	68f8      	ldr	r0, [r7, #12]
 8006198:	f8d0 0140 	ldr.w	r0, [r0, #320]	; 0x140
 800619c:	0a80      	lsrs	r0, r0, #10
 800619e:	4044      	eors	r4, r0
 80061a0:	68f8      	ldr	r0, [r7, #12]
 80061a2:	f8d0 012c 	ldr.w	r0, [r0, #300]	; 0x12c
 80061a6:	4404      	add	r4, r0
 80061a8:	68f8      	ldr	r0, [r7, #12]
 80061aa:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 80061ae:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80061b2:	68f8      	ldr	r0, [r7, #12]
 80061b4:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 80061b8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80061bc:	4045      	eors	r5, r0
 80061be:	68f8      	ldr	r0, [r7, #12]
 80061c0:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 80061c4:	08c0      	lsrs	r0, r0, #3
 80061c6:	4068      	eors	r0, r5
 80061c8:	4404      	add	r4, r0
 80061ca:	68f8      	ldr	r0, [r7, #12]
 80061cc:	f8d0 0108 	ldr.w	r0, [r0, #264]	; 0x108
 80061d0:	4404      	add	r4, r0
 80061d2:	68f8      	ldr	r0, [r7, #12]
 80061d4:	f8c0 4148 	str.w	r4, [r0, #328]	; 0x148
 80061d8:	68f8      	ldr	r0, [r7, #12]
 80061da:	f8d0 0148 	ldr.w	r0, [r0, #328]	; 0x148
 80061de:	f107 0520 	add.w	r5, r7, #32
 80061e2:	4c95      	ldr	r4, [pc, #596]	; (8006438 <B5_Sha256ProcessBlock+0x1e84>)
 80061e4:	9405      	str	r4, [sp, #20]
 80061e6:	9004      	str	r0, [sp, #16]
 80061e8:	f107 0010 	add.w	r0, r7, #16
 80061ec:	9003      	str	r0, [sp, #12]
 80061ee:	9102      	str	r1, [sp, #8]
 80061f0:	9201      	str	r2, [sp, #4]
 80061f2:	9300      	str	r3, [sp, #0]
 80061f4:	462b      	mov	r3, r5
 80061f6:	683a      	ldr	r2, [r7, #0]
 80061f8:	6879      	ldr	r1, [r7, #4]
 80061fa:	4630      	mov	r0, r6
 80061fc:	f7fe f991 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( H, A, B, &C, D, E, F, &G, B5_SHA256_R(57), 0x78A5636F );
 8006200:	693e      	ldr	r6, [r7, #16]
 8006202:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006204:	607b      	str	r3, [r7, #4]
 8006206:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006208:	603a      	str	r2, [r7, #0]
 800620a:	6a3b      	ldr	r3, [r7, #32]
 800620c:	69fa      	ldr	r2, [r7, #28]
 800620e:	69b9      	ldr	r1, [r7, #24]
 8006210:	68f8      	ldr	r0, [r7, #12]
 8006212:	f8d0 0144 	ldr.w	r0, [r0, #324]	; 0x144
 8006216:	ea4f 4470 	mov.w	r4, r0, ror #17
 800621a:	68f8      	ldr	r0, [r7, #12]
 800621c:	f8d0 0144 	ldr.w	r0, [r0, #324]	; 0x144
 8006220:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006224:	4044      	eors	r4, r0
 8006226:	68f8      	ldr	r0, [r7, #12]
 8006228:	f8d0 0144 	ldr.w	r0, [r0, #324]	; 0x144
 800622c:	0a80      	lsrs	r0, r0, #10
 800622e:	4044      	eors	r4, r0
 8006230:	68f8      	ldr	r0, [r7, #12]
 8006232:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 8006236:	4404      	add	r4, r0
 8006238:	68f8      	ldr	r0, [r7, #12]
 800623a:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 800623e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8006242:	68f8      	ldr	r0, [r7, #12]
 8006244:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8006248:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800624c:	4045      	eors	r5, r0
 800624e:	68f8      	ldr	r0, [r7, #12]
 8006250:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 8006254:	08c0      	lsrs	r0, r0, #3
 8006256:	4068      	eors	r0, r5
 8006258:	4404      	add	r4, r0
 800625a:	68f8      	ldr	r0, [r7, #12]
 800625c:	f8d0 010c 	ldr.w	r0, [r0, #268]	; 0x10c
 8006260:	4404      	add	r4, r0
 8006262:	68f8      	ldr	r0, [r7, #12]
 8006264:	f8c0 414c 	str.w	r4, [r0, #332]	; 0x14c
 8006268:	68f8      	ldr	r0, [r7, #12]
 800626a:	f8d0 014c 	ldr.w	r0, [r0, #332]	; 0x14c
 800626e:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8006272:	4c72      	ldr	r4, [pc, #456]	; (800643c <B5_Sha256ProcessBlock+0x1e88>)
 8006274:	9405      	str	r4, [sp, #20]
 8006276:	9004      	str	r0, [sp, #16]
 8006278:	f107 0014 	add.w	r0, r7, #20
 800627c:	9003      	str	r0, [sp, #12]
 800627e:	9102      	str	r1, [sp, #8]
 8006280:	9201      	str	r2, [sp, #4]
 8006282:	9300      	str	r3, [sp, #0]
 8006284:	462b      	mov	r3, r5
 8006286:	683a      	ldr	r2, [r7, #0]
 8006288:	6879      	ldr	r1, [r7, #4]
 800628a:	4630      	mov	r0, r6
 800628c:	f7fe f949 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( G, H, A, &B, C, D, E, &F, B5_SHA256_R(58), 0x84C87814 );
 8006290:	697e      	ldr	r6, [r7, #20]
 8006292:	693b      	ldr	r3, [r7, #16]
 8006294:	607b      	str	r3, [r7, #4]
 8006296:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8006298:	603a      	str	r2, [r7, #0]
 800629a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800629c:	6a3a      	ldr	r2, [r7, #32]
 800629e:	69f9      	ldr	r1, [r7, #28]
 80062a0:	68f8      	ldr	r0, [r7, #12]
 80062a2:	f8d0 0148 	ldr.w	r0, [r0, #328]	; 0x148
 80062a6:	ea4f 4470 	mov.w	r4, r0, ror #17
 80062aa:	68f8      	ldr	r0, [r7, #12]
 80062ac:	f8d0 0148 	ldr.w	r0, [r0, #328]	; 0x148
 80062b0:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80062b4:	4044      	eors	r4, r0
 80062b6:	68f8      	ldr	r0, [r7, #12]
 80062b8:	f8d0 0148 	ldr.w	r0, [r0, #328]	; 0x148
 80062bc:	0a80      	lsrs	r0, r0, #10
 80062be:	4044      	eors	r4, r0
 80062c0:	68f8      	ldr	r0, [r7, #12]
 80062c2:	f8d0 0134 	ldr.w	r0, [r0, #308]	; 0x134
 80062c6:	4404      	add	r4, r0
 80062c8:	68f8      	ldr	r0, [r7, #12]
 80062ca:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 80062ce:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80062d2:	68f8      	ldr	r0, [r7, #12]
 80062d4:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 80062d8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80062dc:	4045      	eors	r5, r0
 80062de:	68f8      	ldr	r0, [r7, #12]
 80062e0:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 80062e4:	08c0      	lsrs	r0, r0, #3
 80062e6:	4068      	eors	r0, r5
 80062e8:	4404      	add	r4, r0
 80062ea:	68f8      	ldr	r0, [r7, #12]
 80062ec:	f8d0 0110 	ldr.w	r0, [r0, #272]	; 0x110
 80062f0:	4404      	add	r4, r0
 80062f2:	68f8      	ldr	r0, [r7, #12]
 80062f4:	f8c0 4150 	str.w	r4, [r0, #336]	; 0x150
 80062f8:	68f8      	ldr	r0, [r7, #12]
 80062fa:	f8d0 0150 	ldr.w	r0, [r0, #336]	; 0x150
 80062fe:	f107 0528 	add.w	r5, r7, #40	; 0x28
 8006302:	4c4f      	ldr	r4, [pc, #316]	; (8006440 <B5_Sha256ProcessBlock+0x1e8c>)
 8006304:	9405      	str	r4, [sp, #20]
 8006306:	9004      	str	r0, [sp, #16]
 8006308:	f107 0018 	add.w	r0, r7, #24
 800630c:	9003      	str	r0, [sp, #12]
 800630e:	9102      	str	r1, [sp, #8]
 8006310:	9201      	str	r2, [sp, #4]
 8006312:	9300      	str	r3, [sp, #0]
 8006314:	462b      	mov	r3, r5
 8006316:	683a      	ldr	r2, [r7, #0]
 8006318:	6879      	ldr	r1, [r7, #4]
 800631a:	4630      	mov	r0, r6
 800631c:	f7fe f901 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( F, G, H, &A, B, C, D, &E, B5_SHA256_R(59), 0x8CC70208 );
 8006320:	69be      	ldr	r6, [r7, #24]
 8006322:	697b      	ldr	r3, [r7, #20]
 8006324:	607b      	str	r3, [r7, #4]
 8006326:	693a      	ldr	r2, [r7, #16]
 8006328:	603a      	str	r2, [r7, #0]
 800632a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800632c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800632e:	6a39      	ldr	r1, [r7, #32]
 8006330:	68f8      	ldr	r0, [r7, #12]
 8006332:	f8d0 014c 	ldr.w	r0, [r0, #332]	; 0x14c
 8006336:	ea4f 4470 	mov.w	r4, r0, ror #17
 800633a:	68f8      	ldr	r0, [r7, #12]
 800633c:	f8d0 014c 	ldr.w	r0, [r0, #332]	; 0x14c
 8006340:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006344:	4044      	eors	r4, r0
 8006346:	68f8      	ldr	r0, [r7, #12]
 8006348:	f8d0 014c 	ldr.w	r0, [r0, #332]	; 0x14c
 800634c:	0a80      	lsrs	r0, r0, #10
 800634e:	4044      	eors	r4, r0
 8006350:	68f8      	ldr	r0, [r7, #12]
 8006352:	f8d0 0138 	ldr.w	r0, [r0, #312]	; 0x138
 8006356:	4404      	add	r4, r0
 8006358:	68f8      	ldr	r0, [r7, #12]
 800635a:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 800635e:	ea4f 15f0 	mov.w	r5, r0, ror #7
 8006362:	68f8      	ldr	r0, [r7, #12]
 8006364:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8006368:	ea4f 40b0 	mov.w	r0, r0, ror #18
 800636c:	4045      	eors	r5, r0
 800636e:	68f8      	ldr	r0, [r7, #12]
 8006370:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8006374:	08c0      	lsrs	r0, r0, #3
 8006376:	4068      	eors	r0, r5
 8006378:	4404      	add	r4, r0
 800637a:	68f8      	ldr	r0, [r7, #12]
 800637c:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
 8006380:	4404      	add	r4, r0
 8006382:	68f8      	ldr	r0, [r7, #12]
 8006384:	f8c0 4154 	str.w	r4, [r0, #340]	; 0x154
 8006388:	68f8      	ldr	r0, [r7, #12]
 800638a:	f8d0 0154 	ldr.w	r0, [r0, #340]	; 0x154
 800638e:	f107 052c 	add.w	r5, r7, #44	; 0x2c
 8006392:	4c2c      	ldr	r4, [pc, #176]	; (8006444 <B5_Sha256ProcessBlock+0x1e90>)
 8006394:	9405      	str	r4, [sp, #20]
 8006396:	9004      	str	r0, [sp, #16]
 8006398:	f107 001c 	add.w	r0, r7, #28
 800639c:	9003      	str	r0, [sp, #12]
 800639e:	9102      	str	r1, [sp, #8]
 80063a0:	9201      	str	r2, [sp, #4]
 80063a2:	9300      	str	r3, [sp, #0]
 80063a4:	462b      	mov	r3, r5
 80063a6:	683a      	ldr	r2, [r7, #0]
 80063a8:	6879      	ldr	r1, [r7, #4]
 80063aa:	4630      	mov	r0, r6
 80063ac:	f7fe f8b9 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( E, F, G, &H, A, B, C, &D, B5_SHA256_R(60), 0x90BEFFFA );
 80063b0:	69fe      	ldr	r6, [r7, #28]
 80063b2:	69bb      	ldr	r3, [r7, #24]
 80063b4:	607b      	str	r3, [r7, #4]
 80063b6:	697a      	ldr	r2, [r7, #20]
 80063b8:	603a      	str	r2, [r7, #0]
 80063ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80063bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80063be:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80063c0:	68f8      	ldr	r0, [r7, #12]
 80063c2:	f8d0 0150 	ldr.w	r0, [r0, #336]	; 0x150
 80063c6:	ea4f 4470 	mov.w	r4, r0, ror #17
 80063ca:	68f8      	ldr	r0, [r7, #12]
 80063cc:	f8d0 0150 	ldr.w	r0, [r0, #336]	; 0x150
 80063d0:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80063d4:	4044      	eors	r4, r0
 80063d6:	68f8      	ldr	r0, [r7, #12]
 80063d8:	f8d0 0150 	ldr.w	r0, [r0, #336]	; 0x150
 80063dc:	0a80      	lsrs	r0, r0, #10
 80063de:	4044      	eors	r4, r0
 80063e0:	68f8      	ldr	r0, [r7, #12]
 80063e2:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
 80063e6:	4404      	add	r4, r0
 80063e8:	68f8      	ldr	r0, [r7, #12]
 80063ea:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 80063ee:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80063f2:	68f8      	ldr	r0, [r7, #12]
 80063f4:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 80063f8:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80063fc:	4045      	eors	r5, r0
 80063fe:	68f8      	ldr	r0, [r7, #12]
 8006400:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 8006404:	08c0      	lsrs	r0, r0, #3
 8006406:	4068      	eors	r0, r5
 8006408:	4404      	add	r4, r0
 800640a:	68f8      	ldr	r0, [r7, #12]
 800640c:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
 8006410:	4404      	add	r4, r0
 8006412:	68f8      	ldr	r0, [r7, #12]
 8006414:	f8c0 4158 	str.w	r4, [r0, #344]	; 0x158
 8006418:	68f8      	ldr	r0, [r7, #12]
 800641a:	f8d0 0158 	ldr.w	r0, [r0, #344]	; 0x158
 800641e:	f107 0510 	add.w	r5, r7, #16
 8006422:	4c09      	ldr	r4, [pc, #36]	; (8006448 <B5_Sha256ProcessBlock+0x1e94>)
 8006424:	9405      	str	r4, [sp, #20]
 8006426:	9004      	str	r0, [sp, #16]
 8006428:	f107 0020 	add.w	r0, r7, #32
 800642c:	9003      	str	r0, [sp, #12]
 800642e:	9102      	str	r1, [sp, #8]
 8006430:	e00c      	b.n	800644c <B5_Sha256ProcessBlock+0x1e98>
 8006432:	bf00      	nop
 8006434:	682e6ff3 	.word	0x682e6ff3
 8006438:	748f82ee 	.word	0x748f82ee
 800643c:	78a5636f 	.word	0x78a5636f
 8006440:	84c87814 	.word	0x84c87814
 8006444:	8cc70208 	.word	0x8cc70208
 8006448:	90befffa 	.word	0x90befffa
 800644c:	9201      	str	r2, [sp, #4]
 800644e:	9300      	str	r3, [sp, #0]
 8006450:	462b      	mov	r3, r5
 8006452:	683a      	ldr	r2, [r7, #0]
 8006454:	6879      	ldr	r1, [r7, #4]
 8006456:	4630      	mov	r0, r6
 8006458:	f7fe f863 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( D, E, F, &G, H, A, B, &C, B5_SHA256_R(61), 0xA4506CEB );
 800645c:	6a3e      	ldr	r6, [r7, #32]
 800645e:	69fb      	ldr	r3, [r7, #28]
 8006460:	607b      	str	r3, [r7, #4]
 8006462:	69ba      	ldr	r2, [r7, #24]
 8006464:	603a      	str	r2, [r7, #0]
 8006466:	693b      	ldr	r3, [r7, #16]
 8006468:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800646a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800646c:	68f8      	ldr	r0, [r7, #12]
 800646e:	f8d0 0154 	ldr.w	r0, [r0, #340]	; 0x154
 8006472:	ea4f 4470 	mov.w	r4, r0, ror #17
 8006476:	68f8      	ldr	r0, [r7, #12]
 8006478:	f8d0 0154 	ldr.w	r0, [r0, #340]	; 0x154
 800647c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006480:	4044      	eors	r4, r0
 8006482:	68f8      	ldr	r0, [r7, #12]
 8006484:	f8d0 0154 	ldr.w	r0, [r0, #340]	; 0x154
 8006488:	0a80      	lsrs	r0, r0, #10
 800648a:	4044      	eors	r4, r0
 800648c:	68f8      	ldr	r0, [r7, #12]
 800648e:	f8d0 0140 	ldr.w	r0, [r0, #320]	; 0x140
 8006492:	4404      	add	r4, r0
 8006494:	68f8      	ldr	r0, [r7, #12]
 8006496:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 800649a:	ea4f 15f0 	mov.w	r5, r0, ror #7
 800649e:	68f8      	ldr	r0, [r7, #12]
 80064a0:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 80064a4:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80064a8:	4045      	eors	r5, r0
 80064aa:	68f8      	ldr	r0, [r7, #12]
 80064ac:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 80064b0:	08c0      	lsrs	r0, r0, #3
 80064b2:	4068      	eors	r0, r5
 80064b4:	4404      	add	r4, r0
 80064b6:	68f8      	ldr	r0, [r7, #12]
 80064b8:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
 80064bc:	4404      	add	r4, r0
 80064be:	68f8      	ldr	r0, [r7, #12]
 80064c0:	f8c0 415c 	str.w	r4, [r0, #348]	; 0x15c
 80064c4:	68f8      	ldr	r0, [r7, #12]
 80064c6:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
 80064ca:	f107 0514 	add.w	r5, r7, #20
 80064ce:	4c69      	ldr	r4, [pc, #420]	; (8006674 <B5_Sha256ProcessBlock+0x20c0>)
 80064d0:	9405      	str	r4, [sp, #20]
 80064d2:	9004      	str	r0, [sp, #16]
 80064d4:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80064d8:	9003      	str	r0, [sp, #12]
 80064da:	9102      	str	r1, [sp, #8]
 80064dc:	9201      	str	r2, [sp, #4]
 80064de:	9300      	str	r3, [sp, #0]
 80064e0:	462b      	mov	r3, r5
 80064e2:	683a      	ldr	r2, [r7, #0]
 80064e4:	6879      	ldr	r1, [r7, #4]
 80064e6:	4630      	mov	r0, r6
 80064e8:	f7fe f81b 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( C, D, E, &F, G, H, A, &B, B5_SHA256_R(62), 0xBEF9A3F7 );
 80064ec:	6a7e      	ldr	r6, [r7, #36]	; 0x24
 80064ee:	6a3b      	ldr	r3, [r7, #32]
 80064f0:	607b      	str	r3, [r7, #4]
 80064f2:	69fa      	ldr	r2, [r7, #28]
 80064f4:	603a      	str	r2, [r7, #0]
 80064f6:	697b      	ldr	r3, [r7, #20]
 80064f8:	693a      	ldr	r2, [r7, #16]
 80064fa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80064fc:	68f8      	ldr	r0, [r7, #12]
 80064fe:	f8d0 0158 	ldr.w	r0, [r0, #344]	; 0x158
 8006502:	ea4f 4470 	mov.w	r4, r0, ror #17
 8006506:	68f8      	ldr	r0, [r7, #12]
 8006508:	f8d0 0158 	ldr.w	r0, [r0, #344]	; 0x158
 800650c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 8006510:	4044      	eors	r4, r0
 8006512:	68f8      	ldr	r0, [r7, #12]
 8006514:	f8d0 0158 	ldr.w	r0, [r0, #344]	; 0x158
 8006518:	0a80      	lsrs	r0, r0, #10
 800651a:	4044      	eors	r4, r0
 800651c:	68f8      	ldr	r0, [r7, #12]
 800651e:	f8d0 0144 	ldr.w	r0, [r0, #324]	; 0x144
 8006522:	4404      	add	r4, r0
 8006524:	68f8      	ldr	r0, [r7, #12]
 8006526:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 800652a:	ea4f 15f0 	mov.w	r5, r0, ror #7
 800652e:	68f8      	ldr	r0, [r7, #12]
 8006530:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8006534:	ea4f 40b0 	mov.w	r0, r0, ror #18
 8006538:	4045      	eors	r5, r0
 800653a:	68f8      	ldr	r0, [r7, #12]
 800653c:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 8006540:	08c0      	lsrs	r0, r0, #3
 8006542:	4068      	eors	r0, r5
 8006544:	4404      	add	r4, r0
 8006546:	68f8      	ldr	r0, [r7, #12]
 8006548:	f8d0 0120 	ldr.w	r0, [r0, #288]	; 0x120
 800654c:	4404      	add	r4, r0
 800654e:	68f8      	ldr	r0, [r7, #12]
 8006550:	f8c0 4160 	str.w	r4, [r0, #352]	; 0x160
 8006554:	68f8      	ldr	r0, [r7, #12]
 8006556:	f8d0 0160 	ldr.w	r0, [r0, #352]	; 0x160
 800655a:	f107 0518 	add.w	r5, r7, #24
 800655e:	4c46      	ldr	r4, [pc, #280]	; (8006678 <B5_Sha256ProcessBlock+0x20c4>)
 8006560:	9405      	str	r4, [sp, #20]
 8006562:	9004      	str	r0, [sp, #16]
 8006564:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8006568:	9003      	str	r0, [sp, #12]
 800656a:	9102      	str	r1, [sp, #8]
 800656c:	9201      	str	r2, [sp, #4]
 800656e:	9300      	str	r3, [sp, #0]
 8006570:	462b      	mov	r3, r5
 8006572:	683a      	ldr	r2, [r7, #0]
 8006574:	6879      	ldr	r1, [r7, #4]
 8006576:	4630      	mov	r0, r6
 8006578:	f7fd ffd3 	bl	8004522 <B5_SHA256_P>
    B5_SHA256_P( B, C, D, &E, F, G, H, &A, B5_SHA256_R(63), 0xC67178F2 );
 800657c:	6abe      	ldr	r6, [r7, #40]	; 0x28
 800657e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006580:	607b      	str	r3, [r7, #4]
 8006582:	6a3a      	ldr	r2, [r7, #32]
 8006584:	603a      	str	r2, [r7, #0]
 8006586:	69bb      	ldr	r3, [r7, #24]
 8006588:	697a      	ldr	r2, [r7, #20]
 800658a:	6939      	ldr	r1, [r7, #16]
 800658c:	68f8      	ldr	r0, [r7, #12]
 800658e:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
 8006592:	ea4f 4470 	mov.w	r4, r0, ror #17
 8006596:	68f8      	ldr	r0, [r7, #12]
 8006598:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
 800659c:	ea4f 40f0 	mov.w	r0, r0, ror #19
 80065a0:	4044      	eors	r4, r0
 80065a2:	68f8      	ldr	r0, [r7, #12]
 80065a4:	f8d0 015c 	ldr.w	r0, [r0, #348]	; 0x15c
 80065a8:	0a80      	lsrs	r0, r0, #10
 80065aa:	4044      	eors	r4, r0
 80065ac:	68f8      	ldr	r0, [r7, #12]
 80065ae:	f8d0 0148 	ldr.w	r0, [r0, #328]	; 0x148
 80065b2:	4404      	add	r4, r0
 80065b4:	68f8      	ldr	r0, [r7, #12]
 80065b6:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 80065ba:	ea4f 15f0 	mov.w	r5, r0, ror #7
 80065be:	68f8      	ldr	r0, [r7, #12]
 80065c0:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 80065c4:	ea4f 40b0 	mov.w	r0, r0, ror #18
 80065c8:	4045      	eors	r5, r0
 80065ca:	68f8      	ldr	r0, [r7, #12]
 80065cc:	f8d0 0128 	ldr.w	r0, [r0, #296]	; 0x128
 80065d0:	08c0      	lsrs	r0, r0, #3
 80065d2:	4068      	eors	r0, r5
 80065d4:	4404      	add	r4, r0
 80065d6:	68f8      	ldr	r0, [r7, #12]
 80065d8:	f8d0 0124 	ldr.w	r0, [r0, #292]	; 0x124
 80065dc:	4404      	add	r4, r0
 80065de:	68f8      	ldr	r0, [r7, #12]
 80065e0:	f8c0 4164 	str.w	r4, [r0, #356]	; 0x164
 80065e4:	68f8      	ldr	r0, [r7, #12]
 80065e6:	f8d0 0164 	ldr.w	r0, [r0, #356]	; 0x164
 80065ea:	f107 051c 	add.w	r5, r7, #28
 80065ee:	4c23      	ldr	r4, [pc, #140]	; (800667c <B5_Sha256ProcessBlock+0x20c8>)
 80065f0:	9405      	str	r4, [sp, #20]
 80065f2:	9004      	str	r0, [sp, #16]
 80065f4:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80065f8:	9003      	str	r0, [sp, #12]
 80065fa:	9102      	str	r1, [sp, #8]
 80065fc:	9201      	str	r2, [sp, #4]
 80065fe:	9300      	str	r3, [sp, #0]
 8006600:	462b      	mov	r3, r5
 8006602:	683a      	ldr	r2, [r7, #0]
 8006604:	6879      	ldr	r1, [r7, #4]
 8006606:	4630      	mov	r0, r6
 8006608:	f7fd ff8b 	bl	8004522 <B5_SHA256_P>

    ctx->state[0] += A;
 800660c:	68fb      	ldr	r3, [r7, #12]
 800660e:	689a      	ldr	r2, [r3, #8]
 8006610:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006612:	441a      	add	r2, r3
 8006614:	68fb      	ldr	r3, [r7, #12]
 8006616:	609a      	str	r2, [r3, #8]
    ctx->state[1] += B;
 8006618:	68fb      	ldr	r3, [r7, #12]
 800661a:	68da      	ldr	r2, [r3, #12]
 800661c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800661e:	441a      	add	r2, r3
 8006620:	68fb      	ldr	r3, [r7, #12]
 8006622:	60da      	str	r2, [r3, #12]
    ctx->state[2] += C;
 8006624:	68fb      	ldr	r3, [r7, #12]
 8006626:	691a      	ldr	r2, [r3, #16]
 8006628:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800662a:	441a      	add	r2, r3
 800662c:	68fb      	ldr	r3, [r7, #12]
 800662e:	611a      	str	r2, [r3, #16]
    ctx->state[3] += D;
 8006630:	68fb      	ldr	r3, [r7, #12]
 8006632:	695a      	ldr	r2, [r3, #20]
 8006634:	6a3b      	ldr	r3, [r7, #32]
 8006636:	441a      	add	r2, r3
 8006638:	68fb      	ldr	r3, [r7, #12]
 800663a:	615a      	str	r2, [r3, #20]
    ctx->state[4] += E;
 800663c:	68fb      	ldr	r3, [r7, #12]
 800663e:	699a      	ldr	r2, [r3, #24]
 8006640:	69fb      	ldr	r3, [r7, #28]
 8006642:	441a      	add	r2, r3
 8006644:	68fb      	ldr	r3, [r7, #12]
 8006646:	619a      	str	r2, [r3, #24]
    ctx->state[5] += F;
 8006648:	68fb      	ldr	r3, [r7, #12]
 800664a:	69da      	ldr	r2, [r3, #28]
 800664c:	69bb      	ldr	r3, [r7, #24]
 800664e:	441a      	add	r2, r3
 8006650:	68fb      	ldr	r3, [r7, #12]
 8006652:	61da      	str	r2, [r3, #28]
    ctx->state[6] += G;
 8006654:	68fb      	ldr	r3, [r7, #12]
 8006656:	6a1a      	ldr	r2, [r3, #32]
 8006658:	697b      	ldr	r3, [r7, #20]
 800665a:	441a      	add	r2, r3
 800665c:	68fb      	ldr	r3, [r7, #12]
 800665e:	621a      	str	r2, [r3, #32]
    ctx->state[7] += H;
 8006660:	68fb      	ldr	r3, [r7, #12]
 8006662:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006664:	693b      	ldr	r3, [r7, #16]
 8006666:	441a      	add	r2, r3
 8006668:	68fb      	ldr	r3, [r7, #12]
 800666a:	625a      	str	r2, [r3, #36]	; 0x24
}
 800666c:	bf00      	nop
 800666e:	3734      	adds	r7, #52	; 0x34
 8006670:	46bd      	mov	sp, r7
 8006672:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006674:	a4506ceb 	.word	0xa4506ceb
 8006678:	bef9a3f7 	.word	0xbef9a3f7
 800667c:	c67178f2 	.word	0xc67178f2

08006680 <B5_Sha256_Init>:




int32_t B5_Sha256_Init (B5_tSha256Ctx *ctx)
{
 8006680:	b580      	push	{r7, lr}
 8006682:	b082      	sub	sp, #8
 8006684:	af00      	add	r7, sp, #0
 8006686:	6078      	str	r0, [r7, #4]
    
    if(ctx == NULL)
 8006688:	687b      	ldr	r3, [r7, #4]
 800668a:	2b00      	cmp	r3, #0
 800668c:	d102      	bne.n	8006694 <B5_Sha256_Init+0x14>
        return  B5_SHA256_RES_INVALID_CONTEXT;
 800668e:	f04f 33ff 	mov.w	r3, #4294967295
 8006692:	e024      	b.n	80066de <B5_Sha256_Init+0x5e>
    
    memset(ctx, 0, sizeof(B5_tSha256Ctx));
 8006694:	f44f 72b4 	mov.w	r2, #360	; 0x168
 8006698:	2100      	movs	r1, #0
 800669a:	6878      	ldr	r0, [r7, #4]
 800669c:	f014 fca7 	bl	801afee <memset>
        
   
    // Set initial hash value
    ctx->total[0] = 0;
 80066a0:	687b      	ldr	r3, [r7, #4]
 80066a2:	2200      	movs	r2, #0
 80066a4:	601a      	str	r2, [r3, #0]
    ctx->total[1] = 0;
 80066a6:	687b      	ldr	r3, [r7, #4]
 80066a8:	2200      	movs	r2, #0
 80066aa:	605a      	str	r2, [r3, #4]

    ctx->state[0] = 0x6A09E667;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	4a0e      	ldr	r2, [pc, #56]	; (80066e8 <B5_Sha256_Init+0x68>)
 80066b0:	609a      	str	r2, [r3, #8]
    ctx->state[1] = 0xBB67AE85;
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	4a0d      	ldr	r2, [pc, #52]	; (80066ec <B5_Sha256_Init+0x6c>)
 80066b6:	60da      	str	r2, [r3, #12]
    ctx->state[2] = 0x3C6EF372;
 80066b8:	687b      	ldr	r3, [r7, #4]
 80066ba:	4a0d      	ldr	r2, [pc, #52]	; (80066f0 <B5_Sha256_Init+0x70>)
 80066bc:	611a      	str	r2, [r3, #16]
    ctx->state[3] = 0xA54FF53A;
 80066be:	687b      	ldr	r3, [r7, #4]
 80066c0:	4a0c      	ldr	r2, [pc, #48]	; (80066f4 <B5_Sha256_Init+0x74>)
 80066c2:	615a      	str	r2, [r3, #20]
    ctx->state[4] = 0x510E527F;
 80066c4:	687b      	ldr	r3, [r7, #4]
 80066c6:	4a0c      	ldr	r2, [pc, #48]	; (80066f8 <B5_Sha256_Init+0x78>)
 80066c8:	619a      	str	r2, [r3, #24]
    ctx->state[5] = 0x9B05688C;
 80066ca:	687b      	ldr	r3, [r7, #4]
 80066cc:	4a0b      	ldr	r2, [pc, #44]	; (80066fc <B5_Sha256_Init+0x7c>)
 80066ce:	61da      	str	r2, [r3, #28]
    ctx->state[6] = 0x1F83D9AB;
 80066d0:	687b      	ldr	r3, [r7, #4]
 80066d2:	4a0b      	ldr	r2, [pc, #44]	; (8006700 <B5_Sha256_Init+0x80>)
 80066d4:	621a      	str	r2, [r3, #32]
    ctx->state[7] = 0x5BE0CD19;
 80066d6:	687b      	ldr	r3, [r7, #4]
 80066d8:	4a0a      	ldr	r2, [pc, #40]	; (8006704 <B5_Sha256_Init+0x84>)
 80066da:	625a      	str	r2, [r3, #36]	; 0x24
    
   return B5_SHA256_RES_OK;
 80066dc:	2300      	movs	r3, #0
}
 80066de:	4618      	mov	r0, r3
 80066e0:	3708      	adds	r7, #8
 80066e2:	46bd      	mov	sp, r7
 80066e4:	bd80      	pop	{r7, pc}
 80066e6:	bf00      	nop
 80066e8:	6a09e667 	.word	0x6a09e667
 80066ec:	bb67ae85 	.word	0xbb67ae85
 80066f0:	3c6ef372 	.word	0x3c6ef372
 80066f4:	a54ff53a 	.word	0xa54ff53a
 80066f8:	510e527f 	.word	0x510e527f
 80066fc:	9b05688c 	.word	0x9b05688c
 8006700:	1f83d9ab 	.word	0x1f83d9ab
 8006704:	5be0cd19 	.word	0x5be0cd19

08006708 <B5_Sha256_Update>:




int32_t B5_Sha256_Update (B5_tSha256Ctx *ctx, const uint8_t* data, int32_t dataLen) 
{
 8006708:	b580      	push	{r7, lr}
 800670a:	b086      	sub	sp, #24
 800670c:	af00      	add	r7, sp, #0
 800670e:	60f8      	str	r0, [r7, #12]
 8006710:	60b9      	str	r1, [r7, #8]
 8006712:	607a      	str	r2, [r7, #4]
    uint32_t left, fill;
    
    if(ctx == NULL)
 8006714:	68fb      	ldr	r3, [r7, #12]
 8006716:	2b00      	cmp	r3, #0
 8006718:	d102      	bne.n	8006720 <B5_Sha256_Update+0x18>
        return  B5_SHA256_RES_INVALID_CONTEXT;
 800671a:	f04f 33ff 	mov.w	r3, #4294967295
 800671e:	e062      	b.n	80067e6 <B5_Sha256_Update+0xde>
    
    if((data == NULL) || (dataLen < 0))
 8006720:	68bb      	ldr	r3, [r7, #8]
 8006722:	2b00      	cmp	r3, #0
 8006724:	d002      	beq.n	800672c <B5_Sha256_Update+0x24>
 8006726:	687b      	ldr	r3, [r7, #4]
 8006728:	2b00      	cmp	r3, #0
 800672a:	da02      	bge.n	8006732 <B5_Sha256_Update+0x2a>
        return B5_SHA256_RES_INVALID_ARGUMENT;
 800672c:	f06f 0302 	mvn.w	r3, #2
 8006730:	e059      	b.n	80067e6 <B5_Sha256_Update+0xde>
        


    left = ctx->total[0] & 0x3F;
 8006732:	68fb      	ldr	r3, [r7, #12]
 8006734:	681b      	ldr	r3, [r3, #0]
 8006736:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800673a:	617b      	str	r3, [r7, #20]
    fill = 64 - left;
 800673c:	697b      	ldr	r3, [r7, #20]
 800673e:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
 8006742:	613b      	str	r3, [r7, #16]

    ctx->total[0] += dataLen;
 8006744:	68fb      	ldr	r3, [r7, #12]
 8006746:	681a      	ldr	r2, [r3, #0]
 8006748:	687b      	ldr	r3, [r7, #4]
 800674a:	441a      	add	r2, r3
 800674c:	68fb      	ldr	r3, [r7, #12]
 800674e:	601a      	str	r2, [r3, #0]
    ctx->total[0] &= 0xFFFFFFFF;
 8006750:	68fb      	ldr	r3, [r7, #12]
 8006752:	681a      	ldr	r2, [r3, #0]
 8006754:	68fb      	ldr	r3, [r7, #12]
 8006756:	601a      	str	r2, [r3, #0]

    if( ctx->total[0] < (uint32_t) dataLen )
 8006758:	68fb      	ldr	r3, [r7, #12]
 800675a:	681a      	ldr	r2, [r3, #0]
 800675c:	687b      	ldr	r3, [r7, #4]
 800675e:	429a      	cmp	r2, r3
 8006760:	d204      	bcs.n	800676c <B5_Sha256_Update+0x64>
        ctx->total[1]++;
 8006762:	68fb      	ldr	r3, [r7, #12]
 8006764:	685b      	ldr	r3, [r3, #4]
 8006766:	1c5a      	adds	r2, r3, #1
 8006768:	68fb      	ldr	r3, [r7, #12]
 800676a:	605a      	str	r2, [r3, #4]

    if( left && ((uint32_t) dataLen >= fill) )
 800676c:	697b      	ldr	r3, [r7, #20]
 800676e:	2b00      	cmp	r3, #0
 8006770:	d028      	beq.n	80067c4 <B5_Sha256_Update+0xbc>
 8006772:	687b      	ldr	r3, [r7, #4]
 8006774:	693a      	ldr	r2, [r7, #16]
 8006776:	429a      	cmp	r2, r3
 8006778:	d824      	bhi.n	80067c4 <B5_Sha256_Update+0xbc>
    {
        memcpy( (void *) (ctx->buffer + left),
 800677a:	68fb      	ldr	r3, [r7, #12]
 800677c:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8006780:	697b      	ldr	r3, [r7, #20]
 8006782:	4413      	add	r3, r2
 8006784:	693a      	ldr	r2, [r7, #16]
 8006786:	68b9      	ldr	r1, [r7, #8]
 8006788:	4618      	mov	r0, r3
 800678a:	f014 fc0c 	bl	801afa6 <memcpy>
                (void *) data, fill );
        B5_Sha256ProcessBlock( ctx, ctx->buffer );
 800678e:	68fb      	ldr	r3, [r7, #12]
 8006790:	3328      	adds	r3, #40	; 0x28
 8006792:	4619      	mov	r1, r3
 8006794:	68f8      	ldr	r0, [r7, #12]
 8006796:	f7fd ff0d 	bl	80045b4 <B5_Sha256ProcessBlock>
        dataLen -= fill;
 800679a:	687a      	ldr	r2, [r7, #4]
 800679c:	693b      	ldr	r3, [r7, #16]
 800679e:	1ad3      	subs	r3, r2, r3
 80067a0:	607b      	str	r3, [r7, #4]
        data  += fill;
 80067a2:	68ba      	ldr	r2, [r7, #8]
 80067a4:	693b      	ldr	r3, [r7, #16]
 80067a6:	4413      	add	r3, r2
 80067a8:	60bb      	str	r3, [r7, #8]
        left = 0;
 80067aa:	2300      	movs	r3, #0
 80067ac:	617b      	str	r3, [r7, #20]
    }

    while( dataLen >= 64 )
 80067ae:	e009      	b.n	80067c4 <B5_Sha256_Update+0xbc>
    {
        B5_Sha256ProcessBlock( ctx, data );
 80067b0:	68b9      	ldr	r1, [r7, #8]
 80067b2:	68f8      	ldr	r0, [r7, #12]
 80067b4:	f7fd fefe 	bl	80045b4 <B5_Sha256ProcessBlock>
        dataLen -= 64;
 80067b8:	687b      	ldr	r3, [r7, #4]
 80067ba:	3b40      	subs	r3, #64	; 0x40
 80067bc:	607b      	str	r3, [r7, #4]
        data  += 64;
 80067be:	68bb      	ldr	r3, [r7, #8]
 80067c0:	3340      	adds	r3, #64	; 0x40
 80067c2:	60bb      	str	r3, [r7, #8]
    while( dataLen >= 64 )
 80067c4:	687b      	ldr	r3, [r7, #4]
 80067c6:	2b3f      	cmp	r3, #63	; 0x3f
 80067c8:	dcf2      	bgt.n	80067b0 <B5_Sha256_Update+0xa8>
    }

    if( dataLen )
 80067ca:	687b      	ldr	r3, [r7, #4]
 80067cc:	2b00      	cmp	r3, #0
 80067ce:	d009      	beq.n	80067e4 <B5_Sha256_Update+0xdc>
    {
        memcpy( (void *) (ctx->buffer + left),
 80067d0:	68fb      	ldr	r3, [r7, #12]
 80067d2:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80067d6:	697b      	ldr	r3, [r7, #20]
 80067d8:	4413      	add	r3, r2
 80067da:	687a      	ldr	r2, [r7, #4]
 80067dc:	68b9      	ldr	r1, [r7, #8]
 80067de:	4618      	mov	r0, r3
 80067e0:	f014 fbe1 	bl	801afa6 <memcpy>
                (void *) data, dataLen );
    }
    
    
   return B5_SHA256_RES_OK;
 80067e4:	2300      	movs	r3, #0
}
 80067e6:	4618      	mov	r0, r3
 80067e8:	3718      	adds	r7, #24
 80067ea:	46bd      	mov	sp, r7
 80067ec:	bd80      	pop	{r7, pc}

080067ee <B5_Sha256_Finit>:




int32_t B5_Sha256_Finit (B5_tSha256Ctx *ctx, uint8_t* rDigest)
{
 80067ee:	b580      	push	{r7, lr}
 80067f0:	b098      	sub	sp, #96	; 0x60
 80067f2:	af00      	add	r7, sp, #0
 80067f4:	6078      	str	r0, [r7, #4]
 80067f6:	6039      	str	r1, [r7, #0]
    uint32_t   last, padn;
    uint32_t   high, low;
    uint8_t    msglen[8];
    
    
    if(ctx == NULL)
 80067f8:	687b      	ldr	r3, [r7, #4]
 80067fa:	2b00      	cmp	r3, #0
 80067fc:	d102      	bne.n	8006804 <B5_Sha256_Finit+0x16>
        return B5_SHA256_RES_INVALID_CONTEXT;
 80067fe:	f04f 33ff 	mov.w	r3, #4294967295
 8006802:	e07f      	b.n	8006904 <B5_Sha256_Finit+0x116>
    
    if(rDigest == NULL)
 8006804:	683b      	ldr	r3, [r7, #0]
 8006806:	2b00      	cmp	r3, #0
 8006808:	d102      	bne.n	8006810 <B5_Sha256_Finit+0x22>
        return B5_SHA256_RES_INVALID_ARGUMENT;
 800680a:	f06f 0302 	mvn.w	r3, #2
 800680e:	e079      	b.n	8006904 <B5_Sha256_Finit+0x116>
    
   

    memset(sha2_padding,0x00,64);
 8006810:	f107 0310 	add.w	r3, r7, #16
 8006814:	2240      	movs	r2, #64	; 0x40
 8006816:	2100      	movs	r1, #0
 8006818:	4618      	mov	r0, r3
 800681a:	f014 fbe8 	bl	801afee <memset>
    sha2_padding[0] = 0x80;
 800681e:	2380      	movs	r3, #128	; 0x80
 8006820:	743b      	strb	r3, [r7, #16]


    high = ( ctx->total[0] >> 29 )
 8006822:	687b      	ldr	r3, [r7, #4]
 8006824:	681b      	ldr	r3, [r3, #0]
 8006826:	0f5a      	lsrs	r2, r3, #29
         | ( ctx->total[1] <<  3 );
 8006828:	687b      	ldr	r3, [r7, #4]
 800682a:	685b      	ldr	r3, [r3, #4]
 800682c:	00db      	lsls	r3, r3, #3
    high = ( ctx->total[0] >> 29 )
 800682e:	4313      	orrs	r3, r2
 8006830:	65fb      	str	r3, [r7, #92]	; 0x5c
    low  = ( ctx->total[0] <<  3 );
 8006832:	687b      	ldr	r3, [r7, #4]
 8006834:	681b      	ldr	r3, [r3, #0]
 8006836:	00db      	lsls	r3, r3, #3
 8006838:	65bb      	str	r3, [r7, #88]	; 0x58

    B5_SHA256_PUTUINT32( high, msglen, 0 );
 800683a:	f107 0308 	add.w	r3, r7, #8
 800683e:	2200      	movs	r2, #0
 8006840:	4619      	mov	r1, r3
 8006842:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8006844:	f7fd fe43 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( low,  msglen, 4 );
 8006848:	f107 0308 	add.w	r3, r7, #8
 800684c:	2204      	movs	r2, #4
 800684e:	4619      	mov	r1, r3
 8006850:	6db8      	ldr	r0, [r7, #88]	; 0x58
 8006852:	f7fd fe3c 	bl	80044ce <B5_SHA256_PUTUINT32>

    last = ctx->total[0] & 0x3F;
 8006856:	687b      	ldr	r3, [r7, #4]
 8006858:	681b      	ldr	r3, [r3, #0]
 800685a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800685e:	657b      	str	r3, [r7, #84]	; 0x54
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
 8006860:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006862:	2b37      	cmp	r3, #55	; 0x37
 8006864:	d803      	bhi.n	800686e <B5_Sha256_Finit+0x80>
 8006866:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006868:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 800686c:	e002      	b.n	8006874 <B5_Sha256_Finit+0x86>
 800686e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006870:	f1c3 0378 	rsb	r3, r3, #120	; 0x78
 8006874:	653b      	str	r3, [r7, #80]	; 0x50

    B5_Sha256_Update(ctx, sha2_padding, padn );
 8006876:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8006878:	f107 0310 	add.w	r3, r7, #16
 800687c:	4619      	mov	r1, r3
 800687e:	6878      	ldr	r0, [r7, #4]
 8006880:	f7ff ff42 	bl	8006708 <B5_Sha256_Update>
    B5_Sha256_Update(ctx, msglen, 8 );
 8006884:	f107 0308 	add.w	r3, r7, #8
 8006888:	2208      	movs	r2, #8
 800688a:	4619      	mov	r1, r3
 800688c:	6878      	ldr	r0, [r7, #4]
 800688e:	f7ff ff3b 	bl	8006708 <B5_Sha256_Update>
		

    B5_SHA256_PUTUINT32( ctx->state[0], rDigest,  0 );
 8006892:	687b      	ldr	r3, [r7, #4]
 8006894:	689b      	ldr	r3, [r3, #8]
 8006896:	2200      	movs	r2, #0
 8006898:	6839      	ldr	r1, [r7, #0]
 800689a:	4618      	mov	r0, r3
 800689c:	f7fd fe17 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[1], rDigest,  4 );
 80068a0:	687b      	ldr	r3, [r7, #4]
 80068a2:	68db      	ldr	r3, [r3, #12]
 80068a4:	2204      	movs	r2, #4
 80068a6:	6839      	ldr	r1, [r7, #0]
 80068a8:	4618      	mov	r0, r3
 80068aa:	f7fd fe10 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[2], rDigest,  8 );
 80068ae:	687b      	ldr	r3, [r7, #4]
 80068b0:	691b      	ldr	r3, [r3, #16]
 80068b2:	2208      	movs	r2, #8
 80068b4:	6839      	ldr	r1, [r7, #0]
 80068b6:	4618      	mov	r0, r3
 80068b8:	f7fd fe09 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[3], rDigest, 12 );
 80068bc:	687b      	ldr	r3, [r7, #4]
 80068be:	695b      	ldr	r3, [r3, #20]
 80068c0:	220c      	movs	r2, #12
 80068c2:	6839      	ldr	r1, [r7, #0]
 80068c4:	4618      	mov	r0, r3
 80068c6:	f7fd fe02 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[4], rDigest, 16 );
 80068ca:	687b      	ldr	r3, [r7, #4]
 80068cc:	699b      	ldr	r3, [r3, #24]
 80068ce:	2210      	movs	r2, #16
 80068d0:	6839      	ldr	r1, [r7, #0]
 80068d2:	4618      	mov	r0, r3
 80068d4:	f7fd fdfb 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[5], rDigest, 20 );
 80068d8:	687b      	ldr	r3, [r7, #4]
 80068da:	69db      	ldr	r3, [r3, #28]
 80068dc:	2214      	movs	r2, #20
 80068de:	6839      	ldr	r1, [r7, #0]
 80068e0:	4618      	mov	r0, r3
 80068e2:	f7fd fdf4 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[6], rDigest, 24 );
 80068e6:	687b      	ldr	r3, [r7, #4]
 80068e8:	6a1b      	ldr	r3, [r3, #32]
 80068ea:	2218      	movs	r2, #24
 80068ec:	6839      	ldr	r1, [r7, #0]
 80068ee:	4618      	mov	r0, r3
 80068f0:	f7fd fded 	bl	80044ce <B5_SHA256_PUTUINT32>
    B5_SHA256_PUTUINT32( ctx->state[7], rDigest, 28 );
 80068f4:	687b      	ldr	r3, [r7, #4]
 80068f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068f8:	221c      	movs	r2, #28
 80068fa:	6839      	ldr	r1, [r7, #0]
 80068fc:	4618      	mov	r0, r3
 80068fe:	f7fd fde6 	bl	80044ce <B5_SHA256_PUTUINT32>
    
    
    
    return B5_SHA256_RES_OK;
 8006902:	2300      	movs	r3, #0
}
 8006904:	4618      	mov	r0, r3
 8006906:	3760      	adds	r7, #96	; 0x60
 8006908:	46bd      	mov	sp, r7
 800690a:	bd80      	pop	{r7, pc}

0800690c <B5_HmacSha256_Init>:




int32_t B5_HmacSha256_Init (B5_tHmacSha256Ctx *ctx, const uint8_t *Key, int16_t keySize)
{
 800690c:	b580      	push	{r7, lr}
 800690e:	b08e      	sub	sp, #56	; 0x38
 8006910:	af00      	add	r7, sp, #0
 8006912:	60f8      	str	r0, [r7, #12]
 8006914:	60b9      	str	r1, [r7, #8]
 8006916:	4613      	mov	r3, r2
 8006918:	80fb      	strh	r3, [r7, #6]
    int32_t   i;
    uint8_t    digest[B5_SHA256_DIGEST_SIZE];

    
    if(Key == NULL) 
 800691a:	68bb      	ldr	r3, [r7, #8]
 800691c:	2b00      	cmp	r3, #0
 800691e:	d102      	bne.n	8006926 <B5_HmacSha256_Init+0x1a>
        return B5_HMAC_SHA256_RES_INVALID_ARGUMENT;
 8006920:	f06f 0302 	mvn.w	r3, #2
 8006924:	e074      	b.n	8006a10 <B5_HmacSha256_Init+0x104>
    
    if(ctx == NULL)
 8006926:	68fb      	ldr	r3, [r7, #12]
 8006928:	2b00      	cmp	r3, #0
 800692a:	d102      	bne.n	8006932 <B5_HmacSha256_Init+0x26>
        return  B5_HMAC_SHA256_RES_INVALID_CONTEXT;
 800692c:	f04f 33ff 	mov.w	r3, #4294967295
 8006930:	e06e      	b.n	8006a10 <B5_HmacSha256_Init+0x104>
    
    memset(ctx, 0, sizeof(B5_tHmacSha256Ctx));
 8006932:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 8006936:	2100      	movs	r1, #0
 8006938:	68f8      	ldr	r0, [r7, #12]
 800693a:	f014 fb58 	bl	801afee <memset>
    
    //The key is longer than the block size?
    if(keySize > B5_SHA256_BLOCK_SIZE)
 800693e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8006942:	2b40      	cmp	r3, #64	; 0x40
 8006944:	dd16      	ble.n	8006974 <B5_HmacSha256_Init+0x68>
    {
        // Initialize the hash function context
        B5_Sha256_Init(&ctx->shaCtx);
 8006946:	68fb      	ldr	r3, [r7, #12]
 8006948:	4618      	mov	r0, r3
 800694a:	f7ff fe99 	bl	8006680 <B5_Sha256_Init>
        // Digest the original key
        B5_Sha256_Update(&ctx->shaCtx, Key, keySize);
 800694e:	68fb      	ldr	r3, [r7, #12]
 8006950:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8006954:	68b9      	ldr	r1, [r7, #8]
 8006956:	4618      	mov	r0, r3
 8006958:	f7ff fed6 	bl	8006708 <B5_Sha256_Update>
        // Finalize the message digest computation
        B5_Sha256_Finit(&ctx->shaCtx, digest);
 800695c:	68fb      	ldr	r3, [r7, #12]
 800695e:	f107 0214 	add.w	r2, r7, #20
 8006962:	4611      	mov	r1, r2
 8006964:	4618      	mov	r0, r3
 8006966:	f7ff ff42 	bl	80067ee <B5_Sha256_Finit>
        
        Key = digest;
 800696a:	f107 0314 	add.w	r3, r7, #20
 800696e:	60bb      	str	r3, [r7, #8]
        keySize = B5_SHA256_DIGEST_SIZE;
 8006970:	2320      	movs	r3, #32
 8006972:	80fb      	strh	r3, [r7, #6]
    }
 
    
    memset( ctx->iPad, B5_HMAC_IPAD, 64 );
 8006974:	68fb      	ldr	r3, [r7, #12]
 8006976:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 800697a:	2240      	movs	r2, #64	; 0x40
 800697c:	2136      	movs	r1, #54	; 0x36
 800697e:	4618      	mov	r0, r3
 8006980:	f014 fb35 	bl	801afee <memset>
    memset( ctx->oPad, B5_HMAC_OPAD, 64 );
 8006984:	68fb      	ldr	r3, [r7, #12]
 8006986:	f503 73d4 	add.w	r3, r3, #424	; 0x1a8
 800698a:	2240      	movs	r2, #64	; 0x40
 800698c:	215c      	movs	r1, #92	; 0x5c
 800698e:	4618      	mov	r0, r3
 8006990:	f014 fb2d 	bl	801afee <memset>
    
    
    for( i = 0; i < keySize; i++ )
 8006994:	2300      	movs	r3, #0
 8006996:	637b      	str	r3, [r7, #52]	; 0x34
 8006998:	e028      	b.n	80069ec <B5_HmacSha256_Init+0xe0>
    {
        ctx->iPad[i] = (unsigned char)( ctx->iPad[i] ^ Key[i] );
 800699a:	68fa      	ldr	r2, [r7, #12]
 800699c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800699e:	4413      	add	r3, r2
 80069a0:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80069a4:	781a      	ldrb	r2, [r3, #0]
 80069a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069a8:	68b9      	ldr	r1, [r7, #8]
 80069aa:	440b      	add	r3, r1
 80069ac:	781b      	ldrb	r3, [r3, #0]
 80069ae:	4053      	eors	r3, r2
 80069b0:	b2d9      	uxtb	r1, r3
 80069b2:	68fa      	ldr	r2, [r7, #12]
 80069b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069b6:	4413      	add	r3, r2
 80069b8:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80069bc:	460a      	mov	r2, r1
 80069be:	701a      	strb	r2, [r3, #0]
        ctx->oPad[i] = (unsigned char)( ctx->oPad[i] ^ Key[i] );
 80069c0:	68fa      	ldr	r2, [r7, #12]
 80069c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069c4:	4413      	add	r3, r2
 80069c6:	f503 73d4 	add.w	r3, r3, #424	; 0x1a8
 80069ca:	781a      	ldrb	r2, [r3, #0]
 80069cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069ce:	68b9      	ldr	r1, [r7, #8]
 80069d0:	440b      	add	r3, r1
 80069d2:	781b      	ldrb	r3, [r3, #0]
 80069d4:	4053      	eors	r3, r2
 80069d6:	b2d9      	uxtb	r1, r3
 80069d8:	68fa      	ldr	r2, [r7, #12]
 80069da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069dc:	4413      	add	r3, r2
 80069de:	f503 73d4 	add.w	r3, r3, #424	; 0x1a8
 80069e2:	460a      	mov	r2, r1
 80069e4:	701a      	strb	r2, [r3, #0]
    for( i = 0; i < keySize; i++ )
 80069e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80069e8:	3301      	adds	r3, #1
 80069ea:	637b      	str	r3, [r7, #52]	; 0x34
 80069ec:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80069f0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80069f2:	429a      	cmp	r2, r3
 80069f4:	dbd1      	blt.n	800699a <B5_HmacSha256_Init+0x8e>
    }
    
    
    // Initialize context for the first pass
		B5_Sha256_Init(&ctx->shaCtx);
 80069f6:	68fb      	ldr	r3, [r7, #12]
 80069f8:	4618      	mov	r0, r3
 80069fa:	f7ff fe41 	bl	8006680 <B5_Sha256_Init>
    
    // Start with the inner pad
    B5_Sha256_Update(&ctx->shaCtx, ctx->iPad, B5_SHA256_BLOCK_SIZE);    
 80069fe:	68f8      	ldr	r0, [r7, #12]
 8006a00:	68fb      	ldr	r3, [r7, #12]
 8006a02:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8006a06:	2240      	movs	r2, #64	; 0x40
 8006a08:	4619      	mov	r1, r3
 8006a0a:	f7ff fe7d 	bl	8006708 <B5_Sha256_Update>
    
    return B5_HMAC_SHA256_RES_OK;
 8006a0e:	2300      	movs	r3, #0
}
 8006a10:	4618      	mov	r0, r3
 8006a12:	3738      	adds	r7, #56	; 0x38
 8006a14:	46bd      	mov	sp, r7
 8006a16:	bd80      	pop	{r7, pc}

08006a18 <B5_HmacSha256_Update>:




int32_t B5_HmacSha256_Update (B5_tHmacSha256Ctx *ctx, const uint8_t *data, int32_t dataLen)
{
 8006a18:	b580      	push	{r7, lr}
 8006a1a:	b084      	sub	sp, #16
 8006a1c:	af00      	add	r7, sp, #0
 8006a1e:	60f8      	str	r0, [r7, #12]
 8006a20:	60b9      	str	r1, [r7, #8]
 8006a22:	607a      	str	r2, [r7, #4]
    if(ctx == NULL)
 8006a24:	68fb      	ldr	r3, [r7, #12]
 8006a26:	2b00      	cmp	r3, #0
 8006a28:	d102      	bne.n	8006a30 <B5_HmacSha256_Update+0x18>
        return  B5_HMAC_SHA256_RES_INVALID_CONTEXT;
 8006a2a:	f04f 33ff 	mov.w	r3, #4294967295
 8006a2e:	e014      	b.n	8006a5a <B5_HmacSha256_Update+0x42>
    
    
    if((data == NULL) || (dataLen < 0))
 8006a30:	68bb      	ldr	r3, [r7, #8]
 8006a32:	2b00      	cmp	r3, #0
 8006a34:	d002      	beq.n	8006a3c <B5_HmacSha256_Update+0x24>
 8006a36:	687b      	ldr	r3, [r7, #4]
 8006a38:	2b00      	cmp	r3, #0
 8006a3a:	da02      	bge.n	8006a42 <B5_HmacSha256_Update+0x2a>
        return B5_HMAC_SHA256_RES_INVALID_ARGUMENT;
 8006a3c:	f06f 0302 	mvn.w	r3, #2
 8006a40:	e00b      	b.n	8006a5a <B5_HmacSha256_Update+0x42>
    
    
    if(dataLen == 0)
 8006a42:	687b      	ldr	r3, [r7, #4]
 8006a44:	2b00      	cmp	r3, #0
 8006a46:	d101      	bne.n	8006a4c <B5_HmacSha256_Update+0x34>
        return B5_HMAC_SHA256_RES_OK;
 8006a48:	2300      	movs	r3, #0
 8006a4a:	e006      	b.n	8006a5a <B5_HmacSha256_Update+0x42>
    
    
    // Digest the message (first pass)
    B5_Sha256_Update(&ctx->shaCtx, data, dataLen);
 8006a4c:	68fb      	ldr	r3, [r7, #12]
 8006a4e:	687a      	ldr	r2, [r7, #4]
 8006a50:	68b9      	ldr	r1, [r7, #8]
 8006a52:	4618      	mov	r0, r3
 8006a54:	f7ff fe58 	bl	8006708 <B5_Sha256_Update>
    
    return B5_HMAC_SHA256_RES_OK;
 8006a58:	2300      	movs	r3, #0
}
 8006a5a:	4618      	mov	r0, r3
 8006a5c:	3710      	adds	r7, #16
 8006a5e:	46bd      	mov	sp, r7
 8006a60:	bd80      	pop	{r7, pc}

08006a62 <B5_HmacSha256_Finit>:




int32_t B5_HmacSha256_Finit (B5_tHmacSha256Ctx *ctx, uint8_t *rDigest)
{
 8006a62:	b580      	push	{r7, lr}
 8006a64:	b08a      	sub	sp, #40	; 0x28
 8006a66:	af00      	add	r7, sp, #0
 8006a68:	6078      	str	r0, [r7, #4]
 8006a6a:	6039      	str	r1, [r7, #0]
    uint8_t    digest[B5_SHA256_DIGEST_SIZE];

    if(ctx == NULL)
 8006a6c:	687b      	ldr	r3, [r7, #4]
 8006a6e:	2b00      	cmp	r3, #0
 8006a70:	d102      	bne.n	8006a78 <B5_HmacSha256_Finit+0x16>
        return  B5_HMAC_SHA256_RES_INVALID_CONTEXT;
 8006a72:	f04f 33ff 	mov.w	r3, #4294967295
 8006a76:	e025      	b.n	8006ac4 <B5_HmacSha256_Finit+0x62>
    
    if(rDigest == NULL)
 8006a78:	683b      	ldr	r3, [r7, #0]
 8006a7a:	2b00      	cmp	r3, #0
 8006a7c:	d102      	bne.n	8006a84 <B5_HmacSha256_Finit+0x22>
        return B5_HMAC_SHA256_RES_INVALID_ARGUMENT;
 8006a7e:	f06f 0302 	mvn.w	r3, #2
 8006a82:	e01f      	b.n	8006ac4 <B5_HmacSha256_Finit+0x62>
    
    
    // Finish the first pass
		B5_Sha256_Finit(&ctx->shaCtx, digest);    
 8006a84:	687b      	ldr	r3, [r7, #4]
 8006a86:	f107 0208 	add.w	r2, r7, #8
 8006a8a:	4611      	mov	r1, r2
 8006a8c:	4618      	mov	r0, r3
 8006a8e:	f7ff feae 	bl	80067ee <B5_Sha256_Finit>
    
    // Initialize context for the second pass
		B5_Sha256_Init(&ctx->shaCtx);
 8006a92:	687b      	ldr	r3, [r7, #4]
 8006a94:	4618      	mov	r0, r3
 8006a96:	f7ff fdf3 	bl	8006680 <B5_Sha256_Init>
    // Start with outer pad
    B5_Sha256_Update(&ctx->shaCtx, ctx->oPad, B5_SHA256_BLOCK_SIZE);
 8006a9a:	6878      	ldr	r0, [r7, #4]
 8006a9c:	687b      	ldr	r3, [r7, #4]
 8006a9e:	f503 73d4 	add.w	r3, r3, #424	; 0x1a8
 8006aa2:	2240      	movs	r2, #64	; 0x40
 8006aa4:	4619      	mov	r1, r3
 8006aa6:	f7ff fe2f 	bl	8006708 <B5_Sha256_Update>
    // Then digest the result of the first hash
    B5_Sha256_Update(&ctx->shaCtx, digest, B5_SHA256_DIGEST_SIZE);
 8006aaa:	687b      	ldr	r3, [r7, #4]
 8006aac:	f107 0108 	add.w	r1, r7, #8
 8006ab0:	2220      	movs	r2, #32
 8006ab2:	4618      	mov	r0, r3
 8006ab4:	f7ff fe28 	bl	8006708 <B5_Sha256_Update>
    // Finish the second pass
    B5_Sha256_Finit(&ctx->shaCtx, rDigest);
 8006ab8:	687b      	ldr	r3, [r7, #4]
 8006aba:	6839      	ldr	r1, [r7, #0]
 8006abc:	4618      	mov	r0, r3
 8006abe:	f7ff fe96 	bl	80067ee <B5_Sha256_Finit>
        
    
    
    return B5_HMAC_SHA256_RES_OK;
 8006ac2:	2300      	movs	r3, #0
}
 8006ac4:	4618      	mov	r0, r3
 8006ac6:	3728      	adds	r7, #40	; 0x28
 8006ac8:	46bd      	mov	sp, r7
 8006aca:	bd80      	pop	{r7, pc}

08006acc <load64>:
 *
 * Arguments:   - const uint8_t *x: pointer to input byte array
 *
 * Returns the loaded 64-bit unsigned integer
 **************************************************/
static uint64_t load64(const uint8_t *x) {
 8006acc:	b4f0      	push	{r4, r5, r6, r7}
 8006ace:	b086      	sub	sp, #24
 8006ad0:	af00      	add	r7, sp, #0
 8006ad2:	6078      	str	r0, [r7, #4]
    uint64_t r = 0;
 8006ad4:	f04f 0100 	mov.w	r1, #0
 8006ad8:	f04f 0200 	mov.w	r2, #0
 8006adc:	e9c7 1204 	strd	r1, r2, [r7, #16]
    for (size_t i = 0; i < 8; ++i) {
 8006ae0:	2200      	movs	r2, #0
 8006ae2:	60fa      	str	r2, [r7, #12]
 8006ae4:	e021      	b.n	8006b2a <load64+0x5e>
        r |= (uint64_t)x[i] << 8 * i;
 8006ae6:	6879      	ldr	r1, [r7, #4]
 8006ae8:	68fa      	ldr	r2, [r7, #12]
 8006aea:	440a      	add	r2, r1
 8006aec:	7812      	ldrb	r2, [r2, #0]
 8006aee:	b2d1      	uxtb	r1, r2
 8006af0:	f04f 0200 	mov.w	r2, #0
 8006af4:	68f8      	ldr	r0, [r7, #12]
 8006af6:	00c0      	lsls	r0, r0, #3
 8006af8:	f1a0 0620 	sub.w	r6, r0, #32
 8006afc:	f1c0 0520 	rsb	r5, r0, #32
 8006b00:	fa02 f400 	lsl.w	r4, r2, r0
 8006b04:	fa01 f606 	lsl.w	r6, r1, r6
 8006b08:	4334      	orrs	r4, r6
 8006b0a:	fa21 f505 	lsr.w	r5, r1, r5
 8006b0e:	432c      	orrs	r4, r5
 8006b10:	fa01 f300 	lsl.w	r3, r1, r0
 8006b14:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8006b18:	ea41 0503 	orr.w	r5, r1, r3
 8006b1c:	ea42 0604 	orr.w	r6, r2, r4
 8006b20:	e9c7 5604 	strd	r5, r6, [r7, #16]
    for (size_t i = 0; i < 8; ++i) {
 8006b24:	68fa      	ldr	r2, [r7, #12]
 8006b26:	3201      	adds	r2, #1
 8006b28:	60fa      	str	r2, [r7, #12]
 8006b2a:	68fa      	ldr	r2, [r7, #12]
 8006b2c:	2a07      	cmp	r2, #7
 8006b2e:	d9da      	bls.n	8006ae6 <load64+0x1a>
    }

    return r;
 8006b30:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
}
 8006b34:	4618      	mov	r0, r3
 8006b36:	4621      	mov	r1, r4
 8006b38:	3718      	adds	r7, #24
 8006b3a:	46bd      	mov	sp, r7
 8006b3c:	bcf0      	pop	{r4, r5, r6, r7}
 8006b3e:	4770      	bx	lr

08006b40 <store64>:
 * Description: Store a 64-bit integer to a byte array in little-endian order
 *
 * Arguments:   - uint8_t *x: pointer to the output byte array
 *              - uint64_t u: input 64-bit unsigned integer
 **************************************************/
static void store64(uint8_t *x, uint64_t u) {
 8006b40:	b4f0      	push	{r4, r5, r6, r7}
 8006b42:	b086      	sub	sp, #24
 8006b44:	af00      	add	r7, sp, #0
 8006b46:	60f8      	str	r0, [r7, #12]
 8006b48:	e9c7 2300 	strd	r2, r3, [r7]
    for (size_t i = 0; i < 8; ++i) {
 8006b4c:	2300      	movs	r3, #0
 8006b4e:	617b      	str	r3, [r7, #20]
 8006b50:	e019      	b.n	8006b86 <store64+0x46>
        x[i] = (uint8_t) (u >> 8 * i);
 8006b52:	697b      	ldr	r3, [r7, #20]
 8006b54:	00d9      	lsls	r1, r3, #3
 8006b56:	e9d7 2300 	ldrd	r2, r3, [r7]
 8006b5a:	f1c1 0620 	rsb	r6, r1, #32
 8006b5e:	f1a1 0020 	sub.w	r0, r1, #32
 8006b62:	fa22 f401 	lsr.w	r4, r2, r1
 8006b66:	fa03 f606 	lsl.w	r6, r3, r6
 8006b6a:	4334      	orrs	r4, r6
 8006b6c:	fa23 f000 	lsr.w	r0, r3, r0
 8006b70:	4304      	orrs	r4, r0
 8006b72:	fa23 f501 	lsr.w	r5, r3, r1
 8006b76:	68fa      	ldr	r2, [r7, #12]
 8006b78:	697b      	ldr	r3, [r7, #20]
 8006b7a:	4413      	add	r3, r2
 8006b7c:	b2e2      	uxtb	r2, r4
 8006b7e:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < 8; ++i) {
 8006b80:	697b      	ldr	r3, [r7, #20]
 8006b82:	3301      	adds	r3, #1
 8006b84:	617b      	str	r3, [r7, #20]
 8006b86:	697b      	ldr	r3, [r7, #20]
 8006b88:	2b07      	cmp	r3, #7
 8006b8a:	d9e2      	bls.n	8006b52 <store64+0x12>
    }
}
 8006b8c:	bf00      	nop
 8006b8e:	3718      	adds	r7, #24
 8006b90:	46bd      	mov	sp, r7
 8006b92:	bcf0      	pop	{r4, r5, r6, r7}
 8006b94:	4770      	bx	lr
	...

08006b98 <KeccakF1600_StatePermute>:
 *
 * Description: The Keccak F1600 Permutation
 *
 * Arguments:   - uint64_t *state: pointer to input/output Keccak state
 **************************************************/
static void KeccakF1600_StatePermute(uint64_t *state) {
 8006b98:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8006b9c:	f5ad 7d6c 	sub.w	sp, sp, #944	; 0x3b0
 8006ba0:	af00      	add	r7, sp, #0
 8006ba2:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006ba6:	6018      	str	r0, [r3, #0]
    uint64_t Eka, Eke, Eki, Eko, Eku;
    uint64_t Ema, Eme, Emi, Emo, Emu;
    uint64_t Esa, Ese, Esi, Eso, Esu;

    // copyFromState(A, state)
    Aba = state[0];
 8006ba8:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006bac:	681b      	ldr	r3, [r3, #0]
 8006bae:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006bb2:	f507 7268 	add.w	r2, r7, #928	; 0x3a0
 8006bb6:	e9c2 3400 	strd	r3, r4, [r2]
    Abe = state[1];
 8006bba:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006bbe:	681b      	ldr	r3, [r3, #0]
 8006bc0:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
 8006bc4:	f507 7266 	add.w	r2, r7, #920	; 0x398
 8006bc8:	e9c2 3400 	strd	r3, r4, [r2]
    Abi = state[2];
 8006bcc:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006bd0:	681b      	ldr	r3, [r3, #0]
 8006bd2:	e9d3 3404 	ldrd	r3, r4, [r3, #16]
 8006bd6:	f507 7264 	add.w	r2, r7, #912	; 0x390
 8006bda:	e9c2 3400 	strd	r3, r4, [r2]
    Abo = state[3];
 8006bde:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006be2:	681b      	ldr	r3, [r3, #0]
 8006be4:	e9d3 3406 	ldrd	r3, r4, [r3, #24]
 8006be8:	f507 7262 	add.w	r2, r7, #904	; 0x388
 8006bec:	e9c2 3400 	strd	r3, r4, [r2]
    Abu = state[4];
 8006bf0:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006bf4:	681b      	ldr	r3, [r3, #0]
 8006bf6:	e9d3 3408 	ldrd	r3, r4, [r3, #32]
 8006bfa:	f507 7260 	add.w	r2, r7, #896	; 0x380
 8006bfe:	e9c2 3400 	strd	r3, r4, [r2]
    Aga = state[5];
 8006c02:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c06:	681b      	ldr	r3, [r3, #0]
 8006c08:	e9d3 340a 	ldrd	r3, r4, [r3, #40]	; 0x28
 8006c0c:	f507 725e 	add.w	r2, r7, #888	; 0x378
 8006c10:	e9c2 3400 	strd	r3, r4, [r2]
    Age = state[6];
 8006c14:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c18:	681b      	ldr	r3, [r3, #0]
 8006c1a:	e9d3 340c 	ldrd	r3, r4, [r3, #48]	; 0x30
 8006c1e:	f507 725c 	add.w	r2, r7, #880	; 0x370
 8006c22:	e9c2 3400 	strd	r3, r4, [r2]
    Agi = state[7];
 8006c26:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c2a:	681b      	ldr	r3, [r3, #0]
 8006c2c:	e9d3 340e 	ldrd	r3, r4, [r3, #56]	; 0x38
 8006c30:	f507 725a 	add.w	r2, r7, #872	; 0x368
 8006c34:	e9c2 3400 	strd	r3, r4, [r2]
    Ago = state[8];
 8006c38:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c3c:	681b      	ldr	r3, [r3, #0]
 8006c3e:	e9d3 3410 	ldrd	r3, r4, [r3, #64]	; 0x40
 8006c42:	f507 7258 	add.w	r2, r7, #864	; 0x360
 8006c46:	e9c2 3400 	strd	r3, r4, [r2]
    Agu = state[9];
 8006c4a:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c4e:	681b      	ldr	r3, [r3, #0]
 8006c50:	e9d3 3412 	ldrd	r3, r4, [r3, #72]	; 0x48
 8006c54:	f507 7256 	add.w	r2, r7, #856	; 0x358
 8006c58:	e9c2 3400 	strd	r3, r4, [r2]
    Aka = state[10];
 8006c5c:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c60:	681b      	ldr	r3, [r3, #0]
 8006c62:	e9d3 3414 	ldrd	r3, r4, [r3, #80]	; 0x50
 8006c66:	f507 7254 	add.w	r2, r7, #848	; 0x350
 8006c6a:	e9c2 3400 	strd	r3, r4, [r2]
    Ake = state[11];
 8006c6e:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c72:	681b      	ldr	r3, [r3, #0]
 8006c74:	e9d3 3416 	ldrd	r3, r4, [r3, #88]	; 0x58
 8006c78:	f507 7252 	add.w	r2, r7, #840	; 0x348
 8006c7c:	e9c2 3400 	strd	r3, r4, [r2]
    Aki = state[12];
 8006c80:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c84:	681b      	ldr	r3, [r3, #0]
 8006c86:	e9d3 3418 	ldrd	r3, r4, [r3, #96]	; 0x60
 8006c8a:	f507 7250 	add.w	r2, r7, #832	; 0x340
 8006c8e:	e9c2 3400 	strd	r3, r4, [r2]
    Ako = state[13];
 8006c92:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006c96:	681b      	ldr	r3, [r3, #0]
 8006c98:	e9d3 341a 	ldrd	r3, r4, [r3, #104]	; 0x68
 8006c9c:	f507 724e 	add.w	r2, r7, #824	; 0x338
 8006ca0:	e9c2 3400 	strd	r3, r4, [r2]
    Aku = state[14];
 8006ca4:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006ca8:	681b      	ldr	r3, [r3, #0]
 8006caa:	e9d3 341c 	ldrd	r3, r4, [r3, #112]	; 0x70
 8006cae:	f507 724c 	add.w	r2, r7, #816	; 0x330
 8006cb2:	e9c2 3400 	strd	r3, r4, [r2]
    Ama = state[15];
 8006cb6:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006cba:	681b      	ldr	r3, [r3, #0]
 8006cbc:	e9d3 341e 	ldrd	r3, r4, [r3, #120]	; 0x78
 8006cc0:	f507 724a 	add.w	r2, r7, #808	; 0x328
 8006cc4:	e9c2 3400 	strd	r3, r4, [r2]
    Ame = state[16];
 8006cc8:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006ccc:	681b      	ldr	r3, [r3, #0]
 8006cce:	e9d3 3420 	ldrd	r3, r4, [r3, #128]	; 0x80
 8006cd2:	f507 7248 	add.w	r2, r7, #800	; 0x320
 8006cd6:	e9c2 3400 	strd	r3, r4, [r2]
    Ami = state[17];
 8006cda:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006cde:	681b      	ldr	r3, [r3, #0]
 8006ce0:	e9d3 3422 	ldrd	r3, r4, [r3, #136]	; 0x88
 8006ce4:	f507 7246 	add.w	r2, r7, #792	; 0x318
 8006ce8:	e9c2 3400 	strd	r3, r4, [r2]
    Amo = state[18];
 8006cec:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006cf0:	681b      	ldr	r3, [r3, #0]
 8006cf2:	e9d3 3424 	ldrd	r3, r4, [r3, #144]	; 0x90
 8006cf6:	f507 7244 	add.w	r2, r7, #784	; 0x310
 8006cfa:	e9c2 3400 	strd	r3, r4, [r2]
    Amu = state[19];
 8006cfe:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d02:	681b      	ldr	r3, [r3, #0]
 8006d04:	e9d3 3426 	ldrd	r3, r4, [r3, #152]	; 0x98
 8006d08:	f507 7242 	add.w	r2, r7, #776	; 0x308
 8006d0c:	e9c2 3400 	strd	r3, r4, [r2]
    Asa = state[20];
 8006d10:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d14:	681b      	ldr	r3, [r3, #0]
 8006d16:	e9d3 3428 	ldrd	r3, r4, [r3, #160]	; 0xa0
 8006d1a:	f507 7240 	add.w	r2, r7, #768	; 0x300
 8006d1e:	e9c2 3400 	strd	r3, r4, [r2]
    Ase = state[21];
 8006d22:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d26:	681b      	ldr	r3, [r3, #0]
 8006d28:	e9d3 342a 	ldrd	r3, r4, [r3, #168]	; 0xa8
 8006d2c:	f507 723e 	add.w	r2, r7, #760	; 0x2f8
 8006d30:	e9c2 3400 	strd	r3, r4, [r2]
    Asi = state[22];
 8006d34:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d38:	681b      	ldr	r3, [r3, #0]
 8006d3a:	e9d3 342c 	ldrd	r3, r4, [r3, #176]	; 0xb0
 8006d3e:	f507 723c 	add.w	r2, r7, #752	; 0x2f0
 8006d42:	e9c2 3400 	strd	r3, r4, [r2]
    Aso = state[23];
 8006d46:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d4a:	681b      	ldr	r3, [r3, #0]
 8006d4c:	e9d3 342e 	ldrd	r3, r4, [r3, #184]	; 0xb8
 8006d50:	f507 723a 	add.w	r2, r7, #744	; 0x2e8
 8006d54:	e9c2 3400 	strd	r3, r4, [r2]
    Asu = state[24];
 8006d58:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8006d5c:	681b      	ldr	r3, [r3, #0]
 8006d5e:	e9d3 3430 	ldrd	r3, r4, [r3, #192]	; 0xc0
 8006d62:	f507 7238 	add.w	r2, r7, #736	; 0x2e0
 8006d66:	e9c2 3400 	strd	r3, r4, [r2]

    for (round = 0; round < NROUNDS; round += 2) {
 8006d6a:	2300      	movs	r3, #0
 8006d6c:	f8c7 33ac 	str.w	r3, [r7, #940]	; 0x3ac
 8006d70:	f002 b90b 	b.w	8008f8a <KeccakF1600_StatePermute+0x23f2>
        //    prepareTheta
        BCa = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
 8006d74:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 8006d78:	e9d3 1200 	ldrd	r1, r2, [r3]
 8006d7c:	f507 735e 	add.w	r3, r7, #888	; 0x378
 8006d80:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006d84:	ea81 0503 	eor.w	r5, r1, r3
 8006d88:	ea82 0604 	eor.w	r6, r2, r4
 8006d8c:	4629      	mov	r1, r5
 8006d8e:	4632      	mov	r2, r6
 8006d90:	f507 7354 	add.w	r3, r7, #848	; 0x350
 8006d94:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006d98:	ea81 0103 	eor.w	r1, r1, r3
 8006d9c:	ea82 0204 	eor.w	r2, r2, r4
 8006da0:	f507 734a 	add.w	r3, r7, #808	; 0x328
 8006da4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006da8:	ea81 0103 	eor.w	r1, r1, r3
 8006dac:	ea82 0204 	eor.w	r2, r2, r4
 8006db0:	f507 7340 	add.w	r3, r7, #768	; 0x300
 8006db4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006db8:	ea83 0501 	eor.w	r5, r3, r1
 8006dbc:	ea84 0602 	eor.w	r6, r4, r2
 8006dc0:	4629      	mov	r1, r5
 8006dc2:	4632      	mov	r2, r6
 8006dc4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8006dc8:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8006dcc:	f507 7366 	add.w	r3, r7, #920	; 0x398
 8006dd0:	e9d3 1200 	ldrd	r1, r2, [r3]
 8006dd4:	f507 735c 	add.w	r3, r7, #880	; 0x370
 8006dd8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006ddc:	ea81 0503 	eor.w	r5, r1, r3
 8006de0:	ea82 0604 	eor.w	r6, r2, r4
 8006de4:	4629      	mov	r1, r5
 8006de6:	4632      	mov	r2, r6
 8006de8:	f507 7352 	add.w	r3, r7, #840	; 0x348
 8006dec:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006df0:	ea81 0103 	eor.w	r1, r1, r3
 8006df4:	ea82 0204 	eor.w	r2, r2, r4
 8006df8:	f507 7348 	add.w	r3, r7, #800	; 0x320
 8006dfc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e00:	ea81 0103 	eor.w	r1, r1, r3
 8006e04:	ea82 0204 	eor.w	r2, r2, r4
 8006e08:	f507 733e 	add.w	r3, r7, #760	; 0x2f8
 8006e0c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e10:	ea83 0501 	eor.w	r5, r3, r1
 8006e14:	ea84 0602 	eor.w	r6, r4, r2
 8006e18:	4629      	mov	r1, r5
 8006e1a:	4632      	mov	r2, r6
 8006e1c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8006e20:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8006e24:	f507 7364 	add.w	r3, r7, #912	; 0x390
 8006e28:	e9d3 1200 	ldrd	r1, r2, [r3]
 8006e2c:	f507 735a 	add.w	r3, r7, #872	; 0x368
 8006e30:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e34:	ea81 0503 	eor.w	r5, r1, r3
 8006e38:	ea82 0604 	eor.w	r6, r2, r4
 8006e3c:	4629      	mov	r1, r5
 8006e3e:	4632      	mov	r2, r6
 8006e40:	f507 7350 	add.w	r3, r7, #832	; 0x340
 8006e44:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e48:	ea81 0103 	eor.w	r1, r1, r3
 8006e4c:	ea82 0204 	eor.w	r2, r2, r4
 8006e50:	f507 7346 	add.w	r3, r7, #792	; 0x318
 8006e54:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e58:	ea81 0103 	eor.w	r1, r1, r3
 8006e5c:	ea82 0204 	eor.w	r2, r2, r4
 8006e60:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
 8006e64:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e68:	ea83 0501 	eor.w	r5, r3, r1
 8006e6c:	ea84 0602 	eor.w	r6, r4, r2
 8006e70:	4629      	mov	r1, r5
 8006e72:	4632      	mov	r2, r6
 8006e74:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8006e78:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8006e7c:	f507 7362 	add.w	r3, r7, #904	; 0x388
 8006e80:	e9d3 1200 	ldrd	r1, r2, [r3]
 8006e84:	f507 7358 	add.w	r3, r7, #864	; 0x360
 8006e88:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006e8c:	ea81 0503 	eor.w	r5, r1, r3
 8006e90:	ea82 0604 	eor.w	r6, r2, r4
 8006e94:	4629      	mov	r1, r5
 8006e96:	4632      	mov	r2, r6
 8006e98:	f507 734e 	add.w	r3, r7, #824	; 0x338
 8006e9c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006ea0:	ea81 0103 	eor.w	r1, r1, r3
 8006ea4:	ea82 0204 	eor.w	r2, r2, r4
 8006ea8:	f507 7344 	add.w	r3, r7, #784	; 0x310
 8006eac:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006eb0:	ea81 0103 	eor.w	r1, r1, r3
 8006eb4:	ea82 0204 	eor.w	r2, r2, r4
 8006eb8:	f507 733a 	add.w	r3, r7, #744	; 0x2e8
 8006ebc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006ec0:	ea83 0501 	eor.w	r5, r3, r1
 8006ec4:	ea84 0602 	eor.w	r6, r4, r2
 8006ec8:	4629      	mov	r1, r5
 8006eca:	4632      	mov	r2, r6
 8006ecc:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8006ed0:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = Abu ^ Agu ^ Aku ^ Amu ^ Asu;
 8006ed4:	f507 7360 	add.w	r3, r7, #896	; 0x380
 8006ed8:	e9d3 1200 	ldrd	r1, r2, [r3]
 8006edc:	f507 7356 	add.w	r3, r7, #856	; 0x358
 8006ee0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006ee4:	ea81 0503 	eor.w	r5, r1, r3
 8006ee8:	ea82 0604 	eor.w	r6, r2, r4
 8006eec:	4629      	mov	r1, r5
 8006eee:	4632      	mov	r2, r6
 8006ef0:	f507 734c 	add.w	r3, r7, #816	; 0x330
 8006ef4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006ef8:	ea81 0103 	eor.w	r1, r1, r3
 8006efc:	ea82 0204 	eor.w	r2, r2, r4
 8006f00:	f507 7342 	add.w	r3, r7, #776	; 0x308
 8006f04:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006f08:	ea81 0103 	eor.w	r1, r1, r3
 8006f0c:	ea82 0204 	eor.w	r2, r2, r4
 8006f10:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
 8006f14:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006f18:	ea83 0501 	eor.w	r5, r3, r1
 8006f1c:	ea84 0602 	eor.w	r6, r4, r2
 8006f20:	462b      	mov	r3, r5
 8006f22:	4634      	mov	r4, r6
 8006f24:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8006f28:	e9c2 3400 	strd	r3, r4, [r2]

        // thetaRhoPiChiIotaPrepareTheta(round  , A, E)
        Da = BCu ^ ROL(BCe, 1);
 8006f2c:	f8d7 32d0 	ldr.w	r3, [r7, #720]	; 0x2d0
 8006f30:	0fda      	lsrs	r2, r3, #31
 8006f32:	f8d7 32d4 	ldr.w	r3, [r7, #724]	; 0x2d4
 8006f36:	005b      	lsls	r3, r3, #1
 8006f38:	4313      	orrs	r3, r2
 8006f3a:	f8c7 31bc 	str.w	r3, [r7, #444]	; 0x1bc
 8006f3e:	f8d7 32d4 	ldr.w	r3, [r7, #724]	; 0x2d4
 8006f42:	0fda      	lsrs	r2, r3, #31
 8006f44:	f8d7 32d0 	ldr.w	r3, [r7, #720]	; 0x2d0
 8006f48:	005b      	lsls	r3, r3, #1
 8006f4a:	4313      	orrs	r3, r2
 8006f4c:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 8006f50:	f507 722c 	add.w	r2, r7, #688	; 0x2b0
 8006f54:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8006f58:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006f5c:	f507 71dc 	add.w	r1, r7, #440	; 0x1b8
 8006f60:	e9d1 0100 	ldrd	r0, r1, [r1]
 8006f64:	ea80 0003 	eor.w	r0, r0, r3
 8006f68:	ea81 0104 	eor.w	r1, r1, r4
 8006f6c:	4603      	mov	r3, r0
 8006f6e:	460c      	mov	r4, r1
 8006f70:	e9c2 3400 	strd	r3, r4, [r2]
        De = BCa ^ ROL(BCi, 1);
 8006f74:	f8d7 32c8 	ldr.w	r3, [r7, #712]	; 0x2c8
 8006f78:	0fda      	lsrs	r2, r3, #31
 8006f7a:	f8d7 32cc 	ldr.w	r3, [r7, #716]	; 0x2cc
 8006f7e:	005b      	lsls	r3, r3, #1
 8006f80:	4313      	orrs	r3, r2
 8006f82:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 8006f86:	f8d7 32cc 	ldr.w	r3, [r7, #716]	; 0x2cc
 8006f8a:	0fda      	lsrs	r2, r3, #31
 8006f8c:	f8d7 32c8 	ldr.w	r3, [r7, #712]	; 0x2c8
 8006f90:	005b      	lsls	r3, r3, #1
 8006f92:	4313      	orrs	r3, r2
 8006f94:	f8c7 31b0 	str.w	r3, [r7, #432]	; 0x1b0
 8006f98:	f507 722a 	add.w	r2, r7, #680	; 0x2a8
 8006f9c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8006fa0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006fa4:	f507 71d8 	add.w	r1, r7, #432	; 0x1b0
 8006fa8:	e9d1 0100 	ldrd	r0, r1, [r1]
 8006fac:	ea80 0003 	eor.w	r0, r0, r3
 8006fb0:	ea81 0104 	eor.w	r1, r1, r4
 8006fb4:	4603      	mov	r3, r0
 8006fb6:	460c      	mov	r4, r1
 8006fb8:	e9c2 3400 	strd	r3, r4, [r2]
        Di = BCe ^ ROL(BCo, 1);
 8006fbc:	f8d7 32c0 	ldr.w	r3, [r7, #704]	; 0x2c0
 8006fc0:	0fda      	lsrs	r2, r3, #31
 8006fc2:	f8d7 32c4 	ldr.w	r3, [r7, #708]	; 0x2c4
 8006fc6:	005b      	lsls	r3, r3, #1
 8006fc8:	4313      	orrs	r3, r2
 8006fca:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 8006fce:	f8d7 32c4 	ldr.w	r3, [r7, #708]	; 0x2c4
 8006fd2:	0fda      	lsrs	r2, r3, #31
 8006fd4:	f8d7 32c0 	ldr.w	r3, [r7, #704]	; 0x2c0
 8006fd8:	005b      	lsls	r3, r3, #1
 8006fda:	4313      	orrs	r3, r2
 8006fdc:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
 8006fe0:	f507 7228 	add.w	r2, r7, #672	; 0x2a0
 8006fe4:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8006fe8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8006fec:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
 8006ff0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8006ff4:	ea80 0003 	eor.w	r0, r0, r3
 8006ff8:	ea81 0104 	eor.w	r1, r1, r4
 8006ffc:	4603      	mov	r3, r0
 8006ffe:	460c      	mov	r4, r1
 8007000:	e9c2 3400 	strd	r3, r4, [r2]
        Do = BCi ^ ROL(BCu, 1);
 8007004:	f8d7 32b8 	ldr.w	r3, [r7, #696]	; 0x2b8
 8007008:	0fda      	lsrs	r2, r3, #31
 800700a:	f8d7 32bc 	ldr.w	r3, [r7, #700]	; 0x2bc
 800700e:	005b      	lsls	r3, r3, #1
 8007010:	4313      	orrs	r3, r2
 8007012:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 8007016:	f8d7 32bc 	ldr.w	r3, [r7, #700]	; 0x2bc
 800701a:	0fda      	lsrs	r2, r3, #31
 800701c:	f8d7 32b8 	ldr.w	r3, [r7, #696]	; 0x2b8
 8007020:	005b      	lsls	r3, r3, #1
 8007022:	4313      	orrs	r3, r2
 8007024:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
 8007028:	f507 7226 	add.w	r2, r7, #664	; 0x298
 800702c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007030:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007034:	f507 71d0 	add.w	r1, r7, #416	; 0x1a0
 8007038:	e9d1 0100 	ldrd	r0, r1, [r1]
 800703c:	ea80 0003 	eor.w	r0, r0, r3
 8007040:	ea81 0104 	eor.w	r1, r1, r4
 8007044:	4603      	mov	r3, r0
 8007046:	460c      	mov	r4, r1
 8007048:	e9c2 3400 	strd	r3, r4, [r2]
        Du = BCo ^ ROL(BCa, 1);
 800704c:	f8d7 32d8 	ldr.w	r3, [r7, #728]	; 0x2d8
 8007050:	0fda      	lsrs	r2, r3, #31
 8007052:	f8d7 32dc 	ldr.w	r3, [r7, #732]	; 0x2dc
 8007056:	005b      	lsls	r3, r3, #1
 8007058:	4313      	orrs	r3, r2
 800705a:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
 800705e:	f8d7 32dc 	ldr.w	r3, [r7, #732]	; 0x2dc
 8007062:	0fda      	lsrs	r2, r3, #31
 8007064:	f8d7 32d8 	ldr.w	r3, [r7, #728]	; 0x2d8
 8007068:	005b      	lsls	r3, r3, #1
 800706a:	4313      	orrs	r3, r2
 800706c:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 8007070:	f507 7224 	add.w	r2, r7, #656	; 0x290
 8007074:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007078:	e9d3 3400 	ldrd	r3, r4, [r3]
 800707c:	f507 71cc 	add.w	r1, r7, #408	; 0x198
 8007080:	e9d1 0100 	ldrd	r0, r1, [r1]
 8007084:	ea80 0003 	eor.w	r0, r0, r3
 8007088:	ea81 0104 	eor.w	r1, r1, r4
 800708c:	4603      	mov	r3, r0
 800708e:	460c      	mov	r4, r1
 8007090:	e9c2 3400 	strd	r3, r4, [r2]

        Aba ^= Da;
 8007094:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8007098:	f507 7268 	add.w	r2, r7, #928	; 0x3a0
 800709c:	e9d2 1200 	ldrd	r1, r2, [r2]
 80070a0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80070a4:	ea83 0501 	eor.w	r5, r3, r1
 80070a8:	ea84 0602 	eor.w	r6, r4, r2
 80070ac:	4629      	mov	r1, r5
 80070ae:	4632      	mov	r2, r6
 80070b0:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 80070b4:	e9c3 1200 	strd	r1, r2, [r3]
        BCa = Aba;
 80070b8:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 80070bc:	e9d3 3400 	ldrd	r3, r4, [r3]
 80070c0:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 80070c4:	e9c2 3400 	strd	r3, r4, [r2]
        Age ^= De;
 80070c8:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 80070cc:	f507 725c 	add.w	r2, r7, #880	; 0x370
 80070d0:	e9d2 1200 	ldrd	r1, r2, [r2]
 80070d4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80070d8:	ea83 0501 	eor.w	r5, r3, r1
 80070dc:	ea84 0602 	eor.w	r6, r4, r2
 80070e0:	4629      	mov	r1, r5
 80070e2:	4632      	mov	r2, r6
 80070e4:	f507 735c 	add.w	r3, r7, #880	; 0x370
 80070e8:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = ROL(Age, 44);
 80070ec:	f8d7 3374 	ldr.w	r3, [r7, #884]	; 0x374
 80070f0:	031a      	lsls	r2, r3, #12
 80070f2:	f8d7 3370 	ldr.w	r3, [r7, #880]	; 0x370
 80070f6:	0d1b      	lsrs	r3, r3, #20
 80070f8:	4313      	orrs	r3, r2
 80070fa:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 80070fe:	f8d7 3370 	ldr.w	r3, [r7, #880]	; 0x370
 8007102:	031a      	lsls	r2, r3, #12
 8007104:	f8d7 3374 	ldr.w	r3, [r7, #884]	; 0x374
 8007108:	0d1b      	lsrs	r3, r3, #20
 800710a:	4313      	orrs	r3, r2
 800710c:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 8007110:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8007114:	f507 73b4 	add.w	r3, r7, #360	; 0x168
 8007118:	e9d3 3400 	ldrd	r3, r4, [r3]
 800711c:	e9c2 3400 	strd	r3, r4, [r2]
        Aki ^= Di;
 8007120:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8007124:	f507 7250 	add.w	r2, r7, #832	; 0x340
 8007128:	e9d2 1200 	ldrd	r1, r2, [r2]
 800712c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007130:	ea83 0501 	eor.w	r5, r3, r1
 8007134:	ea84 0602 	eor.w	r6, r4, r2
 8007138:	4629      	mov	r1, r5
 800713a:	4632      	mov	r2, r6
 800713c:	f507 7350 	add.w	r3, r7, #832	; 0x340
 8007140:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = ROL(Aki, 43);
 8007144:	f8d7 3344 	ldr.w	r3, [r7, #836]	; 0x344
 8007148:	02da      	lsls	r2, r3, #11
 800714a:	f8d7 3340 	ldr.w	r3, [r7, #832]	; 0x340
 800714e:	0d5b      	lsrs	r3, r3, #21
 8007150:	4313      	orrs	r3, r2
 8007152:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 8007156:	f8d7 3340 	ldr.w	r3, [r7, #832]	; 0x340
 800715a:	02da      	lsls	r2, r3, #11
 800715c:	f8d7 3344 	ldr.w	r3, [r7, #836]	; 0x344
 8007160:	0d5b      	lsrs	r3, r3, #21
 8007162:	4313      	orrs	r3, r2
 8007164:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 8007168:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 800716c:	f507 73b0 	add.w	r3, r7, #352	; 0x160
 8007170:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007174:	e9c2 3400 	strd	r3, r4, [r2]
        Amo ^= Do;
 8007178:	f507 7326 	add.w	r3, r7, #664	; 0x298
 800717c:	f507 7244 	add.w	r2, r7, #784	; 0x310
 8007180:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007184:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007188:	ea83 0501 	eor.w	r5, r3, r1
 800718c:	ea84 0602 	eor.w	r6, r4, r2
 8007190:	4629      	mov	r1, r5
 8007192:	4632      	mov	r2, r6
 8007194:	f507 7344 	add.w	r3, r7, #784	; 0x310
 8007198:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = ROL(Amo, 21);
 800719c:	f8d7 3310 	ldr.w	r3, [r7, #784]	; 0x310
 80071a0:	0ada      	lsrs	r2, r3, #11
 80071a2:	f8d7 3314 	ldr.w	r3, [r7, #788]	; 0x314
 80071a6:	055b      	lsls	r3, r3, #21
 80071a8:	4313      	orrs	r3, r2
 80071aa:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
 80071ae:	f8d7 3314 	ldr.w	r3, [r7, #788]	; 0x314
 80071b2:	0ada      	lsrs	r2, r3, #11
 80071b4:	f8d7 3310 	ldr.w	r3, [r7, #784]	; 0x310
 80071b8:	055b      	lsls	r3, r3, #21
 80071ba:	4313      	orrs	r3, r2
 80071bc:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
 80071c0:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 80071c4:	f507 73ac 	add.w	r3, r7, #344	; 0x158
 80071c8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80071cc:	e9c2 3400 	strd	r3, r4, [r2]
        Asu ^= Du;
 80071d0:	f507 7324 	add.w	r3, r7, #656	; 0x290
 80071d4:	f507 7238 	add.w	r2, r7, #736	; 0x2e0
 80071d8:	e9d2 1200 	ldrd	r1, r2, [r2]
 80071dc:	e9d3 3400 	ldrd	r3, r4, [r3]
 80071e0:	ea83 0501 	eor.w	r5, r3, r1
 80071e4:	ea84 0602 	eor.w	r6, r4, r2
 80071e8:	4629      	mov	r1, r5
 80071ea:	4632      	mov	r2, r6
 80071ec:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
 80071f0:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = ROL(Asu, 14);
 80071f4:	f8d7 32e0 	ldr.w	r3, [r7, #736]	; 0x2e0
 80071f8:	0c9a      	lsrs	r2, r3, #18
 80071fa:	f8d7 32e4 	ldr.w	r3, [r7, #740]	; 0x2e4
 80071fe:	039b      	lsls	r3, r3, #14
 8007200:	4313      	orrs	r3, r2
 8007202:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
 8007206:	f8d7 32e4 	ldr.w	r3, [r7, #740]	; 0x2e4
 800720a:	0c9a      	lsrs	r2, r3, #18
 800720c:	f8d7 32e0 	ldr.w	r3, [r7, #736]	; 0x2e0
 8007210:	039b      	lsls	r3, r3, #14
 8007212:	4313      	orrs	r3, r2
 8007214:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
 8007218:	f507 73a8 	add.w	r3, r7, #336	; 0x150
 800721c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007220:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8007224:	e9c2 3400 	strd	r3, r4, [r2]
        Eba = BCa ^ ((~BCe) & BCi);
 8007228:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 800722c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007230:	ea6f 0103 	mvn.w	r1, r3
 8007234:	ea6f 0204 	mvn.w	r2, r4
 8007238:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 800723c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007240:	ea01 0103 	and.w	r1, r1, r3
 8007244:	ea02 0204 	and.w	r2, r2, r4
 8007248:	f507 7022 	add.w	r0, r7, #648	; 0x288
 800724c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007250:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007254:	ea83 0501 	eor.w	r5, r3, r1
 8007258:	ea84 0602 	eor.w	r6, r4, r2
 800725c:	462b      	mov	r3, r5
 800725e:	4634      	mov	r4, r6
 8007260:	e9c0 3400 	strd	r3, r4, [r0]
        Eba ^= KeccakF_RoundConstants[round];
 8007264:	4acb      	ldr	r2, [pc, #812]	; (8007594 <KeccakF1600_StatePermute+0x9fc>)
 8007266:	f8d7 33ac 	ldr.w	r3, [r7, #940]	; 0x3ac
 800726a:	00db      	lsls	r3, r3, #3
 800726c:	4413      	add	r3, r2
 800726e:	e9d3 1200 	ldrd	r1, r2, [r3]
 8007272:	f507 7022 	add.w	r0, r7, #648	; 0x288
 8007276:	f507 7322 	add.w	r3, r7, #648	; 0x288
 800727a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800727e:	ea83 0501 	eor.w	r5, r3, r1
 8007282:	ea84 0602 	eor.w	r6, r4, r2
 8007286:	462b      	mov	r3, r5
 8007288:	4634      	mov	r4, r6
 800728a:	e9c0 3400 	strd	r3, r4, [r0]
        Ebe = BCe ^ ((~BCi) & BCo);
 800728e:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007292:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007296:	ea6f 0103 	mvn.w	r1, r3
 800729a:	ea6f 0204 	mvn.w	r2, r4
 800729e:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80072a2:	e9d3 3400 	ldrd	r3, r4, [r3]
 80072a6:	ea01 0103 	and.w	r1, r1, r3
 80072aa:	ea02 0204 	and.w	r2, r2, r4
 80072ae:	f507 7020 	add.w	r0, r7, #640	; 0x280
 80072b2:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 80072b6:	e9d3 3400 	ldrd	r3, r4, [r3]
 80072ba:	ea83 0501 	eor.w	r5, r3, r1
 80072be:	ea84 0602 	eor.w	r6, r4, r2
 80072c2:	462b      	mov	r3, r5
 80072c4:	4634      	mov	r4, r6
 80072c6:	e9c0 3400 	strd	r3, r4, [r0]
        Ebi = BCi ^ ((~BCo) & BCu);
 80072ca:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80072ce:	e9d3 3400 	ldrd	r3, r4, [r3]
 80072d2:	ea6f 0103 	mvn.w	r1, r3
 80072d6:	ea6f 0204 	mvn.w	r2, r4
 80072da:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80072de:	e9d3 3400 	ldrd	r3, r4, [r3]
 80072e2:	ea01 0103 	and.w	r1, r1, r3
 80072e6:	ea02 0204 	and.w	r2, r2, r4
 80072ea:	f507 701e 	add.w	r0, r7, #632	; 0x278
 80072ee:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80072f2:	e9d3 3400 	ldrd	r3, r4, [r3]
 80072f6:	ea83 0501 	eor.w	r5, r3, r1
 80072fa:	ea84 0602 	eor.w	r6, r4, r2
 80072fe:	462b      	mov	r3, r5
 8007300:	4634      	mov	r4, r6
 8007302:	e9c0 3400 	strd	r3, r4, [r0]
        Ebo = BCo ^ ((~BCu) & BCa);
 8007306:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 800730a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800730e:	ea6f 0103 	mvn.w	r1, r3
 8007312:	ea6f 0204 	mvn.w	r2, r4
 8007316:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 800731a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800731e:	ea01 0103 	and.w	r1, r1, r3
 8007322:	ea02 0204 	and.w	r2, r2, r4
 8007326:	f507 701c 	add.w	r0, r7, #624	; 0x270
 800732a:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 800732e:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007332:	ea83 0501 	eor.w	r5, r3, r1
 8007336:	ea84 0602 	eor.w	r6, r4, r2
 800733a:	462b      	mov	r3, r5
 800733c:	4634      	mov	r4, r6
 800733e:	e9c0 3400 	strd	r3, r4, [r0]
        Ebu = BCu ^ ((~BCa) & BCe);
 8007342:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007346:	e9d3 3400 	ldrd	r3, r4, [r3]
 800734a:	ea6f 0103 	mvn.w	r1, r3
 800734e:	ea6f 0204 	mvn.w	r2, r4
 8007352:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007356:	e9d3 3400 	ldrd	r3, r4, [r3]
 800735a:	ea01 0103 	and.w	r1, r1, r3
 800735e:	ea02 0204 	and.w	r2, r2, r4
 8007362:	f507 701a 	add.w	r0, r7, #616	; 0x268
 8007366:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 800736a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800736e:	ea83 0501 	eor.w	r5, r3, r1
 8007372:	ea84 0602 	eor.w	r6, r4, r2
 8007376:	462b      	mov	r3, r5
 8007378:	4634      	mov	r4, r6
 800737a:	e9c0 3400 	strd	r3, r4, [r0]

        Abo ^= Do;
 800737e:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8007382:	f507 7262 	add.w	r2, r7, #904	; 0x388
 8007386:	e9d2 1200 	ldrd	r1, r2, [r2]
 800738a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800738e:	ea83 0501 	eor.w	r5, r3, r1
 8007392:	ea84 0602 	eor.w	r6, r4, r2
 8007396:	4629      	mov	r1, r5
 8007398:	4632      	mov	r2, r6
 800739a:	f507 7362 	add.w	r3, r7, #904	; 0x388
 800739e:	e9c3 1200 	strd	r1, r2, [r3]
        BCa = ROL(Abo, 28);
 80073a2:	f8d7 3388 	ldr.w	r3, [r7, #904]	; 0x388
 80073a6:	091a      	lsrs	r2, r3, #4
 80073a8:	f8d7 338c 	ldr.w	r3, [r7, #908]	; 0x38c
 80073ac:	071b      	lsls	r3, r3, #28
 80073ae:	4313      	orrs	r3, r2
 80073b0:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
 80073b4:	f8d7 338c 	ldr.w	r3, [r7, #908]	; 0x38c
 80073b8:	091a      	lsrs	r2, r3, #4
 80073ba:	f8d7 3388 	ldr.w	r3, [r7, #904]	; 0x388
 80073be:	071b      	lsls	r3, r3, #28
 80073c0:	4313      	orrs	r3, r2
 80073c2:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
 80073c6:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 80073ca:	f507 73a4 	add.w	r3, r7, #328	; 0x148
 80073ce:	e9d3 3400 	ldrd	r3, r4, [r3]
 80073d2:	e9c2 3400 	strd	r3, r4, [r2]
        Agu ^= Du;
 80073d6:	f507 7324 	add.w	r3, r7, #656	; 0x290
 80073da:	f507 7256 	add.w	r2, r7, #856	; 0x358
 80073de:	e9d2 1200 	ldrd	r1, r2, [r2]
 80073e2:	e9d3 3400 	ldrd	r3, r4, [r3]
 80073e6:	ea83 0501 	eor.w	r5, r3, r1
 80073ea:	ea84 0602 	eor.w	r6, r4, r2
 80073ee:	4629      	mov	r1, r5
 80073f0:	4632      	mov	r2, r6
 80073f2:	f507 7356 	add.w	r3, r7, #856	; 0x358
 80073f6:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = ROL(Agu, 20);
 80073fa:	f8d7 3358 	ldr.w	r3, [r7, #856]	; 0x358
 80073fe:	0b1a      	lsrs	r2, r3, #12
 8007400:	f8d7 335c 	ldr.w	r3, [r7, #860]	; 0x35c
 8007404:	051b      	lsls	r3, r3, #20
 8007406:	4313      	orrs	r3, r2
 8007408:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
 800740c:	f8d7 335c 	ldr.w	r3, [r7, #860]	; 0x35c
 8007410:	0b1a      	lsrs	r2, r3, #12
 8007412:	f8d7 3358 	ldr.w	r3, [r7, #856]	; 0x358
 8007416:	051b      	lsls	r3, r3, #20
 8007418:	4313      	orrs	r3, r2
 800741a:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
 800741e:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8007422:	f507 73a0 	add.w	r3, r7, #320	; 0x140
 8007426:	e9d3 3400 	ldrd	r3, r4, [r3]
 800742a:	e9c2 3400 	strd	r3, r4, [r2]
        Aka ^= Da;
 800742e:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8007432:	f507 7254 	add.w	r2, r7, #848	; 0x350
 8007436:	e9d2 1200 	ldrd	r1, r2, [r2]
 800743a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800743e:	ea83 0501 	eor.w	r5, r3, r1
 8007442:	ea84 0602 	eor.w	r6, r4, r2
 8007446:	4629      	mov	r1, r5
 8007448:	4632      	mov	r2, r6
 800744a:	f507 7354 	add.w	r3, r7, #848	; 0x350
 800744e:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = ROL(Aka, 3);
 8007452:	f8d7 3350 	ldr.w	r3, [r7, #848]	; 0x350
 8007456:	0f5a      	lsrs	r2, r3, #29
 8007458:	f8d7 3354 	ldr.w	r3, [r7, #852]	; 0x354
 800745c:	00db      	lsls	r3, r3, #3
 800745e:	4313      	orrs	r3, r2
 8007460:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
 8007464:	f8d7 3354 	ldr.w	r3, [r7, #852]	; 0x354
 8007468:	0f5a      	lsrs	r2, r3, #29
 800746a:	f8d7 3350 	ldr.w	r3, [r7, #848]	; 0x350
 800746e:	00db      	lsls	r3, r3, #3
 8007470:	4313      	orrs	r3, r2
 8007472:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
 8007476:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 800747a:	f507 739c 	add.w	r3, r7, #312	; 0x138
 800747e:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007482:	e9c2 3400 	strd	r3, r4, [r2]
        Ame ^= De;
 8007486:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 800748a:	f507 7248 	add.w	r2, r7, #800	; 0x320
 800748e:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007492:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007496:	ea83 0501 	eor.w	r5, r3, r1
 800749a:	ea84 0602 	eor.w	r6, r4, r2
 800749e:	4629      	mov	r1, r5
 80074a0:	4632      	mov	r2, r6
 80074a2:	f507 7348 	add.w	r3, r7, #800	; 0x320
 80074a6:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = ROL(Ame, 45);
 80074aa:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80074ae:	035a      	lsls	r2, r3, #13
 80074b0:	f8d7 3320 	ldr.w	r3, [r7, #800]	; 0x320
 80074b4:	0cdb      	lsrs	r3, r3, #19
 80074b6:	4313      	orrs	r3, r2
 80074b8:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
 80074bc:	f8d7 3320 	ldr.w	r3, [r7, #800]	; 0x320
 80074c0:	035a      	lsls	r2, r3, #13
 80074c2:	f8d7 3324 	ldr.w	r3, [r7, #804]	; 0x324
 80074c6:	0cdb      	lsrs	r3, r3, #19
 80074c8:	4313      	orrs	r3, r2
 80074ca:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
 80074ce:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 80074d2:	f507 7398 	add.w	r3, r7, #304	; 0x130
 80074d6:	e9d3 3400 	ldrd	r3, r4, [r3]
 80074da:	e9c2 3400 	strd	r3, r4, [r2]
        Asi ^= Di;
 80074de:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 80074e2:	f507 723c 	add.w	r2, r7, #752	; 0x2f0
 80074e6:	e9d2 1200 	ldrd	r1, r2, [r2]
 80074ea:	e9d3 3400 	ldrd	r3, r4, [r3]
 80074ee:	ea83 0501 	eor.w	r5, r3, r1
 80074f2:	ea84 0602 	eor.w	r6, r4, r2
 80074f6:	4629      	mov	r1, r5
 80074f8:	4632      	mov	r2, r6
 80074fa:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
 80074fe:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = ROL(Asi, 61);
 8007502:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 8007506:	075a      	lsls	r2, r3, #29
 8007508:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 800750c:	08db      	lsrs	r3, r3, #3
 800750e:	4313      	orrs	r3, r2
 8007510:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
 8007514:	f8d7 32f0 	ldr.w	r3, [r7, #752]	; 0x2f0
 8007518:	075a      	lsls	r2, r3, #29
 800751a:	f8d7 32f4 	ldr.w	r3, [r7, #756]	; 0x2f4
 800751e:	08db      	lsrs	r3, r3, #3
 8007520:	4313      	orrs	r3, r2
 8007522:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8007526:	f507 7394 	add.w	r3, r7, #296	; 0x128
 800752a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800752e:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8007532:	e9c2 3400 	strd	r3, r4, [r2]
        Ega = BCa ^ ((~BCe) & BCi);
 8007536:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 800753a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800753e:	ea6f 0103 	mvn.w	r1, r3
 8007542:	ea6f 0204 	mvn.w	r2, r4
 8007546:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 800754a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800754e:	ea01 0103 	and.w	r1, r1, r3
 8007552:	ea02 0204 	and.w	r2, r2, r4
 8007556:	f507 7018 	add.w	r0, r7, #608	; 0x260
 800755a:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 800755e:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007562:	ea83 0501 	eor.w	r5, r3, r1
 8007566:	ea84 0602 	eor.w	r6, r4, r2
 800756a:	462b      	mov	r3, r5
 800756c:	4634      	mov	r4, r6
 800756e:	e9c0 3400 	strd	r3, r4, [r0]
        Ege = BCe ^ ((~BCi) & BCo);
 8007572:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007576:	e9d3 3400 	ldrd	r3, r4, [r3]
 800757a:	ea6f 0103 	mvn.w	r1, r3
 800757e:	ea6f 0204 	mvn.w	r2, r4
 8007582:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007586:	e9d3 3400 	ldrd	r3, r4, [r3]
 800758a:	ea01 0103 	and.w	r1, r1, r3
 800758e:	ea02 0204 	and.w	r2, r2, r4
 8007592:	e001      	b.n	8007598 <KeccakF1600_StatePermute+0xa00>
 8007594:	0801e048 	.word	0x0801e048
 8007598:	f507 7016 	add.w	r0, r7, #600	; 0x258
 800759c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 80075a0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80075a4:	ea83 0501 	eor.w	r5, r3, r1
 80075a8:	ea84 0602 	eor.w	r6, r4, r2
 80075ac:	462b      	mov	r3, r5
 80075ae:	4634      	mov	r4, r6
 80075b0:	e9c0 3400 	strd	r3, r4, [r0]
        Egi = BCi ^ ((~BCo) & BCu);
 80075b4:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80075b8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80075bc:	ea6f 0103 	mvn.w	r1, r3
 80075c0:	ea6f 0204 	mvn.w	r2, r4
 80075c4:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80075c8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80075cc:	ea01 0103 	and.w	r1, r1, r3
 80075d0:	ea02 0204 	and.w	r2, r2, r4
 80075d4:	f507 7014 	add.w	r0, r7, #592	; 0x250
 80075d8:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80075dc:	e9d3 3400 	ldrd	r3, r4, [r3]
 80075e0:	ea83 0501 	eor.w	r5, r3, r1
 80075e4:	ea84 0602 	eor.w	r6, r4, r2
 80075e8:	462b      	mov	r3, r5
 80075ea:	4634      	mov	r4, r6
 80075ec:	e9c0 3400 	strd	r3, r4, [r0]
        Ego = BCo ^ ((~BCu) & BCa);
 80075f0:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80075f4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80075f8:	ea6f 0103 	mvn.w	r1, r3
 80075fc:	ea6f 0204 	mvn.w	r2, r4
 8007600:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007604:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007608:	ea01 0103 	and.w	r1, r1, r3
 800760c:	ea02 0204 	and.w	r2, r2, r4
 8007610:	f507 7012 	add.w	r0, r7, #584	; 0x248
 8007614:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007618:	e9d3 3400 	ldrd	r3, r4, [r3]
 800761c:	ea83 0501 	eor.w	r5, r3, r1
 8007620:	ea84 0602 	eor.w	r6, r4, r2
 8007624:	462b      	mov	r3, r5
 8007626:	4634      	mov	r4, r6
 8007628:	e9c0 3400 	strd	r3, r4, [r0]
        Egu = BCu ^ ((~BCa) & BCe);
 800762c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007630:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007634:	ea6f 0103 	mvn.w	r1, r3
 8007638:	ea6f 0204 	mvn.w	r2, r4
 800763c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007640:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007644:	ea01 0103 	and.w	r1, r1, r3
 8007648:	ea02 0204 	and.w	r2, r2, r4
 800764c:	f507 7010 	add.w	r0, r7, #576	; 0x240
 8007650:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007654:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007658:	ea83 0501 	eor.w	r5, r3, r1
 800765c:	ea84 0602 	eor.w	r6, r4, r2
 8007660:	462b      	mov	r3, r5
 8007662:	4634      	mov	r4, r6
 8007664:	e9c0 3400 	strd	r3, r4, [r0]

        Abe ^= De;
 8007668:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 800766c:	f507 7266 	add.w	r2, r7, #920	; 0x398
 8007670:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007674:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007678:	ea83 0501 	eor.w	r5, r3, r1
 800767c:	ea84 0602 	eor.w	r6, r4, r2
 8007680:	4629      	mov	r1, r5
 8007682:	4632      	mov	r2, r6
 8007684:	f507 7366 	add.w	r3, r7, #920	; 0x398
 8007688:	e9c3 1200 	strd	r1, r2, [r3]
        BCa = ROL(Abe, 1);
 800768c:	f8d7 3398 	ldr.w	r3, [r7, #920]	; 0x398
 8007690:	0fda      	lsrs	r2, r3, #31
 8007692:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 8007696:	005b      	lsls	r3, r3, #1
 8007698:	4313      	orrs	r3, r2
 800769a:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 800769e:	f8d7 339c 	ldr.w	r3, [r7, #924]	; 0x39c
 80076a2:	0fda      	lsrs	r2, r3, #31
 80076a4:	f8d7 3398 	ldr.w	r3, [r7, #920]	; 0x398
 80076a8:	005b      	lsls	r3, r3, #1
 80076aa:	4313      	orrs	r3, r2
 80076ac:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 80076b0:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 80076b4:	f507 7390 	add.w	r3, r7, #288	; 0x120
 80076b8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80076bc:	e9c2 3400 	strd	r3, r4, [r2]
        Agi ^= Di;
 80076c0:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 80076c4:	f507 725a 	add.w	r2, r7, #872	; 0x368
 80076c8:	e9d2 1200 	ldrd	r1, r2, [r2]
 80076cc:	e9d3 3400 	ldrd	r3, r4, [r3]
 80076d0:	ea83 0501 	eor.w	r5, r3, r1
 80076d4:	ea84 0602 	eor.w	r6, r4, r2
 80076d8:	4629      	mov	r1, r5
 80076da:	4632      	mov	r2, r6
 80076dc:	f507 735a 	add.w	r3, r7, #872	; 0x368
 80076e0:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = ROL(Agi, 6);
 80076e4:	f8d7 3368 	ldr.w	r3, [r7, #872]	; 0x368
 80076e8:	0e9a      	lsrs	r2, r3, #26
 80076ea:	f8d7 336c 	ldr.w	r3, [r7, #876]	; 0x36c
 80076ee:	019b      	lsls	r3, r3, #6
 80076f0:	4313      	orrs	r3, r2
 80076f2:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 80076f6:	f8d7 336c 	ldr.w	r3, [r7, #876]	; 0x36c
 80076fa:	0e9a      	lsrs	r2, r3, #26
 80076fc:	f8d7 3368 	ldr.w	r3, [r7, #872]	; 0x368
 8007700:	019b      	lsls	r3, r3, #6
 8007702:	4313      	orrs	r3, r2
 8007704:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
 8007708:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 800770c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8007710:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007714:	e9c2 3400 	strd	r3, r4, [r2]
        Ako ^= Do;
 8007718:	f507 7326 	add.w	r3, r7, #664	; 0x298
 800771c:	f507 724e 	add.w	r2, r7, #824	; 0x338
 8007720:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007724:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007728:	ea83 0501 	eor.w	r5, r3, r1
 800772c:	ea84 0602 	eor.w	r6, r4, r2
 8007730:	4629      	mov	r1, r5
 8007732:	4632      	mov	r2, r6
 8007734:	f507 734e 	add.w	r3, r7, #824	; 0x338
 8007738:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = ROL(Ako, 25);
 800773c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8007740:	09da      	lsrs	r2, r3, #7
 8007742:	f8d7 333c 	ldr.w	r3, [r7, #828]	; 0x33c
 8007746:	065b      	lsls	r3, r3, #25
 8007748:	4313      	orrs	r3, r2
 800774a:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 800774e:	f8d7 333c 	ldr.w	r3, [r7, #828]	; 0x33c
 8007752:	09da      	lsrs	r2, r3, #7
 8007754:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8007758:	065b      	lsls	r3, r3, #25
 800775a:	4313      	orrs	r3, r2
 800775c:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
 8007760:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 8007764:	f507 7388 	add.w	r3, r7, #272	; 0x110
 8007768:	e9d3 3400 	ldrd	r3, r4, [r3]
 800776c:	e9c2 3400 	strd	r3, r4, [r2]
        Amu ^= Du;
 8007770:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8007774:	f507 7242 	add.w	r2, r7, #776	; 0x308
 8007778:	e9d2 1200 	ldrd	r1, r2, [r2]
 800777c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007780:	ea83 0501 	eor.w	r5, r3, r1
 8007784:	ea84 0602 	eor.w	r6, r4, r2
 8007788:	4629      	mov	r1, r5
 800778a:	4632      	mov	r2, r6
 800778c:	f507 7342 	add.w	r3, r7, #776	; 0x308
 8007790:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = ROL(Amu, 8);
 8007794:	f8d7 3308 	ldr.w	r3, [r7, #776]	; 0x308
 8007798:	0e1a      	lsrs	r2, r3, #24
 800779a:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 800779e:	021b      	lsls	r3, r3, #8
 80077a0:	4313      	orrs	r3, r2
 80077a2:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
 80077a6:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 80077aa:	0e1a      	lsrs	r2, r3, #24
 80077ac:	f8d7 3308 	ldr.w	r3, [r7, #776]	; 0x308
 80077b0:	021b      	lsls	r3, r3, #8
 80077b2:	4313      	orrs	r3, r2
 80077b4:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
 80077b8:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 80077bc:	f507 7384 	add.w	r3, r7, #264	; 0x108
 80077c0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80077c4:	e9c2 3400 	strd	r3, r4, [r2]
        Asa ^= Da;
 80077c8:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 80077cc:	f507 7240 	add.w	r2, r7, #768	; 0x300
 80077d0:	e9d2 1200 	ldrd	r1, r2, [r2]
 80077d4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80077d8:	ea83 0501 	eor.w	r5, r3, r1
 80077dc:	ea84 0602 	eor.w	r6, r4, r2
 80077e0:	4629      	mov	r1, r5
 80077e2:	4632      	mov	r2, r6
 80077e4:	f507 7340 	add.w	r3, r7, #768	; 0x300
 80077e8:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = ROL(Asa, 18);
 80077ec:	f8d7 3300 	ldr.w	r3, [r7, #768]	; 0x300
 80077f0:	0b9a      	lsrs	r2, r3, #14
 80077f2:	f8d7 3304 	ldr.w	r3, [r7, #772]	; 0x304
 80077f6:	049b      	lsls	r3, r3, #18
 80077f8:	4313      	orrs	r3, r2
 80077fa:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 80077fe:	f8d7 3304 	ldr.w	r3, [r7, #772]	; 0x304
 8007802:	0b9a      	lsrs	r2, r3, #14
 8007804:	f8d7 3300 	ldr.w	r3, [r7, #768]	; 0x300
 8007808:	049b      	lsls	r3, r3, #18
 800780a:	4313      	orrs	r3, r2
 800780c:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
 8007810:	f507 7380 	add.w	r3, r7, #256	; 0x100
 8007814:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007818:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 800781c:	e9c2 3400 	strd	r3, r4, [r2]
        Eka = BCa ^ ((~BCe) & BCi);
 8007820:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007824:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007828:	ea6f 0103 	mvn.w	r1, r3
 800782c:	ea6f 0204 	mvn.w	r2, r4
 8007830:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007834:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007838:	ea01 0103 	and.w	r1, r1, r3
 800783c:	ea02 0204 	and.w	r2, r2, r4
 8007840:	f507 700e 	add.w	r0, r7, #568	; 0x238
 8007844:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007848:	e9d3 3400 	ldrd	r3, r4, [r3]
 800784c:	ea83 0501 	eor.w	r5, r3, r1
 8007850:	ea84 0602 	eor.w	r6, r4, r2
 8007854:	462b      	mov	r3, r5
 8007856:	4634      	mov	r4, r6
 8007858:	e9c0 3400 	strd	r3, r4, [r0]
        Eke = BCe ^ ((~BCi) & BCo);
 800785c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007860:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007864:	ea6f 0103 	mvn.w	r1, r3
 8007868:	ea6f 0204 	mvn.w	r2, r4
 800786c:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007870:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007874:	ea01 0103 	and.w	r1, r1, r3
 8007878:	ea02 0204 	and.w	r2, r2, r4
 800787c:	f507 700c 	add.w	r0, r7, #560	; 0x230
 8007880:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007884:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007888:	ea83 0501 	eor.w	r5, r3, r1
 800788c:	ea84 0602 	eor.w	r6, r4, r2
 8007890:	462b      	mov	r3, r5
 8007892:	4634      	mov	r4, r6
 8007894:	e9c0 3400 	strd	r3, r4, [r0]
        Eki = BCi ^ ((~BCo) & BCu);
 8007898:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 800789c:	e9d3 3400 	ldrd	r3, r4, [r3]
 80078a0:	ea6f 0103 	mvn.w	r1, r3
 80078a4:	ea6f 0204 	mvn.w	r2, r4
 80078a8:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80078ac:	e9d3 3400 	ldrd	r3, r4, [r3]
 80078b0:	ea01 0103 	and.w	r1, r1, r3
 80078b4:	ea02 0204 	and.w	r2, r2, r4
 80078b8:	f507 700a 	add.w	r0, r7, #552	; 0x228
 80078bc:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80078c0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80078c4:	ea83 0501 	eor.w	r5, r3, r1
 80078c8:	ea84 0602 	eor.w	r6, r4, r2
 80078cc:	462b      	mov	r3, r5
 80078ce:	4634      	mov	r4, r6
 80078d0:	e9c0 3400 	strd	r3, r4, [r0]
        Eko = BCo ^ ((~BCu) & BCa);
 80078d4:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80078d8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80078dc:	ea6f 0103 	mvn.w	r1, r3
 80078e0:	ea6f 0204 	mvn.w	r2, r4
 80078e4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 80078e8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80078ec:	ea01 0103 	and.w	r1, r1, r3
 80078f0:	ea02 0204 	and.w	r2, r2, r4
 80078f4:	f507 7008 	add.w	r0, r7, #544	; 0x220
 80078f8:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80078fc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007900:	ea83 0501 	eor.w	r5, r3, r1
 8007904:	ea84 0602 	eor.w	r6, r4, r2
 8007908:	462b      	mov	r3, r5
 800790a:	4634      	mov	r4, r6
 800790c:	e9c0 3400 	strd	r3, r4, [r0]
        Eku = BCu ^ ((~BCa) & BCe);
 8007910:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007914:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007918:	ea6f 0103 	mvn.w	r1, r3
 800791c:	ea6f 0204 	mvn.w	r2, r4
 8007920:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007924:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007928:	ea01 0103 	and.w	r1, r1, r3
 800792c:	ea02 0204 	and.w	r2, r2, r4
 8007930:	f507 7006 	add.w	r0, r7, #536	; 0x218
 8007934:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007938:	e9d3 3400 	ldrd	r3, r4, [r3]
 800793c:	ea83 0501 	eor.w	r5, r3, r1
 8007940:	ea84 0602 	eor.w	r6, r4, r2
 8007944:	462b      	mov	r3, r5
 8007946:	4634      	mov	r4, r6
 8007948:	e9c0 3400 	strd	r3, r4, [r0]

        Abu ^= Du;
 800794c:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8007950:	f507 7260 	add.w	r2, r7, #896	; 0x380
 8007954:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007958:	e9d3 3400 	ldrd	r3, r4, [r3]
 800795c:	ea83 0501 	eor.w	r5, r3, r1
 8007960:	ea84 0602 	eor.w	r6, r4, r2
 8007964:	4629      	mov	r1, r5
 8007966:	4632      	mov	r2, r6
 8007968:	f507 7360 	add.w	r3, r7, #896	; 0x380
 800796c:	e9c3 1200 	strd	r1, r2, [r3]
        BCa = ROL(Abu, 27);
 8007970:	f8d7 3380 	ldr.w	r3, [r7, #896]	; 0x380
 8007974:	095a      	lsrs	r2, r3, #5
 8007976:	f8d7 3384 	ldr.w	r3, [r7, #900]	; 0x384
 800797a:	06db      	lsls	r3, r3, #27
 800797c:	4313      	orrs	r3, r2
 800797e:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8007982:	f8d7 3384 	ldr.w	r3, [r7, #900]	; 0x384
 8007986:	095a      	lsrs	r2, r3, #5
 8007988:	f8d7 3380 	ldr.w	r3, [r7, #896]	; 0x380
 800798c:	06db      	lsls	r3, r3, #27
 800798e:	4313      	orrs	r3, r2
 8007990:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
 8007994:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 8007998:	e9d7 343e 	ldrd	r3, r4, [r7, #248]	; 0xf8
 800799c:	e9c2 3400 	strd	r3, r4, [r2]
        Aga ^= Da;
 80079a0:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 80079a4:	f507 725e 	add.w	r2, r7, #888	; 0x378
 80079a8:	e9d2 1200 	ldrd	r1, r2, [r2]
 80079ac:	e9d3 3400 	ldrd	r3, r4, [r3]
 80079b0:	ea83 0501 	eor.w	r5, r3, r1
 80079b4:	ea84 0602 	eor.w	r6, r4, r2
 80079b8:	4629      	mov	r1, r5
 80079ba:	4632      	mov	r2, r6
 80079bc:	f507 735e 	add.w	r3, r7, #888	; 0x378
 80079c0:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = ROL(Aga, 36);
 80079c4:	f8d7 337c 	ldr.w	r3, [r7, #892]	; 0x37c
 80079c8:	011a      	lsls	r2, r3, #4
 80079ca:	f8d7 3378 	ldr.w	r3, [r7, #888]	; 0x378
 80079ce:	0f1b      	lsrs	r3, r3, #28
 80079d0:	4313      	orrs	r3, r2
 80079d2:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
 80079d6:	f8d7 3378 	ldr.w	r3, [r7, #888]	; 0x378
 80079da:	011a      	lsls	r2, r3, #4
 80079dc:	f8d7 337c 	ldr.w	r3, [r7, #892]	; 0x37c
 80079e0:	0f1b      	lsrs	r3, r3, #28
 80079e2:	4313      	orrs	r3, r2
 80079e4:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 80079e8:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 80079ec:	e9d7 343c 	ldrd	r3, r4, [r7, #240]	; 0xf0
 80079f0:	e9c2 3400 	strd	r3, r4, [r2]
        Ake ^= De;
 80079f4:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 80079f8:	f507 7252 	add.w	r2, r7, #840	; 0x348
 80079fc:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007a00:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007a04:	ea83 0501 	eor.w	r5, r3, r1
 8007a08:	ea84 0602 	eor.w	r6, r4, r2
 8007a0c:	4629      	mov	r1, r5
 8007a0e:	4632      	mov	r2, r6
 8007a10:	f507 7352 	add.w	r3, r7, #840	; 0x348
 8007a14:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = ROL(Ake, 10);
 8007a18:	f8d7 3348 	ldr.w	r3, [r7, #840]	; 0x348
 8007a1c:	0d9a      	lsrs	r2, r3, #22
 8007a1e:	f8d7 334c 	ldr.w	r3, [r7, #844]	; 0x34c
 8007a22:	029b      	lsls	r3, r3, #10
 8007a24:	4313      	orrs	r3, r2
 8007a26:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
 8007a2a:	f8d7 334c 	ldr.w	r3, [r7, #844]	; 0x34c
 8007a2e:	0d9a      	lsrs	r2, r3, #22
 8007a30:	f8d7 3348 	ldr.w	r3, [r7, #840]	; 0x348
 8007a34:	029b      	lsls	r3, r3, #10
 8007a36:	4313      	orrs	r3, r2
 8007a38:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
 8007a3c:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 8007a40:	e9d7 343a 	ldrd	r3, r4, [r7, #232]	; 0xe8
 8007a44:	e9c2 3400 	strd	r3, r4, [r2]
        Ami ^= Di;
 8007a48:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8007a4c:	f507 7246 	add.w	r2, r7, #792	; 0x318
 8007a50:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007a54:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007a58:	ea83 0501 	eor.w	r5, r3, r1
 8007a5c:	ea84 0602 	eor.w	r6, r4, r2
 8007a60:	4629      	mov	r1, r5
 8007a62:	4632      	mov	r2, r6
 8007a64:	f507 7346 	add.w	r3, r7, #792	; 0x318
 8007a68:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = ROL(Ami, 15);
 8007a6c:	f8d7 3318 	ldr.w	r3, [r7, #792]	; 0x318
 8007a70:	0c5a      	lsrs	r2, r3, #17
 8007a72:	f8d7 331c 	ldr.w	r3, [r7, #796]	; 0x31c
 8007a76:	03db      	lsls	r3, r3, #15
 8007a78:	4313      	orrs	r3, r2
 8007a7a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
 8007a7e:	f8d7 331c 	ldr.w	r3, [r7, #796]	; 0x31c
 8007a82:	0c5a      	lsrs	r2, r3, #17
 8007a84:	f8d7 3318 	ldr.w	r3, [r7, #792]	; 0x318
 8007a88:	03db      	lsls	r3, r3, #15
 8007a8a:	4313      	orrs	r3, r2
 8007a8c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8007a90:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 8007a94:	e9d7 3438 	ldrd	r3, r4, [r7, #224]	; 0xe0
 8007a98:	e9c2 3400 	strd	r3, r4, [r2]
        Aso ^= Do;
 8007a9c:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8007aa0:	f507 723a 	add.w	r2, r7, #744	; 0x2e8
 8007aa4:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007aa8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007aac:	ea83 0501 	eor.w	r5, r3, r1
 8007ab0:	ea84 0602 	eor.w	r6, r4, r2
 8007ab4:	4629      	mov	r1, r5
 8007ab6:	4632      	mov	r2, r6
 8007ab8:	f507 733a 	add.w	r3, r7, #744	; 0x2e8
 8007abc:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = ROL(Aso, 56);
 8007ac0:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 8007ac4:	061a      	lsls	r2, r3, #24
 8007ac6:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 8007aca:	0a1b      	lsrs	r3, r3, #8
 8007acc:	4313      	orrs	r3, r2
 8007ace:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8007ad2:	f8d7 32e8 	ldr.w	r3, [r7, #744]	; 0x2e8
 8007ad6:	061a      	lsls	r2, r3, #24
 8007ad8:	f8d7 32ec 	ldr.w	r3, [r7, #748]	; 0x2ec
 8007adc:	0a1b      	lsrs	r3, r3, #8
 8007ade:	4313      	orrs	r3, r2
 8007ae0:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8007ae4:	e9d7 3436 	ldrd	r3, r4, [r7, #216]	; 0xd8
 8007ae8:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8007aec:	e9c2 3400 	strd	r3, r4, [r2]
        Ema = BCa ^ ((~BCe) & BCi);
 8007af0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007af4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007af8:	ea6f 0103 	mvn.w	r1, r3
 8007afc:	ea6f 0204 	mvn.w	r2, r4
 8007b00:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007b04:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b08:	ea01 0103 	and.w	r1, r1, r3
 8007b0c:	ea02 0204 	and.w	r2, r2, r4
 8007b10:	f507 7004 	add.w	r0, r7, #528	; 0x210
 8007b14:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007b18:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b1c:	ea83 0501 	eor.w	r5, r3, r1
 8007b20:	ea84 0602 	eor.w	r6, r4, r2
 8007b24:	462b      	mov	r3, r5
 8007b26:	4634      	mov	r4, r6
 8007b28:	e9c0 3400 	strd	r3, r4, [r0]
        Eme = BCe ^ ((~BCi) & BCo);
 8007b2c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007b30:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b34:	ea6f 0103 	mvn.w	r1, r3
 8007b38:	ea6f 0204 	mvn.w	r2, r4
 8007b3c:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007b40:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b44:	ea01 0103 	and.w	r1, r1, r3
 8007b48:	ea02 0204 	and.w	r2, r2, r4
 8007b4c:	f507 7002 	add.w	r0, r7, #520	; 0x208
 8007b50:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007b54:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b58:	ea83 0501 	eor.w	r5, r3, r1
 8007b5c:	ea84 0602 	eor.w	r6, r4, r2
 8007b60:	462b      	mov	r3, r5
 8007b62:	4634      	mov	r4, r6
 8007b64:	e9c0 3400 	strd	r3, r4, [r0]
        Emi = BCi ^ ((~BCo) & BCu);
 8007b68:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007b6c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b70:	ea6f 0103 	mvn.w	r1, r3
 8007b74:	ea6f 0204 	mvn.w	r2, r4
 8007b78:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007b7c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b80:	ea01 0103 	and.w	r1, r1, r3
 8007b84:	ea02 0204 	and.w	r2, r2, r4
 8007b88:	f507 7000 	add.w	r0, r7, #512	; 0x200
 8007b8c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007b90:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007b94:	ea83 0501 	eor.w	r5, r3, r1
 8007b98:	ea84 0602 	eor.w	r6, r4, r2
 8007b9c:	462b      	mov	r3, r5
 8007b9e:	4634      	mov	r4, r6
 8007ba0:	e9c0 3400 	strd	r3, r4, [r0]
        Emo = BCo ^ ((~BCu) & BCa);
 8007ba4:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007ba8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007bac:	ea6f 0103 	mvn.w	r1, r3
 8007bb0:	ea6f 0204 	mvn.w	r2, r4
 8007bb4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007bb8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007bbc:	ea01 0103 	and.w	r1, r1, r3
 8007bc0:	ea02 0204 	and.w	r2, r2, r4
 8007bc4:	f507 70fc 	add.w	r0, r7, #504	; 0x1f8
 8007bc8:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007bcc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007bd0:	ea83 0501 	eor.w	r5, r3, r1
 8007bd4:	ea84 0602 	eor.w	r6, r4, r2
 8007bd8:	462b      	mov	r3, r5
 8007bda:	4634      	mov	r4, r6
 8007bdc:	e9c0 3400 	strd	r3, r4, [r0]
        Emu = BCu ^ ((~BCa) & BCe);
 8007be0:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007be4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007be8:	ea6f 0103 	mvn.w	r1, r3
 8007bec:	ea6f 0204 	mvn.w	r2, r4
 8007bf0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007bf4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007bf8:	ea01 0103 	and.w	r1, r1, r3
 8007bfc:	ea02 0204 	and.w	r2, r2, r4
 8007c00:	f507 70f8 	add.w	r0, r7, #496	; 0x1f0
 8007c04:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007c08:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007c0c:	ea83 0501 	eor.w	r5, r3, r1
 8007c10:	ea84 0602 	eor.w	r6, r4, r2
 8007c14:	462b      	mov	r3, r5
 8007c16:	4634      	mov	r4, r6
 8007c18:	e9c0 3400 	strd	r3, r4, [r0]

        Abi ^= Di;
 8007c1c:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8007c20:	f507 7264 	add.w	r2, r7, #912	; 0x390
 8007c24:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007c28:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007c2c:	ea83 0501 	eor.w	r5, r3, r1
 8007c30:	ea84 0602 	eor.w	r6, r4, r2
 8007c34:	4629      	mov	r1, r5
 8007c36:	4632      	mov	r2, r6
 8007c38:	f507 7364 	add.w	r3, r7, #912	; 0x390
 8007c3c:	e9c3 1200 	strd	r1, r2, [r3]
        BCa = ROL(Abi, 62);
 8007c40:	f8d7 3394 	ldr.w	r3, [r7, #916]	; 0x394
 8007c44:	079a      	lsls	r2, r3, #30
 8007c46:	f8d7 3390 	ldr.w	r3, [r7, #912]	; 0x390
 8007c4a:	089b      	lsrs	r3, r3, #2
 8007c4c:	4313      	orrs	r3, r2
 8007c4e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8007c52:	f8d7 3390 	ldr.w	r3, [r7, #912]	; 0x390
 8007c56:	079a      	lsls	r2, r3, #30
 8007c58:	f8d7 3394 	ldr.w	r3, [r7, #916]	; 0x394
 8007c5c:	089b      	lsrs	r3, r3, #2
 8007c5e:	4313      	orrs	r3, r2
 8007c60:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8007c64:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 8007c68:	e9d7 3434 	ldrd	r3, r4, [r7, #208]	; 0xd0
 8007c6c:	e9c2 3400 	strd	r3, r4, [r2]
        Ago ^= Do;
 8007c70:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8007c74:	f507 7258 	add.w	r2, r7, #864	; 0x360
 8007c78:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007c7c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007c80:	ea83 0501 	eor.w	r5, r3, r1
 8007c84:	ea84 0602 	eor.w	r6, r4, r2
 8007c88:	4629      	mov	r1, r5
 8007c8a:	4632      	mov	r2, r6
 8007c8c:	f507 7358 	add.w	r3, r7, #864	; 0x360
 8007c90:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = ROL(Ago, 55);
 8007c94:	f8d7 3364 	ldr.w	r3, [r7, #868]	; 0x364
 8007c98:	05da      	lsls	r2, r3, #23
 8007c9a:	f8d7 3360 	ldr.w	r3, [r7, #864]	; 0x360
 8007c9e:	0a5b      	lsrs	r3, r3, #9
 8007ca0:	4313      	orrs	r3, r2
 8007ca2:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8007ca6:	f8d7 3360 	ldr.w	r3, [r7, #864]	; 0x360
 8007caa:	05da      	lsls	r2, r3, #23
 8007cac:	f8d7 3364 	ldr.w	r3, [r7, #868]	; 0x364
 8007cb0:	0a5b      	lsrs	r3, r3, #9
 8007cb2:	4313      	orrs	r3, r2
 8007cb4:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8007cb8:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8007cbc:	e9d7 3432 	ldrd	r3, r4, [r7, #200]	; 0xc8
 8007cc0:	e9c2 3400 	strd	r3, r4, [r2]
        Aku ^= Du;
 8007cc4:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8007cc8:	f507 724c 	add.w	r2, r7, #816	; 0x330
 8007ccc:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007cd0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007cd4:	ea83 0501 	eor.w	r5, r3, r1
 8007cd8:	ea84 0602 	eor.w	r6, r4, r2
 8007cdc:	4629      	mov	r1, r5
 8007cde:	4632      	mov	r2, r6
 8007ce0:	f507 734c 	add.w	r3, r7, #816	; 0x330
 8007ce4:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = ROL(Aku, 39);
 8007ce8:	f8d7 3334 	ldr.w	r3, [r7, #820]	; 0x334
 8007cec:	01da      	lsls	r2, r3, #7
 8007cee:	f8d7 3330 	ldr.w	r3, [r7, #816]	; 0x330
 8007cf2:	0e5b      	lsrs	r3, r3, #25
 8007cf4:	4313      	orrs	r3, r2
 8007cf6:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8007cfa:	f8d7 3330 	ldr.w	r3, [r7, #816]	; 0x330
 8007cfe:	01da      	lsls	r2, r3, #7
 8007d00:	f8d7 3334 	ldr.w	r3, [r7, #820]	; 0x334
 8007d04:	0e5b      	lsrs	r3, r3, #25
 8007d06:	4313      	orrs	r3, r2
 8007d08:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8007d0c:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 8007d10:	e9d7 3430 	ldrd	r3, r4, [r7, #192]	; 0xc0
 8007d14:	e9c2 3400 	strd	r3, r4, [r2]
        Ama ^= Da;
 8007d18:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8007d1c:	f507 724a 	add.w	r2, r7, #808	; 0x328
 8007d20:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007d24:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007d28:	ea83 0501 	eor.w	r5, r3, r1
 8007d2c:	ea84 0602 	eor.w	r6, r4, r2
 8007d30:	4629      	mov	r1, r5
 8007d32:	4632      	mov	r2, r6
 8007d34:	f507 734a 	add.w	r3, r7, #808	; 0x328
 8007d38:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = ROL(Ama, 41);
 8007d3c:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 8007d40:	025a      	lsls	r2, r3, #9
 8007d42:	f8d7 3328 	ldr.w	r3, [r7, #808]	; 0x328
 8007d46:	0ddb      	lsrs	r3, r3, #23
 8007d48:	4313      	orrs	r3, r2
 8007d4a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8007d4e:	f8d7 3328 	ldr.w	r3, [r7, #808]	; 0x328
 8007d52:	025a      	lsls	r2, r3, #9
 8007d54:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 8007d58:	0ddb      	lsrs	r3, r3, #23
 8007d5a:	4313      	orrs	r3, r2
 8007d5c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8007d60:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 8007d64:	e9d7 342e 	ldrd	r3, r4, [r7, #184]	; 0xb8
 8007d68:	e9c2 3400 	strd	r3, r4, [r2]
        Ase ^= De;
 8007d6c:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 8007d70:	f507 723e 	add.w	r2, r7, #760	; 0x2f8
 8007d74:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007d78:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007d7c:	ea83 0501 	eor.w	r5, r3, r1
 8007d80:	ea84 0602 	eor.w	r6, r4, r2
 8007d84:	4629      	mov	r1, r5
 8007d86:	4632      	mov	r2, r6
 8007d88:	f507 733e 	add.w	r3, r7, #760	; 0x2f8
 8007d8c:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = ROL(Ase, 2);
 8007d90:	f8d7 32f8 	ldr.w	r3, [r7, #760]	; 0x2f8
 8007d94:	0f9a      	lsrs	r2, r3, #30
 8007d96:	f8d7 32fc 	ldr.w	r3, [r7, #764]	; 0x2fc
 8007d9a:	009b      	lsls	r3, r3, #2
 8007d9c:	4313      	orrs	r3, r2
 8007d9e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8007da2:	f8d7 32fc 	ldr.w	r3, [r7, #764]	; 0x2fc
 8007da6:	0f9a      	lsrs	r2, r3, #30
 8007da8:	f8d7 32f8 	ldr.w	r3, [r7, #760]	; 0x2f8
 8007dac:	009b      	lsls	r3, r3, #2
 8007dae:	4313      	orrs	r3, r2
 8007db0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8007db4:	e9d7 342c 	ldrd	r3, r4, [r7, #176]	; 0xb0
 8007db8:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8007dbc:	e9c2 3400 	strd	r3, r4, [r2]
        Esa = BCa ^ ((~BCe) & BCi);
 8007dc0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007dc4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007dc8:	ea6f 0103 	mvn.w	r1, r3
 8007dcc:	ea6f 0204 	mvn.w	r2, r4
 8007dd0:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007dd4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007dd8:	ea01 0103 	and.w	r1, r1, r3
 8007ddc:	ea02 0204 	and.w	r2, r2, r4
 8007de0:	f507 70f4 	add.w	r0, r7, #488	; 0x1e8
 8007de4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007de8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007dec:	ea83 0501 	eor.w	r5, r3, r1
 8007df0:	ea84 0602 	eor.w	r6, r4, r2
 8007df4:	462b      	mov	r3, r5
 8007df6:	4634      	mov	r4, r6
 8007df8:	e9c0 3400 	strd	r3, r4, [r0]
        Ese = BCe ^ ((~BCi) & BCo);
 8007dfc:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007e00:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e04:	ea6f 0103 	mvn.w	r1, r3
 8007e08:	ea6f 0204 	mvn.w	r2, r4
 8007e0c:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007e10:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e14:	ea01 0103 	and.w	r1, r1, r3
 8007e18:	ea02 0204 	and.w	r2, r2, r4
 8007e1c:	f507 70f0 	add.w	r0, r7, #480	; 0x1e0
 8007e20:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007e24:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e28:	ea83 0501 	eor.w	r5, r3, r1
 8007e2c:	ea84 0602 	eor.w	r6, r4, r2
 8007e30:	462b      	mov	r3, r5
 8007e32:	4634      	mov	r4, r6
 8007e34:	e9c0 3400 	strd	r3, r4, [r0]
        Esi = BCi ^ ((~BCo) & BCu);
 8007e38:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007e3c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e40:	ea6f 0103 	mvn.w	r1, r3
 8007e44:	ea6f 0204 	mvn.w	r2, r4
 8007e48:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007e4c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e50:	ea01 0103 	and.w	r1, r1, r3
 8007e54:	ea02 0204 	and.w	r2, r2, r4
 8007e58:	f507 70ec 	add.w	r0, r7, #472	; 0x1d8
 8007e5c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007e60:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e64:	ea83 0501 	eor.w	r5, r3, r1
 8007e68:	ea84 0602 	eor.w	r6, r4, r2
 8007e6c:	462b      	mov	r3, r5
 8007e6e:	4634      	mov	r4, r6
 8007e70:	e9c0 3400 	strd	r3, r4, [r0]
        Eso = BCo ^ ((~BCu) & BCa);
 8007e74:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007e78:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e7c:	ea6f 0103 	mvn.w	r1, r3
 8007e80:	ea6f 0204 	mvn.w	r2, r4
 8007e84:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007e88:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007e8c:	ea01 0103 	and.w	r1, r1, r3
 8007e90:	ea02 0204 	and.w	r2, r2, r4
 8007e94:	f507 70e8 	add.w	r0, r7, #464	; 0x1d0
 8007e98:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8007e9c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007ea0:	ea83 0501 	eor.w	r5, r3, r1
 8007ea4:	ea84 0602 	eor.w	r6, r4, r2
 8007ea8:	462b      	mov	r3, r5
 8007eaa:	4634      	mov	r4, r6
 8007eac:	e9c0 3400 	strd	r3, r4, [r0]
        Esu = BCu ^ ((~BCa) & BCe);
 8007eb0:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007eb4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007eb8:	ea6f 0103 	mvn.w	r1, r3
 8007ebc:	ea6f 0204 	mvn.w	r2, r4
 8007ec0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007ec4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007ec8:	ea01 0103 	and.w	r1, r1, r3
 8007ecc:	ea02 0204 	and.w	r2, r2, r4
 8007ed0:	f507 70e4 	add.w	r0, r7, #456	; 0x1c8
 8007ed4:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8007ed8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007edc:	ea83 0501 	eor.w	r5, r3, r1
 8007ee0:	ea84 0602 	eor.w	r6, r4, r2
 8007ee4:	462b      	mov	r3, r5
 8007ee6:	4634      	mov	r4, r6
 8007ee8:	e9c0 3400 	strd	r3, r4, [r0]

        //    prepareTheta
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8007eec:	f507 7222 	add.w	r2, r7, #648	; 0x288
 8007ef0:	f507 7318 	add.w	r3, r7, #608	; 0x260
 8007ef4:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007ef8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007efc:	ea81 0503 	eor.w	r5, r1, r3
 8007f00:	ea82 0604 	eor.w	r6, r2, r4
 8007f04:	4629      	mov	r1, r5
 8007f06:	4632      	mov	r2, r6
 8007f08:	f507 730e 	add.w	r3, r7, #568	; 0x238
 8007f0c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f10:	ea81 0103 	eor.w	r1, r1, r3
 8007f14:	ea82 0204 	eor.w	r2, r2, r4
 8007f18:	f507 7304 	add.w	r3, r7, #528	; 0x210
 8007f1c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f20:	ea81 0103 	eor.w	r1, r1, r3
 8007f24:	ea82 0204 	eor.w	r2, r2, r4
 8007f28:	f507 73f4 	add.w	r3, r7, #488	; 0x1e8
 8007f2c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f30:	ea83 0501 	eor.w	r5, r3, r1
 8007f34:	ea84 0602 	eor.w	r6, r4, r2
 8007f38:	4629      	mov	r1, r5
 8007f3a:	4632      	mov	r2, r6
 8007f3c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8007f40:	e9c3 1200 	strd	r1, r2, [r3]
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 8007f44:	f507 7220 	add.w	r2, r7, #640	; 0x280
 8007f48:	f507 7316 	add.w	r3, r7, #600	; 0x258
 8007f4c:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007f50:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f54:	ea81 0503 	eor.w	r5, r1, r3
 8007f58:	ea82 0604 	eor.w	r6, r2, r4
 8007f5c:	4629      	mov	r1, r5
 8007f5e:	4632      	mov	r2, r6
 8007f60:	f507 730c 	add.w	r3, r7, #560	; 0x230
 8007f64:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f68:	ea81 0103 	eor.w	r1, r1, r3
 8007f6c:	ea82 0204 	eor.w	r2, r2, r4
 8007f70:	f507 7302 	add.w	r3, r7, #520	; 0x208
 8007f74:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f78:	ea81 0103 	eor.w	r1, r1, r3
 8007f7c:	ea82 0204 	eor.w	r2, r2, r4
 8007f80:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
 8007f84:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007f88:	ea83 0501 	eor.w	r5, r3, r1
 8007f8c:	ea84 0602 	eor.w	r6, r4, r2
 8007f90:	4629      	mov	r1, r5
 8007f92:	4632      	mov	r2, r6
 8007f94:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8007f98:	e9c3 1200 	strd	r1, r2, [r3]
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 8007f9c:	f507 721e 	add.w	r2, r7, #632	; 0x278
 8007fa0:	f507 7314 	add.w	r3, r7, #592	; 0x250
 8007fa4:	e9d2 1200 	ldrd	r1, r2, [r2]
 8007fa8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007fac:	ea81 0503 	eor.w	r5, r1, r3
 8007fb0:	ea82 0604 	eor.w	r6, r2, r4
 8007fb4:	4629      	mov	r1, r5
 8007fb6:	4632      	mov	r2, r6
 8007fb8:	f507 730a 	add.w	r3, r7, #552	; 0x228
 8007fbc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007fc0:	ea81 0103 	eor.w	r1, r1, r3
 8007fc4:	ea82 0204 	eor.w	r2, r2, r4
 8007fc8:	f507 7300 	add.w	r3, r7, #512	; 0x200
 8007fcc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007fd0:	ea81 0103 	eor.w	r1, r1, r3
 8007fd4:	ea82 0204 	eor.w	r2, r2, r4
 8007fd8:	f507 73ec 	add.w	r3, r7, #472	; 0x1d8
 8007fdc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8007fe0:	ea83 0501 	eor.w	r5, r3, r1
 8007fe4:	ea84 0602 	eor.w	r6, r4, r2
 8007fe8:	4629      	mov	r1, r5
 8007fea:	4632      	mov	r2, r6
 8007fec:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8007ff0:	e9c3 1200 	strd	r1, r2, [r3]
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 8007ff4:	f507 721c 	add.w	r2, r7, #624	; 0x270
 8007ff8:	f507 7312 	add.w	r3, r7, #584	; 0x248
 8007ffc:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008000:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008004:	ea81 0503 	eor.w	r5, r1, r3
 8008008:	ea82 0604 	eor.w	r6, r2, r4
 800800c:	4629      	mov	r1, r5
 800800e:	4632      	mov	r2, r6
 8008010:	f507 7308 	add.w	r3, r7, #544	; 0x220
 8008014:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008018:	ea81 0103 	eor.w	r1, r1, r3
 800801c:	ea82 0204 	eor.w	r2, r2, r4
 8008020:	f507 73fc 	add.w	r3, r7, #504	; 0x1f8
 8008024:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008028:	ea81 0103 	eor.w	r1, r1, r3
 800802c:	ea82 0204 	eor.w	r2, r2, r4
 8008030:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
 8008034:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008038:	ea83 0501 	eor.w	r5, r3, r1
 800803c:	ea84 0602 	eor.w	r6, r4, r2
 8008040:	4629      	mov	r1, r5
 8008042:	4632      	mov	r2, r6
 8008044:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008048:	e9c3 1200 	strd	r1, r2, [r3]
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 800804c:	f507 721a 	add.w	r2, r7, #616	; 0x268
 8008050:	f507 7310 	add.w	r3, r7, #576	; 0x240
 8008054:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008058:	e9d3 3400 	ldrd	r3, r4, [r3]
 800805c:	ea81 0503 	eor.w	r5, r1, r3
 8008060:	ea82 0604 	eor.w	r6, r2, r4
 8008064:	4629      	mov	r1, r5
 8008066:	4632      	mov	r2, r6
 8008068:	f507 7306 	add.w	r3, r7, #536	; 0x218
 800806c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008070:	ea81 0103 	eor.w	r1, r1, r3
 8008074:	ea82 0204 	eor.w	r2, r2, r4
 8008078:	f507 73f8 	add.w	r3, r7, #496	; 0x1f0
 800807c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008080:	ea81 0103 	eor.w	r1, r1, r3
 8008084:	ea82 0204 	eor.w	r2, r2, r4
 8008088:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
 800808c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008090:	ea83 0501 	eor.w	r5, r3, r1
 8008094:	ea84 0602 	eor.w	r6, r4, r2
 8008098:	462b      	mov	r3, r5
 800809a:	4634      	mov	r4, r6
 800809c:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 80080a0:	e9c2 3400 	strd	r3, r4, [r2]

        // thetaRhoPiChiIotaPrepareTheta(round+1, E, A)
        Da = BCu ^ ROL(BCe, 1);
 80080a4:	f8d7 32d0 	ldr.w	r3, [r7, #720]	; 0x2d0
 80080a8:	0fda      	lsrs	r2, r3, #31
 80080aa:	f8d7 32d4 	ldr.w	r3, [r7, #724]	; 0x2d4
 80080ae:	005b      	lsls	r3, r3, #1
 80080b0:	4313      	orrs	r3, r2
 80080b2:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 80080b6:	f8d7 32d4 	ldr.w	r3, [r7, #724]	; 0x2d4
 80080ba:	0fda      	lsrs	r2, r3, #31
 80080bc:	f8d7 32d0 	ldr.w	r3, [r7, #720]	; 0x2d0
 80080c0:	005b      	lsls	r3, r3, #1
 80080c2:	4313      	orrs	r3, r2
 80080c4:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
 80080c8:	f507 722c 	add.w	r2, r7, #688	; 0x2b0
 80080cc:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80080d0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80080d4:	f507 71c8 	add.w	r1, r7, #400	; 0x190
 80080d8:	e9d1 0100 	ldrd	r0, r1, [r1]
 80080dc:	ea80 0003 	eor.w	r0, r0, r3
 80080e0:	ea81 0104 	eor.w	r1, r1, r4
 80080e4:	4603      	mov	r3, r0
 80080e6:	460c      	mov	r4, r1
 80080e8:	e9c2 3400 	strd	r3, r4, [r2]
        De = BCa ^ ROL(BCi, 1);
 80080ec:	f8d7 32c8 	ldr.w	r3, [r7, #712]	; 0x2c8
 80080f0:	0fda      	lsrs	r2, r3, #31
 80080f2:	f8d7 32cc 	ldr.w	r3, [r7, #716]	; 0x2cc
 80080f6:	005b      	lsls	r3, r3, #1
 80080f8:	4313      	orrs	r3, r2
 80080fa:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
 80080fe:	f8d7 32cc 	ldr.w	r3, [r7, #716]	; 0x2cc
 8008102:	0fda      	lsrs	r2, r3, #31
 8008104:	f8d7 32c8 	ldr.w	r3, [r7, #712]	; 0x2c8
 8008108:	005b      	lsls	r3, r3, #1
 800810a:	4313      	orrs	r3, r2
 800810c:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
 8008110:	f507 722a 	add.w	r2, r7, #680	; 0x2a8
 8008114:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008118:	e9d3 3400 	ldrd	r3, r4, [r3]
 800811c:	f507 71c4 	add.w	r1, r7, #392	; 0x188
 8008120:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008124:	ea80 0003 	eor.w	r0, r0, r3
 8008128:	ea81 0104 	eor.w	r1, r1, r4
 800812c:	4603      	mov	r3, r0
 800812e:	460c      	mov	r4, r1
 8008130:	e9c2 3400 	strd	r3, r4, [r2]
        Di = BCe ^ ROL(BCo, 1);
 8008134:	f8d7 32c0 	ldr.w	r3, [r7, #704]	; 0x2c0
 8008138:	0fda      	lsrs	r2, r3, #31
 800813a:	f8d7 32c4 	ldr.w	r3, [r7, #708]	; 0x2c4
 800813e:	005b      	lsls	r3, r3, #1
 8008140:	4313      	orrs	r3, r2
 8008142:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184
 8008146:	f8d7 32c4 	ldr.w	r3, [r7, #708]	; 0x2c4
 800814a:	0fda      	lsrs	r2, r3, #31
 800814c:	f8d7 32c0 	ldr.w	r3, [r7, #704]	; 0x2c0
 8008150:	005b      	lsls	r3, r3, #1
 8008152:	4313      	orrs	r3, r2
 8008154:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 8008158:	f507 7228 	add.w	r2, r7, #672	; 0x2a0
 800815c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008160:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008164:	f507 71c0 	add.w	r1, r7, #384	; 0x180
 8008168:	e9d1 0100 	ldrd	r0, r1, [r1]
 800816c:	ea80 0003 	eor.w	r0, r0, r3
 8008170:	ea81 0104 	eor.w	r1, r1, r4
 8008174:	4603      	mov	r3, r0
 8008176:	460c      	mov	r4, r1
 8008178:	e9c2 3400 	strd	r3, r4, [r2]
        Do = BCi ^ ROL(BCu, 1);
 800817c:	f8d7 32b8 	ldr.w	r3, [r7, #696]	; 0x2b8
 8008180:	0fda      	lsrs	r2, r3, #31
 8008182:	f8d7 32bc 	ldr.w	r3, [r7, #700]	; 0x2bc
 8008186:	005b      	lsls	r3, r3, #1
 8008188:	4313      	orrs	r3, r2
 800818a:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 800818e:	f8d7 32bc 	ldr.w	r3, [r7, #700]	; 0x2bc
 8008192:	0fda      	lsrs	r2, r3, #31
 8008194:	f8d7 32b8 	ldr.w	r3, [r7, #696]	; 0x2b8
 8008198:	005b      	lsls	r3, r3, #1
 800819a:	4313      	orrs	r3, r2
 800819c:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 80081a0:	f507 7226 	add.w	r2, r7, #664	; 0x298
 80081a4:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80081a8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80081ac:	f507 71bc 	add.w	r1, r7, #376	; 0x178
 80081b0:	e9d1 0100 	ldrd	r0, r1, [r1]
 80081b4:	ea80 0003 	eor.w	r0, r0, r3
 80081b8:	ea81 0104 	eor.w	r1, r1, r4
 80081bc:	4603      	mov	r3, r0
 80081be:	460c      	mov	r4, r1
 80081c0:	e9c2 3400 	strd	r3, r4, [r2]
        Du = BCo ^ ROL(BCa, 1);
 80081c4:	f8d7 32d8 	ldr.w	r3, [r7, #728]	; 0x2d8
 80081c8:	0fda      	lsrs	r2, r3, #31
 80081ca:	f8d7 32dc 	ldr.w	r3, [r7, #732]	; 0x2dc
 80081ce:	005b      	lsls	r3, r3, #1
 80081d0:	4313      	orrs	r3, r2
 80081d2:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 80081d6:	f8d7 32dc 	ldr.w	r3, [r7, #732]	; 0x2dc
 80081da:	0fda      	lsrs	r2, r3, #31
 80081dc:	f8d7 32d8 	ldr.w	r3, [r7, #728]	; 0x2d8
 80081e0:	005b      	lsls	r3, r3, #1
 80081e2:	4313      	orrs	r3, r2
 80081e4:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 80081e8:	f507 7224 	add.w	r2, r7, #656	; 0x290
 80081ec:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80081f0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80081f4:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 80081f8:	e9d1 0100 	ldrd	r0, r1, [r1]
 80081fc:	ea80 0003 	eor.w	r0, r0, r3
 8008200:	ea81 0104 	eor.w	r1, r1, r4
 8008204:	4603      	mov	r3, r0
 8008206:	460c      	mov	r4, r1
 8008208:	e9c2 3400 	strd	r3, r4, [r2]

        Eba ^= Da;
 800820c:	f507 7022 	add.w	r0, r7, #648	; 0x288
 8008210:	f507 7222 	add.w	r2, r7, #648	; 0x288
 8008214:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8008218:	e9d2 1200 	ldrd	r1, r2, [r2]
 800821c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008220:	ea83 0501 	eor.w	r5, r3, r1
 8008224:	ea84 0602 	eor.w	r6, r4, r2
 8008228:	462b      	mov	r3, r5
 800822a:	4634      	mov	r4, r6
 800822c:	e9c0 3400 	strd	r3, r4, [r0]
        BCa = Eba;
 8008230:	f507 7322 	add.w	r3, r7, #648	; 0x288
 8008234:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008238:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 800823c:	e9c2 3400 	strd	r3, r4, [r2]
        Ege ^= De;
 8008240:	f507 7016 	add.w	r0, r7, #600	; 0x258
 8008244:	f507 7216 	add.w	r2, r7, #600	; 0x258
 8008248:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 800824c:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008250:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008254:	ea83 0501 	eor.w	r5, r3, r1
 8008258:	ea84 0602 	eor.w	r6, r4, r2
 800825c:	462b      	mov	r3, r5
 800825e:	4634      	mov	r4, r6
 8008260:	e9c0 3400 	strd	r3, r4, [r0]
        BCe = ROL(Ege, 44);
 8008264:	f507 7216 	add.w	r2, r7, #600	; 0x258
 8008268:	6853      	ldr	r3, [r2, #4]
 800826a:	0319      	lsls	r1, r3, #12
 800826c:	6813      	ldr	r3, [r2, #0]
 800826e:	0d1b      	lsrs	r3, r3, #20
 8008270:	430b      	orrs	r3, r1
 8008272:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 8008276:	6813      	ldr	r3, [r2, #0]
 8008278:	0319      	lsls	r1, r3, #12
 800827a:	6853      	ldr	r3, [r2, #4]
 800827c:	0d1b      	lsrs	r3, r3, #20
 800827e:	430b      	orrs	r3, r1
 8008280:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8008284:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8008288:	e9d7 342a 	ldrd	r3, r4, [r7, #168]	; 0xa8
 800828c:	e9c2 3400 	strd	r3, r4, [r2]
        Eki ^= Di;
 8008290:	f507 700a 	add.w	r0, r7, #552	; 0x228
 8008294:	f507 720a 	add.w	r2, r7, #552	; 0x228
 8008298:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 800829c:	e9d2 1200 	ldrd	r1, r2, [r2]
 80082a0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80082a4:	ea83 0501 	eor.w	r5, r3, r1
 80082a8:	ea84 0602 	eor.w	r6, r4, r2
 80082ac:	462b      	mov	r3, r5
 80082ae:	4634      	mov	r4, r6
 80082b0:	e9c0 3400 	strd	r3, r4, [r0]
        BCi = ROL(Eki, 43);
 80082b4:	f507 720a 	add.w	r2, r7, #552	; 0x228
 80082b8:	6853      	ldr	r3, [r2, #4]
 80082ba:	02d9      	lsls	r1, r3, #11
 80082bc:	6813      	ldr	r3, [r2, #0]
 80082be:	0d5b      	lsrs	r3, r3, #21
 80082c0:	430b      	orrs	r3, r1
 80082c2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 80082c6:	6813      	ldr	r3, [r2, #0]
 80082c8:	02d9      	lsls	r1, r3, #11
 80082ca:	6853      	ldr	r3, [r2, #4]
 80082cc:	0d5b      	lsrs	r3, r3, #21
 80082ce:	430b      	orrs	r3, r1
 80082d0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 80082d4:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 80082d8:	e9d7 3428 	ldrd	r3, r4, [r7, #160]	; 0xa0
 80082dc:	e9c2 3400 	strd	r3, r4, [r2]
        Emo ^= Do;
 80082e0:	f507 70fc 	add.w	r0, r7, #504	; 0x1f8
 80082e4:	f507 72fc 	add.w	r2, r7, #504	; 0x1f8
 80082e8:	f507 7326 	add.w	r3, r7, #664	; 0x298
 80082ec:	e9d2 1200 	ldrd	r1, r2, [r2]
 80082f0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80082f4:	ea83 0501 	eor.w	r5, r3, r1
 80082f8:	ea84 0602 	eor.w	r6, r4, r2
 80082fc:	462b      	mov	r3, r5
 80082fe:	4634      	mov	r4, r6
 8008300:	e9c0 3400 	strd	r3, r4, [r0]
        BCo = ROL(Emo, 21);
 8008304:	f507 72fc 	add.w	r2, r7, #504	; 0x1f8
 8008308:	6813      	ldr	r3, [r2, #0]
 800830a:	0ad9      	lsrs	r1, r3, #11
 800830c:	6853      	ldr	r3, [r2, #4]
 800830e:	055b      	lsls	r3, r3, #21
 8008310:	430b      	orrs	r3, r1
 8008312:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 8008316:	6853      	ldr	r3, [r2, #4]
 8008318:	0ad9      	lsrs	r1, r3, #11
 800831a:	6813      	ldr	r3, [r2, #0]
 800831c:	055b      	lsls	r3, r3, #21
 800831e:	430b      	orrs	r3, r1
 8008320:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 8008324:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 8008328:	e9d7 3426 	ldrd	r3, r4, [r7, #152]	; 0x98
 800832c:	e9c2 3400 	strd	r3, r4, [r2]
        Esu ^= Du;
 8008330:	f507 70e4 	add.w	r0, r7, #456	; 0x1c8
 8008334:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
 8008338:	f507 7324 	add.w	r3, r7, #656	; 0x290
 800833c:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008340:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008344:	ea83 0501 	eor.w	r5, r3, r1
 8008348:	ea84 0602 	eor.w	r6, r4, r2
 800834c:	462b      	mov	r3, r5
 800834e:	4634      	mov	r4, r6
 8008350:	e9c0 3400 	strd	r3, r4, [r0]
        BCu = ROL(Esu, 14);
 8008354:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
 8008358:	6813      	ldr	r3, [r2, #0]
 800835a:	0c99      	lsrs	r1, r3, #18
 800835c:	6853      	ldr	r3, [r2, #4]
 800835e:	039b      	lsls	r3, r3, #14
 8008360:	430b      	orrs	r3, r1
 8008362:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8008366:	6853      	ldr	r3, [r2, #4]
 8008368:	0c99      	lsrs	r1, r3, #18
 800836a:	6813      	ldr	r3, [r2, #0]
 800836c:	039b      	lsls	r3, r3, #14
 800836e:	430b      	orrs	r3, r1
 8008370:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8008374:	e9d7 3424 	ldrd	r3, r4, [r7, #144]	; 0x90
 8008378:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 800837c:	e9c2 3400 	strd	r3, r4, [r2]
        Aba = BCa ^ ((~BCe) & BCi);
 8008380:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008384:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008388:	ea6f 0103 	mvn.w	r1, r3
 800838c:	ea6f 0204 	mvn.w	r2, r4
 8008390:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008394:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008398:	ea01 0103 	and.w	r1, r1, r3
 800839c:	ea02 0204 	and.w	r2, r2, r4
 80083a0:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 80083a4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80083a8:	ea83 0501 	eor.w	r5, r3, r1
 80083ac:	ea84 0602 	eor.w	r6, r4, r2
 80083b0:	4629      	mov	r1, r5
 80083b2:	4632      	mov	r2, r6
 80083b4:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 80083b8:	e9c3 1200 	strd	r1, r2, [r3]
        Aba ^= KeccakF_RoundConstants[round + 1];
 80083bc:	f8d7 33ac 	ldr.w	r3, [r7, #940]	; 0x3ac
 80083c0:	3301      	adds	r3, #1
 80083c2:	4abf      	ldr	r2, [pc, #764]	; (80086c0 <KeccakF1600_StatePermute+0x1b28>)
 80083c4:	00db      	lsls	r3, r3, #3
 80083c6:	4413      	add	r3, r2
 80083c8:	e9d3 1200 	ldrd	r1, r2, [r3]
 80083cc:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 80083d0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80083d4:	ea83 0501 	eor.w	r5, r3, r1
 80083d8:	ea84 0602 	eor.w	r6, r4, r2
 80083dc:	4629      	mov	r1, r5
 80083de:	4632      	mov	r2, r6
 80083e0:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 80083e4:	e9c3 1200 	strd	r1, r2, [r3]
        Abe = BCe ^ ((~BCi) & BCo);
 80083e8:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80083ec:	e9d3 3400 	ldrd	r3, r4, [r3]
 80083f0:	ea6f 0103 	mvn.w	r1, r3
 80083f4:	ea6f 0204 	mvn.w	r2, r4
 80083f8:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80083fc:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008400:	ea01 0103 	and.w	r1, r1, r3
 8008404:	ea02 0204 	and.w	r2, r2, r4
 8008408:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 800840c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008410:	ea83 0501 	eor.w	r5, r3, r1
 8008414:	ea84 0602 	eor.w	r6, r4, r2
 8008418:	4629      	mov	r1, r5
 800841a:	4632      	mov	r2, r6
 800841c:	f507 7366 	add.w	r3, r7, #920	; 0x398
 8008420:	e9c3 1200 	strd	r1, r2, [r3]
        Abi = BCi ^ ((~BCo) & BCu);
 8008424:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008428:	e9d3 3400 	ldrd	r3, r4, [r3]
 800842c:	ea6f 0103 	mvn.w	r1, r3
 8008430:	ea6f 0204 	mvn.w	r2, r4
 8008434:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008438:	e9d3 3400 	ldrd	r3, r4, [r3]
 800843c:	ea01 0103 	and.w	r1, r1, r3
 8008440:	ea02 0204 	and.w	r2, r2, r4
 8008444:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008448:	e9d3 3400 	ldrd	r3, r4, [r3]
 800844c:	ea83 0501 	eor.w	r5, r3, r1
 8008450:	ea84 0602 	eor.w	r6, r4, r2
 8008454:	4629      	mov	r1, r5
 8008456:	4632      	mov	r2, r6
 8008458:	f507 7364 	add.w	r3, r7, #912	; 0x390
 800845c:	e9c3 1200 	strd	r1, r2, [r3]
        Abo = BCo ^ ((~BCu) & BCa);
 8008460:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008464:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008468:	ea6f 0103 	mvn.w	r1, r3
 800846c:	ea6f 0204 	mvn.w	r2, r4
 8008470:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008474:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008478:	ea01 0103 	and.w	r1, r1, r3
 800847c:	ea02 0204 	and.w	r2, r2, r4
 8008480:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008484:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008488:	ea83 0501 	eor.w	r5, r3, r1
 800848c:	ea84 0602 	eor.w	r6, r4, r2
 8008490:	4629      	mov	r1, r5
 8008492:	4632      	mov	r2, r6
 8008494:	f507 7362 	add.w	r3, r7, #904	; 0x388
 8008498:	e9c3 1200 	strd	r1, r2, [r3]
        Abu = BCu ^ ((~BCa) & BCe);
 800849c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 80084a0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80084a4:	ea6f 0103 	mvn.w	r1, r3
 80084a8:	ea6f 0204 	mvn.w	r2, r4
 80084ac:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 80084b0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80084b4:	ea01 0103 	and.w	r1, r1, r3
 80084b8:	ea02 0204 	and.w	r2, r2, r4
 80084bc:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80084c0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80084c4:	ea83 0501 	eor.w	r5, r3, r1
 80084c8:	ea84 0602 	eor.w	r6, r4, r2
 80084cc:	4629      	mov	r1, r5
 80084ce:	4632      	mov	r2, r6
 80084d0:	f507 7360 	add.w	r3, r7, #896	; 0x380
 80084d4:	e9c3 1200 	strd	r1, r2, [r3]

        Ebo ^= Do;
 80084d8:	f507 701c 	add.w	r0, r7, #624	; 0x270
 80084dc:	f507 721c 	add.w	r2, r7, #624	; 0x270
 80084e0:	f507 7326 	add.w	r3, r7, #664	; 0x298
 80084e4:	e9d2 1200 	ldrd	r1, r2, [r2]
 80084e8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80084ec:	ea83 0501 	eor.w	r5, r3, r1
 80084f0:	ea84 0602 	eor.w	r6, r4, r2
 80084f4:	462b      	mov	r3, r5
 80084f6:	4634      	mov	r4, r6
 80084f8:	e9c0 3400 	strd	r3, r4, [r0]
        BCa = ROL(Ebo, 28);
 80084fc:	f507 721c 	add.w	r2, r7, #624	; 0x270
 8008500:	6813      	ldr	r3, [r2, #0]
 8008502:	0919      	lsrs	r1, r3, #4
 8008504:	6853      	ldr	r3, [r2, #4]
 8008506:	071b      	lsls	r3, r3, #28
 8008508:	430b      	orrs	r3, r1
 800850a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800850e:	6853      	ldr	r3, [r2, #4]
 8008510:	0919      	lsrs	r1, r3, #4
 8008512:	6813      	ldr	r3, [r2, #0]
 8008514:	071b      	lsls	r3, r3, #28
 8008516:	430b      	orrs	r3, r1
 8008518:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800851c:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 8008520:	e9d7 3422 	ldrd	r3, r4, [r7, #136]	; 0x88
 8008524:	e9c2 3400 	strd	r3, r4, [r2]
        Egu ^= Du;
 8008528:	f507 7010 	add.w	r0, r7, #576	; 0x240
 800852c:	f507 7210 	add.w	r2, r7, #576	; 0x240
 8008530:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8008534:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008538:	e9d3 3400 	ldrd	r3, r4, [r3]
 800853c:	ea83 0501 	eor.w	r5, r3, r1
 8008540:	ea84 0602 	eor.w	r6, r4, r2
 8008544:	462b      	mov	r3, r5
 8008546:	4634      	mov	r4, r6
 8008548:	e9c0 3400 	strd	r3, r4, [r0]
        BCe = ROL(Egu, 20);
 800854c:	f507 7210 	add.w	r2, r7, #576	; 0x240
 8008550:	6813      	ldr	r3, [r2, #0]
 8008552:	0b19      	lsrs	r1, r3, #12
 8008554:	6853      	ldr	r3, [r2, #4]
 8008556:	051b      	lsls	r3, r3, #20
 8008558:	430b      	orrs	r3, r1
 800855a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800855e:	6853      	ldr	r3, [r2, #4]
 8008560:	0b19      	lsrs	r1, r3, #12
 8008562:	6813      	ldr	r3, [r2, #0]
 8008564:	051b      	lsls	r3, r3, #20
 8008566:	430b      	orrs	r3, r1
 8008568:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800856c:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8008570:	e9d7 3420 	ldrd	r3, r4, [r7, #128]	; 0x80
 8008574:	e9c2 3400 	strd	r3, r4, [r2]
        Eka ^= Da;
 8008578:	f507 700e 	add.w	r0, r7, #568	; 0x238
 800857c:	f507 720e 	add.w	r2, r7, #568	; 0x238
 8008580:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8008584:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008588:	e9d3 3400 	ldrd	r3, r4, [r3]
 800858c:	ea83 0501 	eor.w	r5, r3, r1
 8008590:	ea84 0602 	eor.w	r6, r4, r2
 8008594:	462b      	mov	r3, r5
 8008596:	4634      	mov	r4, r6
 8008598:	e9c0 3400 	strd	r3, r4, [r0]
        BCi = ROL(Eka, 3);
 800859c:	f507 720e 	add.w	r2, r7, #568	; 0x238
 80085a0:	6813      	ldr	r3, [r2, #0]
 80085a2:	0f59      	lsrs	r1, r3, #29
 80085a4:	6853      	ldr	r3, [r2, #4]
 80085a6:	00db      	lsls	r3, r3, #3
 80085a8:	430b      	orrs	r3, r1
 80085aa:	67fb      	str	r3, [r7, #124]	; 0x7c
 80085ac:	6853      	ldr	r3, [r2, #4]
 80085ae:	0f59      	lsrs	r1, r3, #29
 80085b0:	6813      	ldr	r3, [r2, #0]
 80085b2:	00db      	lsls	r3, r3, #3
 80085b4:	430b      	orrs	r3, r1
 80085b6:	67bb      	str	r3, [r7, #120]	; 0x78
 80085b8:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 80085bc:	e9d7 341e 	ldrd	r3, r4, [r7, #120]	; 0x78
 80085c0:	e9c2 3400 	strd	r3, r4, [r2]
        Eme ^= De;
 80085c4:	f507 7002 	add.w	r0, r7, #520	; 0x208
 80085c8:	f507 7202 	add.w	r2, r7, #520	; 0x208
 80085cc:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 80085d0:	e9d2 1200 	ldrd	r1, r2, [r2]
 80085d4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80085d8:	ea83 0501 	eor.w	r5, r3, r1
 80085dc:	ea84 0602 	eor.w	r6, r4, r2
 80085e0:	462b      	mov	r3, r5
 80085e2:	4634      	mov	r4, r6
 80085e4:	e9c0 3400 	strd	r3, r4, [r0]
        BCo = ROL(Eme, 45);
 80085e8:	f507 7202 	add.w	r2, r7, #520	; 0x208
 80085ec:	6853      	ldr	r3, [r2, #4]
 80085ee:	0359      	lsls	r1, r3, #13
 80085f0:	6813      	ldr	r3, [r2, #0]
 80085f2:	0cdb      	lsrs	r3, r3, #19
 80085f4:	430b      	orrs	r3, r1
 80085f6:	673b      	str	r3, [r7, #112]	; 0x70
 80085f8:	6813      	ldr	r3, [r2, #0]
 80085fa:	0359      	lsls	r1, r3, #13
 80085fc:	6853      	ldr	r3, [r2, #4]
 80085fe:	0cdb      	lsrs	r3, r3, #19
 8008600:	430b      	orrs	r3, r1
 8008602:	677b      	str	r3, [r7, #116]	; 0x74
 8008604:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 8008608:	e9d7 341c 	ldrd	r3, r4, [r7, #112]	; 0x70
 800860c:	e9c2 3400 	strd	r3, r4, [r2]
        Esi ^= Di;
 8008610:	f507 70ec 	add.w	r0, r7, #472	; 0x1d8
 8008614:	f507 72ec 	add.w	r2, r7, #472	; 0x1d8
 8008618:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 800861c:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008620:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008624:	ea83 0501 	eor.w	r5, r3, r1
 8008628:	ea84 0602 	eor.w	r6, r4, r2
 800862c:	462b      	mov	r3, r5
 800862e:	4634      	mov	r4, r6
 8008630:	e9c0 3400 	strd	r3, r4, [r0]
        BCu = ROL(Esi, 61);
 8008634:	f507 72ec 	add.w	r2, r7, #472	; 0x1d8
 8008638:	6853      	ldr	r3, [r2, #4]
 800863a:	0759      	lsls	r1, r3, #29
 800863c:	6813      	ldr	r3, [r2, #0]
 800863e:	08db      	lsrs	r3, r3, #3
 8008640:	430b      	orrs	r3, r1
 8008642:	66bb      	str	r3, [r7, #104]	; 0x68
 8008644:	6813      	ldr	r3, [r2, #0]
 8008646:	0759      	lsls	r1, r3, #29
 8008648:	6853      	ldr	r3, [r2, #4]
 800864a:	08db      	lsrs	r3, r3, #3
 800864c:	430b      	orrs	r3, r1
 800864e:	66fb      	str	r3, [r7, #108]	; 0x6c
 8008650:	e9d7 341a 	ldrd	r3, r4, [r7, #104]	; 0x68
 8008654:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8008658:	e9c2 3400 	strd	r3, r4, [r2]
        Aga = BCa ^ ((~BCe) & BCi);
 800865c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008660:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008664:	ea6f 0103 	mvn.w	r1, r3
 8008668:	ea6f 0204 	mvn.w	r2, r4
 800866c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008670:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008674:	ea01 0103 	and.w	r1, r1, r3
 8008678:	ea02 0204 	and.w	r2, r2, r4
 800867c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008680:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008684:	ea83 0501 	eor.w	r5, r3, r1
 8008688:	ea84 0602 	eor.w	r6, r4, r2
 800868c:	4629      	mov	r1, r5
 800868e:	4632      	mov	r2, r6
 8008690:	f507 735e 	add.w	r3, r7, #888	; 0x378
 8008694:	e9c3 1200 	strd	r1, r2, [r3]
        Age = BCe ^ ((~BCi) & BCo);
 8008698:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 800869c:	e9d3 3400 	ldrd	r3, r4, [r3]
 80086a0:	ea6f 0103 	mvn.w	r1, r3
 80086a4:	ea6f 0204 	mvn.w	r2, r4
 80086a8:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80086ac:	e9d3 3400 	ldrd	r3, r4, [r3]
 80086b0:	ea01 0103 	and.w	r1, r1, r3
 80086b4:	ea02 0204 	and.w	r2, r2, r4
 80086b8:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 80086bc:	e002      	b.n	80086c4 <KeccakF1600_StatePermute+0x1b2c>
 80086be:	bf00      	nop
 80086c0:	0801e048 	.word	0x0801e048
 80086c4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80086c8:	ea83 0501 	eor.w	r5, r3, r1
 80086cc:	ea84 0602 	eor.w	r6, r4, r2
 80086d0:	4629      	mov	r1, r5
 80086d2:	4632      	mov	r2, r6
 80086d4:	f507 735c 	add.w	r3, r7, #880	; 0x370
 80086d8:	e9c3 1200 	strd	r1, r2, [r3]
        Agi = BCi ^ ((~BCo) & BCu);
 80086dc:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80086e0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80086e4:	ea6f 0103 	mvn.w	r1, r3
 80086e8:	ea6f 0204 	mvn.w	r2, r4
 80086ec:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80086f0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80086f4:	ea01 0103 	and.w	r1, r1, r3
 80086f8:	ea02 0204 	and.w	r2, r2, r4
 80086fc:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008700:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008704:	ea83 0501 	eor.w	r5, r3, r1
 8008708:	ea84 0602 	eor.w	r6, r4, r2
 800870c:	4629      	mov	r1, r5
 800870e:	4632      	mov	r2, r6
 8008710:	f507 735a 	add.w	r3, r7, #872	; 0x368
 8008714:	e9c3 1200 	strd	r1, r2, [r3]
        Ago = BCo ^ ((~BCu) & BCa);
 8008718:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 800871c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008720:	ea6f 0103 	mvn.w	r1, r3
 8008724:	ea6f 0204 	mvn.w	r2, r4
 8008728:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 800872c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008730:	ea01 0103 	and.w	r1, r1, r3
 8008734:	ea02 0204 	and.w	r2, r2, r4
 8008738:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 800873c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008740:	ea83 0501 	eor.w	r5, r3, r1
 8008744:	ea84 0602 	eor.w	r6, r4, r2
 8008748:	4629      	mov	r1, r5
 800874a:	4632      	mov	r2, r6
 800874c:	f507 7358 	add.w	r3, r7, #864	; 0x360
 8008750:	e9c3 1200 	strd	r1, r2, [r3]
        Agu = BCu ^ ((~BCa) & BCe);
 8008754:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008758:	e9d3 3400 	ldrd	r3, r4, [r3]
 800875c:	ea6f 0103 	mvn.w	r1, r3
 8008760:	ea6f 0204 	mvn.w	r2, r4
 8008764:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008768:	e9d3 3400 	ldrd	r3, r4, [r3]
 800876c:	ea01 0103 	and.w	r1, r1, r3
 8008770:	ea02 0204 	and.w	r2, r2, r4
 8008774:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008778:	e9d3 3400 	ldrd	r3, r4, [r3]
 800877c:	ea83 0501 	eor.w	r5, r3, r1
 8008780:	ea84 0602 	eor.w	r6, r4, r2
 8008784:	4629      	mov	r1, r5
 8008786:	4632      	mov	r2, r6
 8008788:	f507 7356 	add.w	r3, r7, #856	; 0x358
 800878c:	e9c3 1200 	strd	r1, r2, [r3]

        Ebe ^= De;
 8008790:	f507 7020 	add.w	r0, r7, #640	; 0x280
 8008794:	f507 7220 	add.w	r2, r7, #640	; 0x280
 8008798:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 800879c:	e9d2 1200 	ldrd	r1, r2, [r2]
 80087a0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80087a4:	ea83 0501 	eor.w	r5, r3, r1
 80087a8:	ea84 0602 	eor.w	r6, r4, r2
 80087ac:	462b      	mov	r3, r5
 80087ae:	4634      	mov	r4, r6
 80087b0:	e9c0 3400 	strd	r3, r4, [r0]
        BCa = ROL(Ebe, 1);
 80087b4:	f507 7220 	add.w	r2, r7, #640	; 0x280
 80087b8:	6813      	ldr	r3, [r2, #0]
 80087ba:	0fd9      	lsrs	r1, r3, #31
 80087bc:	6853      	ldr	r3, [r2, #4]
 80087be:	005b      	lsls	r3, r3, #1
 80087c0:	430b      	orrs	r3, r1
 80087c2:	667b      	str	r3, [r7, #100]	; 0x64
 80087c4:	6853      	ldr	r3, [r2, #4]
 80087c6:	0fd9      	lsrs	r1, r3, #31
 80087c8:	6813      	ldr	r3, [r2, #0]
 80087ca:	005b      	lsls	r3, r3, #1
 80087cc:	430b      	orrs	r3, r1
 80087ce:	663b      	str	r3, [r7, #96]	; 0x60
 80087d0:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 80087d4:	e9d7 3418 	ldrd	r3, r4, [r7, #96]	; 0x60
 80087d8:	e9c2 3400 	strd	r3, r4, [r2]
        Egi ^= Di;
 80087dc:	f507 7014 	add.w	r0, r7, #592	; 0x250
 80087e0:	f507 7214 	add.w	r2, r7, #592	; 0x250
 80087e4:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 80087e8:	e9d2 1200 	ldrd	r1, r2, [r2]
 80087ec:	e9d3 3400 	ldrd	r3, r4, [r3]
 80087f0:	ea83 0501 	eor.w	r5, r3, r1
 80087f4:	ea84 0602 	eor.w	r6, r4, r2
 80087f8:	462b      	mov	r3, r5
 80087fa:	4634      	mov	r4, r6
 80087fc:	e9c0 3400 	strd	r3, r4, [r0]
        BCe = ROL(Egi, 6);
 8008800:	f507 7214 	add.w	r2, r7, #592	; 0x250
 8008804:	6813      	ldr	r3, [r2, #0]
 8008806:	0e99      	lsrs	r1, r3, #26
 8008808:	6853      	ldr	r3, [r2, #4]
 800880a:	019b      	lsls	r3, r3, #6
 800880c:	430b      	orrs	r3, r1
 800880e:	65fb      	str	r3, [r7, #92]	; 0x5c
 8008810:	6853      	ldr	r3, [r2, #4]
 8008812:	0e99      	lsrs	r1, r3, #26
 8008814:	6813      	ldr	r3, [r2, #0]
 8008816:	019b      	lsls	r3, r3, #6
 8008818:	430b      	orrs	r3, r1
 800881a:	65bb      	str	r3, [r7, #88]	; 0x58
 800881c:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8008820:	e9d7 3416 	ldrd	r3, r4, [r7, #88]	; 0x58
 8008824:	e9c2 3400 	strd	r3, r4, [r2]
        Eko ^= Do;
 8008828:	f507 7008 	add.w	r0, r7, #544	; 0x220
 800882c:	f507 7208 	add.w	r2, r7, #544	; 0x220
 8008830:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8008834:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008838:	e9d3 3400 	ldrd	r3, r4, [r3]
 800883c:	ea83 0501 	eor.w	r5, r3, r1
 8008840:	ea84 0602 	eor.w	r6, r4, r2
 8008844:	462b      	mov	r3, r5
 8008846:	4634      	mov	r4, r6
 8008848:	e9c0 3400 	strd	r3, r4, [r0]
        BCi = ROL(Eko, 25);
 800884c:	f507 7208 	add.w	r2, r7, #544	; 0x220
 8008850:	6813      	ldr	r3, [r2, #0]
 8008852:	09d9      	lsrs	r1, r3, #7
 8008854:	6853      	ldr	r3, [r2, #4]
 8008856:	065b      	lsls	r3, r3, #25
 8008858:	430b      	orrs	r3, r1
 800885a:	657b      	str	r3, [r7, #84]	; 0x54
 800885c:	6853      	ldr	r3, [r2, #4]
 800885e:	09d9      	lsrs	r1, r3, #7
 8008860:	6813      	ldr	r3, [r2, #0]
 8008862:	065b      	lsls	r3, r3, #25
 8008864:	430b      	orrs	r3, r1
 8008866:	653b      	str	r3, [r7, #80]	; 0x50
 8008868:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 800886c:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
 8008870:	e9c2 3400 	strd	r3, r4, [r2]
        Emu ^= Du;
 8008874:	f507 70f8 	add.w	r0, r7, #496	; 0x1f0
 8008878:	f507 72f8 	add.w	r2, r7, #496	; 0x1f0
 800887c:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8008880:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008884:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008888:	ea83 0501 	eor.w	r5, r3, r1
 800888c:	ea84 0602 	eor.w	r6, r4, r2
 8008890:	462b      	mov	r3, r5
 8008892:	4634      	mov	r4, r6
 8008894:	e9c0 3400 	strd	r3, r4, [r0]
        BCo = ROL(Emu, 8);
 8008898:	f507 72f8 	add.w	r2, r7, #496	; 0x1f0
 800889c:	6813      	ldr	r3, [r2, #0]
 800889e:	0e19      	lsrs	r1, r3, #24
 80088a0:	6853      	ldr	r3, [r2, #4]
 80088a2:	021b      	lsls	r3, r3, #8
 80088a4:	430b      	orrs	r3, r1
 80088a6:	64fb      	str	r3, [r7, #76]	; 0x4c
 80088a8:	6853      	ldr	r3, [r2, #4]
 80088aa:	0e19      	lsrs	r1, r3, #24
 80088ac:	6813      	ldr	r3, [r2, #0]
 80088ae:	021b      	lsls	r3, r3, #8
 80088b0:	430b      	orrs	r3, r1
 80088b2:	64bb      	str	r3, [r7, #72]	; 0x48
 80088b4:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 80088b8:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 80088bc:	e9c2 3400 	strd	r3, r4, [r2]
        Esa ^= Da;
 80088c0:	f507 70f4 	add.w	r0, r7, #488	; 0x1e8
 80088c4:	f507 72f4 	add.w	r2, r7, #488	; 0x1e8
 80088c8:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 80088cc:	e9d2 1200 	ldrd	r1, r2, [r2]
 80088d0:	e9d3 3400 	ldrd	r3, r4, [r3]
 80088d4:	ea83 0501 	eor.w	r5, r3, r1
 80088d8:	ea84 0602 	eor.w	r6, r4, r2
 80088dc:	462b      	mov	r3, r5
 80088de:	4634      	mov	r4, r6
 80088e0:	e9c0 3400 	strd	r3, r4, [r0]
        BCu = ROL(Esa, 18);
 80088e4:	f507 72f4 	add.w	r2, r7, #488	; 0x1e8
 80088e8:	6813      	ldr	r3, [r2, #0]
 80088ea:	0b99      	lsrs	r1, r3, #14
 80088ec:	6853      	ldr	r3, [r2, #4]
 80088ee:	049b      	lsls	r3, r3, #18
 80088f0:	430b      	orrs	r3, r1
 80088f2:	647b      	str	r3, [r7, #68]	; 0x44
 80088f4:	6853      	ldr	r3, [r2, #4]
 80088f6:	0b99      	lsrs	r1, r3, #14
 80088f8:	6813      	ldr	r3, [r2, #0]
 80088fa:	049b      	lsls	r3, r3, #18
 80088fc:	430b      	orrs	r3, r1
 80088fe:	643b      	str	r3, [r7, #64]	; 0x40
 8008900:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 8008904:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8008908:	e9c2 3400 	strd	r3, r4, [r2]
        Aka = BCa ^ ((~BCe) & BCi);
 800890c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008910:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008914:	ea6f 0103 	mvn.w	r1, r3
 8008918:	ea6f 0204 	mvn.w	r2, r4
 800891c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008920:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008924:	ea01 0103 	and.w	r1, r1, r3
 8008928:	ea02 0204 	and.w	r2, r2, r4
 800892c:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008930:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008934:	ea83 0501 	eor.w	r5, r3, r1
 8008938:	ea84 0602 	eor.w	r6, r4, r2
 800893c:	4629      	mov	r1, r5
 800893e:	4632      	mov	r2, r6
 8008940:	f507 7354 	add.w	r3, r7, #848	; 0x350
 8008944:	e9c3 1200 	strd	r1, r2, [r3]
        Ake = BCe ^ ((~BCi) & BCo);
 8008948:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 800894c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008950:	ea6f 0103 	mvn.w	r1, r3
 8008954:	ea6f 0204 	mvn.w	r2, r4
 8008958:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 800895c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008960:	ea01 0103 	and.w	r1, r1, r3
 8008964:	ea02 0204 	and.w	r2, r2, r4
 8008968:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 800896c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008970:	ea83 0501 	eor.w	r5, r3, r1
 8008974:	ea84 0602 	eor.w	r6, r4, r2
 8008978:	4629      	mov	r1, r5
 800897a:	4632      	mov	r2, r6
 800897c:	f507 7352 	add.w	r3, r7, #840	; 0x348
 8008980:	e9c3 1200 	strd	r1, r2, [r3]
        Aki = BCi ^ ((~BCo) & BCu);
 8008984:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008988:	e9d3 3400 	ldrd	r3, r4, [r3]
 800898c:	ea6f 0103 	mvn.w	r1, r3
 8008990:	ea6f 0204 	mvn.w	r2, r4
 8008994:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008998:	e9d3 3400 	ldrd	r3, r4, [r3]
 800899c:	ea01 0103 	and.w	r1, r1, r3
 80089a0:	ea02 0204 	and.w	r2, r2, r4
 80089a4:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 80089a8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80089ac:	ea83 0501 	eor.w	r5, r3, r1
 80089b0:	ea84 0602 	eor.w	r6, r4, r2
 80089b4:	4629      	mov	r1, r5
 80089b6:	4632      	mov	r2, r6
 80089b8:	f507 7350 	add.w	r3, r7, #832	; 0x340
 80089bc:	e9c3 1200 	strd	r1, r2, [r3]
        Ako = BCo ^ ((~BCu) & BCa);
 80089c0:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 80089c4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80089c8:	ea6f 0103 	mvn.w	r1, r3
 80089cc:	ea6f 0204 	mvn.w	r2, r4
 80089d0:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 80089d4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80089d8:	ea01 0103 	and.w	r1, r1, r3
 80089dc:	ea02 0204 	and.w	r2, r2, r4
 80089e0:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 80089e4:	e9d3 3400 	ldrd	r3, r4, [r3]
 80089e8:	ea83 0501 	eor.w	r5, r3, r1
 80089ec:	ea84 0602 	eor.w	r6, r4, r2
 80089f0:	4629      	mov	r1, r5
 80089f2:	4632      	mov	r2, r6
 80089f4:	f507 734e 	add.w	r3, r7, #824	; 0x338
 80089f8:	e9c3 1200 	strd	r1, r2, [r3]
        Aku = BCu ^ ((~BCa) & BCe);
 80089fc:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008a00:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008a04:	ea6f 0103 	mvn.w	r1, r3
 8008a08:	ea6f 0204 	mvn.w	r2, r4
 8008a0c:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008a10:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008a14:	ea01 0103 	and.w	r1, r1, r3
 8008a18:	ea02 0204 	and.w	r2, r2, r4
 8008a1c:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008a20:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008a24:	ea83 0501 	eor.w	r5, r3, r1
 8008a28:	ea84 0602 	eor.w	r6, r4, r2
 8008a2c:	4629      	mov	r1, r5
 8008a2e:	4632      	mov	r2, r6
 8008a30:	f507 734c 	add.w	r3, r7, #816	; 0x330
 8008a34:	e9c3 1200 	strd	r1, r2, [r3]

        Ebu ^= Du;
 8008a38:	f507 701a 	add.w	r0, r7, #616	; 0x268
 8008a3c:	f507 721a 	add.w	r2, r7, #616	; 0x268
 8008a40:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8008a44:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008a48:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008a4c:	ea83 0501 	eor.w	r5, r3, r1
 8008a50:	ea84 0602 	eor.w	r6, r4, r2
 8008a54:	462b      	mov	r3, r5
 8008a56:	4634      	mov	r4, r6
 8008a58:	e9c0 3400 	strd	r3, r4, [r0]
        BCa = ROL(Ebu, 27);
 8008a5c:	f507 721a 	add.w	r2, r7, #616	; 0x268
 8008a60:	6813      	ldr	r3, [r2, #0]
 8008a62:	0959      	lsrs	r1, r3, #5
 8008a64:	6853      	ldr	r3, [r2, #4]
 8008a66:	06db      	lsls	r3, r3, #27
 8008a68:	430b      	orrs	r3, r1
 8008a6a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8008a6c:	6853      	ldr	r3, [r2, #4]
 8008a6e:	0959      	lsrs	r1, r3, #5
 8008a70:	6813      	ldr	r3, [r2, #0]
 8008a72:	06db      	lsls	r3, r3, #27
 8008a74:	430b      	orrs	r3, r1
 8008a76:	63bb      	str	r3, [r7, #56]	; 0x38
 8008a78:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 8008a7c:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 8008a80:	e9c2 3400 	strd	r3, r4, [r2]
        Ega ^= Da;
 8008a84:	f507 7018 	add.w	r0, r7, #608	; 0x260
 8008a88:	f507 7218 	add.w	r2, r7, #608	; 0x260
 8008a8c:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8008a90:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008a94:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008a98:	ea83 0501 	eor.w	r5, r3, r1
 8008a9c:	ea84 0602 	eor.w	r6, r4, r2
 8008aa0:	462b      	mov	r3, r5
 8008aa2:	4634      	mov	r4, r6
 8008aa4:	e9c0 3400 	strd	r3, r4, [r0]
        BCe = ROL(Ega, 36);
 8008aa8:	f507 7218 	add.w	r2, r7, #608	; 0x260
 8008aac:	6853      	ldr	r3, [r2, #4]
 8008aae:	0119      	lsls	r1, r3, #4
 8008ab0:	6813      	ldr	r3, [r2, #0]
 8008ab2:	0f1b      	lsrs	r3, r3, #28
 8008ab4:	430b      	orrs	r3, r1
 8008ab6:	633b      	str	r3, [r7, #48]	; 0x30
 8008ab8:	6813      	ldr	r3, [r2, #0]
 8008aba:	0119      	lsls	r1, r3, #4
 8008abc:	6853      	ldr	r3, [r2, #4]
 8008abe:	0f1b      	lsrs	r3, r3, #28
 8008ac0:	430b      	orrs	r3, r1
 8008ac2:	637b      	str	r3, [r7, #52]	; 0x34
 8008ac4:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8008ac8:	e9d7 340c 	ldrd	r3, r4, [r7, #48]	; 0x30
 8008acc:	e9c2 3400 	strd	r3, r4, [r2]
        Eke ^= De;
 8008ad0:	f507 700c 	add.w	r0, r7, #560	; 0x230
 8008ad4:	f507 720c 	add.w	r2, r7, #560	; 0x230
 8008ad8:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 8008adc:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008ae0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ae4:	ea83 0501 	eor.w	r5, r3, r1
 8008ae8:	ea84 0602 	eor.w	r6, r4, r2
 8008aec:	462b      	mov	r3, r5
 8008aee:	4634      	mov	r4, r6
 8008af0:	e9c0 3400 	strd	r3, r4, [r0]
        BCi = ROL(Eke, 10);
 8008af4:	f507 720c 	add.w	r2, r7, #560	; 0x230
 8008af8:	6813      	ldr	r3, [r2, #0]
 8008afa:	0d99      	lsrs	r1, r3, #22
 8008afc:	6853      	ldr	r3, [r2, #4]
 8008afe:	029b      	lsls	r3, r3, #10
 8008b00:	430b      	orrs	r3, r1
 8008b02:	62fb      	str	r3, [r7, #44]	; 0x2c
 8008b04:	6853      	ldr	r3, [r2, #4]
 8008b06:	0d99      	lsrs	r1, r3, #22
 8008b08:	6813      	ldr	r3, [r2, #0]
 8008b0a:	029b      	lsls	r3, r3, #10
 8008b0c:	430b      	orrs	r3, r1
 8008b0e:	62bb      	str	r3, [r7, #40]	; 0x28
 8008b10:	f507 7232 	add.w	r2, r7, #712	; 0x2c8
 8008b14:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	; 0x28
 8008b18:	e9c2 3400 	strd	r3, r4, [r2]
        Emi ^= Di;
 8008b1c:	f507 7000 	add.w	r0, r7, #512	; 0x200
 8008b20:	f507 7200 	add.w	r2, r7, #512	; 0x200
 8008b24:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8008b28:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008b2c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008b30:	ea83 0501 	eor.w	r5, r3, r1
 8008b34:	ea84 0602 	eor.w	r6, r4, r2
 8008b38:	462b      	mov	r3, r5
 8008b3a:	4634      	mov	r4, r6
 8008b3c:	e9c0 3400 	strd	r3, r4, [r0]
        BCo = ROL(Emi, 15);
 8008b40:	f507 7200 	add.w	r2, r7, #512	; 0x200
 8008b44:	6813      	ldr	r3, [r2, #0]
 8008b46:	0c59      	lsrs	r1, r3, #17
 8008b48:	6853      	ldr	r3, [r2, #4]
 8008b4a:	03db      	lsls	r3, r3, #15
 8008b4c:	430b      	orrs	r3, r1
 8008b4e:	627b      	str	r3, [r7, #36]	; 0x24
 8008b50:	6853      	ldr	r3, [r2, #4]
 8008b52:	0c59      	lsrs	r1, r3, #17
 8008b54:	6813      	ldr	r3, [r2, #0]
 8008b56:	03db      	lsls	r3, r3, #15
 8008b58:	430b      	orrs	r3, r1
 8008b5a:	623b      	str	r3, [r7, #32]
 8008b5c:	f507 7230 	add.w	r2, r7, #704	; 0x2c0
 8008b60:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 8008b64:	e9c2 3400 	strd	r3, r4, [r2]
        Eso ^= Do;
 8008b68:	f507 70e8 	add.w	r0, r7, #464	; 0x1d0
 8008b6c:	f507 72e8 	add.w	r2, r7, #464	; 0x1d0
 8008b70:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8008b74:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008b78:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008b7c:	ea83 0501 	eor.w	r5, r3, r1
 8008b80:	ea84 0602 	eor.w	r6, r4, r2
 8008b84:	462b      	mov	r3, r5
 8008b86:	4634      	mov	r4, r6
 8008b88:	e9c0 3400 	strd	r3, r4, [r0]
        BCu = ROL(Eso, 56);
 8008b8c:	f507 72e8 	add.w	r2, r7, #464	; 0x1d0
 8008b90:	6853      	ldr	r3, [r2, #4]
 8008b92:	0619      	lsls	r1, r3, #24
 8008b94:	6813      	ldr	r3, [r2, #0]
 8008b96:	0a1b      	lsrs	r3, r3, #8
 8008b98:	430b      	orrs	r3, r1
 8008b9a:	61bb      	str	r3, [r7, #24]
 8008b9c:	6813      	ldr	r3, [r2, #0]
 8008b9e:	0619      	lsls	r1, r3, #24
 8008ba0:	6853      	ldr	r3, [r2, #4]
 8008ba2:	0a1b      	lsrs	r3, r3, #8
 8008ba4:	430b      	orrs	r3, r1
 8008ba6:	61fb      	str	r3, [r7, #28]
 8008ba8:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 8008bac:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8008bb0:	e9c2 3400 	strd	r3, r4, [r2]
        Ama = BCa ^ ((~BCe) & BCi);
 8008bb4:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008bb8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008bbc:	ea6f 0103 	mvn.w	r1, r3
 8008bc0:	ea6f 0204 	mvn.w	r2, r4
 8008bc4:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008bc8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008bcc:	ea01 0103 	and.w	r1, r1, r3
 8008bd0:	ea02 0204 	and.w	r2, r2, r4
 8008bd4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008bd8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008bdc:	ea83 0501 	eor.w	r5, r3, r1
 8008be0:	ea84 0602 	eor.w	r6, r4, r2
 8008be4:	4629      	mov	r1, r5
 8008be6:	4632      	mov	r2, r6
 8008be8:	f507 734a 	add.w	r3, r7, #808	; 0x328
 8008bec:	e9c3 1200 	strd	r1, r2, [r3]
        Ame = BCe ^ ((~BCi) & BCo);
 8008bf0:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008bf4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008bf8:	ea6f 0103 	mvn.w	r1, r3
 8008bfc:	ea6f 0204 	mvn.w	r2, r4
 8008c00:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008c04:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c08:	ea01 0103 	and.w	r1, r1, r3
 8008c0c:	ea02 0204 	and.w	r2, r2, r4
 8008c10:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008c14:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c18:	ea83 0501 	eor.w	r5, r3, r1
 8008c1c:	ea84 0602 	eor.w	r6, r4, r2
 8008c20:	4629      	mov	r1, r5
 8008c22:	4632      	mov	r2, r6
 8008c24:	f507 7348 	add.w	r3, r7, #800	; 0x320
 8008c28:	e9c3 1200 	strd	r1, r2, [r3]
        Ami = BCi ^ ((~BCo) & BCu);
 8008c2c:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008c30:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c34:	ea6f 0103 	mvn.w	r1, r3
 8008c38:	ea6f 0204 	mvn.w	r2, r4
 8008c3c:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008c40:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c44:	ea01 0103 	and.w	r1, r1, r3
 8008c48:	ea02 0204 	and.w	r2, r2, r4
 8008c4c:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008c50:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c54:	ea83 0501 	eor.w	r5, r3, r1
 8008c58:	ea84 0602 	eor.w	r6, r4, r2
 8008c5c:	4629      	mov	r1, r5
 8008c5e:	4632      	mov	r2, r6
 8008c60:	f507 7346 	add.w	r3, r7, #792	; 0x318
 8008c64:	e9c3 1200 	strd	r1, r2, [r3]
        Amo = BCo ^ ((~BCu) & BCa);
 8008c68:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008c6c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c70:	ea6f 0103 	mvn.w	r1, r3
 8008c74:	ea6f 0204 	mvn.w	r2, r4
 8008c78:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008c7c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c80:	ea01 0103 	and.w	r1, r1, r3
 8008c84:	ea02 0204 	and.w	r2, r2, r4
 8008c88:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008c8c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008c90:	ea83 0501 	eor.w	r5, r3, r1
 8008c94:	ea84 0602 	eor.w	r6, r4, r2
 8008c98:	4629      	mov	r1, r5
 8008c9a:	4632      	mov	r2, r6
 8008c9c:	f507 7344 	add.w	r3, r7, #784	; 0x310
 8008ca0:	e9c3 1200 	strd	r1, r2, [r3]
        Amu = BCu ^ ((~BCa) & BCe);
 8008ca4:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008ca8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008cac:	ea6f 0103 	mvn.w	r1, r3
 8008cb0:	ea6f 0204 	mvn.w	r2, r4
 8008cb4:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008cb8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008cbc:	ea01 0103 	and.w	r1, r1, r3
 8008cc0:	ea02 0204 	and.w	r2, r2, r4
 8008cc4:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008cc8:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ccc:	ea83 0501 	eor.w	r5, r3, r1
 8008cd0:	ea84 0602 	eor.w	r6, r4, r2
 8008cd4:	4629      	mov	r1, r5
 8008cd6:	4632      	mov	r2, r6
 8008cd8:	f507 7342 	add.w	r3, r7, #776	; 0x308
 8008cdc:	e9c3 1200 	strd	r1, r2, [r3]

        Ebi ^= Di;
 8008ce0:	f507 701e 	add.w	r0, r7, #632	; 0x278
 8008ce4:	f507 721e 	add.w	r2, r7, #632	; 0x278
 8008ce8:	f507 7328 	add.w	r3, r7, #672	; 0x2a0
 8008cec:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008cf0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008cf4:	ea83 0501 	eor.w	r5, r3, r1
 8008cf8:	ea84 0602 	eor.w	r6, r4, r2
 8008cfc:	462b      	mov	r3, r5
 8008cfe:	4634      	mov	r4, r6
 8008d00:	e9c0 3400 	strd	r3, r4, [r0]
        BCa = ROL(Ebi, 62);
 8008d04:	f507 721e 	add.w	r2, r7, #632	; 0x278
 8008d08:	6853      	ldr	r3, [r2, #4]
 8008d0a:	0799      	lsls	r1, r3, #30
 8008d0c:	6813      	ldr	r3, [r2, #0]
 8008d0e:	089b      	lsrs	r3, r3, #2
 8008d10:	430b      	orrs	r3, r1
 8008d12:	613b      	str	r3, [r7, #16]
 8008d14:	6813      	ldr	r3, [r2, #0]
 8008d16:	0799      	lsls	r1, r3, #30
 8008d18:	6853      	ldr	r3, [r2, #4]
 8008d1a:	089b      	lsrs	r3, r3, #2
 8008d1c:	430b      	orrs	r3, r1
 8008d1e:	617b      	str	r3, [r7, #20]
 8008d20:	f507 7236 	add.w	r2, r7, #728	; 0x2d8
 8008d24:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 8008d28:	e9c2 3400 	strd	r3, r4, [r2]
        Ego ^= Do;
 8008d2c:	f507 7012 	add.w	r0, r7, #584	; 0x248
 8008d30:	f507 7212 	add.w	r2, r7, #584	; 0x248
 8008d34:	f507 7326 	add.w	r3, r7, #664	; 0x298
 8008d38:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008d3c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008d40:	ea83 0501 	eor.w	r5, r3, r1
 8008d44:	ea84 0602 	eor.w	r6, r4, r2
 8008d48:	462b      	mov	r3, r5
 8008d4a:	4634      	mov	r4, r6
 8008d4c:	e9c0 3400 	strd	r3, r4, [r0]
        BCe = ROL(Ego, 55);
 8008d50:	f507 7212 	add.w	r2, r7, #584	; 0x248
 8008d54:	6853      	ldr	r3, [r2, #4]
 8008d56:	05d9      	lsls	r1, r3, #23
 8008d58:	6813      	ldr	r3, [r2, #0]
 8008d5a:	0a5b      	lsrs	r3, r3, #9
 8008d5c:	430b      	orrs	r3, r1
 8008d5e:	60bb      	str	r3, [r7, #8]
 8008d60:	6813      	ldr	r3, [r2, #0]
 8008d62:	05d9      	lsls	r1, r3, #23
 8008d64:	6853      	ldr	r3, [r2, #4]
 8008d66:	0a5b      	lsrs	r3, r3, #9
 8008d68:	430b      	orrs	r3, r1
 8008d6a:	60fb      	str	r3, [r7, #12]
 8008d6c:	f507 7234 	add.w	r2, r7, #720	; 0x2d0
 8008d70:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 8008d74:	e9c2 3400 	strd	r3, r4, [r2]
        Eku ^= Du;
 8008d78:	f507 7006 	add.w	r0, r7, #536	; 0x218
 8008d7c:	f507 7206 	add.w	r2, r7, #536	; 0x218
 8008d80:	f507 7324 	add.w	r3, r7, #656	; 0x290
 8008d84:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008d88:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008d8c:	ea83 0501 	eor.w	r5, r3, r1
 8008d90:	ea84 0602 	eor.w	r6, r4, r2
 8008d94:	462b      	mov	r3, r5
 8008d96:	4634      	mov	r4, r6
 8008d98:	e9c0 3400 	strd	r3, r4, [r0]
        BCi = ROL(Eku, 39);
 8008d9c:	f507 7206 	add.w	r2, r7, #536	; 0x218
 8008da0:	6853      	ldr	r3, [r2, #4]
 8008da2:	01d9      	lsls	r1, r3, #7
 8008da4:	6813      	ldr	r3, [r2, #0]
 8008da6:	0e5b      	lsrs	r3, r3, #25
 8008da8:	ea41 0a03 	orr.w	sl, r1, r3
 8008dac:	6813      	ldr	r3, [r2, #0]
 8008dae:	01d9      	lsls	r1, r3, #7
 8008db0:	6853      	ldr	r3, [r2, #4]
 8008db2:	0e5b      	lsrs	r3, r3, #25
 8008db4:	ea41 0b03 	orr.w	fp, r1, r3
 8008db8:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008dbc:	e9c3 ab00 	strd	sl, fp, [r3]
        Ema ^= Da;
 8008dc0:	f507 7004 	add.w	r0, r7, #528	; 0x210
 8008dc4:	f507 7204 	add.w	r2, r7, #528	; 0x210
 8008dc8:	f507 732c 	add.w	r3, r7, #688	; 0x2b0
 8008dcc:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008dd0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008dd4:	ea83 0501 	eor.w	r5, r3, r1
 8008dd8:	ea84 0602 	eor.w	r6, r4, r2
 8008ddc:	462b      	mov	r3, r5
 8008dde:	4634      	mov	r4, r6
 8008de0:	e9c0 3400 	strd	r3, r4, [r0]
        BCo = ROL(Ema, 41);
 8008de4:	f507 7204 	add.w	r2, r7, #528	; 0x210
 8008de8:	6853      	ldr	r3, [r2, #4]
 8008dea:	0259      	lsls	r1, r3, #9
 8008dec:	6813      	ldr	r3, [r2, #0]
 8008dee:	0ddb      	lsrs	r3, r3, #23
 8008df0:	ea41 0803 	orr.w	r8, r1, r3
 8008df4:	6813      	ldr	r3, [r2, #0]
 8008df6:	0259      	lsls	r1, r3, #9
 8008df8:	6853      	ldr	r3, [r2, #4]
 8008dfa:	0ddb      	lsrs	r3, r3, #23
 8008dfc:	ea41 0903 	orr.w	r9, r1, r3
 8008e00:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008e04:	e9c3 8900 	strd	r8, r9, [r3]
        Ese ^= De;
 8008e08:	f507 70f0 	add.w	r0, r7, #480	; 0x1e0
 8008e0c:	f507 72f0 	add.w	r2, r7, #480	; 0x1e0
 8008e10:	f507 732a 	add.w	r3, r7, #680	; 0x2a8
 8008e14:	e9d2 1200 	ldrd	r1, r2, [r2]
 8008e18:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008e1c:	ea83 0501 	eor.w	r5, r3, r1
 8008e20:	ea84 0602 	eor.w	r6, r4, r2
 8008e24:	462b      	mov	r3, r5
 8008e26:	4634      	mov	r4, r6
 8008e28:	e9c0 3400 	strd	r3, r4, [r0]
        BCu = ROL(Ese, 2);
 8008e2c:	f507 72f0 	add.w	r2, r7, #480	; 0x1e0
 8008e30:	6813      	ldr	r3, [r2, #0]
 8008e32:	0f99      	lsrs	r1, r3, #30
 8008e34:	6853      	ldr	r3, [r2, #4]
 8008e36:	009b      	lsls	r3, r3, #2
 8008e38:	430b      	orrs	r3, r1
 8008e3a:	607b      	str	r3, [r7, #4]
 8008e3c:	6853      	ldr	r3, [r2, #4]
 8008e3e:	0f99      	lsrs	r1, r3, #30
 8008e40:	6813      	ldr	r3, [r2, #0]
 8008e42:	009b      	lsls	r3, r3, #2
 8008e44:	430b      	orrs	r3, r1
 8008e46:	603b      	str	r3, [r7, #0]
 8008e48:	e9d7 3400 	ldrd	r3, r4, [r7]
 8008e4c:	f507 722e 	add.w	r2, r7, #696	; 0x2b8
 8008e50:	e9c2 3400 	strd	r3, r4, [r2]
        Asa = BCa ^ ((~BCe) & BCi);
 8008e54:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008e58:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008e5c:	ea6f 0103 	mvn.w	r1, r3
 8008e60:	ea6f 0204 	mvn.w	r2, r4
 8008e64:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008e68:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008e6c:	ea01 0103 	and.w	r1, r1, r3
 8008e70:	ea02 0204 	and.w	r2, r2, r4
 8008e74:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008e78:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008e7c:	ea83 0501 	eor.w	r5, r3, r1
 8008e80:	ea84 0602 	eor.w	r6, r4, r2
 8008e84:	4629      	mov	r1, r5
 8008e86:	4632      	mov	r2, r6
 8008e88:	f507 7340 	add.w	r3, r7, #768	; 0x300
 8008e8c:	e9c3 1200 	strd	r1, r2, [r3]
        Ase = BCe ^ ((~BCi) & BCo);
 8008e90:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008e94:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008e98:	ea6f 0103 	mvn.w	r1, r3
 8008e9c:	ea6f 0204 	mvn.w	r2, r4
 8008ea0:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008ea4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ea8:	ea01 0103 	and.w	r1, r1, r3
 8008eac:	ea02 0204 	and.w	r2, r2, r4
 8008eb0:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008eb4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008eb8:	ea83 0501 	eor.w	r5, r3, r1
 8008ebc:	ea84 0602 	eor.w	r6, r4, r2
 8008ec0:	4629      	mov	r1, r5
 8008ec2:	4632      	mov	r2, r6
 8008ec4:	f507 733e 	add.w	r3, r7, #760	; 0x2f8
 8008ec8:	e9c3 1200 	strd	r1, r2, [r3]
        Asi = BCi ^ ((~BCo) & BCu);
 8008ecc:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008ed0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ed4:	ea6f 0103 	mvn.w	r1, r3
 8008ed8:	ea6f 0204 	mvn.w	r2, r4
 8008edc:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008ee0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ee4:	ea01 0103 	and.w	r1, r1, r3
 8008ee8:	ea02 0204 	and.w	r2, r2, r4
 8008eec:	f507 7332 	add.w	r3, r7, #712	; 0x2c8
 8008ef0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ef4:	ea83 0501 	eor.w	r5, r3, r1
 8008ef8:	ea84 0602 	eor.w	r6, r4, r2
 8008efc:	4629      	mov	r1, r5
 8008efe:	4632      	mov	r2, r6
 8008f00:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
 8008f04:	e9c3 1200 	strd	r1, r2, [r3]
        Aso = BCo ^ ((~BCu) & BCa);
 8008f08:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008f0c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f10:	ea6f 0103 	mvn.w	r1, r3
 8008f14:	ea6f 0204 	mvn.w	r2, r4
 8008f18:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008f1c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f20:	ea01 0103 	and.w	r1, r1, r3
 8008f24:	ea02 0204 	and.w	r2, r2, r4
 8008f28:	f507 7330 	add.w	r3, r7, #704	; 0x2c0
 8008f2c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f30:	ea83 0501 	eor.w	r5, r3, r1
 8008f34:	ea84 0602 	eor.w	r6, r4, r2
 8008f38:	4629      	mov	r1, r5
 8008f3a:	4632      	mov	r2, r6
 8008f3c:	f507 733a 	add.w	r3, r7, #744	; 0x2e8
 8008f40:	e9c3 1200 	strd	r1, r2, [r3]
        Asu = BCu ^ ((~BCa) & BCe);
 8008f44:	f507 7336 	add.w	r3, r7, #728	; 0x2d8
 8008f48:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f4c:	ea6f 0103 	mvn.w	r1, r3
 8008f50:	ea6f 0204 	mvn.w	r2, r4
 8008f54:	f507 7334 	add.w	r3, r7, #720	; 0x2d0
 8008f58:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f5c:	ea01 0103 	and.w	r1, r1, r3
 8008f60:	ea02 0204 	and.w	r2, r2, r4
 8008f64:	f507 732e 	add.w	r3, r7, #696	; 0x2b8
 8008f68:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008f6c:	ea83 0501 	eor.w	r5, r3, r1
 8008f70:	ea84 0602 	eor.w	r6, r4, r2
 8008f74:	4629      	mov	r1, r5
 8008f76:	4632      	mov	r2, r6
 8008f78:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
 8008f7c:	e9c3 1200 	strd	r1, r2, [r3]
    for (round = 0; round < NROUNDS; round += 2) {
 8008f80:	f8d7 33ac 	ldr.w	r3, [r7, #940]	; 0x3ac
 8008f84:	3302      	adds	r3, #2
 8008f86:	f8c7 33ac 	str.w	r3, [r7, #940]	; 0x3ac
 8008f8a:	f8d7 33ac 	ldr.w	r3, [r7, #940]	; 0x3ac
 8008f8e:	2b17      	cmp	r3, #23
 8008f90:	f77d aef0 	ble.w	8006d74 <KeccakF1600_StatePermute+0x1dc>
    }

    // copyToState(state, A)
    state[0] = Aba;
 8008f94:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8008f98:	681a      	ldr	r2, [r3, #0]
 8008f9a:	f507 7368 	add.w	r3, r7, #928	; 0x3a0
 8008f9e:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008fa2:	e9c2 3400 	strd	r3, r4, [r2]
    state[1] = Abe;
 8008fa6:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8008faa:	681b      	ldr	r3, [r3, #0]
 8008fac:	f103 0208 	add.w	r2, r3, #8
 8008fb0:	f507 7366 	add.w	r3, r7, #920	; 0x398
 8008fb4:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008fb8:	e9c2 3400 	strd	r3, r4, [r2]
    state[2] = Abi;
 8008fbc:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8008fc0:	681b      	ldr	r3, [r3, #0]
 8008fc2:	f103 0210 	add.w	r2, r3, #16
 8008fc6:	f507 7364 	add.w	r3, r7, #912	; 0x390
 8008fca:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008fce:	e9c2 3400 	strd	r3, r4, [r2]
    state[3] = Abo;
 8008fd2:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8008fd6:	681b      	ldr	r3, [r3, #0]
 8008fd8:	f103 0218 	add.w	r2, r3, #24
 8008fdc:	f507 7362 	add.w	r3, r7, #904	; 0x388
 8008fe0:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008fe4:	e9c2 3400 	strd	r3, r4, [r2]
    state[4] = Abu;
 8008fe8:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8008fec:	681b      	ldr	r3, [r3, #0]
 8008fee:	f103 0220 	add.w	r2, r3, #32
 8008ff2:	f507 7360 	add.w	r3, r7, #896	; 0x380
 8008ff6:	e9d3 3400 	ldrd	r3, r4, [r3]
 8008ffa:	e9c2 3400 	strd	r3, r4, [r2]
    state[5] = Aga;
 8008ffe:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009002:	681b      	ldr	r3, [r3, #0]
 8009004:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8009008:	f507 735e 	add.w	r3, r7, #888	; 0x378
 800900c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009010:	e9c2 3400 	strd	r3, r4, [r2]
    state[6] = Age;
 8009014:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009018:	681b      	ldr	r3, [r3, #0]
 800901a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800901e:	f507 735c 	add.w	r3, r7, #880	; 0x370
 8009022:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009026:	e9c2 3400 	strd	r3, r4, [r2]
    state[7] = Agi;
 800902a:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800902e:	681b      	ldr	r3, [r3, #0]
 8009030:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8009034:	f507 735a 	add.w	r3, r7, #872	; 0x368
 8009038:	e9d3 3400 	ldrd	r3, r4, [r3]
 800903c:	e9c2 3400 	strd	r3, r4, [r2]
    state[8] = Ago;
 8009040:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009044:	681b      	ldr	r3, [r3, #0]
 8009046:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800904a:	f507 7358 	add.w	r3, r7, #864	; 0x360
 800904e:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009052:	e9c2 3400 	strd	r3, r4, [r2]
    state[9] = Agu;
 8009056:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800905a:	681b      	ldr	r3, [r3, #0]
 800905c:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8009060:	f507 7356 	add.w	r3, r7, #856	; 0x358
 8009064:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009068:	e9c2 3400 	strd	r3, r4, [r2]
    state[10] = Aka;
 800906c:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009070:	681b      	ldr	r3, [r3, #0]
 8009072:	f103 0250 	add.w	r2, r3, #80	; 0x50
 8009076:	f507 7354 	add.w	r3, r7, #848	; 0x350
 800907a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800907e:	e9c2 3400 	strd	r3, r4, [r2]
    state[11] = Ake;
 8009082:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009086:	681b      	ldr	r3, [r3, #0]
 8009088:	f103 0258 	add.w	r2, r3, #88	; 0x58
 800908c:	f507 7352 	add.w	r3, r7, #840	; 0x348
 8009090:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009094:	e9c2 3400 	strd	r3, r4, [r2]
    state[12] = Aki;
 8009098:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800909c:	681b      	ldr	r3, [r3, #0]
 800909e:	f103 0260 	add.w	r2, r3, #96	; 0x60
 80090a2:	f507 7350 	add.w	r3, r7, #832	; 0x340
 80090a6:	e9d3 3400 	ldrd	r3, r4, [r3]
 80090aa:	e9c2 3400 	strd	r3, r4, [r2]
    state[13] = Ako;
 80090ae:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 80090b2:	681b      	ldr	r3, [r3, #0]
 80090b4:	f103 0268 	add.w	r2, r3, #104	; 0x68
 80090b8:	f507 734e 	add.w	r3, r7, #824	; 0x338
 80090bc:	e9d3 3400 	ldrd	r3, r4, [r3]
 80090c0:	e9c2 3400 	strd	r3, r4, [r2]
    state[14] = Aku;
 80090c4:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 80090c8:	681b      	ldr	r3, [r3, #0]
 80090ca:	f103 0270 	add.w	r2, r3, #112	; 0x70
 80090ce:	f507 734c 	add.w	r3, r7, #816	; 0x330
 80090d2:	e9d3 3400 	ldrd	r3, r4, [r3]
 80090d6:	e9c2 3400 	strd	r3, r4, [r2]
    state[15] = Ama;
 80090da:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 80090de:	681b      	ldr	r3, [r3, #0]
 80090e0:	f103 0278 	add.w	r2, r3, #120	; 0x78
 80090e4:	f507 734a 	add.w	r3, r7, #808	; 0x328
 80090e8:	e9d3 3400 	ldrd	r3, r4, [r3]
 80090ec:	e9c2 3400 	strd	r3, r4, [r2]
    state[16] = Ame;
 80090f0:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 80090f4:	681b      	ldr	r3, [r3, #0]
 80090f6:	f103 0280 	add.w	r2, r3, #128	; 0x80
 80090fa:	f507 7348 	add.w	r3, r7, #800	; 0x320
 80090fe:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009102:	e9c2 3400 	strd	r3, r4, [r2]
    state[17] = Ami;
 8009106:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800910a:	681b      	ldr	r3, [r3, #0]
 800910c:	f103 0288 	add.w	r2, r3, #136	; 0x88
 8009110:	f507 7346 	add.w	r3, r7, #792	; 0x318
 8009114:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009118:	e9c2 3400 	strd	r3, r4, [r2]
    state[18] = Amo;
 800911c:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009120:	681b      	ldr	r3, [r3, #0]
 8009122:	f103 0290 	add.w	r2, r3, #144	; 0x90
 8009126:	f507 7344 	add.w	r3, r7, #784	; 0x310
 800912a:	e9d3 3400 	ldrd	r3, r4, [r3]
 800912e:	e9c2 3400 	strd	r3, r4, [r2]
    state[19] = Amu;
 8009132:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009136:	681b      	ldr	r3, [r3, #0]
 8009138:	f103 0298 	add.w	r2, r3, #152	; 0x98
 800913c:	f507 7342 	add.w	r3, r7, #776	; 0x308
 8009140:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009144:	e9c2 3400 	strd	r3, r4, [r2]
    state[20] = Asa;
 8009148:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800914c:	681b      	ldr	r3, [r3, #0]
 800914e:	f103 02a0 	add.w	r2, r3, #160	; 0xa0
 8009152:	f507 7340 	add.w	r3, r7, #768	; 0x300
 8009156:	e9d3 3400 	ldrd	r3, r4, [r3]
 800915a:	e9c2 3400 	strd	r3, r4, [r2]
    state[21] = Ase;
 800915e:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009162:	681b      	ldr	r3, [r3, #0]
 8009164:	f103 02a8 	add.w	r2, r3, #168	; 0xa8
 8009168:	f507 733e 	add.w	r3, r7, #760	; 0x2f8
 800916c:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009170:	e9c2 3400 	strd	r3, r4, [r2]
    state[22] = Asi;
 8009174:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 8009178:	681b      	ldr	r3, [r3, #0]
 800917a:	f103 02b0 	add.w	r2, r3, #176	; 0xb0
 800917e:	f507 733c 	add.w	r3, r7, #752	; 0x2f0
 8009182:	e9d3 3400 	ldrd	r3, r4, [r3]
 8009186:	e9c2 3400 	strd	r3, r4, [r2]
    state[23] = Aso;
 800918a:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 800918e:	681b      	ldr	r3, [r3, #0]
 8009190:	f103 02b8 	add.w	r2, r3, #184	; 0xb8
 8009194:	f507 733a 	add.w	r3, r7, #744	; 0x2e8
 8009198:	e9d3 3400 	ldrd	r3, r4, [r3]
 800919c:	e9c2 3400 	strd	r3, r4, [r2]
    state[24] = Asu;
 80091a0:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
 80091a4:	681b      	ldr	r3, [r3, #0]
 80091a6:	f103 02c0 	add.w	r2, r3, #192	; 0xc0
 80091aa:	f507 7338 	add.w	r3, r7, #736	; 0x2e0
 80091ae:	e9d3 3400 	ldrd	r3, r4, [r3]
 80091b2:	e9c2 3400 	strd	r3, r4, [r2]
}
 80091b6:	bf00      	nop
 80091b8:	f507 776c 	add.w	r7, r7, #944	; 0x3b0
 80091bc:	46bd      	mov	sp, r7
 80091be:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80091c2:	4770      	bx	lr

080091c4 <keccak_absorb>:
 *              - size_t mlen: length of input in bytes
 *              - uint8_t p: domain-separation byte for different
 *                                 Keccak-derived functions
 **************************************************/
static void keccak_absorb(uint64_t *s, uint32_t r, const uint8_t *m,
                          size_t mlen, uint8_t p) {
 80091c4:	e92d 48b0 	stmdb	sp!, {r4, r5, r7, fp, lr}
 80091c8:	b0b9      	sub	sp, #228	; 0xe4
 80091ca:	af00      	add	r7, sp, #0
 80091cc:	60f8      	str	r0, [r7, #12]
 80091ce:	60b9      	str	r1, [r7, #8]
 80091d0:	607a      	str	r2, [r7, #4]
 80091d2:	603b      	str	r3, [r7, #0]
    size_t i;
    uint8_t t[200];

    /* Zero state */
    for (i = 0; i < 25; ++i) {
 80091d4:	2300      	movs	r3, #0
 80091d6:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80091da:	e00f      	b.n	80091fc <keccak_absorb+0x38>
        s[i] = 0;
 80091dc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80091e0:	00db      	lsls	r3, r3, #3
 80091e2:	68fa      	ldr	r2, [r7, #12]
 80091e4:	441a      	add	r2, r3
 80091e6:	f04f 0300 	mov.w	r3, #0
 80091ea:	f04f 0400 	mov.w	r4, #0
 80091ee:	e9c2 3400 	strd	r3, r4, [r2]
    for (i = 0; i < 25; ++i) {
 80091f2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80091f6:	3301      	adds	r3, #1
 80091f8:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80091fc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009200:	2b18      	cmp	r3, #24
 8009202:	d9eb      	bls.n	80091dc <keccak_absorb+0x18>
    }

    while (mlen >= r) {
 8009204:	e035      	b.n	8009272 <keccak_absorb+0xae>
        for (i = 0; i < r / 8; ++i) {
 8009206:	2300      	movs	r3, #0
 8009208:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800920c:	e020      	b.n	8009250 <keccak_absorb+0x8c>
            s[i] ^= load64(m + 8 * i);
 800920e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009212:	00db      	lsls	r3, r3, #3
 8009214:	687a      	ldr	r2, [r7, #4]
 8009216:	4413      	add	r3, r2
 8009218:	4618      	mov	r0, r3
 800921a:	f7fd fc57 	bl	8006acc <load64>
 800921e:	460a      	mov	r2, r1
 8009220:	4601      	mov	r1, r0
 8009222:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009226:	00db      	lsls	r3, r3, #3
 8009228:	68f8      	ldr	r0, [r7, #12]
 800922a:	4403      	add	r3, r0
 800922c:	e9d3 bc00 	ldrd	fp, ip, [r3]
 8009230:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 8009234:	00c0      	lsls	r0, r0, #3
 8009236:	68fd      	ldr	r5, [r7, #12]
 8009238:	4428      	add	r0, r5
 800923a:	ea8b 0301 	eor.w	r3, fp, r1
 800923e:	ea8c 0402 	eor.w	r4, ip, r2
 8009242:	e9c0 3400 	strd	r3, r4, [r0]
        for (i = 0; i < r / 8; ++i) {
 8009246:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800924a:	3301      	adds	r3, #1
 800924c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8009250:	68bb      	ldr	r3, [r7, #8]
 8009252:	08db      	lsrs	r3, r3, #3
 8009254:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8009258:	429a      	cmp	r2, r3
 800925a:	d3d8      	bcc.n	800920e <keccak_absorb+0x4a>
        }

        KeccakF1600_StatePermute(s);
 800925c:	68f8      	ldr	r0, [r7, #12]
 800925e:	f7fd fc9b 	bl	8006b98 <KeccakF1600_StatePermute>
        mlen -= r;
 8009262:	683a      	ldr	r2, [r7, #0]
 8009264:	68bb      	ldr	r3, [r7, #8]
 8009266:	1ad3      	subs	r3, r2, r3
 8009268:	603b      	str	r3, [r7, #0]
        m += r;
 800926a:	687a      	ldr	r2, [r7, #4]
 800926c:	68bb      	ldr	r3, [r7, #8]
 800926e:	4413      	add	r3, r2
 8009270:	607b      	str	r3, [r7, #4]
    while (mlen >= r) {
 8009272:	683a      	ldr	r2, [r7, #0]
 8009274:	68bb      	ldr	r3, [r7, #8]
 8009276:	429a      	cmp	r2, r3
 8009278:	d2c5      	bcs.n	8009206 <keccak_absorb+0x42>
    }

    for (i = 0; i < r; ++i) {
 800927a:	2300      	movs	r3, #0
 800927c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8009280:	e00b      	b.n	800929a <keccak_absorb+0xd6>
        t[i] = 0;
 8009282:	f107 0214 	add.w	r2, r7, #20
 8009286:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800928a:	4413      	add	r3, r2
 800928c:	2200      	movs	r2, #0
 800928e:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < r; ++i) {
 8009290:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009294:	3301      	adds	r3, #1
 8009296:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 800929a:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 800929e:	68bb      	ldr	r3, [r7, #8]
 80092a0:	429a      	cmp	r2, r3
 80092a2:	d3ee      	bcc.n	8009282 <keccak_absorb+0xbe>
    }
    for (i = 0; i < mlen; ++i) {
 80092a4:	2300      	movs	r3, #0
 80092a6:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80092aa:	e010      	b.n	80092ce <keccak_absorb+0x10a>
        t[i] = m[i];
 80092ac:	687a      	ldr	r2, [r7, #4]
 80092ae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80092b2:	4413      	add	r3, r2
 80092b4:	7819      	ldrb	r1, [r3, #0]
 80092b6:	f107 0214 	add.w	r2, r7, #20
 80092ba:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80092be:	4413      	add	r3, r2
 80092c0:	460a      	mov	r2, r1
 80092c2:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < mlen; ++i) {
 80092c4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80092c8:	3301      	adds	r3, #1
 80092ca:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 80092ce:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80092d2:	683b      	ldr	r3, [r7, #0]
 80092d4:	429a      	cmp	r2, r3
 80092d6:	d3e9      	bcc.n	80092ac <keccak_absorb+0xe8>
    }
    t[i] = p;
 80092d8:	f107 0214 	add.w	r2, r7, #20
 80092dc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80092e0:	4413      	add	r3, r2
 80092e2:	f897 20f8 	ldrb.w	r2, [r7, #248]	; 0xf8
 80092e6:	701a      	strb	r2, [r3, #0]
    t[r - 1] |= 128;
 80092e8:	68bb      	ldr	r3, [r7, #8]
 80092ea:	3b01      	subs	r3, #1
 80092ec:	f107 02e0 	add.w	r2, r7, #224	; 0xe0
 80092f0:	4413      	add	r3, r2
 80092f2:	f813 2ccc 	ldrb.w	r2, [r3, #-204]
 80092f6:	68bb      	ldr	r3, [r7, #8]
 80092f8:	3b01      	subs	r3, #1
 80092fa:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80092fe:	b2d2      	uxtb	r2, r2
 8009300:	f107 01e0 	add.w	r1, r7, #224	; 0xe0
 8009304:	440b      	add	r3, r1
 8009306:	f803 2ccc 	strb.w	r2, [r3, #-204]
    for (i = 0; i < r / 8; ++i) {
 800930a:	2300      	movs	r3, #0
 800930c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8009310:	e021      	b.n	8009356 <keccak_absorb+0x192>
        s[i] ^= load64(t + 8 * i);
 8009312:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009316:	00db      	lsls	r3, r3, #3
 8009318:	f107 0214 	add.w	r2, r7, #20
 800931c:	4413      	add	r3, r2
 800931e:	4618      	mov	r0, r3
 8009320:	f7fd fbd4 	bl	8006acc <load64>
 8009324:	460a      	mov	r2, r1
 8009326:	4601      	mov	r1, r0
 8009328:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800932c:	00db      	lsls	r3, r3, #3
 800932e:	68f8      	ldr	r0, [r7, #12]
 8009330:	4403      	add	r3, r0
 8009332:	e9d3 bc00 	ldrd	fp, ip, [r3]
 8009336:	f8d7 00dc 	ldr.w	r0, [r7, #220]	; 0xdc
 800933a:	00c0      	lsls	r0, r0, #3
 800933c:	68fd      	ldr	r5, [r7, #12]
 800933e:	4428      	add	r0, r5
 8009340:	ea8b 0301 	eor.w	r3, fp, r1
 8009344:	ea8c 0402 	eor.w	r4, ip, r2
 8009348:	e9c0 3400 	strd	r3, r4, [r0]
    for (i = 0; i < r / 8; ++i) {
 800934c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8009350:	3301      	adds	r3, #1
 8009352:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8009356:	68bb      	ldr	r3, [r7, #8]
 8009358:	08db      	lsrs	r3, r3, #3
 800935a:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 800935e:	429a      	cmp	r2, r3
 8009360:	d3d7      	bcc.n	8009312 <keccak_absorb+0x14e>
    }
}
 8009362:	bf00      	nop
 8009364:	37e4      	adds	r7, #228	; 0xe4
 8009366:	46bd      	mov	sp, r7
 8009368:	e8bd 88b0 	ldmia.w	sp!, {r4, r5, r7, fp, pc}

0800936c <keccak_squeezeblocks>:
 *                                                squeezed (written to h)
 *              - uint64_t *s: pointer to input/output Keccak state
 *              - uint32_t r: rate in bytes (e.g., 168 for SHAKE128)
 **************************************************/
static void keccak_squeezeblocks(uint8_t *h, size_t nblocks,
                                 uint64_t *s, uint32_t r) {
 800936c:	b590      	push	{r4, r7, lr}
 800936e:	b087      	sub	sp, #28
 8009370:	af00      	add	r7, sp, #0
 8009372:	60f8      	str	r0, [r7, #12]
 8009374:	60b9      	str	r1, [r7, #8]
 8009376:	607a      	str	r2, [r7, #4]
 8009378:	603b      	str	r3, [r7, #0]
    while (nblocks > 0) {
 800937a:	e023      	b.n	80093c4 <keccak_squeezeblocks+0x58>
        KeccakF1600_StatePermute(s);
 800937c:	6878      	ldr	r0, [r7, #4]
 800937e:	f7fd fc0b 	bl	8006b98 <KeccakF1600_StatePermute>
        for (size_t i = 0; i < (r >> 3); i++) {
 8009382:	2300      	movs	r3, #0
 8009384:	617b      	str	r3, [r7, #20]
 8009386:	e011      	b.n	80093ac <keccak_squeezeblocks+0x40>
            store64(h + 8 * i, s[i]);
 8009388:	697b      	ldr	r3, [r7, #20]
 800938a:	00db      	lsls	r3, r3, #3
 800938c:	68fa      	ldr	r2, [r7, #12]
 800938e:	18d1      	adds	r1, r2, r3
 8009390:	697b      	ldr	r3, [r7, #20]
 8009392:	00db      	lsls	r3, r3, #3
 8009394:	687a      	ldr	r2, [r7, #4]
 8009396:	4413      	add	r3, r2
 8009398:	e9d3 3400 	ldrd	r3, r4, [r3]
 800939c:	461a      	mov	r2, r3
 800939e:	4623      	mov	r3, r4
 80093a0:	4608      	mov	r0, r1
 80093a2:	f7fd fbcd 	bl	8006b40 <store64>
        for (size_t i = 0; i < (r >> 3); i++) {
 80093a6:	697b      	ldr	r3, [r7, #20]
 80093a8:	3301      	adds	r3, #1
 80093aa:	617b      	str	r3, [r7, #20]
 80093ac:	683b      	ldr	r3, [r7, #0]
 80093ae:	08db      	lsrs	r3, r3, #3
 80093b0:	697a      	ldr	r2, [r7, #20]
 80093b2:	429a      	cmp	r2, r3
 80093b4:	d3e8      	bcc.n	8009388 <keccak_squeezeblocks+0x1c>
        }
        h += r;
 80093b6:	68fa      	ldr	r2, [r7, #12]
 80093b8:	683b      	ldr	r3, [r7, #0]
 80093ba:	4413      	add	r3, r2
 80093bc:	60fb      	str	r3, [r7, #12]
        nblocks--;
 80093be:	68bb      	ldr	r3, [r7, #8]
 80093c0:	3b01      	subs	r3, #1
 80093c2:	60bb      	str	r3, [r7, #8]
    while (nblocks > 0) {
 80093c4:	68bb      	ldr	r3, [r7, #8]
 80093c6:	2b00      	cmp	r3, #0
 80093c8:	d1d8      	bne.n	800937c <keccak_squeezeblocks+0x10>
    }
}
 80093ca:	bf00      	nop
 80093cc:	371c      	adds	r7, #28
 80093ce:	46bd      	mov	sp, r7
 80093d0:	bd90      	pop	{r4, r7, pc}

080093d2 <shake128_absorb>:
 * Arguments:   - uint64_t *s: pointer to (uninitialized) output Keccak state
 *              - const uint8_t *input: pointer to input to be absorbed
 *                                            into s
 *              - size_t inlen: length of input in bytes
 **************************************************/
void shake128_absorb(shake128ctx *state, const uint8_t *input, size_t inlen) {
 80093d2:	b580      	push	{r7, lr}
 80093d4:	b086      	sub	sp, #24
 80093d6:	af02      	add	r7, sp, #8
 80093d8:	60f8      	str	r0, [r7, #12]
 80093da:	60b9      	str	r1, [r7, #8]
 80093dc:	607a      	str	r2, [r7, #4]
    state->ctx = malloc(PQC_SHAKECTX_BYTES);
 80093de:	20c8      	movs	r0, #200	; 0xc8
 80093e0:	f011 fdc2 	bl	801af68 <malloc>
 80093e4:	4603      	mov	r3, r0
 80093e6:	461a      	mov	r2, r3
 80093e8:	68fb      	ldr	r3, [r7, #12]
 80093ea:	601a      	str	r2, [r3, #0]
    if (state->ctx == NULL) {
 80093ec:	68fb      	ldr	r3, [r7, #12]
 80093ee:	681b      	ldr	r3, [r3, #0]
 80093f0:	2b00      	cmp	r3, #0
 80093f2:	d102      	bne.n	80093fa <shake128_absorb+0x28>
        exit(111);
 80093f4:	206f      	movs	r0, #111	; 0x6f
 80093f6:	f011 fd7f 	bl	801aef8 <exit>
    }
    keccak_absorb(state->ctx, SHAKE128_RATE, input, inlen, 0x1F);
 80093fa:	68fb      	ldr	r3, [r7, #12]
 80093fc:	6818      	ldr	r0, [r3, #0]
 80093fe:	231f      	movs	r3, #31
 8009400:	9300      	str	r3, [sp, #0]
 8009402:	687b      	ldr	r3, [r7, #4]
 8009404:	68ba      	ldr	r2, [r7, #8]
 8009406:	21a8      	movs	r1, #168	; 0xa8
 8009408:	f7ff fedc 	bl	80091c4 <keccak_absorb>
}
 800940c:	bf00      	nop
 800940e:	3710      	adds	r7, #16
 8009410:	46bd      	mov	sp, r7
 8009412:	bd80      	pop	{r7, pc}

08009414 <shake128_squeezeblocks>:
 * Arguments:   - uint8_t *output: pointer to output blocks
 *              - size_t nblocks: number of blocks to be squeezed
 *                                            (written to output)
 *              - shake128ctx *state: pointer to input/output Keccak state
 **************************************************/
void shake128_squeezeblocks(uint8_t *output, size_t nblocks, shake128ctx *state) {
 8009414:	b580      	push	{r7, lr}
 8009416:	b084      	sub	sp, #16
 8009418:	af00      	add	r7, sp, #0
 800941a:	60f8      	str	r0, [r7, #12]
 800941c:	60b9      	str	r1, [r7, #8]
 800941e:	607a      	str	r2, [r7, #4]
    keccak_squeezeblocks(output, nblocks, state->ctx, SHAKE128_RATE);
 8009420:	687b      	ldr	r3, [r7, #4]
 8009422:	681a      	ldr	r2, [r3, #0]
 8009424:	23a8      	movs	r3, #168	; 0xa8
 8009426:	68b9      	ldr	r1, [r7, #8]
 8009428:	68f8      	ldr	r0, [r7, #12]
 800942a:	f7ff ff9f 	bl	800936c <keccak_squeezeblocks>
}
 800942e:	bf00      	nop
 8009430:	3710      	adds	r7, #16
 8009432:	46bd      	mov	sp, r7
 8009434:	bd80      	pop	{r7, pc}

08009436 <shake128_ctx_release>:
    }
    memcpy(dest->ctx, src->ctx, PQC_SHAKECTX_BYTES);
}

/** Release the allocated state. Call only once. */
void shake128_ctx_release(shake128ctx *state) {
 8009436:	b580      	push	{r7, lr}
 8009438:	b082      	sub	sp, #8
 800943a:	af00      	add	r7, sp, #0
 800943c:	6078      	str	r0, [r7, #4]
    free(state->ctx);
 800943e:	687b      	ldr	r3, [r7, #4]
 8009440:	681b      	ldr	r3, [r3, #0]
 8009442:	4618      	mov	r0, r3
 8009444:	f011 fd98 	bl	801af78 <free>
}
 8009448:	bf00      	nop
 800944a:	3708      	adds	r7, #8
 800944c:	46bd      	mov	sp, r7
 800944e:	bd80      	pop	{r7, pc}

08009450 <shake128>:
 *              - size_t outlen: requested output length in bytes
 *              - const uint8_t *input: pointer to input
 *              - size_t inlen: length of input in bytes
 **************************************************/
void shake128(uint8_t *output, size_t outlen,
              const uint8_t *input, size_t inlen) {
 8009450:	b580      	push	{r7, lr}
 8009452:	b0b2      	sub	sp, #200	; 0xc8
 8009454:	af00      	add	r7, sp, #0
 8009456:	60f8      	str	r0, [r7, #12]
 8009458:	60b9      	str	r1, [r7, #8]
 800945a:	607a      	str	r2, [r7, #4]
 800945c:	603b      	str	r3, [r7, #0]
    size_t nblocks = outlen / SHAKE128_RATE;
 800945e:	68bb      	ldr	r3, [r7, #8]
 8009460:	08db      	lsrs	r3, r3, #3
 8009462:	4a29      	ldr	r2, [pc, #164]	; (8009508 <shake128+0xb8>)
 8009464:	fba2 2303 	umull	r2, r3, r2, r3
 8009468:	085b      	lsrs	r3, r3, #1
 800946a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    uint8_t t[SHAKE128_RATE];
    shake128ctx s;

    shake128_absorb(&s, input, inlen);
 800946e:	f107 0314 	add.w	r3, r7, #20
 8009472:	683a      	ldr	r2, [r7, #0]
 8009474:	6879      	ldr	r1, [r7, #4]
 8009476:	4618      	mov	r0, r3
 8009478:	f7ff ffab 	bl	80093d2 <shake128_absorb>
    shake128_squeezeblocks(output, nblocks, &s);
 800947c:	f107 0314 	add.w	r3, r7, #20
 8009480:	461a      	mov	r2, r3
 8009482:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8009486:	68f8      	ldr	r0, [r7, #12]
 8009488:	f7ff ffc4 	bl	8009414 <shake128_squeezeblocks>

    output += nblocks * SHAKE128_RATE;
 800948c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8009490:	22a8      	movs	r2, #168	; 0xa8
 8009492:	fb02 f303 	mul.w	r3, r2, r3
 8009496:	68fa      	ldr	r2, [r7, #12]
 8009498:	4413      	add	r3, r2
 800949a:	60fb      	str	r3, [r7, #12]
    outlen -= nblocks * SHAKE128_RATE;
 800949c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80094a0:	22a8      	movs	r2, #168	; 0xa8
 80094a2:	fb02 f303 	mul.w	r3, r2, r3
 80094a6:	68ba      	ldr	r2, [r7, #8]
 80094a8:	1ad3      	subs	r3, r2, r3
 80094aa:	60bb      	str	r3, [r7, #8]

    if (outlen) {
 80094ac:	68bb      	ldr	r3, [r7, #8]
 80094ae:	2b00      	cmp	r3, #0
 80094b0:	d020      	beq.n	80094f4 <shake128+0xa4>
        shake128_squeezeblocks(t, 1, &s);
 80094b2:	f107 0214 	add.w	r2, r7, #20
 80094b6:	f107 0318 	add.w	r3, r7, #24
 80094ba:	2101      	movs	r1, #1
 80094bc:	4618      	mov	r0, r3
 80094be:	f7ff ffa9 	bl	8009414 <shake128_squeezeblocks>
        for (size_t i = 0; i < outlen; ++i) {
 80094c2:	2300      	movs	r3, #0
 80094c4:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 80094c8:	e00f      	b.n	80094ea <shake128+0x9a>
            output[i] = t[i];
 80094ca:	68fa      	ldr	r2, [r7, #12]
 80094cc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80094d0:	4413      	add	r3, r2
 80094d2:	f107 0118 	add.w	r1, r7, #24
 80094d6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80094da:	440a      	add	r2, r1
 80094dc:	7812      	ldrb	r2, [r2, #0]
 80094de:	701a      	strb	r2, [r3, #0]
        for (size_t i = 0; i < outlen; ++i) {
 80094e0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80094e4:	3301      	adds	r3, #1
 80094e6:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 80094ea:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 80094ee:	68bb      	ldr	r3, [r7, #8]
 80094f0:	429a      	cmp	r2, r3
 80094f2:	d3ea      	bcc.n	80094ca <shake128+0x7a>
        }
    }
    shake128_ctx_release(&s);
 80094f4:	f107 0314 	add.w	r3, r7, #20
 80094f8:	4618      	mov	r0, r3
 80094fa:	f7ff ff9c 	bl	8009436 <shake128_ctx_release>
}
 80094fe:	bf00      	nop
 8009500:	37c8      	adds	r7, #200	; 0xc8
 8009502:	46bd      	mov	sp, r7
 8009504:	bd80      	pop	{r7, pc}
 8009506:	bf00      	nop
 8009508:	18618619 	.word	0x18618619

0800950c <sha3_256>:
 *
 * Arguments:   - uint8_t *output:      pointer to output
 *              - const uint8_t *input: pointer to input
 *              - size_t inlen:   length of input in bytes
 **************************************************/
void sha3_256(uint8_t *output, const uint8_t *input, size_t inlen) {
 800950c:	b580      	push	{r7, lr}
 800950e:	b0dc      	sub	sp, #368	; 0x170
 8009510:	af02      	add	r7, sp, #8
 8009512:	f107 030c 	add.w	r3, r7, #12
 8009516:	6018      	str	r0, [r3, #0]
 8009518:	f107 0308 	add.w	r3, r7, #8
 800951c:	6019      	str	r1, [r3, #0]
 800951e:	1d3b      	adds	r3, r7, #4
 8009520:	601a      	str	r2, [r3, #0]
    uint64_t s[25];
    uint8_t t[SHA3_256_RATE];

    /* Absorb input */
    keccak_absorb(s, SHA3_256_RATE, input, inlen, 0x06);
 8009522:	1d3b      	adds	r3, r7, #4
 8009524:	f107 0208 	add.w	r2, r7, #8
 8009528:	f107 0098 	add.w	r0, r7, #152	; 0x98
 800952c:	2106      	movs	r1, #6
 800952e:	9100      	str	r1, [sp, #0]
 8009530:	681b      	ldr	r3, [r3, #0]
 8009532:	6812      	ldr	r2, [r2, #0]
 8009534:	2188      	movs	r1, #136	; 0x88
 8009536:	f7ff fe45 	bl	80091c4 <keccak_absorb>

    /* Squeeze output */
    keccak_squeezeblocks(t, 1, s, SHA3_256_RATE);
 800953a:	f107 0298 	add.w	r2, r7, #152	; 0x98
 800953e:	f107 0010 	add.w	r0, r7, #16
 8009542:	2388      	movs	r3, #136	; 0x88
 8009544:	2101      	movs	r1, #1
 8009546:	f7ff ff11 	bl	800936c <keccak_squeezeblocks>

    for (size_t i = 0; i < 32; i++) {
 800954a:	2300      	movs	r3, #0
 800954c:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 8009550:	e011      	b.n	8009576 <sha3_256+0x6a>
        output[i] = t[i];
 8009552:	f107 030c 	add.w	r3, r7, #12
 8009556:	681a      	ldr	r2, [r3, #0]
 8009558:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800955c:	4413      	add	r3, r2
 800955e:	f107 0110 	add.w	r1, r7, #16
 8009562:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 8009566:	440a      	add	r2, r1
 8009568:	7812      	ldrb	r2, [r2, #0]
 800956a:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < 32; i++) {
 800956c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8009570:	3301      	adds	r3, #1
 8009572:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 8009576:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800957a:	2b1f      	cmp	r3, #31
 800957c:	d9e9      	bls.n	8009552 <sha3_256+0x46>
    }
}
 800957e:	bf00      	nop
 8009580:	f507 77b4 	add.w	r7, r7, #360	; 0x168
 8009584:	46bd      	mov	sp, r7
 8009586:	bd80      	pop	{r7, pc}

08009588 <sha3_512>:
 *
 * Arguments:   - uint8_t *output:      pointer to output
 *              - const uint8_t *input: pointer to input
 *              - size_t inlen:   length of input in bytes
 **************************************************/
void sha3_512(uint8_t *output, const uint8_t *input, size_t inlen) {
 8009588:	b580      	push	{r7, lr}
 800958a:	b0cc      	sub	sp, #304	; 0x130
 800958c:	af02      	add	r7, sp, #8
 800958e:	f107 030c 	add.w	r3, r7, #12
 8009592:	6018      	str	r0, [r3, #0]
 8009594:	f107 0308 	add.w	r3, r7, #8
 8009598:	6019      	str	r1, [r3, #0]
 800959a:	1d3b      	adds	r3, r7, #4
 800959c:	601a      	str	r2, [r3, #0]
    uint64_t s[25];
    uint8_t t[SHA3_512_RATE];

    /* Absorb input */
    keccak_absorb(s, SHA3_512_RATE, input, inlen, 0x06);
 800959e:	1d3b      	adds	r3, r7, #4
 80095a0:	f107 0208 	add.w	r2, r7, #8
 80095a4:	f107 0058 	add.w	r0, r7, #88	; 0x58
 80095a8:	2106      	movs	r1, #6
 80095aa:	9100      	str	r1, [sp, #0]
 80095ac:	681b      	ldr	r3, [r3, #0]
 80095ae:	6812      	ldr	r2, [r2, #0]
 80095b0:	2148      	movs	r1, #72	; 0x48
 80095b2:	f7ff fe07 	bl	80091c4 <keccak_absorb>

    /* Squeeze output */
    keccak_squeezeblocks(t, 1, s, SHA3_512_RATE);
 80095b6:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80095ba:	f107 0010 	add.w	r0, r7, #16
 80095be:	2348      	movs	r3, #72	; 0x48
 80095c0:	2101      	movs	r1, #1
 80095c2:	f7ff fed3 	bl	800936c <keccak_squeezeblocks>

    for (size_t i = 0; i < 64; i++) {
 80095c6:	2300      	movs	r3, #0
 80095c8:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80095cc:	e011      	b.n	80095f2 <sha3_512+0x6a>
        output[i] = t[i];
 80095ce:	f107 030c 	add.w	r3, r7, #12
 80095d2:	681a      	ldr	r2, [r3, #0]
 80095d4:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80095d8:	4413      	add	r3, r2
 80095da:	f107 0110 	add.w	r1, r7, #16
 80095de:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 80095e2:	440a      	add	r2, r1
 80095e4:	7812      	ldrb	r2, [r2, #0]
 80095e6:	701a      	strb	r2, [r3, #0]
    for (size_t i = 0; i < 64; i++) {
 80095e8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80095ec:	3301      	adds	r3, #1
 80095ee:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 80095f2:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80095f6:	2b3f      	cmp	r3, #63	; 0x3f
 80095f8:	d9e9      	bls.n	80095ce <sha3_512+0x46>
    }
}
 80095fa:	bf00      	nop
 80095fc:	f507 7794 	add.w	r7, r7, #296	; 0x128
 8009600:	46bd      	mov	sp, r7
 8009602:	bd80      	pop	{r7, pc}

08009604 <randombytes>:

#include "randombytes.h"
#include "se3_rand.h"


int randombytes(uint8_t *buf, size_t n) {
 8009604:	b580      	push	{r7, lr}
 8009606:	b082      	sub	sp, #8
 8009608:	af00      	add	r7, sp, #0
 800960a:	6078      	str	r0, [r7, #4]
 800960c:	6039      	str	r1, [r7, #0]
	if ( n == se3_rand(n, buf)){
 800960e:	683b      	ldr	r3, [r7, #0]
 8009610:	b29b      	uxth	r3, r3
 8009612:	6879      	ldr	r1, [r7, #4]
 8009614:	4618      	mov	r0, r3
 8009616:	f006 fff9 	bl	801060c <se3_rand>
 800961a:	4603      	mov	r3, r0
 800961c:	461a      	mov	r2, r3
 800961e:	683b      	ldr	r3, [r7, #0]
 8009620:	4293      	cmp	r3, r2
 8009622:	d101      	bne.n	8009628 <randombytes+0x24>
		return 0;
 8009624:	2300      	movs	r3, #0
 8009626:	e001      	b.n	800962c <randombytes+0x28>
	}
	return -1;
 8009628:	f04f 33ff 	mov.w	r3, #4294967295
}
 800962c:	4618      	mov	r0, r3
 800962e:	3708      	adds	r7, #8
 8009630:	46bd      	mov	sp, r7
 8009632:	bd80      	pop	{r7, pc}

08009634 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair>:
#include <string.h>

#define h1 (1 << (SABER_EQ - SABER_EP - 1))
#define h2 ((1 << (SABER_EP - 2)) - (1 << (SABER_EP - SABER_ET - 1)) + (1 << (SABER_EQ - SABER_EP - 1)))

void PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair(uint8_t pk[SABER_INDCPA_PUBLICKEYBYTES], uint8_t sk[SABER_INDCPA_SECRETKEYBYTES]) {
 8009634:	b580      	push	{r7, lr}
 8009636:	f5ad 5d40 	sub.w	sp, sp, #12288	; 0x3000
 800963a:	b08e      	sub	sp, #56	; 0x38
 800963c:	af00      	add	r7, sp, #0
 800963e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8009642:	3b34      	subs	r3, #52	; 0x34
 8009644:	6018      	str	r0, [r3, #0]
 8009646:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800964a:	3b38      	subs	r3, #56	; 0x38
 800964c:	6019      	str	r1, [r3, #0]
    poly A[SABER_L][SABER_L];
    poly s[SABER_L];
    poly res[SABER_L];

    uint8_t rand[SABER_NOISESEEDBYTES];
    uint8_t *seed_A = pk + SABER_POLYVECCOMPRESSEDBYTES;
 800964e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8009652:	3b34      	subs	r3, #52	; 0x34
 8009654:	681b      	ldr	r3, [r3, #0]
 8009656:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800965a:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800965e:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009662:	6013      	str	r3, [r2, #0]

    randombytes(seed_A, SABER_SEEDBYTES);
 8009664:	2120      	movs	r1, #32
 8009666:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 800966a:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 800966e:	6818      	ldr	r0, [r3, #0]
 8009670:	f7ff ffc8 	bl	8009604 <randombytes>
    shake128(seed_A, SABER_SEEDBYTES, seed_A, SABER_SEEDBYTES); // for not revealing system RNG state
 8009674:	2320      	movs	r3, #32
 8009676:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800967a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 800967e:	6812      	ldr	r2, [r2, #0]
 8009680:	2120      	movs	r1, #32
 8009682:	f507 5040 	add.w	r0, r7, #12288	; 0x3000
 8009686:	f100 002c 	add.w	r0, r0, #44	; 0x2c
 800968a:	6800      	ldr	r0, [r0, #0]
 800968c:	f7ff fee0 	bl	8009450 <shake128>

    randombytes(rand, SABER_NOISESEEDBYTES);
 8009690:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8009694:	3b2c      	subs	r3, #44	; 0x2c
 8009696:	2120      	movs	r1, #32
 8009698:	4618      	mov	r0, r3
 800969a:	f7ff ffb3 	bl	8009604 <randombytes>
    PQCLEAN_FIRESABER_CLEAN_GenSecret(s, rand);
 800969e:	f107 0238 	add.w	r2, r7, #56	; 0x38
 80096a2:	3a2c      	subs	r2, #44	; 0x2c
 80096a4:	f607 0338 	addw	r3, r7, #2104	; 0x838
 80096a8:	3b0c      	subs	r3, #12
 80096aa:	4611      	mov	r1, r2
 80096ac:	4618      	mov	r0, r3
 80096ae:	f001 fa10 	bl	800aad2 <PQCLEAN_FIRESABER_CLEAN_GenSecret>
    PQCLEAN_FIRESABER_CLEAN_POLVECq2BS(sk, s);
 80096b2:	f607 0238 	addw	r2, r7, #2104	; 0x838
 80096b6:	3a0c      	subs	r2, #12
 80096b8:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80096bc:	3b38      	subs	r3, #56	; 0x38
 80096be:	4611      	mov	r1, r2
 80096c0:	6818      	ldr	r0, [r3, #0]
 80096c2:	f001 f832 	bl	800a72a <PQCLEAN_FIRESABER_CLEAN_POLVECq2BS>

    PQCLEAN_FIRESABER_CLEAN_GenMatrix(A, seed_A); // sample matrix A
 80096c6:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 80096ca:	f103 0318 	add.w	r3, r3, #24
 80096ce:	3b0c      	subs	r3, #12
 80096d0:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80096d4:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 80096d8:	6811      	ldr	r1, [r2, #0]
 80096da:	4618      	mov	r0, r3
 80096dc:	f001 f9a6 	bl	800aa2c <PQCLEAN_FIRESABER_CLEAN_GenMatrix>
    PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul(res, (const poly (*)[SABER_L])A, (const poly *)s, 1); // Matrix in transposed order
 80096e0:	f607 0238 	addw	r2, r7, #2104	; 0x838
 80096e4:	3a0c      	subs	r2, #12
 80096e6:	f507 5181 	add.w	r1, r7, #4128	; 0x1020
 80096ea:	f101 0118 	add.w	r1, r1, #24
 80096ee:	390c      	subs	r1, #12
 80096f0:	f107 0038 	add.w	r0, r7, #56	; 0x38
 80096f4:	380c      	subs	r0, #12
 80096f6:	2301      	movs	r3, #1
 80096f8:	f001 f902 	bl	800a900 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul>


    // rounding
    for (i = 0; i < SABER_L; i++) {
 80096fc:	2300      	movs	r3, #0
 80096fe:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009702:	f102 0234 	add.w	r2, r2, #52	; 0x34
 8009706:	6013      	str	r3, [r2, #0]
 8009708:	e094      	b.n	8009834 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair+0x200>
        for (j = 0; j < SABER_N; j++) {
 800970a:	2300      	movs	r3, #0
 800970c:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009710:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8009714:	6013      	str	r3, [r2, #0]
 8009716:	e07a      	b.n	800980e <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair+0x1da>
            res[i].coeffs[j] += h1;
 8009718:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800971c:	3b0c      	subs	r3, #12
 800971e:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009722:	f102 0234 	add.w	r2, r2, #52	; 0x34
 8009726:	6812      	ldr	r2, [r2, #0]
 8009728:	0211      	lsls	r1, r2, #8
 800972a:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800972e:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8009732:	6812      	ldr	r2, [r2, #0]
 8009734:	440a      	add	r2, r1
 8009736:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800973a:	3304      	adds	r3, #4
 800973c:	b298      	uxth	r0, r3
 800973e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8009742:	3b0c      	subs	r3, #12
 8009744:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009748:	f102 0234 	add.w	r2, r2, #52	; 0x34
 800974c:	6812      	ldr	r2, [r2, #0]
 800974e:	0211      	lsls	r1, r2, #8
 8009750:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009754:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8009758:	6812      	ldr	r2, [r2, #0]
 800975a:	440a      	add	r2, r1
 800975c:	4601      	mov	r1, r0
 800975e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
            res[i].coeffs[j] >>= SABER_EQ - SABER_EP;
 8009762:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8009766:	3b0c      	subs	r3, #12
 8009768:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800976c:	f102 0234 	add.w	r2, r2, #52	; 0x34
 8009770:	6812      	ldr	r2, [r2, #0]
 8009772:	0211      	lsls	r1, r2, #8
 8009774:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009778:	f102 0230 	add.w	r2, r2, #48	; 0x30
 800977c:	6812      	ldr	r2, [r2, #0]
 800977e:	440a      	add	r2, r1
 8009780:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009784:	08db      	lsrs	r3, r3, #3
 8009786:	b298      	uxth	r0, r3
 8009788:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800978c:	3b0c      	subs	r3, #12
 800978e:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009792:	f102 0234 	add.w	r2, r2, #52	; 0x34
 8009796:	6812      	ldr	r2, [r2, #0]
 8009798:	0211      	lsls	r1, r2, #8
 800979a:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800979e:	f102 0230 	add.w	r2, r2, #48	; 0x30
 80097a2:	6812      	ldr	r2, [r2, #0]
 80097a4:	440a      	add	r2, r1
 80097a6:	4601      	mov	r1, r0
 80097a8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
            res[i].coeffs[j] &= SABER_Q - 1;
 80097ac:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80097b0:	3b0c      	subs	r3, #12
 80097b2:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80097b6:	f102 0234 	add.w	r2, r2, #52	; 0x34
 80097ba:	6812      	ldr	r2, [r2, #0]
 80097bc:	0211      	lsls	r1, r2, #8
 80097be:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80097c2:	f102 0230 	add.w	r2, r2, #48	; 0x30
 80097c6:	6812      	ldr	r2, [r2, #0]
 80097c8:	440a      	add	r2, r1
 80097ca:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80097ce:	f3c3 030c 	ubfx	r3, r3, #0, #13
 80097d2:	b298      	uxth	r0, r3
 80097d4:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80097d8:	3b0c      	subs	r3, #12
 80097da:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80097de:	f102 0234 	add.w	r2, r2, #52	; 0x34
 80097e2:	6812      	ldr	r2, [r2, #0]
 80097e4:	0211      	lsls	r1, r2, #8
 80097e6:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80097ea:	f102 0230 	add.w	r2, r2, #48	; 0x30
 80097ee:	6812      	ldr	r2, [r2, #0]
 80097f0:	440a      	add	r2, r1
 80097f2:	4601      	mov	r1, r0
 80097f4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        for (j = 0; j < SABER_N; j++) {
 80097f8:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 80097fc:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8009800:	681b      	ldr	r3, [r3, #0]
 8009802:	3301      	adds	r3, #1
 8009804:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009808:	f102 0230 	add.w	r2, r2, #48	; 0x30
 800980c:	6013      	str	r3, [r2, #0]
 800980e:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009812:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8009816:	681b      	ldr	r3, [r3, #0]
 8009818:	2bff      	cmp	r3, #255	; 0xff
 800981a:	f67f af7d 	bls.w	8009718 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair+0xe4>
    for (i = 0; i < SABER_L; i++) {
 800981e:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009822:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8009826:	681b      	ldr	r3, [r3, #0]
 8009828:	3301      	adds	r3, #1
 800982a:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800982e:	f102 0234 	add.w	r2, r2, #52	; 0x34
 8009832:	6013      	str	r3, [r2, #0]
 8009834:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009838:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800983c:	681b      	ldr	r3, [r3, #0]
 800983e:	2b03      	cmp	r3, #3
 8009840:	f67f af63 	bls.w	800970a <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair+0xd6>
        }
    }

    PQCLEAN_FIRESABER_CLEAN_POLVECp2BS(pk, res); // pack public key
 8009844:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8009848:	3a0c      	subs	r2, #12
 800984a:	f107 0338 	add.w	r3, r7, #56	; 0x38
 800984e:	3b34      	subs	r3, #52	; 0x34
 8009850:	4611      	mov	r1, r2
 8009852:	6818      	ldr	r0, [r3, #0]
 8009854:	f000 ffa9 	bl	800a7aa <PQCLEAN_FIRESABER_CLEAN_POLVECp2BS>
}
 8009858:	bf00      	nop
 800985a:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 800985e:	3738      	adds	r7, #56	; 0x38
 8009860:	46bd      	mov	sp, r7
 8009862:	bd80      	pop	{r7, pc}

08009864 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc>:


void PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc(uint8_t ciphertext[SABER_BYTES_CCA_DEC], const uint8_t m[SABER_KEYBYTES], const uint8_t noiseseed[SABER_NOISESEEDBYTES], const uint8_t pk[SABER_INDCPA_PUBLICKEYBYTES]) {
 8009864:	b590      	push	{r4, r7, lr}
 8009866:	f5ad 5d40 	sub.w	sp, sp, #12288	; 0x3000
 800986a:	b08d      	sub	sp, #52	; 0x34
 800986c:	af00      	add	r7, sp, #0
 800986e:	f107 0430 	add.w	r4, r7, #48	; 0x30
 8009872:	3c24      	subs	r4, #36	; 0x24
 8009874:	6020      	str	r0, [r4, #0]
 8009876:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800987a:	3828      	subs	r0, #40	; 0x28
 800987c:	6001      	str	r1, [r0, #0]
 800987e:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8009882:	392c      	subs	r1, #44	; 0x2c
 8009884:	600a      	str	r2, [r1, #0]
 8009886:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800988a:	3a30      	subs	r2, #48	; 0x30
 800988c:	6013      	str	r3, [r2, #0]
    size_t i, j;

    poly A[SABER_L][SABER_L];
    poly res[SABER_L];
    poly s[SABER_L];
    poly *temp = A[0]; // re-use stack space
 800988e:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 8009892:	f103 0310 	add.w	r3, r3, #16
 8009896:	3b1c      	subs	r3, #28
 8009898:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800989c:	f102 0224 	add.w	r2, r2, #36	; 0x24
 80098a0:	6013      	str	r3, [r2, #0]
    poly *vprime = &A[0][0];
 80098a2:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 80098a6:	f103 0310 	add.w	r3, r3, #16
 80098aa:	3b1c      	subs	r3, #28
 80098ac:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80098b0:	f102 0220 	add.w	r2, r2, #32
 80098b4:	6013      	str	r3, [r2, #0]
    poly *message = &A[0][1];
 80098b6:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 80098ba:	f103 0310 	add.w	r3, r3, #16
 80098be:	3b1c      	subs	r3, #28
 80098c0:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80098c4:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80098c8:	f102 021c 	add.w	r2, r2, #28
 80098cc:	6013      	str	r3, [r2, #0]

    const uint8_t *seed_A = pk + SABER_POLYVECCOMPRESSEDBYTES;
 80098ce:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80098d2:	3b30      	subs	r3, #48	; 0x30
 80098d4:	681b      	ldr	r3, [r3, #0]
 80098d6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80098da:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80098de:	f102 0218 	add.w	r2, r2, #24
 80098e2:	6013      	str	r3, [r2, #0]
    uint8_t *msk_c = ciphertext + SABER_POLYVECCOMPRESSEDBYTES;
 80098e4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80098e8:	3b24      	subs	r3, #36	; 0x24
 80098ea:	681b      	ldr	r3, [r3, #0]
 80098ec:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80098f0:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80098f4:	f102 0214 	add.w	r2, r2, #20
 80098f8:	6013      	str	r3, [r2, #0]

    PQCLEAN_FIRESABER_CLEAN_GenSecret(s, noiseseed);
 80098fa:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80098fe:	3b2c      	subs	r3, #44	; 0x2c
 8009900:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8009904:	3a1c      	subs	r2, #28
 8009906:	6819      	ldr	r1, [r3, #0]
 8009908:	4610      	mov	r0, r2
 800990a:	f001 f8e2 	bl	800aad2 <PQCLEAN_FIRESABER_CLEAN_GenSecret>
    PQCLEAN_FIRESABER_CLEAN_GenMatrix(A, seed_A);
 800990e:	f507 5381 	add.w	r3, r7, #4128	; 0x1020
 8009912:	f103 0310 	add.w	r3, r3, #16
 8009916:	3b1c      	subs	r3, #28
 8009918:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800991c:	f102 0218 	add.w	r2, r2, #24
 8009920:	6811      	ldr	r1, [r2, #0]
 8009922:	4618      	mov	r0, r3
 8009924:	f001 f882 	bl	800aa2c <PQCLEAN_FIRESABER_CLEAN_GenMatrix>
    PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul(res, (const poly (*)[SABER_L])A, (const poly *)s, 0); // 0 => not transposed
 8009928:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800992c:	3a1c      	subs	r2, #28
 800992e:	f507 5181 	add.w	r1, r7, #4128	; 0x1020
 8009932:	f101 0110 	add.w	r1, r1, #16
 8009936:	391c      	subs	r1, #28
 8009938:	f507 6003 	add.w	r0, r7, #2096	; 0x830
 800993c:	381c      	subs	r0, #28
 800993e:	2300      	movs	r3, #0
 8009940:	f000 ffde 	bl	800a900 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul>


    // rounding
    for (i = 0; i < SABER_L; i++) { //shift right EQ-EP bits
 8009944:	2300      	movs	r3, #0
 8009946:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800994a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 800994e:	6013      	str	r3, [r2, #0]
 8009950:	e094      	b.n	8009a7c <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0x218>
        for (j = 0; j < SABER_N; j++) {
 8009952:	2300      	movs	r3, #0
 8009954:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009958:	f102 0228 	add.w	r2, r2, #40	; 0x28
 800995c:	6013      	str	r3, [r2, #0]
 800995e:	e07a      	b.n	8009a56 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0x1f2>
            res[i].coeffs[j] += h1;
 8009960:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 8009964:	3b1c      	subs	r3, #28
 8009966:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800996a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 800996e:	6812      	ldr	r2, [r2, #0]
 8009970:	0211      	lsls	r1, r2, #8
 8009972:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009976:	f102 0228 	add.w	r2, r2, #40	; 0x28
 800997a:	6812      	ldr	r2, [r2, #0]
 800997c:	440a      	add	r2, r1
 800997e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009982:	3304      	adds	r3, #4
 8009984:	b298      	uxth	r0, r3
 8009986:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 800998a:	3b1c      	subs	r3, #28
 800998c:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009990:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009994:	6812      	ldr	r2, [r2, #0]
 8009996:	0211      	lsls	r1, r2, #8
 8009998:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 800999c:	f102 0228 	add.w	r2, r2, #40	; 0x28
 80099a0:	6812      	ldr	r2, [r2, #0]
 80099a2:	440a      	add	r2, r1
 80099a4:	4601      	mov	r1, r0
 80099a6:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
            res[i].coeffs[j] >>= SABER_EQ - SABER_EP;
 80099aa:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 80099ae:	3b1c      	subs	r3, #28
 80099b0:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80099b4:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 80099b8:	6812      	ldr	r2, [r2, #0]
 80099ba:	0211      	lsls	r1, r2, #8
 80099bc:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80099c0:	f102 0228 	add.w	r2, r2, #40	; 0x28
 80099c4:	6812      	ldr	r2, [r2, #0]
 80099c6:	440a      	add	r2, r1
 80099c8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80099cc:	08db      	lsrs	r3, r3, #3
 80099ce:	b298      	uxth	r0, r3
 80099d0:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 80099d4:	3b1c      	subs	r3, #28
 80099d6:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80099da:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 80099de:	6812      	ldr	r2, [r2, #0]
 80099e0:	0211      	lsls	r1, r2, #8
 80099e2:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80099e6:	f102 0228 	add.w	r2, r2, #40	; 0x28
 80099ea:	6812      	ldr	r2, [r2, #0]
 80099ec:	440a      	add	r2, r1
 80099ee:	4601      	mov	r1, r0
 80099f0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
            res[i].coeffs[j] &= SABER_Q - 1;
 80099f4:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 80099f8:	3b1c      	subs	r3, #28
 80099fa:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 80099fe:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009a02:	6812      	ldr	r2, [r2, #0]
 8009a04:	0211      	lsls	r1, r2, #8
 8009a06:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009a0a:	f102 0228 	add.w	r2, r2, #40	; 0x28
 8009a0e:	6812      	ldr	r2, [r2, #0]
 8009a10:	440a      	add	r2, r1
 8009a12:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009a16:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8009a1a:	b298      	uxth	r0, r3
 8009a1c:	f507 6303 	add.w	r3, r7, #2096	; 0x830
 8009a20:	3b1c      	subs	r3, #28
 8009a22:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009a26:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009a2a:	6812      	ldr	r2, [r2, #0]
 8009a2c:	0211      	lsls	r1, r2, #8
 8009a2e:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009a32:	f102 0228 	add.w	r2, r2, #40	; 0x28
 8009a36:	6812      	ldr	r2, [r2, #0]
 8009a38:	440a      	add	r2, r1
 8009a3a:	4601      	mov	r1, r0
 8009a3c:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        for (j = 0; j < SABER_N; j++) {
 8009a40:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009a44:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8009a48:	681b      	ldr	r3, [r3, #0]
 8009a4a:	3301      	adds	r3, #1
 8009a4c:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009a50:	f102 0228 	add.w	r2, r2, #40	; 0x28
 8009a54:	6013      	str	r3, [r2, #0]
 8009a56:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009a5a:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8009a5e:	681b      	ldr	r3, [r3, #0]
 8009a60:	2bff      	cmp	r3, #255	; 0xff
 8009a62:	f67f af7d 	bls.w	8009960 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0xfc>
    for (i = 0; i < SABER_L; i++) { //shift right EQ-EP bits
 8009a66:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009a6a:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8009a6e:	681b      	ldr	r3, [r3, #0]
 8009a70:	3301      	adds	r3, #1
 8009a72:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009a76:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009a7a:	6013      	str	r3, [r2, #0]
 8009a7c:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009a80:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8009a84:	681b      	ldr	r3, [r3, #0]
 8009a86:	2b03      	cmp	r3, #3
 8009a88:	f67f af63 	bls.w	8009952 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0xee>
        }
    }
    PQCLEAN_FIRESABER_CLEAN_POLVECp2BS(ciphertext, res);
 8009a8c:	f507 6203 	add.w	r2, r7, #2096	; 0x830
 8009a90:	3a1c      	subs	r2, #28
 8009a92:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8009a96:	3b24      	subs	r3, #36	; 0x24
 8009a98:	4611      	mov	r1, r2
 8009a9a:	6818      	ldr	r0, [r3, #0]
 8009a9c:	f000 fe85 	bl	800a7aa <PQCLEAN_FIRESABER_CLEAN_POLVECp2BS>

    // vector-vector scalar multiplication with mod p
    PQCLEAN_FIRESABER_CLEAN_BS2POLVECp(temp, pk);
 8009aa0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8009aa4:	3b30      	subs	r3, #48	; 0x30
 8009aa6:	6819      	ldr	r1, [r3, #0]
 8009aa8:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009aac:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8009ab0:	6818      	ldr	r0, [r3, #0]
 8009ab2:	f000 fe9b 	bl	800a7ec <PQCLEAN_FIRESABER_CLEAN_BS2POLVECp>
    PQCLEAN_FIRESABER_CLEAN_InnerProd(vprime, temp, s);
 8009ab6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8009aba:	3b1c      	subs	r3, #28
 8009abc:	461a      	mov	r2, r3
 8009abe:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009ac2:	f103 0324 	add.w	r3, r3, #36	; 0x24
 8009ac6:	6819      	ldr	r1, [r3, #0]
 8009ac8:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009acc:	f103 0320 	add.w	r3, r3, #32
 8009ad0:	6818      	ldr	r0, [r3, #0]
 8009ad2:	f000 ff86 	bl	800a9e2 <PQCLEAN_FIRESABER_CLEAN_InnerProd>
    PQCLEAN_FIRESABER_CLEAN_BS2POLmsg(message, m);
 8009ad6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8009ada:	3b28      	subs	r3, #40	; 0x28
 8009adc:	6819      	ldr	r1, [r3, #0]
 8009ade:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009ae2:	f103 031c 	add.w	r3, r3, #28
 8009ae6:	6818      	ldr	r0, [r3, #0]
 8009ae8:	f000 fea1 	bl	800a82e <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg>

    for (i = 0; i < SABER_N; i++) {
 8009aec:	2300      	movs	r3, #0
 8009aee:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009af2:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009af6:	6013      	str	r3, [r2, #0]
 8009af8:	e069      	b.n	8009bce <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0x36a>
        vprime->coeffs[i] += h1 - (message->coeffs[i] << (SABER_EP - 1));
 8009afa:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009afe:	f103 0320 	add.w	r3, r3, #32
 8009b02:	681b      	ldr	r3, [r3, #0]
 8009b04:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009b08:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009b0c:	6812      	ldr	r2, [r2, #0]
 8009b0e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8009b12:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009b16:	f103 031c 	add.w	r3, r3, #28
 8009b1a:	681b      	ldr	r3, [r3, #0]
 8009b1c:	f507 5140 	add.w	r1, r7, #12288	; 0x3000
 8009b20:	f101 012c 	add.w	r1, r1, #44	; 0x2c
 8009b24:	6809      	ldr	r1, [r1, #0]
 8009b26:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8009b2a:	025b      	lsls	r3, r3, #9
 8009b2c:	b29b      	uxth	r3, r3
 8009b2e:	1ad3      	subs	r3, r2, r3
 8009b30:	b29b      	uxth	r3, r3
 8009b32:	3304      	adds	r3, #4
 8009b34:	b299      	uxth	r1, r3
 8009b36:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009b3a:	f103 0320 	add.w	r3, r3, #32
 8009b3e:	681b      	ldr	r3, [r3, #0]
 8009b40:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009b44:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009b48:	6812      	ldr	r2, [r2, #0]
 8009b4a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        vprime->coeffs[i] &= SABER_P - 1;
 8009b4e:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009b52:	f103 0320 	add.w	r3, r3, #32
 8009b56:	681b      	ldr	r3, [r3, #0]
 8009b58:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009b5c:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009b60:	6812      	ldr	r2, [r2, #0]
 8009b62:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009b66:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8009b6a:	b299      	uxth	r1, r3
 8009b6c:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009b70:	f103 0320 	add.w	r3, r3, #32
 8009b74:	681b      	ldr	r3, [r3, #0]
 8009b76:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009b7a:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009b7e:	6812      	ldr	r2, [r2, #0]
 8009b80:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        vprime->coeffs[i] >>= SABER_EP - SABER_ET;
 8009b84:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009b88:	f103 0320 	add.w	r3, r3, #32
 8009b8c:	681b      	ldr	r3, [r3, #0]
 8009b8e:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009b92:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009b96:	6812      	ldr	r2, [r2, #0]
 8009b98:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009b9c:	091b      	lsrs	r3, r3, #4
 8009b9e:	b299      	uxth	r1, r3
 8009ba0:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009ba4:	f103 0320 	add.w	r3, r3, #32
 8009ba8:	681b      	ldr	r3, [r3, #0]
 8009baa:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009bae:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009bb2:	6812      	ldr	r2, [r2, #0]
 8009bb4:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < SABER_N; i++) {
 8009bb8:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009bbc:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8009bc0:	681b      	ldr	r3, [r3, #0]
 8009bc2:	3301      	adds	r3, #1
 8009bc4:	f507 5240 	add.w	r2, r7, #12288	; 0x3000
 8009bc8:	f102 022c 	add.w	r2, r2, #44	; 0x2c
 8009bcc:	6013      	str	r3, [r2, #0]
 8009bce:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009bd2:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8009bd6:	681b      	ldr	r3, [r3, #0]
 8009bd8:	2bff      	cmp	r3, #255	; 0xff
 8009bda:	d98e      	bls.n	8009afa <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc+0x296>
    }

    PQCLEAN_FIRESABER_CLEAN_POLT2BS(msk_c, vprime);
 8009bdc:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009be0:	f103 0320 	add.w	r3, r3, #32
 8009be4:	6819      	ldr	r1, [r3, #0]
 8009be6:	f507 5340 	add.w	r3, r7, #12288	; 0x3000
 8009bea:	f103 0314 	add.w	r3, r3, #20
 8009bee:	6818      	ldr	r0, [r3, #0]
 8009bf0:	f000 fa98 	bl	800a124 <PQCLEAN_FIRESABER_CLEAN_POLT2BS>
}
 8009bf4:	bf00      	nop
 8009bf6:	f507 5740 	add.w	r7, r7, #12288	; 0x3000
 8009bfa:	3734      	adds	r7, #52	; 0x34
 8009bfc:	46bd      	mov	sp, r7
 8009bfe:	bd90      	pop	{r4, r7, pc}

08009c00 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec>:


void PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec(uint8_t m[SABER_KEYBYTES], const uint8_t sk[SABER_INDCPA_SECRETKEYBYTES], const uint8_t ciphertext[SABER_BYTES_CCA_DEC]) {
 8009c00:	b580      	push	{r7, lr}
 8009c02:	f5ad 5d81 	sub.w	sp, sp, #4128	; 0x1020
 8009c06:	af00      	add	r7, sp, #0
 8009c08:	f107 0320 	add.w	r3, r7, #32
 8009c0c:	3b14      	subs	r3, #20
 8009c0e:	6018      	str	r0, [r3, #0]
 8009c10:	f107 0320 	add.w	r3, r7, #32
 8009c14:	3b18      	subs	r3, #24
 8009c16:	6019      	str	r1, [r3, #0]
 8009c18:	f107 0320 	add.w	r3, r7, #32
 8009c1c:	3b1c      	subs	r3, #28
 8009c1e:	601a      	str	r2, [r3, #0]
    size_t i;

    poly temp[SABER_L];
    poly s[SABER_L];

    const uint8_t *packed_cm = ciphertext + SABER_POLYVECCOMPRESSEDBYTES;
 8009c20:	f107 0320 	add.w	r3, r7, #32
 8009c24:	3b1c      	subs	r3, #28
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8009c2c:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009c30:	f102 0218 	add.w	r2, r2, #24
 8009c34:	6013      	str	r3, [r2, #0]
    poly *v = &temp[0];
 8009c36:	f507 6301 	add.w	r3, r7, #2064	; 0x810
 8009c3a:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009c3e:	f102 0214 	add.w	r2, r2, #20
 8009c42:	6013      	str	r3, [r2, #0]
    poly *cm = &temp[1];
 8009c44:	f507 6301 	add.w	r3, r7, #2064	; 0x810
 8009c48:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8009c4c:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009c50:	f102 0210 	add.w	r2, r2, #16
 8009c54:	6013      	str	r3, [r2, #0]

    PQCLEAN_FIRESABER_CLEAN_BS2POLVECq(s, sk);
 8009c56:	f107 0320 	add.w	r3, r7, #32
 8009c5a:	3b18      	subs	r3, #24
 8009c5c:	f107 0220 	add.w	r2, r7, #32
 8009c60:	3a10      	subs	r2, #16
 8009c62:	6819      	ldr	r1, [r3, #0]
 8009c64:	4610      	mov	r0, r2
 8009c66:	f000 fd80 	bl	800a76a <PQCLEAN_FIRESABER_CLEAN_BS2POLVECq>
    PQCLEAN_FIRESABER_CLEAN_BS2POLVECp(temp, ciphertext);
 8009c6a:	f107 0320 	add.w	r3, r7, #32
 8009c6e:	3b1c      	subs	r3, #28
 8009c70:	f507 6201 	add.w	r2, r7, #2064	; 0x810
 8009c74:	6819      	ldr	r1, [r3, #0]
 8009c76:	4610      	mov	r0, r2
 8009c78:	f000 fdb8 	bl	800a7ec <PQCLEAN_FIRESABER_CLEAN_BS2POLVECp>
    PQCLEAN_FIRESABER_CLEAN_InnerProd(&temp[0], temp, s);
 8009c7c:	f107 0320 	add.w	r3, r7, #32
 8009c80:	3b10      	subs	r3, #16
 8009c82:	f507 6101 	add.w	r1, r7, #2064	; 0x810
 8009c86:	f507 6001 	add.w	r0, r7, #2064	; 0x810
 8009c8a:	461a      	mov	r2, r3
 8009c8c:	f000 fea9 	bl	800a9e2 <PQCLEAN_FIRESABER_CLEAN_InnerProd>

    PQCLEAN_FIRESABER_CLEAN_BS2POLT(cm, packed_cm);
 8009c90:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009c94:	f103 0318 	add.w	r3, r3, #24
 8009c98:	6819      	ldr	r1, [r3, #0]
 8009c9a:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009c9e:	f103 0310 	add.w	r3, r3, #16
 8009ca2:	6818      	ldr	r0, [r3, #0]
 8009ca4:	f000 fa94 	bl	800a1d0 <PQCLEAN_FIRESABER_CLEAN_BS2POLT>

    for (i = 0; i < SABER_N; i++) {
 8009ca8:	2300      	movs	r3, #0
 8009caa:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009cae:	f102 021c 	add.w	r2, r2, #28
 8009cb2:	6013      	str	r3, [r2, #0]
 8009cb4:	e069      	b.n	8009d8a <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec+0x18a>
        v->coeffs[i] += h2 - (cm->coeffs[i] << (SABER_EP - SABER_ET));
 8009cb6:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009cba:	f103 0314 	add.w	r3, r3, #20
 8009cbe:	681b      	ldr	r3, [r3, #0]
 8009cc0:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009cc4:	f102 021c 	add.w	r2, r2, #28
 8009cc8:	6812      	ldr	r2, [r2, #0]
 8009cca:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8009cce:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009cd2:	f103 0310 	add.w	r3, r3, #16
 8009cd6:	681b      	ldr	r3, [r3, #0]
 8009cd8:	f507 5180 	add.w	r1, r7, #4096	; 0x1000
 8009cdc:	f101 011c 	add.w	r1, r1, #28
 8009ce0:	6809      	ldr	r1, [r1, #0]
 8009ce2:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8009ce6:	011b      	lsls	r3, r3, #4
 8009ce8:	b29b      	uxth	r3, r3
 8009cea:	1ad3      	subs	r3, r2, r3
 8009cec:	b29b      	uxth	r3, r3
 8009cee:	33fc      	adds	r3, #252	; 0xfc
 8009cf0:	b299      	uxth	r1, r3
 8009cf2:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009cf6:	f103 0314 	add.w	r3, r3, #20
 8009cfa:	681b      	ldr	r3, [r3, #0]
 8009cfc:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d00:	f102 021c 	add.w	r2, r2, #28
 8009d04:	6812      	ldr	r2, [r2, #0]
 8009d06:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        v->coeffs[i] &= SABER_P - 1;
 8009d0a:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d0e:	f103 0314 	add.w	r3, r3, #20
 8009d12:	681b      	ldr	r3, [r3, #0]
 8009d14:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d18:	f102 021c 	add.w	r2, r2, #28
 8009d1c:	6812      	ldr	r2, [r2, #0]
 8009d1e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009d22:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8009d26:	b299      	uxth	r1, r3
 8009d28:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d2c:	f103 0314 	add.w	r3, r3, #20
 8009d30:	681b      	ldr	r3, [r3, #0]
 8009d32:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d36:	f102 021c 	add.w	r2, r2, #28
 8009d3a:	6812      	ldr	r2, [r2, #0]
 8009d3c:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        v->coeffs[i] >>= SABER_EP - 1;
 8009d40:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d44:	f103 0314 	add.w	r3, r3, #20
 8009d48:	681b      	ldr	r3, [r3, #0]
 8009d4a:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d4e:	f102 021c 	add.w	r2, r2, #28
 8009d52:	6812      	ldr	r2, [r2, #0]
 8009d54:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8009d58:	0a5b      	lsrs	r3, r3, #9
 8009d5a:	b299      	uxth	r1, r3
 8009d5c:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d60:	f103 0314 	add.w	r3, r3, #20
 8009d64:	681b      	ldr	r3, [r3, #0]
 8009d66:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d6a:	f102 021c 	add.w	r2, r2, #28
 8009d6e:	6812      	ldr	r2, [r2, #0]
 8009d70:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < SABER_N; i++) {
 8009d74:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d78:	f103 031c 	add.w	r3, r3, #28
 8009d7c:	681b      	ldr	r3, [r3, #0]
 8009d7e:	3301      	adds	r3, #1
 8009d80:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009d84:	f102 021c 	add.w	r2, r2, #28
 8009d88:	6013      	str	r3, [r2, #0]
 8009d8a:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
 8009d8e:	f103 031c 	add.w	r3, r3, #28
 8009d92:	681b      	ldr	r3, [r3, #0]
 8009d94:	2bff      	cmp	r3, #255	; 0xff
 8009d96:	d98e      	bls.n	8009cb6 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec+0xb6>
    }

    PQCLEAN_FIRESABER_CLEAN_POLmsg2BS(m, v);
 8009d98:	f107 0320 	add.w	r3, r7, #32
 8009d9c:	3b14      	subs	r3, #20
 8009d9e:	f507 5280 	add.w	r2, r7, #4096	; 0x1000
 8009da2:	f102 0214 	add.w	r2, r2, #20
 8009da6:	6811      	ldr	r1, [r2, #0]
 8009da8:	6818      	ldr	r0, [r3, #0]
 8009daa:	f000 fd70 	bl	800a88e <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS>
}
 8009dae:	bf00      	nop
 8009db0:	f507 5781 	add.w	r7, r7, #4128	; 0x1020
 8009db4:	46bd      	mov	sp, r7
 8009db6:	bd80      	pop	{r7, pc}

08009db8 <load_littleendian>:
by : Joppe Bos, Leo Ducas, Eike Kiltz, Tancrede Lepoint,
Vadim Lyubashevsky, John M. Schanck, Peter Schwabe & Damien stehle
----------------------------------------------------------------------*/


static uint64_t load_littleendian(const uint8_t *x, int bytes) {
 8009db8:	b4f0      	push	{r4, r5, r6, r7}
 8009dba:	b086      	sub	sp, #24
 8009dbc:	af00      	add	r7, sp, #0
 8009dbe:	6078      	str	r0, [r7, #4]
 8009dc0:	6039      	str	r1, [r7, #0]
    int i;
    uint64_t r = x[0];
 8009dc2:	687a      	ldr	r2, [r7, #4]
 8009dc4:	7812      	ldrb	r2, [r2, #0]
 8009dc6:	b2d1      	uxtb	r1, r2
 8009dc8:	f04f 0200 	mov.w	r2, #0
 8009dcc:	e9c7 1202 	strd	r1, r2, [r7, #8]
    for (i = 1; i < bytes; i++) {
 8009dd0:	2201      	movs	r2, #1
 8009dd2:	617a      	str	r2, [r7, #20]
 8009dd4:	e021      	b.n	8009e1a <load_littleendian+0x62>
        r |= (uint64_t)x[i] << (8 * i);
 8009dd6:	697a      	ldr	r2, [r7, #20]
 8009dd8:	6879      	ldr	r1, [r7, #4]
 8009dda:	440a      	add	r2, r1
 8009ddc:	7812      	ldrb	r2, [r2, #0]
 8009dde:	b2d1      	uxtb	r1, r2
 8009de0:	f04f 0200 	mov.w	r2, #0
 8009de4:	6978      	ldr	r0, [r7, #20]
 8009de6:	00c0      	lsls	r0, r0, #3
 8009de8:	f1a0 0620 	sub.w	r6, r0, #32
 8009dec:	f1c0 0520 	rsb	r5, r0, #32
 8009df0:	fa02 f400 	lsl.w	r4, r2, r0
 8009df4:	fa01 f606 	lsl.w	r6, r1, r6
 8009df8:	4334      	orrs	r4, r6
 8009dfa:	fa21 f505 	lsr.w	r5, r1, r5
 8009dfe:	432c      	orrs	r4, r5
 8009e00:	fa01 f300 	lsl.w	r3, r1, r0
 8009e04:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8009e08:	ea41 0503 	orr.w	r5, r1, r3
 8009e0c:	ea42 0604 	orr.w	r6, r2, r4
 8009e10:	e9c7 5602 	strd	r5, r6, [r7, #8]
    for (i = 1; i < bytes; i++) {
 8009e14:	697a      	ldr	r2, [r7, #20]
 8009e16:	3201      	adds	r2, #1
 8009e18:	617a      	str	r2, [r7, #20]
 8009e1a:	6979      	ldr	r1, [r7, #20]
 8009e1c:	683a      	ldr	r2, [r7, #0]
 8009e1e:	4291      	cmp	r1, r2
 8009e20:	dbd9      	blt.n	8009dd6 <load_littleendian+0x1e>
    }
    return r;
 8009e22:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
}
 8009e26:	4618      	mov	r0, r3
 8009e28:	4621      	mov	r1, r4
 8009e2a:	3718      	adds	r7, #24
 8009e2c:	46bd      	mov	sp, r7
 8009e2e:	bcf0      	pop	{r4, r5, r6, r7}
 8009e30:	4770      	bx	lr
	...

08009e34 <PQCLEAN_FIRESABER_CLEAN_cbd>:

void PQCLEAN_FIRESABER_CLEAN_cbd(uint16_t s[SABER_N], const uint8_t buf[SABER_POLYCOINBYTES]) {
 8009e34:	b590      	push	{r4, r7, lr}
 8009e36:	b08f      	sub	sp, #60	; 0x3c
 8009e38:	af00      	add	r7, sp, #0
 8009e3a:	6078      	str	r0, [r7, #4]
 8009e3c:	6039      	str	r1, [r7, #0]
    uint32_t t, d, a[4], b[4];
    int i, j;

    for (i = 0; i < SABER_N / 4; i++) {
 8009e3e:	2300      	movs	r3, #0
 8009e40:	633b      	str	r3, [r7, #48]	; 0x30
 8009e42:	e078      	b.n	8009f36 <PQCLEAN_FIRESABER_CLEAN_cbd+0x102>
        t = (uint32_t) load_littleendian(buf + 3 * i, 3);
 8009e44:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009e46:	4613      	mov	r3, r2
 8009e48:	005b      	lsls	r3, r3, #1
 8009e4a:	4413      	add	r3, r2
 8009e4c:	461a      	mov	r2, r3
 8009e4e:	683b      	ldr	r3, [r7, #0]
 8009e50:	4413      	add	r3, r2
 8009e52:	2103      	movs	r1, #3
 8009e54:	4618      	mov	r0, r3
 8009e56:	f7ff ffaf 	bl	8009db8 <load_littleendian>
 8009e5a:	4603      	mov	r3, r0
 8009e5c:	460c      	mov	r4, r1
 8009e5e:	62bb      	str	r3, [r7, #40]	; 0x28
        d = 0;
 8009e60:	2300      	movs	r3, #0
 8009e62:	637b      	str	r3, [r7, #52]	; 0x34
        for (j = 0; j < 3; j++) {
 8009e64:	2300      	movs	r3, #0
 8009e66:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009e68:	e00a      	b.n	8009e80 <PQCLEAN_FIRESABER_CLEAN_cbd+0x4c>
            d += (t >> j) & 0x249249;
 8009e6a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009e6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e6e:	40da      	lsrs	r2, r3
 8009e70:	4b34      	ldr	r3, [pc, #208]	; (8009f44 <PQCLEAN_FIRESABER_CLEAN_cbd+0x110>)
 8009e72:	4013      	ands	r3, r2
 8009e74:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009e76:	4413      	add	r3, r2
 8009e78:	637b      	str	r3, [r7, #52]	; 0x34
        for (j = 0; j < 3; j++) {
 8009e7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e7c:	3301      	adds	r3, #1
 8009e7e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009e80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e82:	2b02      	cmp	r3, #2
 8009e84:	ddf1      	ble.n	8009e6a <PQCLEAN_FIRESABER_CLEAN_cbd+0x36>
        }

        a[0] = d & 0x7;
 8009e86:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009e88:	f003 0307 	and.w	r3, r3, #7
 8009e8c:	61bb      	str	r3, [r7, #24]
        b[0] = (d >> 3) & 0x7;
 8009e8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009e90:	08db      	lsrs	r3, r3, #3
 8009e92:	f003 0307 	and.w	r3, r3, #7
 8009e96:	60bb      	str	r3, [r7, #8]
        a[1] = (d >> 6) & 0x7;
 8009e98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009e9a:	099b      	lsrs	r3, r3, #6
 8009e9c:	f003 0307 	and.w	r3, r3, #7
 8009ea0:	61fb      	str	r3, [r7, #28]
        b[1] = (d >> 9) & 0x7;
 8009ea2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ea4:	0a5b      	lsrs	r3, r3, #9
 8009ea6:	f003 0307 	and.w	r3, r3, #7
 8009eaa:	60fb      	str	r3, [r7, #12]
        a[2] = (d >> 12) & 0x7;
 8009eac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009eae:	0b1b      	lsrs	r3, r3, #12
 8009eb0:	f003 0307 	and.w	r3, r3, #7
 8009eb4:	623b      	str	r3, [r7, #32]
        b[2] = (d >> 15) & 0x7;
 8009eb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009eb8:	0bdb      	lsrs	r3, r3, #15
 8009eba:	f003 0307 	and.w	r3, r3, #7
 8009ebe:	613b      	str	r3, [r7, #16]
        a[3] = (d >> 18) & 0x7;
 8009ec0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ec2:	0c9b      	lsrs	r3, r3, #18
 8009ec4:	f003 0307 	and.w	r3, r3, #7
 8009ec8:	627b      	str	r3, [r7, #36]	; 0x24
        b[3] = (d >> 21);
 8009eca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ecc:	0d5b      	lsrs	r3, r3, #21
 8009ece:	617b      	str	r3, [r7, #20]

        s[4 * i + 0] = (uint16_t)(a[0] - b[0]);
 8009ed0:	69bb      	ldr	r3, [r7, #24]
 8009ed2:	b299      	uxth	r1, r3
 8009ed4:	68bb      	ldr	r3, [r7, #8]
 8009ed6:	b29a      	uxth	r2, r3
 8009ed8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009eda:	00db      	lsls	r3, r3, #3
 8009edc:	4618      	mov	r0, r3
 8009ede:	687b      	ldr	r3, [r7, #4]
 8009ee0:	4403      	add	r3, r0
 8009ee2:	1a8a      	subs	r2, r1, r2
 8009ee4:	b292      	uxth	r2, r2
 8009ee6:	801a      	strh	r2, [r3, #0]
        s[4 * i + 1] = (uint16_t)(a[1] - b[1]);
 8009ee8:	69fb      	ldr	r3, [r7, #28]
 8009eea:	b299      	uxth	r1, r3
 8009eec:	68fb      	ldr	r3, [r7, #12]
 8009eee:	b29a      	uxth	r2, r3
 8009ef0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009ef2:	00db      	lsls	r3, r3, #3
 8009ef4:	3302      	adds	r3, #2
 8009ef6:	6878      	ldr	r0, [r7, #4]
 8009ef8:	4403      	add	r3, r0
 8009efa:	1a8a      	subs	r2, r1, r2
 8009efc:	b292      	uxth	r2, r2
 8009efe:	801a      	strh	r2, [r3, #0]
        s[4 * i + 2] = (uint16_t)(a[2] - b[2]);
 8009f00:	6a3b      	ldr	r3, [r7, #32]
 8009f02:	b299      	uxth	r1, r3
 8009f04:	693b      	ldr	r3, [r7, #16]
 8009f06:	b29a      	uxth	r2, r3
 8009f08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f0a:	00db      	lsls	r3, r3, #3
 8009f0c:	3304      	adds	r3, #4
 8009f0e:	6878      	ldr	r0, [r7, #4]
 8009f10:	4403      	add	r3, r0
 8009f12:	1a8a      	subs	r2, r1, r2
 8009f14:	b292      	uxth	r2, r2
 8009f16:	801a      	strh	r2, [r3, #0]
        s[4 * i + 3] = (uint16_t)(a[3] - b[3]);
 8009f18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f1a:	b299      	uxth	r1, r3
 8009f1c:	697b      	ldr	r3, [r7, #20]
 8009f1e:	b29a      	uxth	r2, r3
 8009f20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f22:	00db      	lsls	r3, r3, #3
 8009f24:	3306      	adds	r3, #6
 8009f26:	6878      	ldr	r0, [r7, #4]
 8009f28:	4403      	add	r3, r0
 8009f2a:	1a8a      	subs	r2, r1, r2
 8009f2c:	b292      	uxth	r2, r2
 8009f2e:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < SABER_N / 4; i++) {
 8009f30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f32:	3301      	adds	r3, #1
 8009f34:	633b      	str	r3, [r7, #48]	; 0x30
 8009f36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f38:	2b3f      	cmp	r3, #63	; 0x3f
 8009f3a:	dd83      	ble.n	8009e44 <PQCLEAN_FIRESABER_CLEAN_cbd+0x10>
    }
}
 8009f3c:	bf00      	nop
 8009f3e:	373c      	adds	r7, #60	; 0x3c
 8009f40:	46bd      	mov	sp, r7
 8009f42:	bd90      	pop	{r4, r7, pc}
 8009f44:	00249249 	.word	0x00249249

08009f48 <PQCLEAN_FIRESABER_CLEAN_crypto_kem_keypair>:
#include "verify.h"
#include <stddef.h>
#include <stdint.h>


int PQCLEAN_FIRESABER_CLEAN_crypto_kem_keypair(uint8_t *pk, uint8_t *sk) {
 8009f48:	b580      	push	{r7, lr}
 8009f4a:	b084      	sub	sp, #16
 8009f4c:	af00      	add	r7, sp, #0
 8009f4e:	6078      	str	r0, [r7, #4]
 8009f50:	6039      	str	r1, [r7, #0]
    size_t i;

    PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair(pk, sk); // sk[0:SABER_INDCPA_SECRETKEYBYTES-1] <-- sk
 8009f52:	6839      	ldr	r1, [r7, #0]
 8009f54:	6878      	ldr	r0, [r7, #4]
 8009f56:	f7ff fb6d 	bl	8009634 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_keypair>
    for (i = 0; i < SABER_INDCPA_PUBLICKEYBYTES; i++) {
 8009f5a:	2300      	movs	r3, #0
 8009f5c:	60fb      	str	r3, [r7, #12]
 8009f5e:	e00c      	b.n	8009f7a <PQCLEAN_FIRESABER_CLEAN_crypto_kem_keypair+0x32>
        sk[i + SABER_INDCPA_SECRETKEYBYTES] = pk[i];    // sk[SABER_INDCPA_SECRETKEYBYTES:SABER_INDCPA_SECRETKEYBYTES+SABER_INDCPA_SECRETKEYBYTES-1] <-- pk
 8009f60:	687a      	ldr	r2, [r7, #4]
 8009f62:	68fb      	ldr	r3, [r7, #12]
 8009f64:	441a      	add	r2, r3
 8009f66:	68fb      	ldr	r3, [r7, #12]
 8009f68:	f503 63d0 	add.w	r3, r3, #1664	; 0x680
 8009f6c:	6839      	ldr	r1, [r7, #0]
 8009f6e:	440b      	add	r3, r1
 8009f70:	7812      	ldrb	r2, [r2, #0]
 8009f72:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < SABER_INDCPA_PUBLICKEYBYTES; i++) {
 8009f74:	68fb      	ldr	r3, [r7, #12]
 8009f76:	3301      	adds	r3, #1
 8009f78:	60fb      	str	r3, [r7, #12]
 8009f7a:	68fb      	ldr	r3, [r7, #12]
 8009f7c:	f5b3 6fa4 	cmp.w	r3, #1312	; 0x520
 8009f80:	d3ee      	bcc.n	8009f60 <PQCLEAN_FIRESABER_CLEAN_crypto_kem_keypair+0x18>
    }

    sha3_256(sk + SABER_SECRETKEYBYTES - 64, pk, SABER_INDCPA_PUBLICKEYBYTES); // Then hash(pk) is appended.
 8009f82:	683b      	ldr	r3, [r7, #0]
 8009f84:	f503 633a 	add.w	r3, r3, #2976	; 0xba0
 8009f88:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 8009f8c:	6879      	ldr	r1, [r7, #4]
 8009f8e:	4618      	mov	r0, r3
 8009f90:	f7ff fabc 	bl	800950c <sha3_256>

    randombytes(sk + SABER_SECRETKEYBYTES - SABER_KEYBYTES, SABER_KEYBYTES); // Remaining part of sk contains a pseudo-random number.
 8009f94:	683b      	ldr	r3, [r7, #0]
 8009f96:	f503 633c 	add.w	r3, r3, #3008	; 0xbc0
 8009f9a:	2120      	movs	r1, #32
 8009f9c:	4618      	mov	r0, r3
 8009f9e:	f7ff fb31 	bl	8009604 <randombytes>
    // This is output when check in PQCLEAN_FIRESABER_CLEAN_crypto_kem_dec() fails.
    return (0);
 8009fa2:	2300      	movs	r3, #0
}
 8009fa4:	4618      	mov	r0, r3
 8009fa6:	3710      	adds	r7, #16
 8009fa8:	46bd      	mov	sp, r7
 8009faa:	bd80      	pop	{r7, pc}

08009fac <PQCLEAN_FIRESABER_CLEAN_crypto_kem_enc>:

int PQCLEAN_FIRESABER_CLEAN_crypto_kem_enc(uint8_t *c, uint8_t *k, const uint8_t *pk) {
 8009fac:	b580      	push	{r7, lr}
 8009fae:	b0a4      	sub	sp, #144	; 0x90
 8009fb0:	af00      	add	r7, sp, #0
 8009fb2:	60f8      	str	r0, [r7, #12]
 8009fb4:	60b9      	str	r1, [r7, #8]
 8009fb6:	607a      	str	r2, [r7, #4]

    uint8_t kr[64]; // Will contain key, coins
    uint8_t buf[64];

    randombytes(buf, 32);
 8009fb8:	f107 0310 	add.w	r3, r7, #16
 8009fbc:	2120      	movs	r1, #32
 8009fbe:	4618      	mov	r0, r3
 8009fc0:	f7ff fb20 	bl	8009604 <randombytes>

    sha3_256(buf, buf, 32); // BUF[0:31] <-- random message (will be used as the key for client) Note: hash doesnot release system RNG output
 8009fc4:	f107 0110 	add.w	r1, r7, #16
 8009fc8:	f107 0310 	add.w	r3, r7, #16
 8009fcc:	2220      	movs	r2, #32
 8009fce:	4618      	mov	r0, r3
 8009fd0:	f7ff fa9c 	bl	800950c <sha3_256>

    sha3_256(buf + 32, pk, SABER_INDCPA_PUBLICKEYBYTES); // BUF[32:63] <-- Hash(public key);  Multitarget countermeasure for coins + contributory KEM
 8009fd4:	f107 0310 	add.w	r3, r7, #16
 8009fd8:	3320      	adds	r3, #32
 8009fda:	f44f 62a4 	mov.w	r2, #1312	; 0x520
 8009fde:	6879      	ldr	r1, [r7, #4]
 8009fe0:	4618      	mov	r0, r3
 8009fe2:	f7ff fa93 	bl	800950c <sha3_256>

    sha3_512(kr, buf, 64);               // kr[0:63] <-- Hash(buf[0:63]);
 8009fe6:	f107 0110 	add.w	r1, r7, #16
 8009fea:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8009fee:	2240      	movs	r2, #64	; 0x40
 8009ff0:	4618      	mov	r0, r3
 8009ff2:	f7ff fac9 	bl	8009588 <sha3_512>
    // K^ <-- kr[0:31]
    // noiseseed (r) <-- kr[32:63];
    PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc(c, buf, kr + 32, pk); // buf[0:31] contains message; kr[32:63] contains randomness r;
 8009ff6:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8009ffa:	3220      	adds	r2, #32
 8009ffc:	f107 0110 	add.w	r1, r7, #16
 800a000:	687b      	ldr	r3, [r7, #4]
 800a002:	68f8      	ldr	r0, [r7, #12]
 800a004:	f7ff fc2e 	bl	8009864 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc>

    sha3_256(kr + 32, c, SABER_BYTES_CCA_DEC);
 800a008:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800a00c:	3320      	adds	r3, #32
 800a00e:	f44f 62b8 	mov.w	r2, #1472	; 0x5c0
 800a012:	68f9      	ldr	r1, [r7, #12]
 800a014:	4618      	mov	r0, r3
 800a016:	f7ff fa79 	bl	800950c <sha3_256>

    sha3_256(k, kr, 64); // hash concatenation of pre-k and h(c) to k
 800a01a:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800a01e:	2240      	movs	r2, #64	; 0x40
 800a020:	4619      	mov	r1, r3
 800a022:	68b8      	ldr	r0, [r7, #8]
 800a024:	f7ff fa72 	bl	800950c <sha3_256>

    return (0);
 800a028:	2300      	movs	r3, #0
}
 800a02a:	4618      	mov	r0, r3
 800a02c:	3790      	adds	r7, #144	; 0x90
 800a02e:	46bd      	mov	sp, r7
 800a030:	bd80      	pop	{r7, pc}

0800a032 <PQCLEAN_FIRESABER_CLEAN_crypto_kem_dec>:

int PQCLEAN_FIRESABER_CLEAN_crypto_kem_dec(uint8_t *k, const uint8_t *c, const uint8_t *sk) {
 800a032:	b580      	push	{r7, lr}
 800a034:	f5ad 6dcc 	sub.w	sp, sp, #1632	; 0x660
 800a038:	af00      	add	r7, sp, #0
 800a03a:	f107 030c 	add.w	r3, r7, #12
 800a03e:	6018      	str	r0, [r3, #0]
 800a040:	f107 0308 	add.w	r3, r7, #8
 800a044:	6019      	str	r1, [r3, #0]
 800a046:	1d3b      	adds	r3, r7, #4
 800a048:	601a      	str	r2, [r3, #0]
    size_t i;
    uint8_t fail;
    uint8_t cmp[SABER_BYTES_CCA_DEC];
    uint8_t buf[64];
    uint8_t kr[64]; // Will contain key, coins
    const uint8_t *pk = sk + SABER_INDCPA_SECRETKEYBYTES;
 800a04a:	1d3b      	adds	r3, r7, #4
 800a04c:	681b      	ldr	r3, [r3, #0]
 800a04e:	f503 63d0 	add.w	r3, r3, #1664	; 0x680
 800a052:	f8c7 3658 	str.w	r3, [r7, #1624]	; 0x658

    PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec(buf, sk, c); // buf[0:31] <-- message
 800a056:	f107 0208 	add.w	r2, r7, #8
 800a05a:	1d3b      	adds	r3, r7, #4
 800a05c:	f107 0054 	add.w	r0, r7, #84	; 0x54
 800a060:	6812      	ldr	r2, [r2, #0]
 800a062:	6819      	ldr	r1, [r3, #0]
 800a064:	f7ff fdcc 	bl	8009c00 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_dec>

    // Multitarget countermeasure for coins + contributory KEM
    for (i = 0; i < 32; i++) { // Save hash by storing h(pk) in sk
 800a068:	2300      	movs	r3, #0
 800a06a:	f8c7 365c 	str.w	r3, [r7, #1628]	; 0x65c
 800a06e:	e012      	b.n	800a096 <PQCLEAN_FIRESABER_CLEAN_crypto_kem_dec+0x64>
        buf[32 + i] = sk[SABER_SECRETKEYBYTES - 64 + i];
 800a070:	f8d7 365c 	ldr.w	r3, [r7, #1628]	; 0x65c
 800a074:	f503 633a 	add.w	r3, r3, #2976	; 0xba0
 800a078:	1d3a      	adds	r2, r7, #4
 800a07a:	6812      	ldr	r2, [r2, #0]
 800a07c:	441a      	add	r2, r3
 800a07e:	f8d7 365c 	ldr.w	r3, [r7, #1628]	; 0x65c
 800a082:	3320      	adds	r3, #32
 800a084:	7811      	ldrb	r1, [r2, #0]
 800a086:	f107 0254 	add.w	r2, r7, #84	; 0x54
 800a08a:	54d1      	strb	r1, [r2, r3]
    for (i = 0; i < 32; i++) { // Save hash by storing h(pk) in sk
 800a08c:	f8d7 365c 	ldr.w	r3, [r7, #1628]	; 0x65c
 800a090:	3301      	adds	r3, #1
 800a092:	f8c7 365c 	str.w	r3, [r7, #1628]	; 0x65c
 800a096:	f8d7 365c 	ldr.w	r3, [r7, #1628]	; 0x65c
 800a09a:	2b1f      	cmp	r3, #31
 800a09c:	d9e8      	bls.n	800a070 <PQCLEAN_FIRESABER_CLEAN_crypto_kem_dec+0x3e>
    }

    sha3_512(kr, buf, 64);
 800a09e:	f107 0154 	add.w	r1, r7, #84	; 0x54
 800a0a2:	f107 0314 	add.w	r3, r7, #20
 800a0a6:	2240      	movs	r2, #64	; 0x40
 800a0a8:	4618      	mov	r0, r3
 800a0aa:	f7ff fa6d 	bl	8009588 <sha3_512>

    PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc(cmp, buf, kr + 32, pk);
 800a0ae:	f107 0214 	add.w	r2, r7, #20
 800a0b2:	3220      	adds	r2, #32
 800a0b4:	f107 0154 	add.w	r1, r7, #84	; 0x54
 800a0b8:	f107 0094 	add.w	r0, r7, #148	; 0x94
 800a0bc:	f8d7 3658 	ldr.w	r3, [r7, #1624]	; 0x658
 800a0c0:	f7ff fbd0 	bl	8009864 <PQCLEAN_FIRESABER_CLEAN_indcpa_kem_enc>

    fail = PQCLEAN_FIRESABER_CLEAN_verify(c, cmp, SABER_BYTES_CCA_DEC);
 800a0c4:	f107 0194 	add.w	r1, r7, #148	; 0x94
 800a0c8:	f107 0308 	add.w	r3, r7, #8
 800a0cc:	f44f 62b8 	mov.w	r2, #1472	; 0x5c0
 800a0d0:	6818      	ldr	r0, [r3, #0]
 800a0d2:	f001 fcab 	bl	800ba2c <PQCLEAN_FIRESABER_CLEAN_verify>
 800a0d6:	4603      	mov	r3, r0
 800a0d8:	f887 3657 	strb.w	r3, [r7, #1623]	; 0x657

    sha3_256(kr + 32, c, SABER_BYTES_CCA_DEC); // overwrite coins in kr with h(c)
 800a0dc:	f107 0314 	add.w	r3, r7, #20
 800a0e0:	3320      	adds	r3, #32
 800a0e2:	f107 0108 	add.w	r1, r7, #8
 800a0e6:	f44f 62b8 	mov.w	r2, #1472	; 0x5c0
 800a0ea:	6809      	ldr	r1, [r1, #0]
 800a0ec:	4618      	mov	r0, r3
 800a0ee:	f7ff fa0d 	bl	800950c <sha3_256>

    PQCLEAN_FIRESABER_CLEAN_cmov(kr, sk + SABER_SECRETKEYBYTES - SABER_KEYBYTES, SABER_KEYBYTES, fail);
 800a0f2:	1d3b      	adds	r3, r7, #4
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	f503 613c 	add.w	r1, r3, #3008	; 0xbc0
 800a0fa:	f897 3657 	ldrb.w	r3, [r7, #1623]	; 0x657
 800a0fe:	f107 0014 	add.w	r0, r7, #20
 800a102:	2220      	movs	r2, #32
 800a104:	f001 fcd7 	bl	800bab6 <PQCLEAN_FIRESABER_CLEAN_cmov>

    sha3_256(k, kr, 64); // hash concatenation of pre-k and h(c) to k
 800a108:	f107 0114 	add.w	r1, r7, #20
 800a10c:	f107 030c 	add.w	r3, r7, #12
 800a110:	2240      	movs	r2, #64	; 0x40
 800a112:	6818      	ldr	r0, [r3, #0]
 800a114:	f7ff f9fa 	bl	800950c <sha3_256>

    return (0);
 800a118:	2300      	movs	r3, #0
}
 800a11a:	4618      	mov	r0, r3
 800a11c:	f507 67cc 	add.w	r7, r7, #1632	; 0x660
 800a120:	46bd      	mov	sp, r7
 800a122:	bd80      	pop	{r7, pc}

0800a124 <PQCLEAN_FIRESABER_CLEAN_POLT2BS>:
#include "SABER_params.h"
#include "pack_unpack.h"
#include "poly.h"
#include <string.h>

void PQCLEAN_FIRESABER_CLEAN_POLT2BS(uint8_t bytes[SABER_SCALEBYTES_KEM], const poly *data) {
 800a124:	b480      	push	{r7}
 800a126:	b087      	sub	sp, #28
 800a128:	af00      	add	r7, sp, #0
 800a12a:	6078      	str	r0, [r7, #4]
 800a12c:	6039      	str	r1, [r7, #0]
    size_t j;
    const uint16_t *in = data->coeffs;
 800a12e:	683b      	ldr	r3, [r7, #0]
 800a130:	613b      	str	r3, [r7, #16]
    uint8_t *out = bytes;
 800a132:	687b      	ldr	r3, [r7, #4]
 800a134:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a136:	2300      	movs	r3, #0
 800a138:	617b      	str	r3, [r7, #20]
 800a13a:	e040      	b.n	800a1be <PQCLEAN_FIRESABER_CLEAN_POLT2BS+0x9a>
        out[0] = (uint8_t) ((in[0] & 0x3f) | (in[1] << 6));
 800a13c:	693b      	ldr	r3, [r7, #16]
 800a13e:	881b      	ldrh	r3, [r3, #0]
 800a140:	b25b      	sxtb	r3, r3
 800a142:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a146:	b25a      	sxtb	r2, r3
 800a148:	693b      	ldr	r3, [r7, #16]
 800a14a:	3302      	adds	r3, #2
 800a14c:	881b      	ldrh	r3, [r3, #0]
 800a14e:	019b      	lsls	r3, r3, #6
 800a150:	b25b      	sxtb	r3, r3
 800a152:	4313      	orrs	r3, r2
 800a154:	b25b      	sxtb	r3, r3
 800a156:	b2da      	uxtb	r2, r3
 800a158:	68fb      	ldr	r3, [r7, #12]
 800a15a:	701a      	strb	r2, [r3, #0]
        out[1] = (uint8_t) (((in[1] >> 2) & 0x0f) | (in[2] << 4));
 800a15c:	693b      	ldr	r3, [r7, #16]
 800a15e:	3302      	adds	r3, #2
 800a160:	881b      	ldrh	r3, [r3, #0]
 800a162:	089b      	lsrs	r3, r3, #2
 800a164:	b29b      	uxth	r3, r3
 800a166:	b25b      	sxtb	r3, r3
 800a168:	f003 030f 	and.w	r3, r3, #15
 800a16c:	b25a      	sxtb	r2, r3
 800a16e:	693b      	ldr	r3, [r7, #16]
 800a170:	3304      	adds	r3, #4
 800a172:	881b      	ldrh	r3, [r3, #0]
 800a174:	011b      	lsls	r3, r3, #4
 800a176:	b25b      	sxtb	r3, r3
 800a178:	4313      	orrs	r3, r2
 800a17a:	b25a      	sxtb	r2, r3
 800a17c:	68fb      	ldr	r3, [r7, #12]
 800a17e:	3301      	adds	r3, #1
 800a180:	b2d2      	uxtb	r2, r2
 800a182:	701a      	strb	r2, [r3, #0]
        out[2] = (uint8_t) (((in[2] >> 4) & 0x03) | (in[3] << 2));
 800a184:	693b      	ldr	r3, [r7, #16]
 800a186:	3304      	adds	r3, #4
 800a188:	881b      	ldrh	r3, [r3, #0]
 800a18a:	091b      	lsrs	r3, r3, #4
 800a18c:	b29b      	uxth	r3, r3
 800a18e:	b25b      	sxtb	r3, r3
 800a190:	f003 0303 	and.w	r3, r3, #3
 800a194:	b25a      	sxtb	r2, r3
 800a196:	693b      	ldr	r3, [r7, #16]
 800a198:	3306      	adds	r3, #6
 800a19a:	881b      	ldrh	r3, [r3, #0]
 800a19c:	009b      	lsls	r3, r3, #2
 800a19e:	b25b      	sxtb	r3, r3
 800a1a0:	4313      	orrs	r3, r2
 800a1a2:	b25a      	sxtb	r2, r3
 800a1a4:	68fb      	ldr	r3, [r7, #12]
 800a1a6:	3302      	adds	r3, #2
 800a1a8:	b2d2      	uxtb	r2, r2
 800a1aa:	701a      	strb	r2, [r3, #0]
        in += 4;
 800a1ac:	693b      	ldr	r3, [r7, #16]
 800a1ae:	3308      	adds	r3, #8
 800a1b0:	613b      	str	r3, [r7, #16]
        out += 3;
 800a1b2:	68fb      	ldr	r3, [r7, #12]
 800a1b4:	3303      	adds	r3, #3
 800a1b6:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a1b8:	697b      	ldr	r3, [r7, #20]
 800a1ba:	3301      	adds	r3, #1
 800a1bc:	617b      	str	r3, [r7, #20]
 800a1be:	697b      	ldr	r3, [r7, #20]
 800a1c0:	2b3f      	cmp	r3, #63	; 0x3f
 800a1c2:	d9bb      	bls.n	800a13c <PQCLEAN_FIRESABER_CLEAN_POLT2BS+0x18>
    }
}
 800a1c4:	bf00      	nop
 800a1c6:	371c      	adds	r7, #28
 800a1c8:	46bd      	mov	sp, r7
 800a1ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a1ce:	4770      	bx	lr

0800a1d0 <PQCLEAN_FIRESABER_CLEAN_BS2POLT>:

void PQCLEAN_FIRESABER_CLEAN_BS2POLT(poly *data, const uint8_t bytes[SABER_SCALEBYTES_KEM]) {
 800a1d0:	b480      	push	{r7}
 800a1d2:	b087      	sub	sp, #28
 800a1d4:	af00      	add	r7, sp, #0
 800a1d6:	6078      	str	r0, [r7, #4]
 800a1d8:	6039      	str	r1, [r7, #0]
    /* This function does not reduce its output mod T */
    size_t j;
    const uint8_t *in = bytes;
 800a1da:	683b      	ldr	r3, [r7, #0]
 800a1dc:	613b      	str	r3, [r7, #16]
    uint16_t *out = data->coeffs;
 800a1de:	687b      	ldr	r3, [r7, #4]
 800a1e0:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a1e2:	2300      	movs	r3, #0
 800a1e4:	617b      	str	r3, [r7, #20]
 800a1e6:	e037      	b.n	800a258 <PQCLEAN_FIRESABER_CLEAN_BS2POLT+0x88>
        out[0] = in[0];
 800a1e8:	693b      	ldr	r3, [r7, #16]
 800a1ea:	781b      	ldrb	r3, [r3, #0]
 800a1ec:	b29a      	uxth	r2, r3
 800a1ee:	68fb      	ldr	r3, [r7, #12]
 800a1f0:	801a      	strh	r2, [r3, #0]
        out[1] = (in[0] >> 6) | (in[1] << 2);
 800a1f2:	693b      	ldr	r3, [r7, #16]
 800a1f4:	781b      	ldrb	r3, [r3, #0]
 800a1f6:	099b      	lsrs	r3, r3, #6
 800a1f8:	b2db      	uxtb	r3, r3
 800a1fa:	b21a      	sxth	r2, r3
 800a1fc:	693b      	ldr	r3, [r7, #16]
 800a1fe:	3301      	adds	r3, #1
 800a200:	781b      	ldrb	r3, [r3, #0]
 800a202:	009b      	lsls	r3, r3, #2
 800a204:	b21b      	sxth	r3, r3
 800a206:	4313      	orrs	r3, r2
 800a208:	b21a      	sxth	r2, r3
 800a20a:	68fb      	ldr	r3, [r7, #12]
 800a20c:	3302      	adds	r3, #2
 800a20e:	b292      	uxth	r2, r2
 800a210:	801a      	strh	r2, [r3, #0]
        out[2] = (in[1] >> 4) | (in[2] << 4);
 800a212:	693b      	ldr	r3, [r7, #16]
 800a214:	3301      	adds	r3, #1
 800a216:	781b      	ldrb	r3, [r3, #0]
 800a218:	091b      	lsrs	r3, r3, #4
 800a21a:	b2db      	uxtb	r3, r3
 800a21c:	b21a      	sxth	r2, r3
 800a21e:	693b      	ldr	r3, [r7, #16]
 800a220:	3302      	adds	r3, #2
 800a222:	781b      	ldrb	r3, [r3, #0]
 800a224:	011b      	lsls	r3, r3, #4
 800a226:	b21b      	sxth	r3, r3
 800a228:	4313      	orrs	r3, r2
 800a22a:	b21a      	sxth	r2, r3
 800a22c:	68fb      	ldr	r3, [r7, #12]
 800a22e:	3304      	adds	r3, #4
 800a230:	b292      	uxth	r2, r2
 800a232:	801a      	strh	r2, [r3, #0]
        out[3] = (in[2] >> 2);
 800a234:	693b      	ldr	r3, [r7, #16]
 800a236:	3302      	adds	r3, #2
 800a238:	781b      	ldrb	r3, [r3, #0]
 800a23a:	089b      	lsrs	r3, r3, #2
 800a23c:	b2da      	uxtb	r2, r3
 800a23e:	68fb      	ldr	r3, [r7, #12]
 800a240:	3306      	adds	r3, #6
 800a242:	b292      	uxth	r2, r2
 800a244:	801a      	strh	r2, [r3, #0]
        in += 3;
 800a246:	693b      	ldr	r3, [r7, #16]
 800a248:	3303      	adds	r3, #3
 800a24a:	613b      	str	r3, [r7, #16]
        out += 4;
 800a24c:	68fb      	ldr	r3, [r7, #12]
 800a24e:	3308      	adds	r3, #8
 800a250:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a252:	697b      	ldr	r3, [r7, #20]
 800a254:	3301      	adds	r3, #1
 800a256:	617b      	str	r3, [r7, #20]
 800a258:	697b      	ldr	r3, [r7, #20]
 800a25a:	2b3f      	cmp	r3, #63	; 0x3f
 800a25c:	d9c4      	bls.n	800a1e8 <PQCLEAN_FIRESABER_CLEAN_BS2POLT+0x18>
    }
}
 800a25e:	bf00      	nop
 800a260:	371c      	adds	r7, #28
 800a262:	46bd      	mov	sp, r7
 800a264:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a268:	4770      	bx	lr

0800a26a <POLq2BS>:

static void POLq2BS(uint8_t bytes[SABER_POLYBYTES], const poly *data) {
 800a26a:	b480      	push	{r7}
 800a26c:	b087      	sub	sp, #28
 800a26e:	af00      	add	r7, sp, #0
 800a270:	6078      	str	r0, [r7, #4]
 800a272:	6039      	str	r1, [r7, #0]
    size_t j;
    const uint16_t *in = data->coeffs;
 800a274:	683b      	ldr	r3, [r7, #0]
 800a276:	613b      	str	r3, [r7, #16]
    uint8_t *out = bytes;
 800a278:	687b      	ldr	r3, [r7, #4]
 800a27a:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 8; j++) {
 800a27c:	2300      	movs	r3, #0
 800a27e:	617b      	str	r3, [r7, #20]
 800a280:	e0c5      	b.n	800a40e <POLq2BS+0x1a4>
        out[0] = (uint8_t) (in[0]);
 800a282:	693b      	ldr	r3, [r7, #16]
 800a284:	881b      	ldrh	r3, [r3, #0]
 800a286:	b2da      	uxtb	r2, r3
 800a288:	68fb      	ldr	r3, [r7, #12]
 800a28a:	701a      	strb	r2, [r3, #0]
        out[1] = (uint8_t) (((in[0] >> 8) & 0x1f) | (in[1] << 5));
 800a28c:	693b      	ldr	r3, [r7, #16]
 800a28e:	881b      	ldrh	r3, [r3, #0]
 800a290:	0a1b      	lsrs	r3, r3, #8
 800a292:	b29b      	uxth	r3, r3
 800a294:	b25b      	sxtb	r3, r3
 800a296:	f003 031f 	and.w	r3, r3, #31
 800a29a:	b25a      	sxtb	r2, r3
 800a29c:	693b      	ldr	r3, [r7, #16]
 800a29e:	3302      	adds	r3, #2
 800a2a0:	881b      	ldrh	r3, [r3, #0]
 800a2a2:	015b      	lsls	r3, r3, #5
 800a2a4:	b25b      	sxtb	r3, r3
 800a2a6:	4313      	orrs	r3, r2
 800a2a8:	b25a      	sxtb	r2, r3
 800a2aa:	68fb      	ldr	r3, [r7, #12]
 800a2ac:	3301      	adds	r3, #1
 800a2ae:	b2d2      	uxtb	r2, r2
 800a2b0:	701a      	strb	r2, [r3, #0]
        out[2] = (uint8_t) (in[1] >> 3);
 800a2b2:	693b      	ldr	r3, [r7, #16]
 800a2b4:	3302      	adds	r3, #2
 800a2b6:	881b      	ldrh	r3, [r3, #0]
 800a2b8:	08db      	lsrs	r3, r3, #3
 800a2ba:	b29a      	uxth	r2, r3
 800a2bc:	68fb      	ldr	r3, [r7, #12]
 800a2be:	3302      	adds	r3, #2
 800a2c0:	b2d2      	uxtb	r2, r2
 800a2c2:	701a      	strb	r2, [r3, #0]
        out[3] = (uint8_t) (((in[1] >> 11) & 0x03) | (in[2] << 2));
 800a2c4:	693b      	ldr	r3, [r7, #16]
 800a2c6:	3302      	adds	r3, #2
 800a2c8:	881b      	ldrh	r3, [r3, #0]
 800a2ca:	0adb      	lsrs	r3, r3, #11
 800a2cc:	b29b      	uxth	r3, r3
 800a2ce:	b25b      	sxtb	r3, r3
 800a2d0:	f003 0303 	and.w	r3, r3, #3
 800a2d4:	b25a      	sxtb	r2, r3
 800a2d6:	693b      	ldr	r3, [r7, #16]
 800a2d8:	3304      	adds	r3, #4
 800a2da:	881b      	ldrh	r3, [r3, #0]
 800a2dc:	009b      	lsls	r3, r3, #2
 800a2de:	b25b      	sxtb	r3, r3
 800a2e0:	4313      	orrs	r3, r2
 800a2e2:	b25a      	sxtb	r2, r3
 800a2e4:	68fb      	ldr	r3, [r7, #12]
 800a2e6:	3303      	adds	r3, #3
 800a2e8:	b2d2      	uxtb	r2, r2
 800a2ea:	701a      	strb	r2, [r3, #0]
        out[4] = (uint8_t) (((in[2] >> 6) & 0x7f) | (in[3] << 7));
 800a2ec:	693b      	ldr	r3, [r7, #16]
 800a2ee:	3304      	adds	r3, #4
 800a2f0:	881b      	ldrh	r3, [r3, #0]
 800a2f2:	099b      	lsrs	r3, r3, #6
 800a2f4:	b29b      	uxth	r3, r3
 800a2f6:	b25b      	sxtb	r3, r3
 800a2f8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800a2fc:	b25a      	sxtb	r2, r3
 800a2fe:	693b      	ldr	r3, [r7, #16]
 800a300:	3306      	adds	r3, #6
 800a302:	881b      	ldrh	r3, [r3, #0]
 800a304:	01db      	lsls	r3, r3, #7
 800a306:	b25b      	sxtb	r3, r3
 800a308:	4313      	orrs	r3, r2
 800a30a:	b25a      	sxtb	r2, r3
 800a30c:	68fb      	ldr	r3, [r7, #12]
 800a30e:	3304      	adds	r3, #4
 800a310:	b2d2      	uxtb	r2, r2
 800a312:	701a      	strb	r2, [r3, #0]
        out[5] = (uint8_t) (in[3] >> 1);
 800a314:	693b      	ldr	r3, [r7, #16]
 800a316:	3306      	adds	r3, #6
 800a318:	881b      	ldrh	r3, [r3, #0]
 800a31a:	085b      	lsrs	r3, r3, #1
 800a31c:	b29a      	uxth	r2, r3
 800a31e:	68fb      	ldr	r3, [r7, #12]
 800a320:	3305      	adds	r3, #5
 800a322:	b2d2      	uxtb	r2, r2
 800a324:	701a      	strb	r2, [r3, #0]
        out[6] = (uint8_t) (((in[3] >> 9) & 0x0f) | (in[4] << 4));
 800a326:	693b      	ldr	r3, [r7, #16]
 800a328:	3306      	adds	r3, #6
 800a32a:	881b      	ldrh	r3, [r3, #0]
 800a32c:	0a5b      	lsrs	r3, r3, #9
 800a32e:	b29b      	uxth	r3, r3
 800a330:	b25b      	sxtb	r3, r3
 800a332:	f003 030f 	and.w	r3, r3, #15
 800a336:	b25a      	sxtb	r2, r3
 800a338:	693b      	ldr	r3, [r7, #16]
 800a33a:	3308      	adds	r3, #8
 800a33c:	881b      	ldrh	r3, [r3, #0]
 800a33e:	011b      	lsls	r3, r3, #4
 800a340:	b25b      	sxtb	r3, r3
 800a342:	4313      	orrs	r3, r2
 800a344:	b25a      	sxtb	r2, r3
 800a346:	68fb      	ldr	r3, [r7, #12]
 800a348:	3306      	adds	r3, #6
 800a34a:	b2d2      	uxtb	r2, r2
 800a34c:	701a      	strb	r2, [r3, #0]
        out[7] = (uint8_t) (in[4] >> 4);
 800a34e:	693b      	ldr	r3, [r7, #16]
 800a350:	3308      	adds	r3, #8
 800a352:	881b      	ldrh	r3, [r3, #0]
 800a354:	091b      	lsrs	r3, r3, #4
 800a356:	b29a      	uxth	r2, r3
 800a358:	68fb      	ldr	r3, [r7, #12]
 800a35a:	3307      	adds	r3, #7
 800a35c:	b2d2      	uxtb	r2, r2
 800a35e:	701a      	strb	r2, [r3, #0]
        out[8] = (uint8_t) (((in[4] >> 12) & 0x01) | (in[5] << 1));
 800a360:	693b      	ldr	r3, [r7, #16]
 800a362:	3308      	adds	r3, #8
 800a364:	881b      	ldrh	r3, [r3, #0]
 800a366:	0b1b      	lsrs	r3, r3, #12
 800a368:	b29b      	uxth	r3, r3
 800a36a:	b25b      	sxtb	r3, r3
 800a36c:	f003 0301 	and.w	r3, r3, #1
 800a370:	b25a      	sxtb	r2, r3
 800a372:	693b      	ldr	r3, [r7, #16]
 800a374:	330a      	adds	r3, #10
 800a376:	881b      	ldrh	r3, [r3, #0]
 800a378:	005b      	lsls	r3, r3, #1
 800a37a:	b25b      	sxtb	r3, r3
 800a37c:	4313      	orrs	r3, r2
 800a37e:	b25a      	sxtb	r2, r3
 800a380:	68fb      	ldr	r3, [r7, #12]
 800a382:	3308      	adds	r3, #8
 800a384:	b2d2      	uxtb	r2, r2
 800a386:	701a      	strb	r2, [r3, #0]
        out[9] = (uint8_t) (((in[5] >> 7) & 0x3f) | (in[6] << 6));
 800a388:	693b      	ldr	r3, [r7, #16]
 800a38a:	330a      	adds	r3, #10
 800a38c:	881b      	ldrh	r3, [r3, #0]
 800a38e:	09db      	lsrs	r3, r3, #7
 800a390:	b29b      	uxth	r3, r3
 800a392:	b25b      	sxtb	r3, r3
 800a394:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a398:	b25a      	sxtb	r2, r3
 800a39a:	693b      	ldr	r3, [r7, #16]
 800a39c:	330c      	adds	r3, #12
 800a39e:	881b      	ldrh	r3, [r3, #0]
 800a3a0:	019b      	lsls	r3, r3, #6
 800a3a2:	b25b      	sxtb	r3, r3
 800a3a4:	4313      	orrs	r3, r2
 800a3a6:	b25a      	sxtb	r2, r3
 800a3a8:	68fb      	ldr	r3, [r7, #12]
 800a3aa:	3309      	adds	r3, #9
 800a3ac:	b2d2      	uxtb	r2, r2
 800a3ae:	701a      	strb	r2, [r3, #0]
        out[10] = (uint8_t) (in[6] >> 2);
 800a3b0:	693b      	ldr	r3, [r7, #16]
 800a3b2:	330c      	adds	r3, #12
 800a3b4:	881b      	ldrh	r3, [r3, #0]
 800a3b6:	089b      	lsrs	r3, r3, #2
 800a3b8:	b29a      	uxth	r2, r3
 800a3ba:	68fb      	ldr	r3, [r7, #12]
 800a3bc:	330a      	adds	r3, #10
 800a3be:	b2d2      	uxtb	r2, r2
 800a3c0:	701a      	strb	r2, [r3, #0]
        out[11] = (uint8_t) (((in[6] >> 10) & 0x07) | (in[7] << 3));
 800a3c2:	693b      	ldr	r3, [r7, #16]
 800a3c4:	330c      	adds	r3, #12
 800a3c6:	881b      	ldrh	r3, [r3, #0]
 800a3c8:	0a9b      	lsrs	r3, r3, #10
 800a3ca:	b29b      	uxth	r3, r3
 800a3cc:	b25b      	sxtb	r3, r3
 800a3ce:	f003 0307 	and.w	r3, r3, #7
 800a3d2:	b25a      	sxtb	r2, r3
 800a3d4:	693b      	ldr	r3, [r7, #16]
 800a3d6:	330e      	adds	r3, #14
 800a3d8:	881b      	ldrh	r3, [r3, #0]
 800a3da:	00db      	lsls	r3, r3, #3
 800a3dc:	b25b      	sxtb	r3, r3
 800a3de:	4313      	orrs	r3, r2
 800a3e0:	b25a      	sxtb	r2, r3
 800a3e2:	68fb      	ldr	r3, [r7, #12]
 800a3e4:	330b      	adds	r3, #11
 800a3e6:	b2d2      	uxtb	r2, r2
 800a3e8:	701a      	strb	r2, [r3, #0]
        out[12] = (uint8_t) (in[7] >> 5);
 800a3ea:	693b      	ldr	r3, [r7, #16]
 800a3ec:	330e      	adds	r3, #14
 800a3ee:	881b      	ldrh	r3, [r3, #0]
 800a3f0:	095b      	lsrs	r3, r3, #5
 800a3f2:	b29a      	uxth	r2, r3
 800a3f4:	68fb      	ldr	r3, [r7, #12]
 800a3f6:	330c      	adds	r3, #12
 800a3f8:	b2d2      	uxtb	r2, r2
 800a3fa:	701a      	strb	r2, [r3, #0]
        in += 8;
 800a3fc:	693b      	ldr	r3, [r7, #16]
 800a3fe:	3310      	adds	r3, #16
 800a400:	613b      	str	r3, [r7, #16]
        out += 13;
 800a402:	68fb      	ldr	r3, [r7, #12]
 800a404:	330d      	adds	r3, #13
 800a406:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 8; j++) {
 800a408:	697b      	ldr	r3, [r7, #20]
 800a40a:	3301      	adds	r3, #1
 800a40c:	617b      	str	r3, [r7, #20]
 800a40e:	697b      	ldr	r3, [r7, #20]
 800a410:	2b1f      	cmp	r3, #31
 800a412:	f67f af36 	bls.w	800a282 <POLq2BS+0x18>
    }
}
 800a416:	bf00      	nop
 800a418:	371c      	adds	r7, #28
 800a41a:	46bd      	mov	sp, r7
 800a41c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a420:	4770      	bx	lr

0800a422 <BS2POLq>:

static void BS2POLq(poly *data, const uint8_t bytes[SABER_POLYBYTES]) {
 800a422:	b480      	push	{r7}
 800a424:	b087      	sub	sp, #28
 800a426:	af00      	add	r7, sp, #0
 800a428:	6078      	str	r0, [r7, #4]
 800a42a:	6039      	str	r1, [r7, #0]
    /* This function does not reduce its output mod Q */
    size_t j;
    const uint8_t *in = bytes;
 800a42c:	683b      	ldr	r3, [r7, #0]
 800a42e:	613b      	str	r3, [r7, #16]
    uint16_t *out = data->coeffs;
 800a430:	687b      	ldr	r3, [r7, #4]
 800a432:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 8; j++) {
 800a434:	2300      	movs	r3, #0
 800a436:	617b      	str	r3, [r7, #20]
 800a438:	e0a8      	b.n	800a58c <BS2POLq+0x16a>
        out[0] = (in[0]) | (in[1] << 8);
 800a43a:	693b      	ldr	r3, [r7, #16]
 800a43c:	781b      	ldrb	r3, [r3, #0]
 800a43e:	b21a      	sxth	r2, r3
 800a440:	693b      	ldr	r3, [r7, #16]
 800a442:	3301      	adds	r3, #1
 800a444:	781b      	ldrb	r3, [r3, #0]
 800a446:	021b      	lsls	r3, r3, #8
 800a448:	b21b      	sxth	r3, r3
 800a44a:	4313      	orrs	r3, r2
 800a44c:	b21b      	sxth	r3, r3
 800a44e:	b29a      	uxth	r2, r3
 800a450:	68fb      	ldr	r3, [r7, #12]
 800a452:	801a      	strh	r2, [r3, #0]
        out[1] = (in[1] >> 5) | (in[2] << 3) | (in[3] << 11);
 800a454:	693b      	ldr	r3, [r7, #16]
 800a456:	3301      	adds	r3, #1
 800a458:	781b      	ldrb	r3, [r3, #0]
 800a45a:	095b      	lsrs	r3, r3, #5
 800a45c:	b2db      	uxtb	r3, r3
 800a45e:	b21a      	sxth	r2, r3
 800a460:	693b      	ldr	r3, [r7, #16]
 800a462:	3302      	adds	r3, #2
 800a464:	781b      	ldrb	r3, [r3, #0]
 800a466:	00db      	lsls	r3, r3, #3
 800a468:	b21b      	sxth	r3, r3
 800a46a:	4313      	orrs	r3, r2
 800a46c:	b21a      	sxth	r2, r3
 800a46e:	693b      	ldr	r3, [r7, #16]
 800a470:	3303      	adds	r3, #3
 800a472:	781b      	ldrb	r3, [r3, #0]
 800a474:	02db      	lsls	r3, r3, #11
 800a476:	b21b      	sxth	r3, r3
 800a478:	4313      	orrs	r3, r2
 800a47a:	b21a      	sxth	r2, r3
 800a47c:	68fb      	ldr	r3, [r7, #12]
 800a47e:	3302      	adds	r3, #2
 800a480:	b292      	uxth	r2, r2
 800a482:	801a      	strh	r2, [r3, #0]
        out[2] = (in[3] >> 2) | (in[4] << 6);
 800a484:	693b      	ldr	r3, [r7, #16]
 800a486:	3303      	adds	r3, #3
 800a488:	781b      	ldrb	r3, [r3, #0]
 800a48a:	089b      	lsrs	r3, r3, #2
 800a48c:	b2db      	uxtb	r3, r3
 800a48e:	b21a      	sxth	r2, r3
 800a490:	693b      	ldr	r3, [r7, #16]
 800a492:	3304      	adds	r3, #4
 800a494:	781b      	ldrb	r3, [r3, #0]
 800a496:	019b      	lsls	r3, r3, #6
 800a498:	b21b      	sxth	r3, r3
 800a49a:	4313      	orrs	r3, r2
 800a49c:	b21a      	sxth	r2, r3
 800a49e:	68fb      	ldr	r3, [r7, #12]
 800a4a0:	3304      	adds	r3, #4
 800a4a2:	b292      	uxth	r2, r2
 800a4a4:	801a      	strh	r2, [r3, #0]
        out[3] = (in[4] >> 7) | (in[5] << 1) | (in[6] << 9);
 800a4a6:	693b      	ldr	r3, [r7, #16]
 800a4a8:	3304      	adds	r3, #4
 800a4aa:	781b      	ldrb	r3, [r3, #0]
 800a4ac:	09db      	lsrs	r3, r3, #7
 800a4ae:	b2db      	uxtb	r3, r3
 800a4b0:	b21a      	sxth	r2, r3
 800a4b2:	693b      	ldr	r3, [r7, #16]
 800a4b4:	3305      	adds	r3, #5
 800a4b6:	781b      	ldrb	r3, [r3, #0]
 800a4b8:	005b      	lsls	r3, r3, #1
 800a4ba:	b21b      	sxth	r3, r3
 800a4bc:	4313      	orrs	r3, r2
 800a4be:	b21a      	sxth	r2, r3
 800a4c0:	693b      	ldr	r3, [r7, #16]
 800a4c2:	3306      	adds	r3, #6
 800a4c4:	781b      	ldrb	r3, [r3, #0]
 800a4c6:	025b      	lsls	r3, r3, #9
 800a4c8:	b21b      	sxth	r3, r3
 800a4ca:	4313      	orrs	r3, r2
 800a4cc:	b21a      	sxth	r2, r3
 800a4ce:	68fb      	ldr	r3, [r7, #12]
 800a4d0:	3306      	adds	r3, #6
 800a4d2:	b292      	uxth	r2, r2
 800a4d4:	801a      	strh	r2, [r3, #0]
        out[4] = (in[6] >> 4) | (in[7] << 4) | (in[8] << 12);
 800a4d6:	693b      	ldr	r3, [r7, #16]
 800a4d8:	3306      	adds	r3, #6
 800a4da:	781b      	ldrb	r3, [r3, #0]
 800a4dc:	091b      	lsrs	r3, r3, #4
 800a4de:	b2db      	uxtb	r3, r3
 800a4e0:	b21a      	sxth	r2, r3
 800a4e2:	693b      	ldr	r3, [r7, #16]
 800a4e4:	3307      	adds	r3, #7
 800a4e6:	781b      	ldrb	r3, [r3, #0]
 800a4e8:	011b      	lsls	r3, r3, #4
 800a4ea:	b21b      	sxth	r3, r3
 800a4ec:	4313      	orrs	r3, r2
 800a4ee:	b21a      	sxth	r2, r3
 800a4f0:	693b      	ldr	r3, [r7, #16]
 800a4f2:	3308      	adds	r3, #8
 800a4f4:	781b      	ldrb	r3, [r3, #0]
 800a4f6:	031b      	lsls	r3, r3, #12
 800a4f8:	b21b      	sxth	r3, r3
 800a4fa:	4313      	orrs	r3, r2
 800a4fc:	b21a      	sxth	r2, r3
 800a4fe:	68fb      	ldr	r3, [r7, #12]
 800a500:	3308      	adds	r3, #8
 800a502:	b292      	uxth	r2, r2
 800a504:	801a      	strh	r2, [r3, #0]
        out[5] = (in[8] >> 1) | (in[9] << 7);
 800a506:	693b      	ldr	r3, [r7, #16]
 800a508:	3308      	adds	r3, #8
 800a50a:	781b      	ldrb	r3, [r3, #0]
 800a50c:	085b      	lsrs	r3, r3, #1
 800a50e:	b2db      	uxtb	r3, r3
 800a510:	b21a      	sxth	r2, r3
 800a512:	693b      	ldr	r3, [r7, #16]
 800a514:	3309      	adds	r3, #9
 800a516:	781b      	ldrb	r3, [r3, #0]
 800a518:	01db      	lsls	r3, r3, #7
 800a51a:	b21b      	sxth	r3, r3
 800a51c:	4313      	orrs	r3, r2
 800a51e:	b21a      	sxth	r2, r3
 800a520:	68fb      	ldr	r3, [r7, #12]
 800a522:	330a      	adds	r3, #10
 800a524:	b292      	uxth	r2, r2
 800a526:	801a      	strh	r2, [r3, #0]
        out[6] = (in[9] >> 6) | (in[10] << 2) | (in[11] << 10);
 800a528:	693b      	ldr	r3, [r7, #16]
 800a52a:	3309      	adds	r3, #9
 800a52c:	781b      	ldrb	r3, [r3, #0]
 800a52e:	099b      	lsrs	r3, r3, #6
 800a530:	b2db      	uxtb	r3, r3
 800a532:	b21a      	sxth	r2, r3
 800a534:	693b      	ldr	r3, [r7, #16]
 800a536:	330a      	adds	r3, #10
 800a538:	781b      	ldrb	r3, [r3, #0]
 800a53a:	009b      	lsls	r3, r3, #2
 800a53c:	b21b      	sxth	r3, r3
 800a53e:	4313      	orrs	r3, r2
 800a540:	b21a      	sxth	r2, r3
 800a542:	693b      	ldr	r3, [r7, #16]
 800a544:	330b      	adds	r3, #11
 800a546:	781b      	ldrb	r3, [r3, #0]
 800a548:	029b      	lsls	r3, r3, #10
 800a54a:	b21b      	sxth	r3, r3
 800a54c:	4313      	orrs	r3, r2
 800a54e:	b21a      	sxth	r2, r3
 800a550:	68fb      	ldr	r3, [r7, #12]
 800a552:	330c      	adds	r3, #12
 800a554:	b292      	uxth	r2, r2
 800a556:	801a      	strh	r2, [r3, #0]
        out[7] = (in[11] >> 3) | (in[12] << 5);
 800a558:	693b      	ldr	r3, [r7, #16]
 800a55a:	330b      	adds	r3, #11
 800a55c:	781b      	ldrb	r3, [r3, #0]
 800a55e:	08db      	lsrs	r3, r3, #3
 800a560:	b2db      	uxtb	r3, r3
 800a562:	b21a      	sxth	r2, r3
 800a564:	693b      	ldr	r3, [r7, #16]
 800a566:	330c      	adds	r3, #12
 800a568:	781b      	ldrb	r3, [r3, #0]
 800a56a:	015b      	lsls	r3, r3, #5
 800a56c:	b21b      	sxth	r3, r3
 800a56e:	4313      	orrs	r3, r2
 800a570:	b21a      	sxth	r2, r3
 800a572:	68fb      	ldr	r3, [r7, #12]
 800a574:	330e      	adds	r3, #14
 800a576:	b292      	uxth	r2, r2
 800a578:	801a      	strh	r2, [r3, #0]
        in += 13;
 800a57a:	693b      	ldr	r3, [r7, #16]
 800a57c:	330d      	adds	r3, #13
 800a57e:	613b      	str	r3, [r7, #16]
        out += 8;
 800a580:	68fb      	ldr	r3, [r7, #12]
 800a582:	3310      	adds	r3, #16
 800a584:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 8; j++) {
 800a586:	697b      	ldr	r3, [r7, #20]
 800a588:	3301      	adds	r3, #1
 800a58a:	617b      	str	r3, [r7, #20]
 800a58c:	697b      	ldr	r3, [r7, #20]
 800a58e:	2b1f      	cmp	r3, #31
 800a590:	f67f af53 	bls.w	800a43a <BS2POLq+0x18>
    }
}
 800a594:	bf00      	nop
 800a596:	371c      	adds	r7, #28
 800a598:	46bd      	mov	sp, r7
 800a59a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a59e:	4770      	bx	lr

0800a5a0 <POLp2BS>:

static void POLp2BS(uint8_t bytes[SABER_POLYCOMPRESSEDBYTES], const poly *data) {
 800a5a0:	b480      	push	{r7}
 800a5a2:	b087      	sub	sp, #28
 800a5a4:	af00      	add	r7, sp, #0
 800a5a6:	6078      	str	r0, [r7, #4]
 800a5a8:	6039      	str	r1, [r7, #0]
    size_t j;
    const uint16_t *in = data->coeffs;
 800a5aa:	683b      	ldr	r3, [r7, #0]
 800a5ac:	613b      	str	r3, [r7, #16]
    uint8_t *out = bytes;
 800a5ae:	687b      	ldr	r3, [r7, #4]
 800a5b0:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a5b2:	2300      	movs	r3, #0
 800a5b4:	617b      	str	r3, [r7, #20]
 800a5b6:	e051      	b.n	800a65c <POLp2BS+0xbc>
        out[0] = (uint8_t) (in[0]);
 800a5b8:	693b      	ldr	r3, [r7, #16]
 800a5ba:	881b      	ldrh	r3, [r3, #0]
 800a5bc:	b2da      	uxtb	r2, r3
 800a5be:	68fb      	ldr	r3, [r7, #12]
 800a5c0:	701a      	strb	r2, [r3, #0]
        out[1] = (uint8_t) (((in[0] >> 8) & 0x03) | (in[1] << 2));
 800a5c2:	693b      	ldr	r3, [r7, #16]
 800a5c4:	881b      	ldrh	r3, [r3, #0]
 800a5c6:	0a1b      	lsrs	r3, r3, #8
 800a5c8:	b29b      	uxth	r3, r3
 800a5ca:	b25b      	sxtb	r3, r3
 800a5cc:	f003 0303 	and.w	r3, r3, #3
 800a5d0:	b25a      	sxtb	r2, r3
 800a5d2:	693b      	ldr	r3, [r7, #16]
 800a5d4:	3302      	adds	r3, #2
 800a5d6:	881b      	ldrh	r3, [r3, #0]
 800a5d8:	009b      	lsls	r3, r3, #2
 800a5da:	b25b      	sxtb	r3, r3
 800a5dc:	4313      	orrs	r3, r2
 800a5de:	b25a      	sxtb	r2, r3
 800a5e0:	68fb      	ldr	r3, [r7, #12]
 800a5e2:	3301      	adds	r3, #1
 800a5e4:	b2d2      	uxtb	r2, r2
 800a5e6:	701a      	strb	r2, [r3, #0]
        out[2] = (uint8_t) (((in[1] >> 6) & 0x0f) | (in[2] << 4));
 800a5e8:	693b      	ldr	r3, [r7, #16]
 800a5ea:	3302      	adds	r3, #2
 800a5ec:	881b      	ldrh	r3, [r3, #0]
 800a5ee:	099b      	lsrs	r3, r3, #6
 800a5f0:	b29b      	uxth	r3, r3
 800a5f2:	b25b      	sxtb	r3, r3
 800a5f4:	f003 030f 	and.w	r3, r3, #15
 800a5f8:	b25a      	sxtb	r2, r3
 800a5fa:	693b      	ldr	r3, [r7, #16]
 800a5fc:	3304      	adds	r3, #4
 800a5fe:	881b      	ldrh	r3, [r3, #0]
 800a600:	011b      	lsls	r3, r3, #4
 800a602:	b25b      	sxtb	r3, r3
 800a604:	4313      	orrs	r3, r2
 800a606:	b25a      	sxtb	r2, r3
 800a608:	68fb      	ldr	r3, [r7, #12]
 800a60a:	3302      	adds	r3, #2
 800a60c:	b2d2      	uxtb	r2, r2
 800a60e:	701a      	strb	r2, [r3, #0]
        out[3] = (uint8_t) (((in[2] >> 4) & 0x3f) | (in[3] << 6));
 800a610:	693b      	ldr	r3, [r7, #16]
 800a612:	3304      	adds	r3, #4
 800a614:	881b      	ldrh	r3, [r3, #0]
 800a616:	091b      	lsrs	r3, r3, #4
 800a618:	b29b      	uxth	r3, r3
 800a61a:	b25b      	sxtb	r3, r3
 800a61c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a620:	b25a      	sxtb	r2, r3
 800a622:	693b      	ldr	r3, [r7, #16]
 800a624:	3306      	adds	r3, #6
 800a626:	881b      	ldrh	r3, [r3, #0]
 800a628:	019b      	lsls	r3, r3, #6
 800a62a:	b25b      	sxtb	r3, r3
 800a62c:	4313      	orrs	r3, r2
 800a62e:	b25a      	sxtb	r2, r3
 800a630:	68fb      	ldr	r3, [r7, #12]
 800a632:	3303      	adds	r3, #3
 800a634:	b2d2      	uxtb	r2, r2
 800a636:	701a      	strb	r2, [r3, #0]
        out[4] = (uint8_t) (in[3] >> 2);
 800a638:	693b      	ldr	r3, [r7, #16]
 800a63a:	3306      	adds	r3, #6
 800a63c:	881b      	ldrh	r3, [r3, #0]
 800a63e:	089b      	lsrs	r3, r3, #2
 800a640:	b29a      	uxth	r2, r3
 800a642:	68fb      	ldr	r3, [r7, #12]
 800a644:	3304      	adds	r3, #4
 800a646:	b2d2      	uxtb	r2, r2
 800a648:	701a      	strb	r2, [r3, #0]
        in += 4;
 800a64a:	693b      	ldr	r3, [r7, #16]
 800a64c:	3308      	adds	r3, #8
 800a64e:	613b      	str	r3, [r7, #16]
        out += 5;
 800a650:	68fb      	ldr	r3, [r7, #12]
 800a652:	3305      	adds	r3, #5
 800a654:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a656:	697b      	ldr	r3, [r7, #20]
 800a658:	3301      	adds	r3, #1
 800a65a:	617b      	str	r3, [r7, #20]
 800a65c:	697b      	ldr	r3, [r7, #20]
 800a65e:	2b3f      	cmp	r3, #63	; 0x3f
 800a660:	d9aa      	bls.n	800a5b8 <POLp2BS+0x18>
    }
}
 800a662:	bf00      	nop
 800a664:	371c      	adds	r7, #28
 800a666:	46bd      	mov	sp, r7
 800a668:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a66c:	4770      	bx	lr

0800a66e <BS2POLp>:

static void BS2POLp(poly *data, const uint8_t bytes[SABER_POLYCOMPRESSEDBYTES]) {
 800a66e:	b480      	push	{r7}
 800a670:	b087      	sub	sp, #28
 800a672:	af00      	add	r7, sp, #0
 800a674:	6078      	str	r0, [r7, #4]
 800a676:	6039      	str	r1, [r7, #0]
    size_t j;
    const uint8_t *in = bytes;
 800a678:	683b      	ldr	r3, [r7, #0]
 800a67a:	613b      	str	r3, [r7, #16]
    uint16_t *out = data->coeffs;
 800a67c:	687b      	ldr	r3, [r7, #4]
 800a67e:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a680:	2300      	movs	r3, #0
 800a682:	617b      	str	r3, [r7, #20]
 800a684:	e048      	b.n	800a718 <BS2POLp+0xaa>
        out[0] = in[0] | (in[1] << 8);
 800a686:	693b      	ldr	r3, [r7, #16]
 800a688:	781b      	ldrb	r3, [r3, #0]
 800a68a:	b21a      	sxth	r2, r3
 800a68c:	693b      	ldr	r3, [r7, #16]
 800a68e:	3301      	adds	r3, #1
 800a690:	781b      	ldrb	r3, [r3, #0]
 800a692:	021b      	lsls	r3, r3, #8
 800a694:	b21b      	sxth	r3, r3
 800a696:	4313      	orrs	r3, r2
 800a698:	b21b      	sxth	r3, r3
 800a69a:	b29a      	uxth	r2, r3
 800a69c:	68fb      	ldr	r3, [r7, #12]
 800a69e:	801a      	strh	r2, [r3, #0]
        out[1] = (in[1] >> 2) | (in[2] << 6);
 800a6a0:	693b      	ldr	r3, [r7, #16]
 800a6a2:	3301      	adds	r3, #1
 800a6a4:	781b      	ldrb	r3, [r3, #0]
 800a6a6:	089b      	lsrs	r3, r3, #2
 800a6a8:	b2db      	uxtb	r3, r3
 800a6aa:	b21a      	sxth	r2, r3
 800a6ac:	693b      	ldr	r3, [r7, #16]
 800a6ae:	3302      	adds	r3, #2
 800a6b0:	781b      	ldrb	r3, [r3, #0]
 800a6b2:	019b      	lsls	r3, r3, #6
 800a6b4:	b21b      	sxth	r3, r3
 800a6b6:	4313      	orrs	r3, r2
 800a6b8:	b21a      	sxth	r2, r3
 800a6ba:	68fb      	ldr	r3, [r7, #12]
 800a6bc:	3302      	adds	r3, #2
 800a6be:	b292      	uxth	r2, r2
 800a6c0:	801a      	strh	r2, [r3, #0]
        out[2] = (in[2] >> 4) | (in[3] << 4);
 800a6c2:	693b      	ldr	r3, [r7, #16]
 800a6c4:	3302      	adds	r3, #2
 800a6c6:	781b      	ldrb	r3, [r3, #0]
 800a6c8:	091b      	lsrs	r3, r3, #4
 800a6ca:	b2db      	uxtb	r3, r3
 800a6cc:	b21a      	sxth	r2, r3
 800a6ce:	693b      	ldr	r3, [r7, #16]
 800a6d0:	3303      	adds	r3, #3
 800a6d2:	781b      	ldrb	r3, [r3, #0]
 800a6d4:	011b      	lsls	r3, r3, #4
 800a6d6:	b21b      	sxth	r3, r3
 800a6d8:	4313      	orrs	r3, r2
 800a6da:	b21a      	sxth	r2, r3
 800a6dc:	68fb      	ldr	r3, [r7, #12]
 800a6de:	3304      	adds	r3, #4
 800a6e0:	b292      	uxth	r2, r2
 800a6e2:	801a      	strh	r2, [r3, #0]
        out[3] = (in[3] >> 6) | (in[4] << 2);
 800a6e4:	693b      	ldr	r3, [r7, #16]
 800a6e6:	3303      	adds	r3, #3
 800a6e8:	781b      	ldrb	r3, [r3, #0]
 800a6ea:	099b      	lsrs	r3, r3, #6
 800a6ec:	b2db      	uxtb	r3, r3
 800a6ee:	b21a      	sxth	r2, r3
 800a6f0:	693b      	ldr	r3, [r7, #16]
 800a6f2:	3304      	adds	r3, #4
 800a6f4:	781b      	ldrb	r3, [r3, #0]
 800a6f6:	009b      	lsls	r3, r3, #2
 800a6f8:	b21b      	sxth	r3, r3
 800a6fa:	4313      	orrs	r3, r2
 800a6fc:	b21a      	sxth	r2, r3
 800a6fe:	68fb      	ldr	r3, [r7, #12]
 800a700:	3306      	adds	r3, #6
 800a702:	b292      	uxth	r2, r2
 800a704:	801a      	strh	r2, [r3, #0]
        in += 5;
 800a706:	693b      	ldr	r3, [r7, #16]
 800a708:	3305      	adds	r3, #5
 800a70a:	613b      	str	r3, [r7, #16]
        out += 4;
 800a70c:	68fb      	ldr	r3, [r7, #12]
 800a70e:	3308      	adds	r3, #8
 800a710:	60fb      	str	r3, [r7, #12]
    for (j = 0; j < SABER_N / 4; j++) {
 800a712:	697b      	ldr	r3, [r7, #20]
 800a714:	3301      	adds	r3, #1
 800a716:	617b      	str	r3, [r7, #20]
 800a718:	697b      	ldr	r3, [r7, #20]
 800a71a:	2b3f      	cmp	r3, #63	; 0x3f
 800a71c:	d9b3      	bls.n	800a686 <BS2POLp+0x18>
    }
}
 800a71e:	bf00      	nop
 800a720:	371c      	adds	r7, #28
 800a722:	46bd      	mov	sp, r7
 800a724:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a728:	4770      	bx	lr

0800a72a <PQCLEAN_FIRESABER_CLEAN_POLVECq2BS>:

void PQCLEAN_FIRESABER_CLEAN_POLVECq2BS(uint8_t bytes[SABER_POLYVECBYTES], const poly data[SABER_L]) {
 800a72a:	b580      	push	{r7, lr}
 800a72c:	b084      	sub	sp, #16
 800a72e:	af00      	add	r7, sp, #0
 800a730:	6078      	str	r0, [r7, #4]
 800a732:	6039      	str	r1, [r7, #0]
    size_t i;
    for (i = 0; i < SABER_L; i++) {
 800a734:	2300      	movs	r3, #0
 800a736:	60fb      	str	r3, [r7, #12]
 800a738:	e010      	b.n	800a75c <PQCLEAN_FIRESABER_CLEAN_POLVECq2BS+0x32>
        POLq2BS(bytes + i * SABER_POLYBYTES, &data[i]);
 800a73a:	68fb      	ldr	r3, [r7, #12]
 800a73c:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 800a740:	fb02 f303 	mul.w	r3, r2, r3
 800a744:	687a      	ldr	r2, [r7, #4]
 800a746:	18d0      	adds	r0, r2, r3
 800a748:	68fb      	ldr	r3, [r7, #12]
 800a74a:	025b      	lsls	r3, r3, #9
 800a74c:	683a      	ldr	r2, [r7, #0]
 800a74e:	4413      	add	r3, r2
 800a750:	4619      	mov	r1, r3
 800a752:	f7ff fd8a 	bl	800a26a <POLq2BS>
    for (i = 0; i < SABER_L; i++) {
 800a756:	68fb      	ldr	r3, [r7, #12]
 800a758:	3301      	adds	r3, #1
 800a75a:	60fb      	str	r3, [r7, #12]
 800a75c:	68fb      	ldr	r3, [r7, #12]
 800a75e:	2b03      	cmp	r3, #3
 800a760:	d9eb      	bls.n	800a73a <PQCLEAN_FIRESABER_CLEAN_POLVECq2BS+0x10>
    }
}
 800a762:	bf00      	nop
 800a764:	3710      	adds	r7, #16
 800a766:	46bd      	mov	sp, r7
 800a768:	bd80      	pop	{r7, pc}

0800a76a <PQCLEAN_FIRESABER_CLEAN_BS2POLVECq>:

void PQCLEAN_FIRESABER_CLEAN_BS2POLVECq(poly data[SABER_L], const uint8_t bytes[SABER_POLYVECBYTES]) {
 800a76a:	b580      	push	{r7, lr}
 800a76c:	b084      	sub	sp, #16
 800a76e:	af00      	add	r7, sp, #0
 800a770:	6078      	str	r0, [r7, #4]
 800a772:	6039      	str	r1, [r7, #0]
    size_t i;
    for (i = 0; i < SABER_L; i++) {
 800a774:	2300      	movs	r3, #0
 800a776:	60fb      	str	r3, [r7, #12]
 800a778:	e010      	b.n	800a79c <PQCLEAN_FIRESABER_CLEAN_BS2POLVECq+0x32>
        BS2POLq(&data[i], bytes + i * SABER_POLYBYTES);
 800a77a:	68fb      	ldr	r3, [r7, #12]
 800a77c:	025b      	lsls	r3, r3, #9
 800a77e:	687a      	ldr	r2, [r7, #4]
 800a780:	18d0      	adds	r0, r2, r3
 800a782:	68fb      	ldr	r3, [r7, #12]
 800a784:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 800a788:	fb02 f303 	mul.w	r3, r2, r3
 800a78c:	683a      	ldr	r2, [r7, #0]
 800a78e:	4413      	add	r3, r2
 800a790:	4619      	mov	r1, r3
 800a792:	f7ff fe46 	bl	800a422 <BS2POLq>
    for (i = 0; i < SABER_L; i++) {
 800a796:	68fb      	ldr	r3, [r7, #12]
 800a798:	3301      	adds	r3, #1
 800a79a:	60fb      	str	r3, [r7, #12]
 800a79c:	68fb      	ldr	r3, [r7, #12]
 800a79e:	2b03      	cmp	r3, #3
 800a7a0:	d9eb      	bls.n	800a77a <PQCLEAN_FIRESABER_CLEAN_BS2POLVECq+0x10>
    }
}
 800a7a2:	bf00      	nop
 800a7a4:	3710      	adds	r7, #16
 800a7a6:	46bd      	mov	sp, r7
 800a7a8:	bd80      	pop	{r7, pc}

0800a7aa <PQCLEAN_FIRESABER_CLEAN_POLVECp2BS>:

void PQCLEAN_FIRESABER_CLEAN_POLVECp2BS(uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES], const poly data[SABER_L]) {
 800a7aa:	b580      	push	{r7, lr}
 800a7ac:	b084      	sub	sp, #16
 800a7ae:	af00      	add	r7, sp, #0
 800a7b0:	6078      	str	r0, [r7, #4]
 800a7b2:	6039      	str	r1, [r7, #0]
    size_t i;
    for (i = 0; i < SABER_L; i++) {
 800a7b4:	2300      	movs	r3, #0
 800a7b6:	60fb      	str	r3, [r7, #12]
 800a7b8:	e011      	b.n	800a7de <PQCLEAN_FIRESABER_CLEAN_POLVECp2BS+0x34>
        POLp2BS(bytes + i * SABER_POLYCOMPRESSEDBYTES, &data[i]);
 800a7ba:	68fa      	ldr	r2, [r7, #12]
 800a7bc:	4613      	mov	r3, r2
 800a7be:	009b      	lsls	r3, r3, #2
 800a7c0:	4413      	add	r3, r2
 800a7c2:	019b      	lsls	r3, r3, #6
 800a7c4:	461a      	mov	r2, r3
 800a7c6:	687b      	ldr	r3, [r7, #4]
 800a7c8:	1898      	adds	r0, r3, r2
 800a7ca:	68fb      	ldr	r3, [r7, #12]
 800a7cc:	025b      	lsls	r3, r3, #9
 800a7ce:	683a      	ldr	r2, [r7, #0]
 800a7d0:	4413      	add	r3, r2
 800a7d2:	4619      	mov	r1, r3
 800a7d4:	f7ff fee4 	bl	800a5a0 <POLp2BS>
    for (i = 0; i < SABER_L; i++) {
 800a7d8:	68fb      	ldr	r3, [r7, #12]
 800a7da:	3301      	adds	r3, #1
 800a7dc:	60fb      	str	r3, [r7, #12]
 800a7de:	68fb      	ldr	r3, [r7, #12]
 800a7e0:	2b03      	cmp	r3, #3
 800a7e2:	d9ea      	bls.n	800a7ba <PQCLEAN_FIRESABER_CLEAN_POLVECp2BS+0x10>
    }
}
 800a7e4:	bf00      	nop
 800a7e6:	3710      	adds	r7, #16
 800a7e8:	46bd      	mov	sp, r7
 800a7ea:	bd80      	pop	{r7, pc}

0800a7ec <PQCLEAN_FIRESABER_CLEAN_BS2POLVECp>:

void PQCLEAN_FIRESABER_CLEAN_BS2POLVECp(poly data[SABER_L], const uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES]) {
 800a7ec:	b580      	push	{r7, lr}
 800a7ee:	b084      	sub	sp, #16
 800a7f0:	af00      	add	r7, sp, #0
 800a7f2:	6078      	str	r0, [r7, #4]
 800a7f4:	6039      	str	r1, [r7, #0]
    size_t i;
    for (i = 0; i < SABER_L; i++) {
 800a7f6:	2300      	movs	r3, #0
 800a7f8:	60fb      	str	r3, [r7, #12]
 800a7fa:	e011      	b.n	800a820 <PQCLEAN_FIRESABER_CLEAN_BS2POLVECp+0x34>
        BS2POLp(&data[i], bytes + i * SABER_POLYCOMPRESSEDBYTES);
 800a7fc:	68fb      	ldr	r3, [r7, #12]
 800a7fe:	025b      	lsls	r3, r3, #9
 800a800:	687a      	ldr	r2, [r7, #4]
 800a802:	18d0      	adds	r0, r2, r3
 800a804:	68fa      	ldr	r2, [r7, #12]
 800a806:	4613      	mov	r3, r2
 800a808:	009b      	lsls	r3, r3, #2
 800a80a:	4413      	add	r3, r2
 800a80c:	019b      	lsls	r3, r3, #6
 800a80e:	461a      	mov	r2, r3
 800a810:	683b      	ldr	r3, [r7, #0]
 800a812:	4413      	add	r3, r2
 800a814:	4619      	mov	r1, r3
 800a816:	f7ff ff2a 	bl	800a66e <BS2POLp>
    for (i = 0; i < SABER_L; i++) {
 800a81a:	68fb      	ldr	r3, [r7, #12]
 800a81c:	3301      	adds	r3, #1
 800a81e:	60fb      	str	r3, [r7, #12]
 800a820:	68fb      	ldr	r3, [r7, #12]
 800a822:	2b03      	cmp	r3, #3
 800a824:	d9ea      	bls.n	800a7fc <PQCLEAN_FIRESABER_CLEAN_BS2POLVECp+0x10>
    }
}
 800a826:	bf00      	nop
 800a828:	3710      	adds	r7, #16
 800a82a:	46bd      	mov	sp, r7
 800a82c:	bd80      	pop	{r7, pc}

0800a82e <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg>:

void PQCLEAN_FIRESABER_CLEAN_BS2POLmsg(poly *data, const uint8_t bytes[SABER_KEYBYTES]) {
 800a82e:	b480      	push	{r7}
 800a830:	b085      	sub	sp, #20
 800a832:	af00      	add	r7, sp, #0
 800a834:	6078      	str	r0, [r7, #4]
 800a836:	6039      	str	r1, [r7, #0]
    size_t i, j;
    for (j = 0; j < SABER_KEYBYTES; j++) {
 800a838:	2300      	movs	r3, #0
 800a83a:	60bb      	str	r3, [r7, #8]
 800a83c:	e01e      	b.n	800a87c <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg+0x4e>
        for (i = 0; i < 8; i++) {
 800a83e:	2300      	movs	r3, #0
 800a840:	60fb      	str	r3, [r7, #12]
 800a842:	e015      	b.n	800a870 <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg+0x42>
            data->coeffs[j * 8 + i] = ((bytes[j] >> i) & 0x01);
 800a844:	683a      	ldr	r2, [r7, #0]
 800a846:	68bb      	ldr	r3, [r7, #8]
 800a848:	4413      	add	r3, r2
 800a84a:	781b      	ldrb	r3, [r3, #0]
 800a84c:	461a      	mov	r2, r3
 800a84e:	68fb      	ldr	r3, [r7, #12]
 800a850:	fa42 f303 	asr.w	r3, r2, r3
 800a854:	b29b      	uxth	r3, r3
 800a856:	68ba      	ldr	r2, [r7, #8]
 800a858:	00d1      	lsls	r1, r2, #3
 800a85a:	68fa      	ldr	r2, [r7, #12]
 800a85c:	440a      	add	r2, r1
 800a85e:	f003 0301 	and.w	r3, r3, #1
 800a862:	b299      	uxth	r1, r3
 800a864:	687b      	ldr	r3, [r7, #4]
 800a866:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        for (i = 0; i < 8; i++) {
 800a86a:	68fb      	ldr	r3, [r7, #12]
 800a86c:	3301      	adds	r3, #1
 800a86e:	60fb      	str	r3, [r7, #12]
 800a870:	68fb      	ldr	r3, [r7, #12]
 800a872:	2b07      	cmp	r3, #7
 800a874:	d9e6      	bls.n	800a844 <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg+0x16>
    for (j = 0; j < SABER_KEYBYTES; j++) {
 800a876:	68bb      	ldr	r3, [r7, #8]
 800a878:	3301      	adds	r3, #1
 800a87a:	60bb      	str	r3, [r7, #8]
 800a87c:	68bb      	ldr	r3, [r7, #8]
 800a87e:	2b1f      	cmp	r3, #31
 800a880:	d9dd      	bls.n	800a83e <PQCLEAN_FIRESABER_CLEAN_BS2POLmsg+0x10>
        }
    }
}
 800a882:	bf00      	nop
 800a884:	3714      	adds	r7, #20
 800a886:	46bd      	mov	sp, r7
 800a888:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a88c:	4770      	bx	lr

0800a88e <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS>:

void PQCLEAN_FIRESABER_CLEAN_POLmsg2BS(uint8_t bytes[SABER_KEYBYTES], const poly *data) {
 800a88e:	b580      	push	{r7, lr}
 800a890:	b084      	sub	sp, #16
 800a892:	af00      	add	r7, sp, #0
 800a894:	6078      	str	r0, [r7, #4]
 800a896:	6039      	str	r1, [r7, #0]
    size_t i, j;
    memset(bytes, 0, SABER_KEYBYTES);
 800a898:	2220      	movs	r2, #32
 800a89a:	2100      	movs	r1, #0
 800a89c:	6878      	ldr	r0, [r7, #4]
 800a89e:	f010 fba6 	bl	801afee <memset>

    for (j = 0; j < SABER_KEYBYTES; j++) {
 800a8a2:	2300      	movs	r3, #0
 800a8a4:	60bb      	str	r3, [r7, #8]
 800a8a6:	e024      	b.n	800a8f2 <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS+0x64>
        for (i = 0; i < 8; i++) {
 800a8a8:	2300      	movs	r3, #0
 800a8aa:	60fb      	str	r3, [r7, #12]
 800a8ac:	e01b      	b.n	800a8e6 <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS+0x58>
            bytes[j] = bytes[j] | ((data->coeffs[j * 8 + i] & 0x01) << i);
 800a8ae:	687a      	ldr	r2, [r7, #4]
 800a8b0:	68bb      	ldr	r3, [r7, #8]
 800a8b2:	4413      	add	r3, r2
 800a8b4:	781b      	ldrb	r3, [r3, #0]
 800a8b6:	b25a      	sxtb	r2, r3
 800a8b8:	68bb      	ldr	r3, [r7, #8]
 800a8ba:	00d9      	lsls	r1, r3, #3
 800a8bc:	68fb      	ldr	r3, [r7, #12]
 800a8be:	4419      	add	r1, r3
 800a8c0:	683b      	ldr	r3, [r7, #0]
 800a8c2:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800a8c6:	f003 0101 	and.w	r1, r3, #1
 800a8ca:	68fb      	ldr	r3, [r7, #12]
 800a8cc:	fa01 f303 	lsl.w	r3, r1, r3
 800a8d0:	b25b      	sxtb	r3, r3
 800a8d2:	4313      	orrs	r3, r2
 800a8d4:	b259      	sxtb	r1, r3
 800a8d6:	687a      	ldr	r2, [r7, #4]
 800a8d8:	68bb      	ldr	r3, [r7, #8]
 800a8da:	4413      	add	r3, r2
 800a8dc:	b2ca      	uxtb	r2, r1
 800a8de:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < 8; i++) {
 800a8e0:	68fb      	ldr	r3, [r7, #12]
 800a8e2:	3301      	adds	r3, #1
 800a8e4:	60fb      	str	r3, [r7, #12]
 800a8e6:	68fb      	ldr	r3, [r7, #12]
 800a8e8:	2b07      	cmp	r3, #7
 800a8ea:	d9e0      	bls.n	800a8ae <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS+0x20>
    for (j = 0; j < SABER_KEYBYTES; j++) {
 800a8ec:	68bb      	ldr	r3, [r7, #8]
 800a8ee:	3301      	adds	r3, #1
 800a8f0:	60bb      	str	r3, [r7, #8]
 800a8f2:	68bb      	ldr	r3, [r7, #8]
 800a8f4:	2b1f      	cmp	r3, #31
 800a8f6:	d9d7      	bls.n	800a8a8 <PQCLEAN_FIRESABER_CLEAN_POLmsg2BS+0x1a>
        }
    }
}
 800a8f8:	bf00      	nop
 800a8fa:	3710      	adds	r7, #16
 800a8fc:	46bd      	mov	sp, r7
 800a8fe:	bd80      	pop	{r7, pc}

0800a900 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul>:
#include "../../common/fips202.h"
#include "pack_unpack.h"
#include "poly.h"
#include <stddef.h>

void PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul(poly c[SABER_L], const poly A[SABER_L][SABER_L], const poly s[SABER_L], int16_t transpose) {
 800a900:	b580      	push	{r7, lr}
 800a902:	b086      	sub	sp, #24
 800a904:	af00      	add	r7, sp, #0
 800a906:	60f8      	str	r0, [r7, #12]
 800a908:	60b9      	str	r1, [r7, #8]
 800a90a:	607a      	str	r2, [r7, #4]
 800a90c:	807b      	strh	r3, [r7, #2]
    size_t i, j;

    if (transpose) {
 800a90e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800a912:	2b00      	cmp	r3, #0
 800a914:	d030      	beq.n	800a978 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x78>
        for (i = 0; i < SABER_L; i++) {
 800a916:	2300      	movs	r3, #0
 800a918:	617b      	str	r3, [r7, #20]
 800a91a:	e029      	b.n	800a970 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x70>
            PQCLEAN_FIRESABER_CLEAN_poly_mul(&c[i], &A[0][i], &s[0], 0);
 800a91c:	697b      	ldr	r3, [r7, #20]
 800a91e:	025b      	lsls	r3, r3, #9
 800a920:	68fa      	ldr	r2, [r7, #12]
 800a922:	18d0      	adds	r0, r2, r3
 800a924:	697b      	ldr	r3, [r7, #20]
 800a926:	025b      	lsls	r3, r3, #9
 800a928:	68ba      	ldr	r2, [r7, #8]
 800a92a:	18d1      	adds	r1, r2, r3
 800a92c:	2300      	movs	r3, #0
 800a92e:	687a      	ldr	r2, [r7, #4]
 800a930:	f000 fff6 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
            for (j = 1; j < SABER_L; j++) {
 800a934:	2301      	movs	r3, #1
 800a936:	613b      	str	r3, [r7, #16]
 800a938:	e014      	b.n	800a964 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x64>
                PQCLEAN_FIRESABER_CLEAN_poly_mul(&c[i], &A[j][i], &s[j], 1);
 800a93a:	697b      	ldr	r3, [r7, #20]
 800a93c:	025b      	lsls	r3, r3, #9
 800a93e:	68fa      	ldr	r2, [r7, #12]
 800a940:	18d0      	adds	r0, r2, r3
 800a942:	693b      	ldr	r3, [r7, #16]
 800a944:	02db      	lsls	r3, r3, #11
 800a946:	68ba      	ldr	r2, [r7, #8]
 800a948:	441a      	add	r2, r3
 800a94a:	697b      	ldr	r3, [r7, #20]
 800a94c:	025b      	lsls	r3, r3, #9
 800a94e:	18d1      	adds	r1, r2, r3
 800a950:	693b      	ldr	r3, [r7, #16]
 800a952:	025b      	lsls	r3, r3, #9
 800a954:	687a      	ldr	r2, [r7, #4]
 800a956:	441a      	add	r2, r3
 800a958:	2301      	movs	r3, #1
 800a95a:	f000 ffe1 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
            for (j = 1; j < SABER_L; j++) {
 800a95e:	693b      	ldr	r3, [r7, #16]
 800a960:	3301      	adds	r3, #1
 800a962:	613b      	str	r3, [r7, #16]
 800a964:	693b      	ldr	r3, [r7, #16]
 800a966:	2b03      	cmp	r3, #3
 800a968:	d9e7      	bls.n	800a93a <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x3a>
        for (i = 0; i < SABER_L; i++) {
 800a96a:	697b      	ldr	r3, [r7, #20]
 800a96c:	3301      	adds	r3, #1
 800a96e:	617b      	str	r3, [r7, #20]
 800a970:	697b      	ldr	r3, [r7, #20]
 800a972:	2b03      	cmp	r3, #3
 800a974:	d9d2      	bls.n	800a91c <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x1c>
            for (j = 1; j < SABER_L; j++) {
                PQCLEAN_FIRESABER_CLEAN_poly_mul(&c[i], &A[i][j], &s[j], 1);
            }
        }
    }
}
 800a976:	e030      	b.n	800a9da <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0xda>
        for (i = 0; i < SABER_L; i++) {
 800a978:	2300      	movs	r3, #0
 800a97a:	617b      	str	r3, [r7, #20]
 800a97c:	e02a      	b.n	800a9d4 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0xd4>
            PQCLEAN_FIRESABER_CLEAN_poly_mul(&c[i], &A[i][0], &s[0], 0);
 800a97e:	697b      	ldr	r3, [r7, #20]
 800a980:	025b      	lsls	r3, r3, #9
 800a982:	68fa      	ldr	r2, [r7, #12]
 800a984:	18d0      	adds	r0, r2, r3
 800a986:	697b      	ldr	r3, [r7, #20]
 800a988:	02db      	lsls	r3, r3, #11
 800a98a:	68ba      	ldr	r2, [r7, #8]
 800a98c:	4413      	add	r3, r2
 800a98e:	4619      	mov	r1, r3
 800a990:	2300      	movs	r3, #0
 800a992:	687a      	ldr	r2, [r7, #4]
 800a994:	f000 ffc4 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
            for (j = 1; j < SABER_L; j++) {
 800a998:	2301      	movs	r3, #1
 800a99a:	613b      	str	r3, [r7, #16]
 800a99c:	e014      	b.n	800a9c8 <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0xc8>
                PQCLEAN_FIRESABER_CLEAN_poly_mul(&c[i], &A[i][j], &s[j], 1);
 800a99e:	697b      	ldr	r3, [r7, #20]
 800a9a0:	025b      	lsls	r3, r3, #9
 800a9a2:	68fa      	ldr	r2, [r7, #12]
 800a9a4:	18d0      	adds	r0, r2, r3
 800a9a6:	697b      	ldr	r3, [r7, #20]
 800a9a8:	02db      	lsls	r3, r3, #11
 800a9aa:	68ba      	ldr	r2, [r7, #8]
 800a9ac:	441a      	add	r2, r3
 800a9ae:	693b      	ldr	r3, [r7, #16]
 800a9b0:	025b      	lsls	r3, r3, #9
 800a9b2:	18d1      	adds	r1, r2, r3
 800a9b4:	693b      	ldr	r3, [r7, #16]
 800a9b6:	025b      	lsls	r3, r3, #9
 800a9b8:	687a      	ldr	r2, [r7, #4]
 800a9ba:	441a      	add	r2, r3
 800a9bc:	2301      	movs	r3, #1
 800a9be:	f000 ffaf 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
            for (j = 1; j < SABER_L; j++) {
 800a9c2:	693b      	ldr	r3, [r7, #16]
 800a9c4:	3301      	adds	r3, #1
 800a9c6:	613b      	str	r3, [r7, #16]
 800a9c8:	693b      	ldr	r3, [r7, #16]
 800a9ca:	2b03      	cmp	r3, #3
 800a9cc:	d9e7      	bls.n	800a99e <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x9e>
        for (i = 0; i < SABER_L; i++) {
 800a9ce:	697b      	ldr	r3, [r7, #20]
 800a9d0:	3301      	adds	r3, #1
 800a9d2:	617b      	str	r3, [r7, #20]
 800a9d4:	697b      	ldr	r3, [r7, #20]
 800a9d6:	2b03      	cmp	r3, #3
 800a9d8:	d9d1      	bls.n	800a97e <PQCLEAN_FIRESABER_CLEAN_MatrixVectorMul+0x7e>
}
 800a9da:	bf00      	nop
 800a9dc:	3718      	adds	r7, #24
 800a9de:	46bd      	mov	sp, r7
 800a9e0:	bd80      	pop	{r7, pc}

0800a9e2 <PQCLEAN_FIRESABER_CLEAN_InnerProd>:

void PQCLEAN_FIRESABER_CLEAN_InnerProd(poly *c, const poly b[SABER_L], const poly s[SABER_L]) {
 800a9e2:	b580      	push	{r7, lr}
 800a9e4:	b086      	sub	sp, #24
 800a9e6:	af00      	add	r7, sp, #0
 800a9e8:	60f8      	str	r0, [r7, #12]
 800a9ea:	60b9      	str	r1, [r7, #8]
 800a9ec:	607a      	str	r2, [r7, #4]
    size_t i;

    PQCLEAN_FIRESABER_CLEAN_poly_mul(c, &b[0], &s[0], 0);
 800a9ee:	2300      	movs	r3, #0
 800a9f0:	687a      	ldr	r2, [r7, #4]
 800a9f2:	68b9      	ldr	r1, [r7, #8]
 800a9f4:	68f8      	ldr	r0, [r7, #12]
 800a9f6:	f000 ff93 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
    for (i = 1; i < SABER_L; i++) {
 800a9fa:	2301      	movs	r3, #1
 800a9fc:	617b      	str	r3, [r7, #20]
 800a9fe:	e00e      	b.n	800aa1e <PQCLEAN_FIRESABER_CLEAN_InnerProd+0x3c>
        PQCLEAN_FIRESABER_CLEAN_poly_mul(c, &b[i], &s[i], 1);
 800aa00:	697b      	ldr	r3, [r7, #20]
 800aa02:	025b      	lsls	r3, r3, #9
 800aa04:	68ba      	ldr	r2, [r7, #8]
 800aa06:	18d1      	adds	r1, r2, r3
 800aa08:	697b      	ldr	r3, [r7, #20]
 800aa0a:	025b      	lsls	r3, r3, #9
 800aa0c:	687a      	ldr	r2, [r7, #4]
 800aa0e:	441a      	add	r2, r3
 800aa10:	2301      	movs	r3, #1
 800aa12:	68f8      	ldr	r0, [r7, #12]
 800aa14:	f000 ff84 	bl	800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>
    for (i = 1; i < SABER_L; i++) {
 800aa18:	697b      	ldr	r3, [r7, #20]
 800aa1a:	3301      	adds	r3, #1
 800aa1c:	617b      	str	r3, [r7, #20]
 800aa1e:	697b      	ldr	r3, [r7, #20]
 800aa20:	2b03      	cmp	r3, #3
 800aa22:	d9ed      	bls.n	800aa00 <PQCLEAN_FIRESABER_CLEAN_InnerProd+0x1e>
    }
}
 800aa24:	bf00      	nop
 800aa26:	3718      	adds	r7, #24
 800aa28:	46bd      	mov	sp, r7
 800aa2a:	bd80      	pop	{r7, pc}

0800aa2c <PQCLEAN_FIRESABER_CLEAN_GenMatrix>:

void PQCLEAN_FIRESABER_CLEAN_GenMatrix(poly A[SABER_L][SABER_L], const uint8_t seed[SABER_SEEDBYTES]) {
 800aa2c:	b580      	push	{r7, lr}
 800aa2e:	f5ad 5dd0 	sub.w	sp, sp, #6656	; 0x1a00
 800aa32:	b084      	sub	sp, #16
 800aa34:	af00      	add	r7, sp, #0
 800aa36:	f107 0310 	add.w	r3, r7, #16
 800aa3a:	3b0c      	subs	r3, #12
 800aa3c:	6018      	str	r0, [r3, #0]
 800aa3e:	f107 0310 	add.w	r3, r7, #16
 800aa42:	3b10      	subs	r3, #16
 800aa44:	6019      	str	r1, [r3, #0]
    size_t i;
    uint8_t buf[SABER_L * SABER_POLYVECBYTES];

    shake128(buf, sizeof(buf), seed, SABER_SEEDBYTES);
 800aa46:	f107 0210 	add.w	r2, r7, #16
 800aa4a:	3a10      	subs	r2, #16
 800aa4c:	f107 0010 	add.w	r0, r7, #16
 800aa50:	3804      	subs	r0, #4
 800aa52:	2320      	movs	r3, #32
 800aa54:	6812      	ldr	r2, [r2, #0]
 800aa56:	f44f 51d0 	mov.w	r1, #6656	; 0x1a00
 800aa5a:	f7fe fcf9 	bl	8009450 <shake128>

    for (i = 0; i < SABER_L; i++) {
 800aa5e:	2300      	movs	r3, #0
 800aa60:	f507 52d0 	add.w	r2, r7, #6656	; 0x1a00
 800aa64:	f102 020c 	add.w	r2, r2, #12
 800aa68:	6013      	str	r3, [r2, #0]
 800aa6a:	e025      	b.n	800aab8 <PQCLEAN_FIRESABER_CLEAN_GenMatrix+0x8c>
        PQCLEAN_FIRESABER_CLEAN_BS2POLVECq(A[i], buf + i * SABER_POLYVECBYTES);
 800aa6c:	f507 53d0 	add.w	r3, r7, #6656	; 0x1a00
 800aa70:	f103 030c 	add.w	r3, r3, #12
 800aa74:	681b      	ldr	r3, [r3, #0]
 800aa76:	02da      	lsls	r2, r3, #11
 800aa78:	f107 0310 	add.w	r3, r7, #16
 800aa7c:	3b0c      	subs	r3, #12
 800aa7e:	681b      	ldr	r3, [r3, #0]
 800aa80:	1898      	adds	r0, r3, r2
 800aa82:	f507 53d0 	add.w	r3, r7, #6656	; 0x1a00
 800aa86:	f103 030c 	add.w	r3, r3, #12
 800aa8a:	681b      	ldr	r3, [r3, #0]
 800aa8c:	f44f 62d0 	mov.w	r2, #1664	; 0x680
 800aa90:	fb02 f203 	mul.w	r2, r2, r3
 800aa94:	f107 0310 	add.w	r3, r7, #16
 800aa98:	3b04      	subs	r3, #4
 800aa9a:	4413      	add	r3, r2
 800aa9c:	4619      	mov	r1, r3
 800aa9e:	f7ff fe64 	bl	800a76a <PQCLEAN_FIRESABER_CLEAN_BS2POLVECq>
    for (i = 0; i < SABER_L; i++) {
 800aaa2:	f507 53d0 	add.w	r3, r7, #6656	; 0x1a00
 800aaa6:	f103 030c 	add.w	r3, r3, #12
 800aaaa:	681b      	ldr	r3, [r3, #0]
 800aaac:	3301      	adds	r3, #1
 800aaae:	f507 52d0 	add.w	r2, r7, #6656	; 0x1a00
 800aab2:	f102 020c 	add.w	r2, r2, #12
 800aab6:	6013      	str	r3, [r2, #0]
 800aab8:	f507 53d0 	add.w	r3, r7, #6656	; 0x1a00
 800aabc:	f103 030c 	add.w	r3, r3, #12
 800aac0:	681b      	ldr	r3, [r3, #0]
 800aac2:	2b03      	cmp	r3, #3
 800aac4:	d9d2      	bls.n	800aa6c <PQCLEAN_FIRESABER_CLEAN_GenMatrix+0x40>
    }
}
 800aac6:	bf00      	nop
 800aac8:	f507 57d0 	add.w	r7, r7, #6656	; 0x1a00
 800aacc:	3710      	adds	r7, #16
 800aace:	46bd      	mov	sp, r7
 800aad0:	bd80      	pop	{r7, pc}

0800aad2 <PQCLEAN_FIRESABER_CLEAN_GenSecret>:

void PQCLEAN_FIRESABER_CLEAN_GenSecret(poly s[SABER_L], const uint8_t seed[SABER_NOISESEEDBYTES]) {
 800aad2:	b580      	push	{r7, lr}
 800aad4:	f5ad 7d44 	sub.w	sp, sp, #784	; 0x310
 800aad8:	af00      	add	r7, sp, #0
 800aada:	1d3b      	adds	r3, r7, #4
 800aadc:	6018      	str	r0, [r3, #0]
 800aade:	463b      	mov	r3, r7
 800aae0:	6019      	str	r1, [r3, #0]
    size_t i;
    uint8_t buf[SABER_L * SABER_POLYCOINBYTES];

    shake128(buf, sizeof(buf), seed, SABER_NOISESEEDBYTES);
 800aae2:	463a      	mov	r2, r7
 800aae4:	f107 000c 	add.w	r0, r7, #12
 800aae8:	2320      	movs	r3, #32
 800aaea:	6812      	ldr	r2, [r2, #0]
 800aaec:	f44f 7140 	mov.w	r1, #768	; 0x300
 800aaf0:	f7fe fcae 	bl	8009450 <shake128>

    for (i = 0; i < SABER_L; i++) {
 800aaf4:	2300      	movs	r3, #0
 800aaf6:	f8c7 330c 	str.w	r3, [r7, #780]	; 0x30c
 800aafa:	e018      	b.n	800ab2e <PQCLEAN_FIRESABER_CLEAN_GenSecret+0x5c>
        PQCLEAN_FIRESABER_CLEAN_cbd(s[i].coeffs, buf + i * SABER_POLYCOINBYTES);
 800aafc:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 800ab00:	025b      	lsls	r3, r3, #9
 800ab02:	1d3a      	adds	r2, r7, #4
 800ab04:	6812      	ldr	r2, [r2, #0]
 800ab06:	4413      	add	r3, r2
 800ab08:	4618      	mov	r0, r3
 800ab0a:	f8d7 230c 	ldr.w	r2, [r7, #780]	; 0x30c
 800ab0e:	4613      	mov	r3, r2
 800ab10:	005b      	lsls	r3, r3, #1
 800ab12:	4413      	add	r3, r2
 800ab14:	019b      	lsls	r3, r3, #6
 800ab16:	461a      	mov	r2, r3
 800ab18:	f107 030c 	add.w	r3, r7, #12
 800ab1c:	4413      	add	r3, r2
 800ab1e:	4619      	mov	r1, r3
 800ab20:	f7ff f988 	bl	8009e34 <PQCLEAN_FIRESABER_CLEAN_cbd>
    for (i = 0; i < SABER_L; i++) {
 800ab24:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 800ab28:	3301      	adds	r3, #1
 800ab2a:	f8c7 330c 	str.w	r3, [r7, #780]	; 0x30c
 800ab2e:	f8d7 330c 	ldr.w	r3, [r7, #780]	; 0x30c
 800ab32:	2b03      	cmp	r3, #3
 800ab34:	d9e2      	bls.n	800aafc <PQCLEAN_FIRESABER_CLEAN_GenSecret+0x2a>
    }
}
 800ab36:	bf00      	nop
 800ab38:	f507 7744 	add.w	r7, r7, #784	; 0x310
 800ab3c:	46bd      	mov	sp, r7
 800ab3e:	bd80      	pop	{r7, pc}

0800ab40 <karatsuba_simple>:
#define N_SB_RES (2*N_SB-1)

#define OVERFLOWING_MUL(X, Y) ((uint16_t)((uint32_t)(X) * (uint32_t)(Y)))

#define KARATSUBA_N 64
static void karatsuba_simple(uint16_t *result_final, const uint16_t *a_1, const uint16_t *b_1) {
 800ab40:	b580      	push	{r7, lr}
 800ab42:	b0dc      	sub	sp, #368	; 0x170
 800ab44:	af00      	add	r7, sp, #0
 800ab46:	f107 030c 	add.w	r3, r7, #12
 800ab4a:	6018      	str	r0, [r3, #0]
 800ab4c:	f107 0308 	add.w	r3, r7, #8
 800ab50:	6019      	str	r1, [r3, #0]
 800ab52:	1d3b      	adds	r3, r7, #4
 800ab54:	601a      	str	r2, [r3, #0]
    uint16_t d23[KARATSUBA_N / 2 - 1];
    uint16_t result_d01[KARATSUBA_N - 1];

    size_t i, j;

    memset(result_d01, 0, (KARATSUBA_N - 1)*sizeof(uint16_t));
 800ab56:	f107 0314 	add.w	r3, r7, #20
 800ab5a:	227e      	movs	r2, #126	; 0x7e
 800ab5c:	2100      	movs	r1, #0
 800ab5e:	4618      	mov	r0, r3
 800ab60:	f010 fa45 	bl	801afee <memset>
    memset(d01, 0, (KARATSUBA_N / 2 - 1)*sizeof(uint16_t));
 800ab64:	f507 738a 	add.w	r3, r7, #276	; 0x114
 800ab68:	223e      	movs	r2, #62	; 0x3e
 800ab6a:	2100      	movs	r1, #0
 800ab6c:	4618      	mov	r0, r3
 800ab6e:	f010 fa3e 	bl	801afee <memset>
    memset(d0123, 0, (KARATSUBA_N / 2 - 1)*sizeof(uint16_t));
 800ab72:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
 800ab76:	223e      	movs	r2, #62	; 0x3e
 800ab78:	2100      	movs	r1, #0
 800ab7a:	4618      	mov	r0, r3
 800ab7c:	f010 fa37 	bl	801afee <memset>
    memset(d23, 0, (KARATSUBA_N / 2 - 1)*sizeof(uint16_t));
 800ab80:	f107 0394 	add.w	r3, r7, #148	; 0x94
 800ab84:	223e      	movs	r2, #62	; 0x3e
 800ab86:	2100      	movs	r1, #0
 800ab88:	4618      	mov	r0, r3
 800ab8a:	f010 fa30 	bl	801afee <memset>
    memset(result_final, 0, (2 * KARATSUBA_N - 1)*sizeof(uint16_t));
 800ab8e:	f107 030c 	add.w	r3, r7, #12
 800ab92:	22fe      	movs	r2, #254	; 0xfe
 800ab94:	2100      	movs	r1, #0
 800ab96:	6818      	ldr	r0, [r3, #0]
 800ab98:	f010 fa29 	bl	801afee <memset>

    uint16_t acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8, acc9, acc10;


    for (i = 0; i < KARATSUBA_N / 4; i++) {
 800ab9c:	2300      	movs	r3, #0
 800ab9e:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800aba2:	e1c2      	b.n	800af2a <karatsuba_simple+0x3ea>
        acc1 = a_1[i]; //a0
 800aba4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800aba8:	005b      	lsls	r3, r3, #1
 800abaa:	f107 0208 	add.w	r2, r7, #8
 800abae:	6812      	ldr	r2, [r2, #0]
 800abb0:	4413      	add	r3, r2
 800abb2:	881b      	ldrh	r3, [r3, #0]
 800abb4:	f8a7 3166 	strh.w	r3, [r7, #358]	; 0x166
        acc2 = a_1[i + KARATSUBA_N / 4]; //a1
 800abb8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800abbc:	3310      	adds	r3, #16
 800abbe:	005b      	lsls	r3, r3, #1
 800abc0:	f107 0208 	add.w	r2, r7, #8
 800abc4:	6812      	ldr	r2, [r2, #0]
 800abc6:	4413      	add	r3, r2
 800abc8:	881b      	ldrh	r3, [r3, #0]
 800abca:	f8a7 3164 	strh.w	r3, [r7, #356]	; 0x164
        acc3 = a_1[i + 2 * KARATSUBA_N / 4]; //a2
 800abce:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800abd2:	3320      	adds	r3, #32
 800abd4:	005b      	lsls	r3, r3, #1
 800abd6:	f107 0208 	add.w	r2, r7, #8
 800abda:	6812      	ldr	r2, [r2, #0]
 800abdc:	4413      	add	r3, r2
 800abde:	881b      	ldrh	r3, [r3, #0]
 800abe0:	f8a7 3162 	strh.w	r3, [r7, #354]	; 0x162
        acc4 = a_1[i + 3 * KARATSUBA_N / 4]; //a3
 800abe4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800abe8:	3330      	adds	r3, #48	; 0x30
 800abea:	005b      	lsls	r3, r3, #1
 800abec:	f107 0208 	add.w	r2, r7, #8
 800abf0:	6812      	ldr	r2, [r2, #0]
 800abf2:	4413      	add	r3, r2
 800abf4:	881b      	ldrh	r3, [r3, #0]
 800abf6:	f8a7 3160 	strh.w	r3, [r7, #352]	; 0x160
        for (j = 0; j < KARATSUBA_N / 4; j++) {
 800abfa:	2300      	movs	r3, #0
 800abfc:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 800ac00:	e189      	b.n	800af16 <karatsuba_simple+0x3d6>

            acc5 = b_1[j]; //b0
 800ac02:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac06:	005b      	lsls	r3, r3, #1
 800ac08:	1d3a      	adds	r2, r7, #4
 800ac0a:	6812      	ldr	r2, [r2, #0]
 800ac0c:	4413      	add	r3, r2
 800ac0e:	881b      	ldrh	r3, [r3, #0]
 800ac10:	f8a7 315e 	strh.w	r3, [r7, #350]	; 0x15e
            acc6 = b_1[j + KARATSUBA_N / 4]; //b1
 800ac14:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac18:	3310      	adds	r3, #16
 800ac1a:	005b      	lsls	r3, r3, #1
 800ac1c:	1d3a      	adds	r2, r7, #4
 800ac1e:	6812      	ldr	r2, [r2, #0]
 800ac20:	4413      	add	r3, r2
 800ac22:	881b      	ldrh	r3, [r3, #0]
 800ac24:	f8a7 315c 	strh.w	r3, [r7, #348]	; 0x15c

            result_final[i + j + 0 * KARATSUBA_N / 4] =
                result_final[i + j + 0 * KARATSUBA_N / 4] +
 800ac28:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ac2c:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac30:	4413      	add	r3, r2
 800ac32:	005b      	lsls	r3, r3, #1
 800ac34:	f107 020c 	add.w	r2, r7, #12
 800ac38:	6812      	ldr	r2, [r2, #0]
 800ac3a:	4413      	add	r3, r2
 800ac3c:	8819      	ldrh	r1, [r3, #0]
                OVERFLOWING_MUL(acc1, acc5);
 800ac3e:	f8b7 2166 	ldrh.w	r2, [r7, #358]	; 0x166
 800ac42:	f8b7 315e 	ldrh.w	r3, [r7, #350]	; 0x15e
 800ac46:	fb12 f303 	smulbb	r3, r2, r3
 800ac4a:	b29a      	uxth	r2, r3
            result_final[i + j + 0 * KARATSUBA_N / 4] =
 800ac4c:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ac50:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac54:	4403      	add	r3, r0
 800ac56:	005b      	lsls	r3, r3, #1
 800ac58:	f107 000c 	add.w	r0, r7, #12
 800ac5c:	6800      	ldr	r0, [r0, #0]
 800ac5e:	4403      	add	r3, r0
                result_final[i + j + 0 * KARATSUBA_N / 4] +
 800ac60:	440a      	add	r2, r1
 800ac62:	b292      	uxth	r2, r2
            result_final[i + j + 0 * KARATSUBA_N / 4] =
 800ac64:	801a      	strh	r2, [r3, #0]
            result_final[i + j + 2 * KARATSUBA_N / 4] =
                result_final[i + j + 2 * KARATSUBA_N / 4] +
 800ac66:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ac6a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac6e:	4413      	add	r3, r2
 800ac70:	3320      	adds	r3, #32
 800ac72:	005b      	lsls	r3, r3, #1
 800ac74:	f107 020c 	add.w	r2, r7, #12
 800ac78:	6812      	ldr	r2, [r2, #0]
 800ac7a:	4413      	add	r3, r2
 800ac7c:	8819      	ldrh	r1, [r3, #0]
                OVERFLOWING_MUL(acc2, acc6);
 800ac7e:	f8b7 2164 	ldrh.w	r2, [r7, #356]	; 0x164
 800ac82:	f8b7 315c 	ldrh.w	r3, [r7, #348]	; 0x15c
 800ac86:	fb12 f303 	smulbb	r3, r2, r3
 800ac8a:	b29a      	uxth	r2, r3
            result_final[i + j + 2 * KARATSUBA_N / 4] =
 800ac8c:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ac90:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ac94:	4403      	add	r3, r0
 800ac96:	3320      	adds	r3, #32
 800ac98:	005b      	lsls	r3, r3, #1
 800ac9a:	f107 000c 	add.w	r0, r7, #12
 800ac9e:	6800      	ldr	r0, [r0, #0]
 800aca0:	4403      	add	r3, r0
                result_final[i + j + 2 * KARATSUBA_N / 4] +
 800aca2:	440a      	add	r2, r1
 800aca4:	b292      	uxth	r2, r2
            result_final[i + j + 2 * KARATSUBA_N / 4] =
 800aca6:	801a      	strh	r2, [r3, #0]

            acc7 = acc5 + acc6; //b01
 800aca8:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 800acac:	f8b7 315c 	ldrh.w	r3, [r7, #348]	; 0x15c
 800acb0:	4413      	add	r3, r2
 800acb2:	f8a7 315a 	strh.w	r3, [r7, #346]	; 0x15a
            acc8 = acc1 + acc2; //a01
 800acb6:	f8b7 2166 	ldrh.w	r2, [r7, #358]	; 0x166
 800acba:	f8b7 3164 	ldrh.w	r3, [r7, #356]	; 0x164
 800acbe:	4413      	add	r3, r2
 800acc0:	f8a7 3158 	strh.w	r3, [r7, #344]	; 0x158
            d01[i + j] = d01[i + j] + (uint16_t)(acc7 * (uint64_t)acc8);
 800acc4:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800acc8:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800accc:	4413      	add	r3, r2
 800acce:	005b      	lsls	r3, r3, #1
 800acd0:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800acd4:	4413      	add	r3, r2
 800acd6:	f833 1c5c 	ldrh.w	r1, [r3, #-92]
 800acda:	f8b7 215a 	ldrh.w	r2, [r7, #346]	; 0x15a
 800acde:	f8b7 3158 	ldrh.w	r3, [r7, #344]	; 0x158
 800ace2:	fb12 f303 	smulbb	r3, r2, r3
 800ace6:	b29a      	uxth	r2, r3
 800ace8:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800acec:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800acf0:	4403      	add	r3, r0
 800acf2:	440a      	add	r2, r1
 800acf4:	b292      	uxth	r2, r2
 800acf6:	005b      	lsls	r3, r3, #1
 800acf8:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800acfc:	440b      	add	r3, r1
 800acfe:	f823 2c5c 	strh.w	r2, [r3, #-92]
            //--------------------------------------------------------

            acc7 = b_1[j + 2 * KARATSUBA_N / 4]; //b2
 800ad02:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad06:	3320      	adds	r3, #32
 800ad08:	005b      	lsls	r3, r3, #1
 800ad0a:	1d3a      	adds	r2, r7, #4
 800ad0c:	6812      	ldr	r2, [r2, #0]
 800ad0e:	4413      	add	r3, r2
 800ad10:	881b      	ldrh	r3, [r3, #0]
 800ad12:	f8a7 315a 	strh.w	r3, [r7, #346]	; 0x15a
            acc8 = b_1[j + 3 * KARATSUBA_N / 4]; //b3
 800ad16:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad1a:	3330      	adds	r3, #48	; 0x30
 800ad1c:	005b      	lsls	r3, r3, #1
 800ad1e:	1d3a      	adds	r2, r7, #4
 800ad20:	6812      	ldr	r2, [r2, #0]
 800ad22:	4413      	add	r3, r2
 800ad24:	881b      	ldrh	r3, [r3, #0]
 800ad26:	f8a7 3158 	strh.w	r3, [r7, #344]	; 0x158
            result_final[i + j + 4 * KARATSUBA_N / 4] =
                result_final[i + j + 4 * KARATSUBA_N / 4] +
 800ad2a:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ad2e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad32:	4413      	add	r3, r2
 800ad34:	3340      	adds	r3, #64	; 0x40
 800ad36:	005b      	lsls	r3, r3, #1
 800ad38:	f107 020c 	add.w	r2, r7, #12
 800ad3c:	6812      	ldr	r2, [r2, #0]
 800ad3e:	4413      	add	r3, r2
 800ad40:	8819      	ldrh	r1, [r3, #0]
                OVERFLOWING_MUL(acc7, acc3);
 800ad42:	f8b7 215a 	ldrh.w	r2, [r7, #346]	; 0x15a
 800ad46:	f8b7 3162 	ldrh.w	r3, [r7, #354]	; 0x162
 800ad4a:	fb12 f303 	smulbb	r3, r2, r3
 800ad4e:	b29a      	uxth	r2, r3
            result_final[i + j + 4 * KARATSUBA_N / 4] =
 800ad50:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ad54:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad58:	4403      	add	r3, r0
 800ad5a:	3340      	adds	r3, #64	; 0x40
 800ad5c:	005b      	lsls	r3, r3, #1
 800ad5e:	f107 000c 	add.w	r0, r7, #12
 800ad62:	6800      	ldr	r0, [r0, #0]
 800ad64:	4403      	add	r3, r0
                result_final[i + j + 4 * KARATSUBA_N / 4] +
 800ad66:	440a      	add	r2, r1
 800ad68:	b292      	uxth	r2, r2
            result_final[i + j + 4 * KARATSUBA_N / 4] =
 800ad6a:	801a      	strh	r2, [r3, #0]

            result_final[i + j + 6 * KARATSUBA_N / 4] =
                result_final[i + j + 6 * KARATSUBA_N / 4] +
 800ad6c:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ad70:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad74:	4413      	add	r3, r2
 800ad76:	3360      	adds	r3, #96	; 0x60
 800ad78:	005b      	lsls	r3, r3, #1
 800ad7a:	f107 020c 	add.w	r2, r7, #12
 800ad7e:	6812      	ldr	r2, [r2, #0]
 800ad80:	4413      	add	r3, r2
 800ad82:	8819      	ldrh	r1, [r3, #0]
                OVERFLOWING_MUL(acc8, acc4);
 800ad84:	f8b7 2158 	ldrh.w	r2, [r7, #344]	; 0x158
 800ad88:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
 800ad8c:	fb12 f303 	smulbb	r3, r2, r3
 800ad90:	b29a      	uxth	r2, r3
            result_final[i + j + 6 * KARATSUBA_N / 4] =
 800ad92:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ad96:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ad9a:	4403      	add	r3, r0
 800ad9c:	3360      	adds	r3, #96	; 0x60
 800ad9e:	005b      	lsls	r3, r3, #1
 800ada0:	f107 000c 	add.w	r0, r7, #12
 800ada4:	6800      	ldr	r0, [r0, #0]
 800ada6:	4403      	add	r3, r0
                result_final[i + j + 6 * KARATSUBA_N / 4] +
 800ada8:	440a      	add	r2, r1
 800adaa:	b292      	uxth	r2, r2
            result_final[i + j + 6 * KARATSUBA_N / 4] =
 800adac:	801a      	strh	r2, [r3, #0]

            acc9 = acc3 + acc4;
 800adae:	f8b7 2162 	ldrh.w	r2, [r7, #354]	; 0x162
 800adb2:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
 800adb6:	4413      	add	r3, r2
 800adb8:	f8a7 3156 	strh.w	r3, [r7, #342]	; 0x156
            acc10 = acc7 + acc8;
 800adbc:	f8b7 215a 	ldrh.w	r2, [r7, #346]	; 0x15a
 800adc0:	f8b7 3158 	ldrh.w	r3, [r7, #344]	; 0x158
 800adc4:	4413      	add	r3, r2
 800adc6:	f8a7 3154 	strh.w	r3, [r7, #340]	; 0x154
            d23[i + j] = d23[i + j] + OVERFLOWING_MUL(acc9, acc10);
 800adca:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800adce:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800add2:	4413      	add	r3, r2
 800add4:	005b      	lsls	r3, r3, #1
 800add6:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800adda:	4413      	add	r3, r2
 800addc:	f833 1cdc 	ldrh.w	r1, [r3, #-220]
 800ade0:	f8b7 2156 	ldrh.w	r2, [r7, #342]	; 0x156
 800ade4:	f8b7 3154 	ldrh.w	r3, [r7, #340]	; 0x154
 800ade8:	fb12 f303 	smulbb	r3, r2, r3
 800adec:	b29a      	uxth	r2, r3
 800adee:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800adf2:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800adf6:	4403      	add	r3, r0
 800adf8:	440a      	add	r2, r1
 800adfa:	b292      	uxth	r2, r2
 800adfc:	005b      	lsls	r3, r3, #1
 800adfe:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800ae02:	440b      	add	r3, r1
 800ae04:	f823 2cdc 	strh.w	r2, [r3, #-220]
            //--------------------------------------------------------

            acc5 = acc5 + acc7; //b02
 800ae08:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 800ae0c:	f8b7 315a 	ldrh.w	r3, [r7, #346]	; 0x15a
 800ae10:	4413      	add	r3, r2
 800ae12:	f8a7 315e 	strh.w	r3, [r7, #350]	; 0x15e
            acc7 = acc1 + acc3; //a02
 800ae16:	f8b7 2166 	ldrh.w	r2, [r7, #358]	; 0x166
 800ae1a:	f8b7 3162 	ldrh.w	r3, [r7, #354]	; 0x162
 800ae1e:	4413      	add	r3, r2
 800ae20:	f8a7 315a 	strh.w	r3, [r7, #346]	; 0x15a
            result_d01[i + j + 0 * KARATSUBA_N / 4] =
                result_d01[i + j + 0 * KARATSUBA_N / 4] +
 800ae24:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ae28:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ae2c:	441a      	add	r2, r3
 800ae2e:	f107 0314 	add.w	r3, r7, #20
 800ae32:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
                OVERFLOWING_MUL(acc5, acc7);
 800ae36:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 800ae3a:	f8b7 315a 	ldrh.w	r3, [r7, #346]	; 0x15a
 800ae3e:	fb12 f303 	smulbb	r3, r2, r3
 800ae42:	b29b      	uxth	r3, r3
            result_d01[i + j + 0 * KARATSUBA_N / 4] =
 800ae44:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ae48:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 800ae4c:	4402      	add	r2, r0
                result_d01[i + j + 0 * KARATSUBA_N / 4] +
 800ae4e:	440b      	add	r3, r1
 800ae50:	b299      	uxth	r1, r3
            result_d01[i + j + 0 * KARATSUBA_N / 4] =
 800ae52:	f107 0314 	add.w	r3, r7, #20
 800ae56:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

            acc6 = acc6 + acc8; //b13
 800ae5a:	f8b7 215c 	ldrh.w	r2, [r7, #348]	; 0x15c
 800ae5e:	f8b7 3158 	ldrh.w	r3, [r7, #344]	; 0x158
 800ae62:	4413      	add	r3, r2
 800ae64:	f8a7 315c 	strh.w	r3, [r7, #348]	; 0x15c
            acc8 = acc2 + acc4;
 800ae68:	f8b7 2164 	ldrh.w	r2, [r7, #356]	; 0x164
 800ae6c:	f8b7 3160 	ldrh.w	r3, [r7, #352]	; 0x160
 800ae70:	4413      	add	r3, r2
 800ae72:	f8a7 3158 	strh.w	r3, [r7, #344]	; 0x158
            result_d01[i + j + 2 * KARATSUBA_N / 4] =
                result_d01[i + j + 2 * KARATSUBA_N / 4] +
 800ae76:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800ae7a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800ae7e:	4413      	add	r3, r2
 800ae80:	f103 0220 	add.w	r2, r3, #32
 800ae84:	f107 0314 	add.w	r3, r7, #20
 800ae88:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
                OVERFLOWING_MUL(acc6, acc8);
 800ae8c:	f8b7 215c 	ldrh.w	r2, [r7, #348]	; 0x15c
 800ae90:	f8b7 3158 	ldrh.w	r3, [r7, #344]	; 0x158
 800ae94:	fb12 f303 	smulbb	r3, r2, r3
 800ae98:	b29b      	uxth	r3, r3
            result_d01[i + j + 2 * KARATSUBA_N / 4] =
 800ae9a:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800ae9e:	f8d7 2168 	ldr.w	r2, [r7, #360]	; 0x168
 800aea2:	4402      	add	r2, r0
 800aea4:	3220      	adds	r2, #32
                result_d01[i + j + 2 * KARATSUBA_N / 4] +
 800aea6:	440b      	add	r3, r1
 800aea8:	b299      	uxth	r1, r3
            result_d01[i + j + 2 * KARATSUBA_N / 4] =
 800aeaa:	f107 0314 	add.w	r3, r7, #20
 800aeae:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

            acc5 = acc5 + acc6;
 800aeb2:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 800aeb6:	f8b7 315c 	ldrh.w	r3, [r7, #348]	; 0x15c
 800aeba:	4413      	add	r3, r2
 800aebc:	f8a7 315e 	strh.w	r3, [r7, #350]	; 0x15e
            acc7 = acc7 + acc8;
 800aec0:	f8b7 215a 	ldrh.w	r2, [r7, #346]	; 0x15a
 800aec4:	f8b7 3158 	ldrh.w	r3, [r7, #344]	; 0x158
 800aec8:	4413      	add	r3, r2
 800aeca:	f8a7 315a 	strh.w	r3, [r7, #346]	; 0x15a
            d0123[i + j] = d0123[i + j] + OVERFLOWING_MUL(acc5, acc7);
 800aece:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800aed2:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800aed6:	4413      	add	r3, r2
 800aed8:	005b      	lsls	r3, r3, #1
 800aeda:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800aede:	4413      	add	r3, r2
 800aee0:	f833 1c9c 	ldrh.w	r1, [r3, #-156]
 800aee4:	f8b7 215e 	ldrh.w	r2, [r7, #350]	; 0x15e
 800aee8:	f8b7 315a 	ldrh.w	r3, [r7, #346]	; 0x15a
 800aeec:	fb12 f303 	smulbb	r3, r2, r3
 800aef0:	b29a      	uxth	r2, r3
 800aef2:	f8d7 016c 	ldr.w	r0, [r7, #364]	; 0x16c
 800aef6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800aefa:	4403      	add	r3, r0
 800aefc:	440a      	add	r2, r1
 800aefe:	b292      	uxth	r2, r2
 800af00:	005b      	lsls	r3, r3, #1
 800af02:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800af06:	440b      	add	r3, r1
 800af08:	f823 2c9c 	strh.w	r2, [r3, #-156]
        for (j = 0; j < KARATSUBA_N / 4; j++) {
 800af0c:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800af10:	3301      	adds	r3, #1
 800af12:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 800af16:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800af1a:	2b0f      	cmp	r3, #15
 800af1c:	f67f ae71 	bls.w	800ac02 <karatsuba_simple+0xc2>
    for (i = 0; i < KARATSUBA_N / 4; i++) {
 800af20:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af24:	3301      	adds	r3, #1
 800af26:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800af2a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af2e:	2b0f      	cmp	r3, #15
 800af30:	f67f ae38 	bls.w	800aba4 <karatsuba_simple+0x64>
        }
    }

    // 2nd last stage

    for (i = 0; i < KARATSUBA_N / 2 - 1; i++) {
 800af34:	2300      	movs	r3, #0
 800af36:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800af3a:	e071      	b.n	800b020 <karatsuba_simple+0x4e0>
        d0123[i] = d0123[i] - result_d01[i + 0 * KARATSUBA_N / 4] - result_d01[i + 2 * KARATSUBA_N / 4];
 800af3c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af40:	005b      	lsls	r3, r3, #1
 800af42:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800af46:	4413      	add	r3, r2
 800af48:	f833 2c9c 	ldrh.w	r2, [r3, #-156]
 800af4c:	f107 0314 	add.w	r3, r7, #20
 800af50:	f8d7 116c 	ldr.w	r1, [r7, #364]	; 0x16c
 800af54:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800af58:	1ad3      	subs	r3, r2, r3
 800af5a:	b29a      	uxth	r2, r3
 800af5c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af60:	f103 0120 	add.w	r1, r3, #32
 800af64:	f107 0314 	add.w	r3, r7, #20
 800af68:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 800af6c:	1ad3      	subs	r3, r2, r3
 800af6e:	b29a      	uxth	r2, r3
 800af70:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af74:	005b      	lsls	r3, r3, #1
 800af76:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800af7a:	440b      	add	r3, r1
 800af7c:	f823 2c9c 	strh.w	r2, [r3, #-156]
        d01[i] = d01[i] - result_final[i + 0 * KARATSUBA_N / 4] - result_final[i + 2 * KARATSUBA_N / 4];
 800af80:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af84:	005b      	lsls	r3, r3, #1
 800af86:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800af8a:	4413      	add	r3, r2
 800af8c:	f833 2c5c 	ldrh.w	r2, [r3, #-92]
 800af90:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800af94:	005b      	lsls	r3, r3, #1
 800af96:	f107 010c 	add.w	r1, r7, #12
 800af9a:	6809      	ldr	r1, [r1, #0]
 800af9c:	440b      	add	r3, r1
 800af9e:	881b      	ldrh	r3, [r3, #0]
 800afa0:	1ad3      	subs	r3, r2, r3
 800afa2:	b29a      	uxth	r2, r3
 800afa4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800afa8:	3320      	adds	r3, #32
 800afaa:	005b      	lsls	r3, r3, #1
 800afac:	f107 010c 	add.w	r1, r7, #12
 800afb0:	6809      	ldr	r1, [r1, #0]
 800afb2:	440b      	add	r3, r1
 800afb4:	881b      	ldrh	r3, [r3, #0]
 800afb6:	1ad3      	subs	r3, r2, r3
 800afb8:	b29a      	uxth	r2, r3
 800afba:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800afbe:	005b      	lsls	r3, r3, #1
 800afc0:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800afc4:	440b      	add	r3, r1
 800afc6:	f823 2c5c 	strh.w	r2, [r3, #-92]
        d23[i] = d23[i] - result_final[i + 4 * KARATSUBA_N / 4] - result_final[i + 6 * KARATSUBA_N / 4];
 800afca:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800afce:	005b      	lsls	r3, r3, #1
 800afd0:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800afd4:	4413      	add	r3, r2
 800afd6:	f833 2cdc 	ldrh.w	r2, [r3, #-220]
 800afda:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800afde:	3340      	adds	r3, #64	; 0x40
 800afe0:	005b      	lsls	r3, r3, #1
 800afe2:	f107 010c 	add.w	r1, r7, #12
 800afe6:	6809      	ldr	r1, [r1, #0]
 800afe8:	440b      	add	r3, r1
 800afea:	881b      	ldrh	r3, [r3, #0]
 800afec:	1ad3      	subs	r3, r2, r3
 800afee:	b29a      	uxth	r2, r3
 800aff0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800aff4:	3360      	adds	r3, #96	; 0x60
 800aff6:	005b      	lsls	r3, r3, #1
 800aff8:	f107 010c 	add.w	r1, r7, #12
 800affc:	6809      	ldr	r1, [r1, #0]
 800affe:	440b      	add	r3, r1
 800b000:	881b      	ldrh	r3, [r3, #0]
 800b002:	1ad3      	subs	r3, r2, r3
 800b004:	b29a      	uxth	r2, r3
 800b006:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b00a:	005b      	lsls	r3, r3, #1
 800b00c:	f507 71b8 	add.w	r1, r7, #368	; 0x170
 800b010:	440b      	add	r3, r1
 800b012:	f823 2cdc 	strh.w	r2, [r3, #-220]
    for (i = 0; i < KARATSUBA_N / 2 - 1; i++) {
 800b016:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b01a:	3301      	adds	r3, #1
 800b01c:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b020:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b024:	2b1e      	cmp	r3, #30
 800b026:	d989      	bls.n	800af3c <karatsuba_simple+0x3fc>
    }

    for (i = 0; i < KARATSUBA_N / 2 - 1; i++) {
 800b028:	2300      	movs	r3, #0
 800b02a:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b02e:	e055      	b.n	800b0dc <karatsuba_simple+0x59c>
        result_d01[i + 1 * KARATSUBA_N / 4] = result_d01[i + 1 * KARATSUBA_N / 4] + d0123[i];
 800b030:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b034:	f103 0210 	add.w	r2, r3, #16
 800b038:	f107 0314 	add.w	r3, r7, #20
 800b03c:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 800b040:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b044:	005b      	lsls	r3, r3, #1
 800b046:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800b04a:	4413      	add	r3, r2
 800b04c:	f833 3c9c 	ldrh.w	r3, [r3, #-156]
 800b050:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800b054:	3210      	adds	r2, #16
 800b056:	440b      	add	r3, r1
 800b058:	b299      	uxth	r1, r3
 800b05a:	f107 0314 	add.w	r3, r7, #20
 800b05e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        result_final[i + 1 * KARATSUBA_N / 4] = result_final[i + 1 * KARATSUBA_N / 4] + d01[i];
 800b062:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b066:	3310      	adds	r3, #16
 800b068:	005b      	lsls	r3, r3, #1
 800b06a:	f107 020c 	add.w	r2, r7, #12
 800b06e:	6812      	ldr	r2, [r2, #0]
 800b070:	4413      	add	r3, r2
 800b072:	8819      	ldrh	r1, [r3, #0]
 800b074:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b078:	005b      	lsls	r3, r3, #1
 800b07a:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800b07e:	4413      	add	r3, r2
 800b080:	f833 2c5c 	ldrh.w	r2, [r3, #-92]
 800b084:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b088:	3310      	adds	r3, #16
 800b08a:	005b      	lsls	r3, r3, #1
 800b08c:	f107 000c 	add.w	r0, r7, #12
 800b090:	6800      	ldr	r0, [r0, #0]
 800b092:	4403      	add	r3, r0
 800b094:	440a      	add	r2, r1
 800b096:	b292      	uxth	r2, r2
 800b098:	801a      	strh	r2, [r3, #0]
        result_final[i + 5 * KARATSUBA_N / 4] = result_final[i + 5 * KARATSUBA_N / 4] + d23[i];
 800b09a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b09e:	3350      	adds	r3, #80	; 0x50
 800b0a0:	005b      	lsls	r3, r3, #1
 800b0a2:	f107 020c 	add.w	r2, r7, #12
 800b0a6:	6812      	ldr	r2, [r2, #0]
 800b0a8:	4413      	add	r3, r2
 800b0aa:	8819      	ldrh	r1, [r3, #0]
 800b0ac:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b0b0:	005b      	lsls	r3, r3, #1
 800b0b2:	f507 72b8 	add.w	r2, r7, #368	; 0x170
 800b0b6:	4413      	add	r3, r2
 800b0b8:	f833 2cdc 	ldrh.w	r2, [r3, #-220]
 800b0bc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b0c0:	3350      	adds	r3, #80	; 0x50
 800b0c2:	005b      	lsls	r3, r3, #1
 800b0c4:	f107 000c 	add.w	r0, r7, #12
 800b0c8:	6800      	ldr	r0, [r0, #0]
 800b0ca:	4403      	add	r3, r0
 800b0cc:	440a      	add	r2, r1
 800b0ce:	b292      	uxth	r2, r2
 800b0d0:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < KARATSUBA_N / 2 - 1; i++) {
 800b0d2:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b0d6:	3301      	adds	r3, #1
 800b0d8:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b0dc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b0e0:	2b1e      	cmp	r3, #30
 800b0e2:	d9a5      	bls.n	800b030 <karatsuba_simple+0x4f0>
    }

    // Last stage
    for (i = 0; i < KARATSUBA_N - 1; i++) {
 800b0e4:	2300      	movs	r3, #0
 800b0e6:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b0ea:	e025      	b.n	800b138 <karatsuba_simple+0x5f8>
        result_d01[i] = result_d01[i] - result_final[i] - result_final[i + KARATSUBA_N];
 800b0ec:	f107 0314 	add.w	r3, r7, #20
 800b0f0:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800b0f4:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800b0f8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b0fc:	005b      	lsls	r3, r3, #1
 800b0fe:	f107 010c 	add.w	r1, r7, #12
 800b102:	6809      	ldr	r1, [r1, #0]
 800b104:	440b      	add	r3, r1
 800b106:	881b      	ldrh	r3, [r3, #0]
 800b108:	1ad3      	subs	r3, r2, r3
 800b10a:	b29a      	uxth	r2, r3
 800b10c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b110:	3340      	adds	r3, #64	; 0x40
 800b112:	005b      	lsls	r3, r3, #1
 800b114:	f107 010c 	add.w	r1, r7, #12
 800b118:	6809      	ldr	r1, [r1, #0]
 800b11a:	440b      	add	r3, r1
 800b11c:	881b      	ldrh	r3, [r3, #0]
 800b11e:	1ad3      	subs	r3, r2, r3
 800b120:	b299      	uxth	r1, r3
 800b122:	f107 0314 	add.w	r3, r7, #20
 800b126:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800b12a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (i = 0; i < KARATSUBA_N - 1; i++) {
 800b12e:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b132:	3301      	adds	r3, #1
 800b134:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b138:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b13c:	2b3e      	cmp	r3, #62	; 0x3e
 800b13e:	d9d5      	bls.n	800b0ec <karatsuba_simple+0x5ac>
    }

    for (i = 0; i < KARATSUBA_N - 1; i++) {
 800b140:	2300      	movs	r3, #0
 800b142:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b146:	e01e      	b.n	800b186 <karatsuba_simple+0x646>
        result_final[i + 1 * KARATSUBA_N / 2] = result_final[i + 1 * KARATSUBA_N / 2] + result_d01[i];
 800b148:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b14c:	3320      	adds	r3, #32
 800b14e:	005b      	lsls	r3, r3, #1
 800b150:	f107 020c 	add.w	r2, r7, #12
 800b154:	6812      	ldr	r2, [r2, #0]
 800b156:	4413      	add	r3, r2
 800b158:	8819      	ldrh	r1, [r3, #0]
 800b15a:	f107 0314 	add.w	r3, r7, #20
 800b15e:	f8d7 216c 	ldr.w	r2, [r7, #364]	; 0x16c
 800b162:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800b166:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b16a:	3320      	adds	r3, #32
 800b16c:	005b      	lsls	r3, r3, #1
 800b16e:	f107 000c 	add.w	r0, r7, #12
 800b172:	6800      	ldr	r0, [r0, #0]
 800b174:	4403      	add	r3, r0
 800b176:	440a      	add	r2, r1
 800b178:	b292      	uxth	r2, r2
 800b17a:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < KARATSUBA_N - 1; i++) {
 800b17c:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b180:	3301      	adds	r3, #1
 800b182:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800b186:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800b18a:	2b3e      	cmp	r3, #62	; 0x3e
 800b18c:	d9dc      	bls.n	800b148 <karatsuba_simple+0x608>
    }

}
 800b18e:	bf00      	nop
 800b190:	f507 77b8 	add.w	r7, r7, #368	; 0x170
 800b194:	46bd      	mov	sp, r7
 800b196:	bd80      	pop	{r7, pc}

0800b198 <toom_cook_4way>:



static void toom_cook_4way (uint16_t *result, const uint16_t *a1, const uint16_t *b1) {
 800b198:	b580      	push	{r7, lr}
 800b19a:	f6ad 6d58 	subw	sp, sp, #3672	; 0xe58
 800b19e:	af00      	add	r7, sp, #0
 800b1a0:	f107 030c 	add.w	r3, r7, #12
 800b1a4:	6018      	str	r0, [r3, #0]
 800b1a6:	f107 0308 	add.w	r3, r7, #8
 800b1aa:	6019      	str	r1, [r3, #0]
 800b1ac:	1d3b      	adds	r3, r7, #4
 800b1ae:	601a      	str	r2, [r3, #0]
    uint16_t inv3 = 43691, inv9 = 36409, inv15 = 61167;
 800b1b0:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 800b1b4:	f8a7 3e4e 	strh.w	r3, [r7, #3662]	; 0xe4e
 800b1b8:	f648 6339 	movw	r3, #36409	; 0x8e39
 800b1bc:	f8a7 3e4c 	strh.w	r3, [r7, #3660]	; 0xe4c
 800b1c0:	f64e 63ef 	movw	r3, #61167	; 0xeeef
 800b1c4:	f8a7 3e4a 	strh.w	r3, [r7, #3658]	; 0xe4a

    uint16_t aw1[N_SB], aw2[N_SB], aw3[N_SB], aw4[N_SB], aw5[N_SB], aw6[N_SB], aw7[N_SB];
    uint16_t bw1[N_SB], bw2[N_SB], bw3[N_SB], bw4[N_SB], bw5[N_SB], bw6[N_SB], bw7[N_SB];
    uint16_t w1[N_SB_RES] = {0}, w2[N_SB_RES] = {0}, w3[N_SB_RES] = {0}, w4[N_SB_RES] = {0},
 800b1c8:	f207 6314 	addw	r3, r7, #1556	; 0x614
 800b1cc:	4618      	mov	r0, r3
 800b1ce:	23fe      	movs	r3, #254	; 0xfe
 800b1d0:	461a      	mov	r2, r3
 800b1d2:	2100      	movs	r1, #0
 800b1d4:	f00f ff0b 	bl	801afee <memset>
 800b1d8:	f207 5314 	addw	r3, r7, #1300	; 0x514
 800b1dc:	4618      	mov	r0, r3
 800b1de:	23fe      	movs	r3, #254	; 0xfe
 800b1e0:	461a      	mov	r2, r3
 800b1e2:	2100      	movs	r1, #0
 800b1e4:	f00f ff03 	bl	801afee <memset>
 800b1e8:	f207 4314 	addw	r3, r7, #1044	; 0x414
 800b1ec:	4618      	mov	r0, r3
 800b1ee:	23fe      	movs	r3, #254	; 0xfe
 800b1f0:	461a      	mov	r2, r3
 800b1f2:	2100      	movs	r1, #0
 800b1f4:	f00f fefb 	bl	801afee <memset>
 800b1f8:	f507 7345 	add.w	r3, r7, #788	; 0x314
 800b1fc:	4618      	mov	r0, r3
 800b1fe:	23fe      	movs	r3, #254	; 0xfe
 800b200:	461a      	mov	r2, r3
 800b202:	2100      	movs	r1, #0
 800b204:	f00f fef3 	bl	801afee <memset>
                            w5[N_SB_RES] = {0}, w6[N_SB_RES] = {0}, w7[N_SB_RES] = {0};
 800b208:	f507 7305 	add.w	r3, r7, #532	; 0x214
 800b20c:	4618      	mov	r0, r3
 800b20e:	23fe      	movs	r3, #254	; 0xfe
 800b210:	461a      	mov	r2, r3
 800b212:	2100      	movs	r1, #0
 800b214:	f00f feeb 	bl	801afee <memset>
 800b218:	f507 738a 	add.w	r3, r7, #276	; 0x114
 800b21c:	4618      	mov	r0, r3
 800b21e:	23fe      	movs	r3, #254	; 0xfe
 800b220:	461a      	mov	r2, r3
 800b222:	2100      	movs	r1, #0
 800b224:	f00f fee3 	bl	801afee <memset>
 800b228:	f107 0314 	add.w	r3, r7, #20
 800b22c:	4618      	mov	r0, r3
 800b22e:	23fe      	movs	r3, #254	; 0xfe
 800b230:	461a      	mov	r2, r3
 800b232:	2100      	movs	r1, #0
 800b234:	f00f fedb 	bl	801afee <memset>
    uint16_t r0, r1, r2, r3, r4, r5, r6, r7;
    uint16_t *A0, *A1, *A2, *A3, *B0, *B1, *B2, *B3;
    A0 = (uint16_t *)a1;
 800b238:	f107 0308 	add.w	r3, r7, #8
 800b23c:	681b      	ldr	r3, [r3, #0]
 800b23e:	f8c7 3e44 	str.w	r3, [r7, #3652]	; 0xe44
    A1 = (uint16_t *)&a1[N_SB];
 800b242:	f107 0308 	add.w	r3, r7, #8
 800b246:	681b      	ldr	r3, [r3, #0]
 800b248:	3380      	adds	r3, #128	; 0x80
 800b24a:	f8c7 3e40 	str.w	r3, [r7, #3648]	; 0xe40
    A2 = (uint16_t *)&a1[2 * N_SB];
 800b24e:	f107 0308 	add.w	r3, r7, #8
 800b252:	681b      	ldr	r3, [r3, #0]
 800b254:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800b258:	f8c7 3e3c 	str.w	r3, [r7, #3644]	; 0xe3c
    A3 = (uint16_t *)&a1[3 * N_SB];
 800b25c:	f107 0308 	add.w	r3, r7, #8
 800b260:	681b      	ldr	r3, [r3, #0]
 800b262:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800b266:	f8c7 3e38 	str.w	r3, [r7, #3640]	; 0xe38
    B0 = (uint16_t *)b1;
 800b26a:	1d3b      	adds	r3, r7, #4
 800b26c:	681b      	ldr	r3, [r3, #0]
 800b26e:	f8c7 3e34 	str.w	r3, [r7, #3636]	; 0xe34
    B1 = (uint16_t *)&b1[N_SB];
 800b272:	1d3b      	adds	r3, r7, #4
 800b274:	681b      	ldr	r3, [r3, #0]
 800b276:	3380      	adds	r3, #128	; 0x80
 800b278:	f8c7 3e30 	str.w	r3, [r7, #3632]	; 0xe30
    B2 = (uint16_t *)&b1[2 * N_SB];
 800b27c:	1d3b      	adds	r3, r7, #4
 800b27e:	681b      	ldr	r3, [r3, #0]
 800b280:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800b284:	f8c7 3e2c 	str.w	r3, [r7, #3628]	; 0xe2c
    B3 = (uint16_t *)&b1[3 * N_SB];
 800b288:	1d3b      	adds	r3, r7, #4
 800b28a:	681b      	ldr	r3, [r3, #0]
 800b28c:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800b290:	f8c7 3e28 	str.w	r3, [r7, #3624]	; 0xe28

    uint16_t *C;
    C = result;
 800b294:	f107 030c 	add.w	r3, r7, #12
 800b298:	681b      	ldr	r3, [r3, #0]
 800b29a:	f8c7 3e24 	str.w	r3, [r7, #3620]	; 0xe24

    int i, j;

    // EVALUATION
    for (j = 0; j < N_SB; ++j) {
 800b29e:	2300      	movs	r3, #0
 800b2a0:	f8c7 3e50 	str.w	r3, [r7, #3664]	; 0xe50
 800b2a4:	e0b5      	b.n	800b412 <toom_cook_4way+0x27a>
        r0 = A0[j];
 800b2a6:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b2aa:	005b      	lsls	r3, r3, #1
 800b2ac:	f8d7 2e44 	ldr.w	r2, [r7, #3652]	; 0xe44
 800b2b0:	4413      	add	r3, r2
 800b2b2:	881b      	ldrh	r3, [r3, #0]
 800b2b4:	f8a7 3e22 	strh.w	r3, [r7, #3618]	; 0xe22
        r1 = A1[j];
 800b2b8:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b2bc:	005b      	lsls	r3, r3, #1
 800b2be:	f8d7 2e40 	ldr.w	r2, [r7, #3648]	; 0xe40
 800b2c2:	4413      	add	r3, r2
 800b2c4:	881b      	ldrh	r3, [r3, #0]
 800b2c6:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r2 = A2[j];
 800b2ca:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b2ce:	005b      	lsls	r3, r3, #1
 800b2d0:	f8d7 2e3c 	ldr.w	r2, [r7, #3644]	; 0xe3c
 800b2d4:	4413      	add	r3, r2
 800b2d6:	881b      	ldrh	r3, [r3, #0]
 800b2d8:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r3 = A3[j];
 800b2dc:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b2e0:	005b      	lsls	r3, r3, #1
 800b2e2:	f8d7 2e38 	ldr.w	r2, [r7, #3640]	; 0xe38
 800b2e6:	4413      	add	r3, r2
 800b2e8:	881b      	ldrh	r3, [r3, #0]
 800b2ea:	f8a7 3e1c 	strh.w	r3, [r7, #3612]	; 0xe1c
        r4 = r0 + r2;
 800b2ee:	f8b7 2e22 	ldrh.w	r2, [r7, #3618]	; 0xe22
 800b2f2:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b2f6:	4413      	add	r3, r2
 800b2f8:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = r1 + r3;
 800b2fc:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b300:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b304:	4413      	add	r3, r2
 800b306:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r6 = r4 + r5;
 800b30a:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b30e:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b312:	4413      	add	r3, r2
 800b314:	f8a7 3e16 	strh.w	r3, [r7, #3606]	; 0xe16
        r7 = r4 - r5;
 800b318:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b31c:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b320:	1ad3      	subs	r3, r2, r3
 800b322:	f8a7 3e14 	strh.w	r3, [r7, #3604]	; 0xe14
        aw3[j] = r6;
 800b326:	f607 4394 	addw	r3, r7, #3220	; 0xc94
 800b32a:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b32e:	f8b7 1e16 	ldrh.w	r1, [r7, #3606]	; 0xe16
 800b332:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        aw4[j] = r7;
 800b336:	f607 4314 	addw	r3, r7, #3092	; 0xc14
 800b33a:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b33e:	f8b7 1e14 	ldrh.w	r1, [r7, #3604]	; 0xe14
 800b342:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        r4 = ((r0 << 2) + r2) << 1;
 800b346:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b34a:	009b      	lsls	r3, r3, #2
 800b34c:	b29a      	uxth	r2, r3
 800b34e:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b352:	4413      	add	r3, r2
 800b354:	b29b      	uxth	r3, r3
 800b356:	005b      	lsls	r3, r3, #1
 800b358:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = (r1 << 2) + r3;
 800b35c:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b360:	009b      	lsls	r3, r3, #2
 800b362:	b29a      	uxth	r2, r3
 800b364:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b368:	4413      	add	r3, r2
 800b36a:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r6 = r4 + r5;
 800b36e:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b372:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b376:	4413      	add	r3, r2
 800b378:	f8a7 3e16 	strh.w	r3, [r7, #3606]	; 0xe16
        r7 = r4 - r5;
 800b37c:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b380:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b384:	1ad3      	subs	r3, r2, r3
 800b386:	f8a7 3e14 	strh.w	r3, [r7, #3604]	; 0xe14
        aw5[j] = r6;
 800b38a:	f607 3394 	addw	r3, r7, #2964	; 0xb94
 800b38e:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b392:	f8b7 1e16 	ldrh.w	r1, [r7, #3606]	; 0xe16
 800b396:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        aw6[j] = r7;
 800b39a:	f607 3314 	addw	r3, r7, #2836	; 0xb14
 800b39e:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b3a2:	f8b7 1e14 	ldrh.w	r1, [r7, #3604]	; 0xe14
 800b3a6:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        r4 = (r3 << 3) + (r2 << 2) + (r1 << 1) + r0;
 800b3aa:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b3ae:	00db      	lsls	r3, r3, #3
 800b3b0:	b29a      	uxth	r2, r3
 800b3b2:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b3b6:	009b      	lsls	r3, r3, #2
 800b3b8:	b29b      	uxth	r3, r3
 800b3ba:	4413      	add	r3, r2
 800b3bc:	b29a      	uxth	r2, r3
 800b3be:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b3c2:	005b      	lsls	r3, r3, #1
 800b3c4:	b29b      	uxth	r3, r3
 800b3c6:	4413      	add	r3, r2
 800b3c8:	b29a      	uxth	r2, r3
 800b3ca:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b3ce:	4413      	add	r3, r2
 800b3d0:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        aw2[j] = r4;
 800b3d4:	f607 5314 	addw	r3, r7, #3348	; 0xd14
 800b3d8:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b3dc:	f8b7 1e1a 	ldrh.w	r1, [r7, #3610]	; 0xe1a
 800b3e0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        aw7[j] = r0;
 800b3e4:	f607 2394 	addw	r3, r7, #2708	; 0xa94
 800b3e8:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b3ec:	f8b7 1e22 	ldrh.w	r1, [r7, #3618]	; 0xe22
 800b3f0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        aw1[j] = r3;
 800b3f4:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b3f8:	005b      	lsls	r3, r3, #1
 800b3fa:	f607 6258 	addw	r2, r7, #3672	; 0xe58
 800b3fe:	4413      	add	r3, r2
 800b400:	f8b7 2e1c 	ldrh.w	r2, [r7, #3612]	; 0xe1c
 800b404:	f823 2cc4 	strh.w	r2, [r3, #-196]
    for (j = 0; j < N_SB; ++j) {
 800b408:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b40c:	3301      	adds	r3, #1
 800b40e:	f8c7 3e50 	str.w	r3, [r7, #3664]	; 0xe50
 800b412:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b416:	2b3f      	cmp	r3, #63	; 0x3f
 800b418:	f77f af45 	ble.w	800b2a6 <toom_cook_4way+0x10e>
    }
    for (j = 0; j < N_SB; ++j) {
 800b41c:	2300      	movs	r3, #0
 800b41e:	f8c7 3e50 	str.w	r3, [r7, #3664]	; 0xe50
 800b422:	e0b3      	b.n	800b58c <toom_cook_4way+0x3f4>
        r0 = B0[j];
 800b424:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b428:	005b      	lsls	r3, r3, #1
 800b42a:	f8d7 2e34 	ldr.w	r2, [r7, #3636]	; 0xe34
 800b42e:	4413      	add	r3, r2
 800b430:	881b      	ldrh	r3, [r3, #0]
 800b432:	f8a7 3e22 	strh.w	r3, [r7, #3618]	; 0xe22
        r1 = B1[j];
 800b436:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b43a:	005b      	lsls	r3, r3, #1
 800b43c:	f8d7 2e30 	ldr.w	r2, [r7, #3632]	; 0xe30
 800b440:	4413      	add	r3, r2
 800b442:	881b      	ldrh	r3, [r3, #0]
 800b444:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r2 = B2[j];
 800b448:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b44c:	005b      	lsls	r3, r3, #1
 800b44e:	f8d7 2e2c 	ldr.w	r2, [r7, #3628]	; 0xe2c
 800b452:	4413      	add	r3, r2
 800b454:	881b      	ldrh	r3, [r3, #0]
 800b456:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r3 = B3[j];
 800b45a:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b45e:	005b      	lsls	r3, r3, #1
 800b460:	f8d7 2e28 	ldr.w	r2, [r7, #3624]	; 0xe28
 800b464:	4413      	add	r3, r2
 800b466:	881b      	ldrh	r3, [r3, #0]
 800b468:	f8a7 3e1c 	strh.w	r3, [r7, #3612]	; 0xe1c
        r4 = r0 + r2;
 800b46c:	f8b7 2e22 	ldrh.w	r2, [r7, #3618]	; 0xe22
 800b470:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b474:	4413      	add	r3, r2
 800b476:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = r1 + r3;
 800b47a:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b47e:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b482:	4413      	add	r3, r2
 800b484:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r6 = r4 + r5;
 800b488:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b48c:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b490:	4413      	add	r3, r2
 800b492:	f8a7 3e16 	strh.w	r3, [r7, #3606]	; 0xe16
        r7 = r4 - r5;
 800b496:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b49a:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b49e:	1ad3      	subs	r3, r2, r3
 800b4a0:	f8a7 3e14 	strh.w	r3, [r7, #3604]	; 0xe14
        bw3[j] = r6;
 800b4a4:	f607 1314 	addw	r3, r7, #2324	; 0x914
 800b4a8:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b4ac:	f8b7 1e16 	ldrh.w	r1, [r7, #3606]	; 0xe16
 800b4b0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        bw4[j] = r7;
 800b4b4:	f607 0394 	addw	r3, r7, #2196	; 0x894
 800b4b8:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b4bc:	f8b7 1e14 	ldrh.w	r1, [r7, #3604]	; 0xe14
 800b4c0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        r4 = ((r0 << 2) + r2) << 1;
 800b4c4:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b4c8:	009b      	lsls	r3, r3, #2
 800b4ca:	b29a      	uxth	r2, r3
 800b4cc:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b4d0:	4413      	add	r3, r2
 800b4d2:	b29b      	uxth	r3, r3
 800b4d4:	005b      	lsls	r3, r3, #1
 800b4d6:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = (r1 << 2) + r3;
 800b4da:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b4de:	009b      	lsls	r3, r3, #2
 800b4e0:	b29a      	uxth	r2, r3
 800b4e2:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b4e6:	4413      	add	r3, r2
 800b4e8:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r6 = r4 + r5;
 800b4ec:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b4f0:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b4f4:	4413      	add	r3, r2
 800b4f6:	f8a7 3e16 	strh.w	r3, [r7, #3606]	; 0xe16
        r7 = r4 - r5;
 800b4fa:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b4fe:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b502:	1ad3      	subs	r3, r2, r3
 800b504:	f8a7 3e14 	strh.w	r3, [r7, #3604]	; 0xe14
        bw5[j] = r6;
 800b508:	f607 0314 	addw	r3, r7, #2068	; 0x814
 800b50c:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b510:	f8b7 1e16 	ldrh.w	r1, [r7, #3606]	; 0xe16
 800b514:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        bw6[j] = r7;
 800b518:	f207 7394 	addw	r3, r7, #1940	; 0x794
 800b51c:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b520:	f8b7 1e14 	ldrh.w	r1, [r7, #3604]	; 0xe14
 800b524:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        r4 = (r3 << 3) + (r2 << 2) + (r1 << 1) + r0;
 800b528:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b52c:	00db      	lsls	r3, r3, #3
 800b52e:	b29a      	uxth	r2, r3
 800b530:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b534:	009b      	lsls	r3, r3, #2
 800b536:	b29b      	uxth	r3, r3
 800b538:	4413      	add	r3, r2
 800b53a:	b29a      	uxth	r2, r3
 800b53c:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b540:	005b      	lsls	r3, r3, #1
 800b542:	b29b      	uxth	r3, r3
 800b544:	4413      	add	r3, r2
 800b546:	b29a      	uxth	r2, r3
 800b548:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b54c:	4413      	add	r3, r2
 800b54e:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        bw2[j] = r4;
 800b552:	f607 1394 	addw	r3, r7, #2452	; 0x994
 800b556:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b55a:	f8b7 1e1a 	ldrh.w	r1, [r7, #3610]	; 0xe1a
 800b55e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        bw7[j] = r0;
 800b562:	f207 7314 	addw	r3, r7, #1812	; 0x714
 800b566:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b56a:	f8b7 1e22 	ldrh.w	r1, [r7, #3618]	; 0xe22
 800b56e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        bw1[j] = r3;
 800b572:	f607 2314 	addw	r3, r7, #2580	; 0xa14
 800b576:	f8d7 2e50 	ldr.w	r2, [r7, #3664]	; 0xe50
 800b57a:	f8b7 1e1c 	ldrh.w	r1, [r7, #3612]	; 0xe1c
 800b57e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
    for (j = 0; j < N_SB; ++j) {
 800b582:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b586:	3301      	adds	r3, #1
 800b588:	f8c7 3e50 	str.w	r3, [r7, #3664]	; 0xe50
 800b58c:	f8d7 3e50 	ldr.w	r3, [r7, #3664]	; 0xe50
 800b590:	2b3f      	cmp	r3, #63	; 0x3f
 800b592:	f77f af47 	ble.w	800b424 <toom_cook_4way+0x28c>
    }

    // MULTIPLICATION

    karatsuba_simple(w1, aw1, bw1);
 800b596:	f607 2214 	addw	r2, r7, #2580	; 0xa14
 800b59a:	f607 5194 	addw	r1, r7, #3476	; 0xd94
 800b59e:	f207 6314 	addw	r3, r7, #1556	; 0x614
 800b5a2:	4618      	mov	r0, r3
 800b5a4:	f7ff facc 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w2, aw2, bw2);
 800b5a8:	f607 1294 	addw	r2, r7, #2452	; 0x994
 800b5ac:	f607 5114 	addw	r1, r7, #3348	; 0xd14
 800b5b0:	f207 5314 	addw	r3, r7, #1300	; 0x514
 800b5b4:	4618      	mov	r0, r3
 800b5b6:	f7ff fac3 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w3, aw3, bw3);
 800b5ba:	f607 1214 	addw	r2, r7, #2324	; 0x914
 800b5be:	f607 4194 	addw	r1, r7, #3220	; 0xc94
 800b5c2:	f207 4314 	addw	r3, r7, #1044	; 0x414
 800b5c6:	4618      	mov	r0, r3
 800b5c8:	f7ff faba 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w4, aw4, bw4);
 800b5cc:	f607 0294 	addw	r2, r7, #2196	; 0x894
 800b5d0:	f607 4114 	addw	r1, r7, #3092	; 0xc14
 800b5d4:	f507 7345 	add.w	r3, r7, #788	; 0x314
 800b5d8:	4618      	mov	r0, r3
 800b5da:	f7ff fab1 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w5, aw5, bw5);
 800b5de:	f607 0214 	addw	r2, r7, #2068	; 0x814
 800b5e2:	f607 3194 	addw	r1, r7, #2964	; 0xb94
 800b5e6:	f507 7305 	add.w	r3, r7, #532	; 0x214
 800b5ea:	4618      	mov	r0, r3
 800b5ec:	f7ff faa8 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w6, aw6, bw6);
 800b5f0:	f207 7294 	addw	r2, r7, #1940	; 0x794
 800b5f4:	f607 3114 	addw	r1, r7, #2836	; 0xb14
 800b5f8:	f507 738a 	add.w	r3, r7, #276	; 0x114
 800b5fc:	4618      	mov	r0, r3
 800b5fe:	f7ff fa9f 	bl	800ab40 <karatsuba_simple>
    karatsuba_simple(w7, aw7, bw7);
 800b602:	f207 7214 	addw	r2, r7, #1812	; 0x714
 800b606:	f607 2194 	addw	r1, r7, #2708	; 0xa94
 800b60a:	f107 0314 	add.w	r3, r7, #20
 800b60e:	4618      	mov	r0, r3
 800b610:	f7ff fa96 	bl	800ab40 <karatsuba_simple>

    // INTERPOLATION
    for (i = 0; i < N_SB_RES; ++i) {
 800b614:	2300      	movs	r3, #0
 800b616:	f8c7 3e54 	str.w	r3, [r7, #3668]	; 0xe54
 800b61a:	e177      	b.n	800b90c <toom_cook_4way+0x774>
        r0 = w1[i];
 800b61c:	f207 6314 	addw	r3, r7, #1556	; 0x614
 800b620:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b624:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b628:	f8a7 3e22 	strh.w	r3, [r7, #3618]	; 0xe22
        r1 = w2[i];
 800b62c:	f207 5314 	addw	r3, r7, #1300	; 0x514
 800b630:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b634:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b638:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r2 = w3[i];
 800b63c:	f207 4314 	addw	r3, r7, #1044	; 0x414
 800b640:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b644:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b648:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r3 = w4[i];
 800b64c:	f507 7345 	add.w	r3, r7, #788	; 0x314
 800b650:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b654:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b658:	f8a7 3e1c 	strh.w	r3, [r7, #3612]	; 0xe1c
        r4 = w5[i];
 800b65c:	f507 7305 	add.w	r3, r7, #532	; 0x214
 800b660:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b664:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b668:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = w6[i];
 800b66c:	f507 738a 	add.w	r3, r7, #276	; 0x114
 800b670:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b674:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b678:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r6 = w7[i];
 800b67c:	f107 0314 	add.w	r3, r7, #20
 800b680:	f8d7 2e54 	ldr.w	r2, [r7, #3668]	; 0xe54
 800b684:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b688:	f8a7 3e16 	strh.w	r3, [r7, #3606]	; 0xe16

        r1 = r1 + r4;
 800b68c:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b690:	f8b7 3e1a 	ldrh.w	r3, [r7, #3610]	; 0xe1a
 800b694:	4413      	add	r3, r2
 800b696:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r5 = r5 - r4;
 800b69a:	f8b7 2e18 	ldrh.w	r2, [r7, #3608]	; 0xe18
 800b69e:	f8b7 3e1a 	ldrh.w	r3, [r7, #3610]	; 0xe1a
 800b6a2:	1ad3      	subs	r3, r2, r3
 800b6a4:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r3 = ((r3 - r2) >> 1);
 800b6a8:	f8b7 2e1c 	ldrh.w	r2, [r7, #3612]	; 0xe1c
 800b6ac:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b6b0:	1ad3      	subs	r3, r2, r3
 800b6b2:	105b      	asrs	r3, r3, #1
 800b6b4:	f8a7 3e1c 	strh.w	r3, [r7, #3612]	; 0xe1c
        r4 = r4 - r0;
 800b6b8:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b6bc:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b6c0:	1ad3      	subs	r3, r2, r3
 800b6c2:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r4 = r4 - (r6 << 6);
 800b6c6:	f8b7 3e16 	ldrh.w	r3, [r7, #3606]	; 0xe16
 800b6ca:	019b      	lsls	r3, r3, #6
 800b6cc:	b29b      	uxth	r3, r3
 800b6ce:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b6d2:	1ad3      	subs	r3, r2, r3
 800b6d4:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r4 = (r4 << 1) + r5;
 800b6d8:	f8b7 3e1a 	ldrh.w	r3, [r7, #3610]	; 0xe1a
 800b6dc:	005b      	lsls	r3, r3, #1
 800b6de:	b29a      	uxth	r2, r3
 800b6e0:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b6e4:	4413      	add	r3, r2
 800b6e6:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r2 = r2 + r3;
 800b6ea:	f8b7 2e1e 	ldrh.w	r2, [r7, #3614]	; 0xe1e
 800b6ee:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b6f2:	4413      	add	r3, r2
 800b6f4:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r1 = r1 - (r2 << 6) - r2;
 800b6f8:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b6fc:	019b      	lsls	r3, r3, #6
 800b6fe:	b29b      	uxth	r3, r3
 800b700:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b704:	1ad3      	subs	r3, r2, r3
 800b706:	b29a      	uxth	r2, r3
 800b708:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b70c:	1ad3      	subs	r3, r2, r3
 800b70e:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r2 = r2 - r6;
 800b712:	f8b7 2e1e 	ldrh.w	r2, [r7, #3614]	; 0xe1e
 800b716:	f8b7 3e16 	ldrh.w	r3, [r7, #3606]	; 0xe16
 800b71a:	1ad3      	subs	r3, r2, r3
 800b71c:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r2 = r2 - r0;
 800b720:	f8b7 2e1e 	ldrh.w	r2, [r7, #3614]	; 0xe1e
 800b724:	f8b7 3e22 	ldrh.w	r3, [r7, #3618]	; 0xe22
 800b728:	1ad3      	subs	r3, r2, r3
 800b72a:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r1 = r1 + 45 * r2;
 800b72e:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b732:	461a      	mov	r2, r3
 800b734:	0052      	lsls	r2, r2, #1
 800b736:	4413      	add	r3, r2
 800b738:	461a      	mov	r2, r3
 800b73a:	0112      	lsls	r2, r2, #4
 800b73c:	1ad3      	subs	r3, r2, r3
 800b73e:	b29a      	uxth	r2, r3
 800b740:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b744:	4413      	add	r3, r2
 800b746:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r4 = (uint16_t)(((r4 - (r2 << 3)) * (uint32_t)inv3) >> 3);
 800b74a:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b74e:	f8b7 3e1e 	ldrh.w	r3, [r7, #3614]	; 0xe1e
 800b752:	00db      	lsls	r3, r3, #3
 800b754:	1ad3      	subs	r3, r2, r3
 800b756:	461a      	mov	r2, r3
 800b758:	f8b7 3e4e 	ldrh.w	r3, [r7, #3662]	; 0xe4e
 800b75c:	fb03 f302 	mul.w	r3, r3, r2
 800b760:	08db      	lsrs	r3, r3, #3
 800b762:	f8a7 3e1a 	strh.w	r3, [r7, #3610]	; 0xe1a
        r5 = r5 + r1;
 800b766:	f8b7 2e18 	ldrh.w	r2, [r7, #3608]	; 0xe18
 800b76a:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b76e:	4413      	add	r3, r2
 800b770:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r1 = (uint16_t)(((r1 + (r3 << 4)) * (uint32_t)inv9) >> 1);
 800b774:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b778:	f8b7 3e1c 	ldrh.w	r3, [r7, #3612]	; 0xe1c
 800b77c:	011b      	lsls	r3, r3, #4
 800b77e:	4413      	add	r3, r2
 800b780:	461a      	mov	r2, r3
 800b782:	f8b7 3e4c 	ldrh.w	r3, [r7, #3660]	; 0xe4c
 800b786:	fb03 f302 	mul.w	r3, r3, r2
 800b78a:	085b      	lsrs	r3, r3, #1
 800b78c:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20
        r3 = -(r3 + r1);
 800b790:	f8b7 2e1c 	ldrh.w	r2, [r7, #3612]	; 0xe1c
 800b794:	f8b7 3e20 	ldrh.w	r3, [r7, #3616]	; 0xe20
 800b798:	4413      	add	r3, r2
 800b79a:	b29b      	uxth	r3, r3
 800b79c:	425b      	negs	r3, r3
 800b79e:	f8a7 3e1c 	strh.w	r3, [r7, #3612]	; 0xe1c
        r5 = (uint16_t)(((30 * r1 - r5) * (uint32_t)inv15) >> 2);
 800b7a2:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b7a6:	4613      	mov	r3, r2
 800b7a8:	011b      	lsls	r3, r3, #4
 800b7aa:	1a9b      	subs	r3, r3, r2
 800b7ac:	005b      	lsls	r3, r3, #1
 800b7ae:	461a      	mov	r2, r3
 800b7b0:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b7b4:	1ad3      	subs	r3, r2, r3
 800b7b6:	461a      	mov	r2, r3
 800b7b8:	f8b7 3e4a 	ldrh.w	r3, [r7, #3658]	; 0xe4a
 800b7bc:	fb03 f302 	mul.w	r3, r3, r2
 800b7c0:	089b      	lsrs	r3, r3, #2
 800b7c2:	f8a7 3e18 	strh.w	r3, [r7, #3608]	; 0xe18
        r2 = r2 - r4;
 800b7c6:	f8b7 2e1e 	ldrh.w	r2, [r7, #3614]	; 0xe1e
 800b7ca:	f8b7 3e1a 	ldrh.w	r3, [r7, #3610]	; 0xe1a
 800b7ce:	1ad3      	subs	r3, r2, r3
 800b7d0:	f8a7 3e1e 	strh.w	r3, [r7, #3614]	; 0xe1e
        r1 = r1 - r5;
 800b7d4:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b7d8:	f8b7 3e18 	ldrh.w	r3, [r7, #3608]	; 0xe18
 800b7dc:	1ad3      	subs	r3, r2, r3
 800b7de:	f8a7 3e20 	strh.w	r3, [r7, #3616]	; 0xe20

        C[i]     += r6;
 800b7e2:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b7e6:	005b      	lsls	r3, r3, #1
 800b7e8:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b7ec:	4413      	add	r3, r2
 800b7ee:	8819      	ldrh	r1, [r3, #0]
 800b7f0:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b7f4:	005b      	lsls	r3, r3, #1
 800b7f6:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b7fa:	4413      	add	r3, r2
 800b7fc:	f8b7 2e16 	ldrh.w	r2, [r7, #3606]	; 0xe16
 800b800:	440a      	add	r2, r1
 800b802:	b292      	uxth	r2, r2
 800b804:	801a      	strh	r2, [r3, #0]
        C[i + 64]  += r5;
 800b806:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b80a:	3340      	adds	r3, #64	; 0x40
 800b80c:	005b      	lsls	r3, r3, #1
 800b80e:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b812:	4413      	add	r3, r2
 800b814:	8819      	ldrh	r1, [r3, #0]
 800b816:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b81a:	3340      	adds	r3, #64	; 0x40
 800b81c:	005b      	lsls	r3, r3, #1
 800b81e:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b822:	4413      	add	r3, r2
 800b824:	f8b7 2e18 	ldrh.w	r2, [r7, #3608]	; 0xe18
 800b828:	440a      	add	r2, r1
 800b82a:	b292      	uxth	r2, r2
 800b82c:	801a      	strh	r2, [r3, #0]
        C[i + 128] += r4;
 800b82e:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b832:	3380      	adds	r3, #128	; 0x80
 800b834:	005b      	lsls	r3, r3, #1
 800b836:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b83a:	4413      	add	r3, r2
 800b83c:	8819      	ldrh	r1, [r3, #0]
 800b83e:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b842:	3380      	adds	r3, #128	; 0x80
 800b844:	005b      	lsls	r3, r3, #1
 800b846:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b84a:	4413      	add	r3, r2
 800b84c:	f8b7 2e1a 	ldrh.w	r2, [r7, #3610]	; 0xe1a
 800b850:	440a      	add	r2, r1
 800b852:	b292      	uxth	r2, r2
 800b854:	801a      	strh	r2, [r3, #0]
        C[i + 192] += r3;
 800b856:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b85a:	33c0      	adds	r3, #192	; 0xc0
 800b85c:	005b      	lsls	r3, r3, #1
 800b85e:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b862:	4413      	add	r3, r2
 800b864:	8819      	ldrh	r1, [r3, #0]
 800b866:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b86a:	33c0      	adds	r3, #192	; 0xc0
 800b86c:	005b      	lsls	r3, r3, #1
 800b86e:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b872:	4413      	add	r3, r2
 800b874:	f8b7 2e1c 	ldrh.w	r2, [r7, #3612]	; 0xe1c
 800b878:	440a      	add	r2, r1
 800b87a:	b292      	uxth	r2, r2
 800b87c:	801a      	strh	r2, [r3, #0]
        C[i + 256] += r2;
 800b87e:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b882:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800b886:	005b      	lsls	r3, r3, #1
 800b888:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b88c:	4413      	add	r3, r2
 800b88e:	8819      	ldrh	r1, [r3, #0]
 800b890:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b894:	f503 7380 	add.w	r3, r3, #256	; 0x100
 800b898:	005b      	lsls	r3, r3, #1
 800b89a:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b89e:	4413      	add	r3, r2
 800b8a0:	f8b7 2e1e 	ldrh.w	r2, [r7, #3614]	; 0xe1e
 800b8a4:	440a      	add	r2, r1
 800b8a6:	b292      	uxth	r2, r2
 800b8a8:	801a      	strh	r2, [r3, #0]
        C[i + 320] += r1;
 800b8aa:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b8ae:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800b8b2:	005b      	lsls	r3, r3, #1
 800b8b4:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b8b8:	4413      	add	r3, r2
 800b8ba:	8819      	ldrh	r1, [r3, #0]
 800b8bc:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b8c0:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800b8c4:	005b      	lsls	r3, r3, #1
 800b8c6:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b8ca:	4413      	add	r3, r2
 800b8cc:	f8b7 2e20 	ldrh.w	r2, [r7, #3616]	; 0xe20
 800b8d0:	440a      	add	r2, r1
 800b8d2:	b292      	uxth	r2, r2
 800b8d4:	801a      	strh	r2, [r3, #0]
        C[i + 384] += r0;
 800b8d6:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b8da:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800b8de:	005b      	lsls	r3, r3, #1
 800b8e0:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b8e4:	4413      	add	r3, r2
 800b8e6:	8819      	ldrh	r1, [r3, #0]
 800b8e8:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b8ec:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800b8f0:	005b      	lsls	r3, r3, #1
 800b8f2:	f8d7 2e24 	ldr.w	r2, [r7, #3620]	; 0xe24
 800b8f6:	4413      	add	r3, r2
 800b8f8:	f8b7 2e22 	ldrh.w	r2, [r7, #3618]	; 0xe22
 800b8fc:	440a      	add	r2, r1
 800b8fe:	b292      	uxth	r2, r2
 800b900:	801a      	strh	r2, [r3, #0]
    for (i = 0; i < N_SB_RES; ++i) {
 800b902:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b906:	3301      	adds	r3, #1
 800b908:	f8c7 3e54 	str.w	r3, [r7, #3668]	; 0xe54
 800b90c:	f8d7 3e54 	ldr.w	r3, [r7, #3668]	; 0xe54
 800b910:	2b7e      	cmp	r3, #126	; 0x7e
 800b912:	f77f ae83 	ble.w	800b61c <toom_cook_4way+0x484>
    }
}
 800b916:	bf00      	nop
 800b918:	f607 6758 	addw	r7, r7, #3672	; 0xe58
 800b91c:	46bd      	mov	sp, r7
 800b91e:	bd80      	pop	{r7, pc}

0800b920 <PQCLEAN_FIRESABER_CLEAN_poly_mul>:

/* res += a*b */
void PQCLEAN_FIRESABER_CLEAN_poly_mul(poly *c, const poly *a, const poly *b, const int accumulate) {
 800b920:	b590      	push	{r4, r7, lr}
 800b922:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
 800b926:	af00      	add	r7, sp, #0
 800b928:	f107 040c 	add.w	r4, r7, #12
 800b92c:	6020      	str	r0, [r4, #0]
 800b92e:	f107 0008 	add.w	r0, r7, #8
 800b932:	6001      	str	r1, [r0, #0]
 800b934:	1d39      	adds	r1, r7, #4
 800b936:	600a      	str	r2, [r1, #0]
 800b938:	463a      	mov	r2, r7
 800b93a:	6013      	str	r3, [r2, #0]
    uint16_t C[2 * SABER_N] = {0};
 800b93c:	f107 0314 	add.w	r3, r7, #20
 800b940:	4618      	mov	r0, r3
 800b942:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800b946:	461a      	mov	r2, r3
 800b948:	2100      	movs	r1, #0
 800b94a:	f00f fb50 	bl	801afee <memset>
    size_t i;

    toom_cook_4way(C, a->coeffs, b->coeffs);
 800b94e:	f107 0308 	add.w	r3, r7, #8
 800b952:	6819      	ldr	r1, [r3, #0]
 800b954:	1d3b      	adds	r3, r7, #4
 800b956:	681a      	ldr	r2, [r3, #0]
 800b958:	f107 0314 	add.w	r3, r7, #20
 800b95c:	4618      	mov	r0, r3
 800b95e:	f7ff fc1b 	bl	800b198 <toom_cook_4way>

    /* reduction */
    if (accumulate == 0) {
 800b962:	463b      	mov	r3, r7
 800b964:	681b      	ldr	r3, [r3, #0]
 800b966:	2b00      	cmp	r3, #0
 800b968:	d128      	bne.n	800b9bc <PQCLEAN_FIRESABER_CLEAN_poly_mul+0x9c>
        for (i = SABER_N; i < 2 * SABER_N; i++) {
 800b96a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b96e:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
 800b972:	e01d      	b.n	800b9b0 <PQCLEAN_FIRESABER_CLEAN_poly_mul+0x90>
            c->coeffs[i - SABER_N] = (C[i - SABER_N] - C[i]);
 800b974:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800b978:	f5a3 7280 	sub.w	r2, r3, #256	; 0x100
 800b97c:	f107 0314 	add.w	r3, r7, #20
 800b980:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 800b984:	f107 0314 	add.w	r3, r7, #20
 800b988:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 800b98c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800b990:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 800b994:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
 800b998:	1acb      	subs	r3, r1, r3
 800b99a:	b299      	uxth	r1, r3
 800b99c:	f107 030c 	add.w	r3, r7, #12
 800b9a0:	681b      	ldr	r3, [r3, #0]
 800b9a2:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        for (i = SABER_N; i < 2 * SABER_N; i++) {
 800b9a6:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800b9aa:	3301      	adds	r3, #1
 800b9ac:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
 800b9b0:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800b9b4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b9b8:	d3dc      	bcc.n	800b974 <PQCLEAN_FIRESABER_CLEAN_poly_mul+0x54>
    } else {
        for (i = SABER_N; i < 2 * SABER_N; i++) {
            c->coeffs[i - SABER_N] += (C[i - SABER_N] - C[i]);
        }
    }
}
 800b9ba:	e032      	b.n	800ba22 <PQCLEAN_FIRESABER_CLEAN_poly_mul+0x102>
        for (i = SABER_N; i < 2 * SABER_N; i++) {
 800b9bc:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b9c0:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
 800b9c4:	e028      	b.n	800ba18 <PQCLEAN_FIRESABER_CLEAN_poly_mul+0xf8>
            c->coeffs[i - SABER_N] += (C[i - SABER_N] - C[i]);
 800b9c6:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800b9ca:	f5a3 7280 	sub.w	r2, r3, #256	; 0x100
 800b9ce:	f107 030c 	add.w	r3, r7, #12
 800b9d2:	681b      	ldr	r3, [r3, #0]
 800b9d4:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 800b9d8:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800b9dc:	f5a3 7280 	sub.w	r2, r3, #256	; 0x100
 800b9e0:	f107 0314 	add.w	r3, r7, #20
 800b9e4:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 800b9e8:	f107 0314 	add.w	r3, r7, #20
 800b9ec:	f8d7 0414 	ldr.w	r0, [r7, #1044]	; 0x414
 800b9f0:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
 800b9f4:	1ad3      	subs	r3, r2, r3
 800b9f6:	b29b      	uxth	r3, r3
 800b9f8:	f8d7 2414 	ldr.w	r2, [r7, #1044]	; 0x414
 800b9fc:	f5a2 7280 	sub.w	r2, r2, #256	; 0x100
 800ba00:	440b      	add	r3, r1
 800ba02:	b299      	uxth	r1, r3
 800ba04:	f107 030c 	add.w	r3, r7, #12
 800ba08:	681b      	ldr	r3, [r3, #0]
 800ba0a:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
        for (i = SABER_N; i < 2 * SABER_N; i++) {
 800ba0e:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800ba12:	3301      	adds	r3, #1
 800ba14:	f8c7 3414 	str.w	r3, [r7, #1044]	; 0x414
 800ba18:	f8d7 3414 	ldr.w	r3, [r7, #1044]	; 0x414
 800ba1c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ba20:	d3d1      	bcc.n	800b9c6 <PQCLEAN_FIRESABER_CLEAN_poly_mul+0xa6>
}
 800ba22:	bf00      	nop
 800ba24:	f207 471c 	addw	r7, r7, #1052	; 0x41c
 800ba28:	46bd      	mov	sp, r7
 800ba2a:	bd90      	pop	{r4, r7, pc}

0800ba2c <PQCLEAN_FIRESABER_CLEAN_verify>:
Vadim Lyubashevsky, John M. Schanck, Peter Schwabe & Damien stehle
----------------------------------------------------*/


/* returns 0 for equal strings, 1 for non-equal strings */
uint8_t PQCLEAN_FIRESABER_CLEAN_verify(const uint8_t *a, const uint8_t *b, size_t len) {
 800ba2c:	e92d 0890 	stmdb	sp!, {r4, r7, fp}
 800ba30:	b089      	sub	sp, #36	; 0x24
 800ba32:	af00      	add	r7, sp, #0
 800ba34:	60f8      	str	r0, [r7, #12]
 800ba36:	60b9      	str	r1, [r7, #8]
 800ba38:	607a      	str	r2, [r7, #4]
    uint64_t r;
    size_t i;
    r = 0;
 800ba3a:	f04f 0300 	mov.w	r3, #0
 800ba3e:	f04f 0400 	mov.w	r4, #0
 800ba42:	e9c7 3406 	strd	r3, r4, [r7, #24]

    for (i = 0; i < len; i++) {
 800ba46:	2300      	movs	r3, #0
 800ba48:	617b      	str	r3, [r7, #20]
 800ba4a:	e018      	b.n	800ba7e <PQCLEAN_FIRESABER_CLEAN_verify+0x52>
        r |= a[i] ^ b[i];
 800ba4c:	68fa      	ldr	r2, [r7, #12]
 800ba4e:	697b      	ldr	r3, [r7, #20]
 800ba50:	4413      	add	r3, r2
 800ba52:	781a      	ldrb	r2, [r3, #0]
 800ba54:	68b9      	ldr	r1, [r7, #8]
 800ba56:	697b      	ldr	r3, [r7, #20]
 800ba58:	440b      	add	r3, r1
 800ba5a:	781b      	ldrb	r3, [r3, #0]
 800ba5c:	4053      	eors	r3, r2
 800ba5e:	b2db      	uxtb	r3, r3
 800ba60:	fa5f fb83 	uxtb.w	fp, r3
 800ba64:	f04f 0c00 	mov.w	ip, #0
 800ba68:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800ba6c:	ea4b 0301 	orr.w	r3, fp, r1
 800ba70:	ea4c 0402 	orr.w	r4, ip, r2
 800ba74:	e9c7 3406 	strd	r3, r4, [r7, #24]
    for (i = 0; i < len; i++) {
 800ba78:	697b      	ldr	r3, [r7, #20]
 800ba7a:	3301      	adds	r3, #1
 800ba7c:	617b      	str	r3, [r7, #20]
 800ba7e:	697a      	ldr	r2, [r7, #20]
 800ba80:	687b      	ldr	r3, [r7, #4]
 800ba82:	429a      	cmp	r2, r3
 800ba84:	d3e2      	bcc.n	800ba4c <PQCLEAN_FIRESABER_CLEAN_verify+0x20>
    }

    r = (~r + 1); // Two's complement
 800ba86:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800ba8a:	425b      	negs	r3, r3
 800ba8c:	eb64 0444 	sbc.w	r4, r4, r4, lsl #1
 800ba90:	e9c7 3406 	strd	r3, r4, [r7, #24]
    r >>= 63;
 800ba94:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800ba98:	f04f 0300 	mov.w	r3, #0
 800ba9c:	f04f 0400 	mov.w	r4, #0
 800baa0:	0fd3      	lsrs	r3, r2, #31
 800baa2:	2400      	movs	r4, #0
 800baa4:	e9c7 3406 	strd	r3, r4, [r7, #24]
    return (uint8_t) r;
 800baa8:	7e3b      	ldrb	r3, [r7, #24]
}
 800baaa:	4618      	mov	r0, r3
 800baac:	3724      	adds	r7, #36	; 0x24
 800baae:	46bd      	mov	sp, r7
 800bab0:	e8bd 0890 	ldmia.w	sp!, {r4, r7, fp}
 800bab4:	4770      	bx	lr

0800bab6 <PQCLEAN_FIRESABER_CLEAN_cmov>:

/* b = 1 means mov, b = 0 means don't mov*/
void PQCLEAN_FIRESABER_CLEAN_cmov(uint8_t *r, const uint8_t *x, size_t len, uint8_t b) {
 800bab6:	b480      	push	{r7}
 800bab8:	b087      	sub	sp, #28
 800baba:	af00      	add	r7, sp, #0
 800babc:	60f8      	str	r0, [r7, #12]
 800babe:	60b9      	str	r1, [r7, #8]
 800bac0:	607a      	str	r2, [r7, #4]
 800bac2:	70fb      	strb	r3, [r7, #3]
    size_t i;

    b = -b;
 800bac4:	78fb      	ldrb	r3, [r7, #3]
 800bac6:	425b      	negs	r3, r3
 800bac8:	70fb      	strb	r3, [r7, #3]
    for (i = 0; i < len; i++) {
 800baca:	2300      	movs	r3, #0
 800bacc:	617b      	str	r3, [r7, #20]
 800bace:	e019      	b.n	800bb04 <PQCLEAN_FIRESABER_CLEAN_cmov+0x4e>
        r[i] ^= b & (x[i] ^ r[i]);
 800bad0:	68fa      	ldr	r2, [r7, #12]
 800bad2:	697b      	ldr	r3, [r7, #20]
 800bad4:	4413      	add	r3, r2
 800bad6:	7819      	ldrb	r1, [r3, #0]
 800bad8:	68ba      	ldr	r2, [r7, #8]
 800bada:	697b      	ldr	r3, [r7, #20]
 800badc:	4413      	add	r3, r2
 800bade:	781a      	ldrb	r2, [r3, #0]
 800bae0:	68f8      	ldr	r0, [r7, #12]
 800bae2:	697b      	ldr	r3, [r7, #20]
 800bae4:	4403      	add	r3, r0
 800bae6:	781b      	ldrb	r3, [r3, #0]
 800bae8:	4053      	eors	r3, r2
 800baea:	b2da      	uxtb	r2, r3
 800baec:	78fb      	ldrb	r3, [r7, #3]
 800baee:	4013      	ands	r3, r2
 800baf0:	b2da      	uxtb	r2, r3
 800baf2:	68f8      	ldr	r0, [r7, #12]
 800baf4:	697b      	ldr	r3, [r7, #20]
 800baf6:	4403      	add	r3, r0
 800baf8:	404a      	eors	r2, r1
 800bafa:	b2d2      	uxtb	r2, r2
 800bafc:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < len; i++) {
 800bafe:	697b      	ldr	r3, [r7, #20]
 800bb00:	3301      	adds	r3, #1
 800bb02:	617b      	str	r3, [r7, #20]
 800bb04:	697a      	ldr	r2, [r7, #20]
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	429a      	cmp	r2, r3
 800bb0a:	d3e1      	bcc.n	800bad0 <PQCLEAN_FIRESABER_CLEAN_cmov+0x1a>
    }
}
 800bb0c:	bf00      	nop
 800bb0e:	371c      	adds	r7, #28
 800bb10:	46bd      	mov	sp, r7
 800bb12:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb16:	4770      	bx	lr

0800bb18 <se3_algo_Aes_init>:

#include "se3_algo_Aes.h"

uint16_t se3_algo_Aes_init(
    se3_flash_key* key, uint16_t mode, uint8_t* ctx)
{
 800bb18:	b580      	push	{r7, lr}
 800bb1a:	b088      	sub	sp, #32
 800bb1c:	af00      	add	r7, sp, #0
 800bb1e:	60f8      	str	r0, [r7, #12]
 800bb20:	460b      	mov	r3, r1
 800bb22:	607a      	str	r2, [r7, #4]
 800bb24:	817b      	strh	r3, [r7, #10]
    B5_tAesCtx* aes = (B5_tAesCtx*)ctx;
 800bb26:	687b      	ldr	r3, [r7, #4]
 800bb28:	61bb      	str	r3, [r7, #24]
	
	uint16_t feedback = mode & 0x07;
 800bb2a:	897b      	ldrh	r3, [r7, #10]
 800bb2c:	f003 0307 	and.w	r3, r3, #7
 800bb30:	82fb      	strh	r3, [r7, #22]
	uint16_t direction = (mode & SE3_DIR_ENCRYPT) ? SE3_DIR_ENCRYPT : SE3_DIR_DECRYPT;
 800bb32:	897b      	ldrh	r3, [r7, #10]
 800bb34:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800bb38:	2b00      	cmp	r3, #0
 800bb3a:	d002      	beq.n	800bb42 <se3_algo_Aes_init+0x2a>
 800bb3c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800bb40:	e001      	b.n	800bb46 <se3_algo_Aes_init+0x2e>
 800bb42:	f44f 7300 	mov.w	r3, #512	; 0x200
 800bb46:	82bb      	strh	r3, [r7, #20]
	uint8_t b5_mode = 0;
 800bb48:	2300      	movs	r3, #0
 800bb4a:	77fb      	strb	r3, [r7, #31]

	switch (key->data_size) {
 800bb4c:	68fb      	ldr	r3, [r7, #12]
 800bb4e:	891b      	ldrh	r3, [r3, #8]
 800bb50:	2b18      	cmp	r3, #24
 800bb52:	d006      	beq.n	800bb62 <se3_algo_Aes_init+0x4a>
 800bb54:	2b20      	cmp	r3, #32
 800bb56:	d004      	beq.n	800bb62 <se3_algo_Aes_init+0x4a>
 800bb58:	2b10      	cmp	r3, #16
 800bb5a:	d002      	beq.n	800bb62 <se3_algo_Aes_init+0x4a>
	case B5_AES_192:
	case B5_AES_128:
		break;
	default:
		// unsupported key size
		return SE3_ERR_PARAMS;
 800bb5c:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bb60:	e06f      	b.n	800bc42 <se3_algo_Aes_init+0x12a>
		break;
 800bb62:	bf00      	nop
	}

	switch (direction) {
 800bb64:	8abb      	ldrh	r3, [r7, #20]
 800bb66:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800bb6a:	d003      	beq.n	800bb74 <se3_algo_Aes_init+0x5c>
 800bb6c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800bb70:	d02a      	beq.n	800bbc8 <se3_algo_Aes_init+0xb0>
 800bb72:	e053      	b.n	800bc1c <se3_algo_Aes_init+0x104>
	case (SE3_DIR_ENCRYPT):
		switch (feedback) {
 800bb74:	8afb      	ldrh	r3, [r7, #22]
 800bb76:	3b01      	subs	r3, #1
 800bb78:	2b05      	cmp	r3, #5
 800bb7a:	d821      	bhi.n	800bbc0 <se3_algo_Aes_init+0xa8>
 800bb7c:	a201      	add	r2, pc, #4	; (adr r2, 800bb84 <se3_algo_Aes_init+0x6c>)
 800bb7e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bb82:	bf00      	nop
 800bb84:	0800bb9d 	.word	0x0800bb9d
 800bb88:	0800bba3 	.word	0x0800bba3
 800bb8c:	0800bbaf 	.word	0x0800bbaf
 800bb90:	0800bba9 	.word	0x0800bba9
 800bb94:	0800bbb5 	.word	0x0800bbb5
 800bb98:	0800bbbb 	.word	0x0800bbbb
		case SE3_FEEDBACK_ECB: b5_mode = B5_AES256_ECB_ENC; break;
 800bb9c:	2302      	movs	r3, #2
 800bb9e:	77fb      	strb	r3, [r7, #31]
 800bba0:	e011      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		case SE3_FEEDBACK_CBC: b5_mode = B5_AES256_CBC_ENC; break;
 800bba2:	2304      	movs	r3, #4
 800bba4:	77fb      	strb	r3, [r7, #31]
 800bba6:	e00e      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		case SE3_FEEDBACK_CTR: b5_mode = B5_AES256_CTR; break;
 800bba8:	2308      	movs	r3, #8
 800bbaa:	77fb      	strb	r3, [r7, #31]
 800bbac:	e00b      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		case SE3_FEEDBACK_OFB: b5_mode = B5_AES256_OFB; break;
 800bbae:	2301      	movs	r3, #1
 800bbb0:	77fb      	strb	r3, [r7, #31]
 800bbb2:	e008      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		case SE3_FEEDBACK_CFB: b5_mode = B5_AES256_CFB_ENC; break;
 800bbb4:	2306      	movs	r3, #6
 800bbb6:	77fb      	strb	r3, [r7, #31]
 800bbb8:	e005      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		case SE3_FEEDBACK_GCM: b5_mode = B5_AES256_GCM_ENC; break;
 800bbba:	2309      	movs	r3, #9
 800bbbc:	77fb      	strb	r3, [r7, #31]
 800bbbe:	e002      	b.n	800bbc6 <se3_algo_Aes_init+0xae>
		default: return SE3_ERR_PARAMS;
 800bbc0:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bbc4:	e03d      	b.n	800bc42 <se3_algo_Aes_init+0x12a>
		}
		break;
 800bbc6:	e02c      	b.n	800bc22 <se3_algo_Aes_init+0x10a>
	case (SE3_DIR_DECRYPT):
		switch (feedback) {
 800bbc8:	8afb      	ldrh	r3, [r7, #22]
 800bbca:	3b01      	subs	r3, #1
 800bbcc:	2b05      	cmp	r3, #5
 800bbce:	d821      	bhi.n	800bc14 <se3_algo_Aes_init+0xfc>
 800bbd0:	a201      	add	r2, pc, #4	; (adr r2, 800bbd8 <se3_algo_Aes_init+0xc0>)
 800bbd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bbd6:	bf00      	nop
 800bbd8:	0800bbf1 	.word	0x0800bbf1
 800bbdc:	0800bbf7 	.word	0x0800bbf7
 800bbe0:	0800bc03 	.word	0x0800bc03
 800bbe4:	0800bbfd 	.word	0x0800bbfd
 800bbe8:	0800bc09 	.word	0x0800bc09
 800bbec:	0800bc0f 	.word	0x0800bc0f
		case SE3_FEEDBACK_ECB: b5_mode = B5_AES256_ECB_DEC; break;
 800bbf0:	2303      	movs	r3, #3
 800bbf2:	77fb      	strb	r3, [r7, #31]
 800bbf4:	e011      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		case SE3_FEEDBACK_CBC: b5_mode = B5_AES256_CBC_DEC; break;
 800bbf6:	2305      	movs	r3, #5
 800bbf8:	77fb      	strb	r3, [r7, #31]
 800bbfa:	e00e      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		case SE3_FEEDBACK_CTR: b5_mode = B5_AES256_CTR; break;
 800bbfc:	2308      	movs	r3, #8
 800bbfe:	77fb      	strb	r3, [r7, #31]
 800bc00:	e00b      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		case SE3_FEEDBACK_OFB: b5_mode = B5_AES256_OFB; break;
 800bc02:	2301      	movs	r3, #1
 800bc04:	77fb      	strb	r3, [r7, #31]
 800bc06:	e008      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		case SE3_FEEDBACK_CFB: b5_mode = B5_AES256_CFB_DEC; break;
 800bc08:	2307      	movs	r3, #7
 800bc0a:	77fb      	strb	r3, [r7, #31]
 800bc0c:	e005      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		case SE3_FEEDBACK_GCM: b5_mode = B5_AES256_GCM_DEC; break;
 800bc0e:	230a      	movs	r3, #10
 800bc10:	77fb      	strb	r3, [r7, #31]
 800bc12:	e002      	b.n	800bc1a <se3_algo_Aes_init+0x102>
		default: return SE3_ERR_PARAMS;
 800bc14:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bc18:	e013      	b.n	800bc42 <se3_algo_Aes_init+0x12a>
		}
		break;
 800bc1a:	e002      	b.n	800bc22 <se3_algo_Aes_init+0x10a>
	default:
		return SE3_ERR_PARAMS;
 800bc1c:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bc20:	e00f      	b.n	800bc42 <se3_algo_Aes_init+0x12a>
	}


    if (B5_AES256_RES_OK != B5_Aes256_Init(aes, key->data, (int16_t)key->data_size, b5_mode)) {
 800bc22:	68fb      	ldr	r3, [r7, #12]
 800bc24:	68d9      	ldr	r1, [r3, #12]
 800bc26:	68fb      	ldr	r3, [r7, #12]
 800bc28:	891b      	ldrh	r3, [r3, #8]
 800bc2a:	b21a      	sxth	r2, r3
 800bc2c:	7ffb      	ldrb	r3, [r7, #31]
 800bc2e:	69b8      	ldr	r0, [r7, #24]
 800bc30:	f7f7 fece 	bl	80039d0 <B5_Aes256_Init>
 800bc34:	4603      	mov	r3, r0
 800bc36:	2b00      	cmp	r3, #0
 800bc38:	d002      	beq.n	800bc40 <se3_algo_Aes_init+0x128>
        SE3_TRACE(("[algo_aes256.init] B5_Aes256_Init failed\n"));
        return SE3_ERR_PARAMS;
 800bc3a:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bc3e:	e000      	b.n	800bc42 <se3_algo_Aes_init+0x12a>
    }
	
    return SE3_OK;
 800bc40:	2300      	movs	r3, #0
}
 800bc42:	4618      	mov	r0, r3
 800bc44:	3720      	adds	r7, #32
 800bc46:	46bd      	mov	sp, r7
 800bc48:	bd80      	pop	{r7, pc}
 800bc4a:	bf00      	nop

0800bc4c <se3_algo_Aes_update>:
    uint8_t* ctx, uint16_t flags,
    uint16_t datain0_len, const uint8_t* datain0,
    uint16_t datain1_len, const uint8_t* datain1,
    uint16_t datain2_len, const uint8_t* datain2,
    uint16_t* dataout_len, uint8_t* dataout)
{
 800bc4c:	b580      	push	{r7, lr}
 800bc4e:	b08e      	sub	sp, #56	; 0x38
 800bc50:	af02      	add	r7, sp, #8
 800bc52:	60f8      	str	r0, [r7, #12]
 800bc54:	607b      	str	r3, [r7, #4]
 800bc56:	460b      	mov	r3, r1
 800bc58:	817b      	strh	r3, [r7, #10]
 800bc5a:	4613      	mov	r3, r2
 800bc5c:	813b      	strh	r3, [r7, #8]
	SE3_TRACE(("[algo_aes256.update] OKOKOK \n"));
    B5_tAesCtx* aes = (B5_tAesCtx*)ctx;
 800bc5e:	68fb      	ldr	r3, [r7, #12]
 800bc60:	623b      	str	r3, [r7, #32]
    size_t nblocks = 0;
 800bc62:	2300      	movs	r3, #0
 800bc64:	61fb      	str	r3, [r7, #28]
    size_t n_ass_blocks = 0;
 800bc66:	2300      	movs	r3, #0
 800bc68:	61bb      	str	r3, [r7, #24]
    uint8_t *data_ass, *data_enc, *data_dec;
    bool do_setiv = false;
 800bc6a:	2300      	movs	r3, #0
 800bc6c:	75fb      	strb	r3, [r7, #23]
    bool do_update = false;
 800bc6e:	2300      	movs	r3, #0
 800bc70:	75bb      	strb	r3, [r7, #22]
    bool do_finit = false;
 800bc72:	2300      	movs	r3, #0
 800bc74:	757b      	strb	r3, [r7, #21]
	

	do_setiv = flags & SE3_CRYPTO_FLAG_SETIV;
 800bc76:	897b      	ldrh	r3, [r7, #10]
 800bc78:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800bc7c:	2b00      	cmp	r3, #0
 800bc7e:	bf14      	ite	ne
 800bc80:	2301      	movne	r3, #1
 800bc82:	2300      	moveq	r3, #0
 800bc84:	75fb      	strb	r3, [r7, #23]
	do_update = datain2_len > 0;
 800bc86:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800bc8a:	2b00      	cmp	r3, #0
 800bc8c:	bf14      	ite	ne
 800bc8e:	2301      	movne	r3, #1
 800bc90:	2300      	moveq	r3, #0
 800bc92:	75bb      	strb	r3, [r7, #22]
	do_finit = flags & SE3_CRYPTO_FLAG_FINIT;
 800bc94:	897b      	ldrh	r3, [r7, #10]
 800bc96:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800bc9a:	2b00      	cmp	r3, #0
 800bc9c:	bf14      	ite	ne
 800bc9e:	2301      	movne	r3, #1
 800bca0:	2300      	moveq	r3, #0
 800bca2:	757b      	strb	r3, [r7, #21]

    // check params
	if (do_setiv && (datain1_len != B5_AES_BLK_SIZE)) {
 800bca4:	7dfb      	ldrb	r3, [r7, #23]
 800bca6:	2b00      	cmp	r3, #0
 800bca8:	d005      	beq.n	800bcb6 <se3_algo_Aes_update+0x6a>
 800bcaa:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800bcac:	2b10      	cmp	r3, #16
 800bcae:	d002      	beq.n	800bcb6 <se3_algo_Aes_update+0x6a>
		SE3_TRACE(("[algo_aes256.update] invalid IV size\n"));
		return SE3_ERR_PARAMS;
 800bcb0:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bcb4:	e093      	b.n	800bdde <se3_algo_Aes_update+0x192>
	}
    if (do_update) {
 800bcb6:	7dbb      	ldrb	r3, [r7, #22]
 800bcb8:	2b00      	cmp	r3, #0
 800bcba:	d012      	beq.n	800bce2 <se3_algo_Aes_update+0x96>
        if (datain0_len % B5_AES_BLK_SIZE != 0) {
 800bcbc:	893b      	ldrh	r3, [r7, #8]
 800bcbe:	f003 030f 	and.w	r3, r3, #15
 800bcc2:	b29b      	uxth	r3, r3
 800bcc4:	2b00      	cmp	r3, #0
 800bcc6:	d002      	beq.n	800bcce <se3_algo_Aes_update+0x82>
            SE3_TRACE(("[algo_aes256.update] associated data size not a multiple of block size\n"));
            return SE3_ERR_PARAMS;
 800bcc8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bccc:	e087      	b.n	800bdde <se3_algo_Aes_update+0x192>
        }
        if (datain2_len % B5_AES_BLK_SIZE != 0) {
 800bcce:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800bcd2:	f003 030f 	and.w	r3, r3, #15
 800bcd6:	b29b      	uxth	r3, r3
 800bcd8:	2b00      	cmp	r3, #0
 800bcda:	d002      	beq.n	800bce2 <se3_algo_Aes_update+0x96>
            SE3_TRACE(("[algo_aes256.update] data size not a multiple of block size\n"));
            return SE3_ERR_PARAMS;
 800bcdc:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bce0:	e07d      	b.n	800bdde <se3_algo_Aes_update+0x192>
        }
    }


    if (do_setiv) {
 800bce2:	7dfb      	ldrb	r3, [r7, #23]
 800bce4:	2b00      	cmp	r3, #0
 800bce6:	d009      	beq.n	800bcfc <se3_algo_Aes_update+0xb0>
        // set IV
        if (B5_AES256_RES_OK != B5_Aes256_SetIV(aes, datain1)) {
 800bce8:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800bcea:	6a38      	ldr	r0, [r7, #32]
 800bcec:	f7f7 ff44 	bl	8003b78 <B5_Aes256_SetIV>
 800bcf0:	4603      	mov	r3, r0
 800bcf2:	2b00      	cmp	r3, #0
 800bcf4:	d002      	beq.n	800bcfc <se3_algo_Aes_update+0xb0>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_SetIV failed\n"));
            return SE3_ERR_HW;
 800bcf6:	f24f 0301 	movw	r3, #61441	; 0xf001
 800bcfa:	e070      	b.n	800bdde <se3_algo_Aes_update+0x192>
        }
    }

    if (do_update) {
 800bcfc:	7dbb      	ldrb	r3, [r7, #22]
 800bcfe:	2b00      	cmp	r3, #0
 800bd00:	d060      	beq.n	800bdc4 <se3_algo_Aes_update+0x178>
        // update
		nblocks = datain2_len / B5_AES_BLK_SIZE;
 800bd02:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800bd06:	091b      	lsrs	r3, r3, #4
 800bd08:	b29b      	uxth	r3, r3
 800bd0a:	61fb      	str	r3, [r7, #28]
		n_ass_blocks = datain0_len / B5_AES_BLK_SIZE;
 800bd0c:	893b      	ldrh	r3, [r7, #8]
 800bd0e:	091b      	lsrs	r3, r3, #4
 800bd10:	b29b      	uxth	r3, r3
 800bd12:	61bb      	str	r3, [r7, #24]
        switch (aes->mode) {
 800bd14:	6a3b      	ldr	r3, [r7, #32]
 800bd16:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 800bd1a:	3b03      	subs	r3, #3
 800bd1c:	2b07      	cmp	r3, #7
 800bd1e:	d836      	bhi.n	800bd8e <se3_algo_Aes_update+0x142>
 800bd20:	a201      	add	r2, pc, #4	; (adr r2, 800bd28 <se3_algo_Aes_update+0xdc>)
 800bd22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bd26:	bf00      	nop
 800bd28:	0800bd49 	.word	0x0800bd49
 800bd2c:	0800bd8f 	.word	0x0800bd8f
 800bd30:	0800bd49 	.word	0x0800bd49
 800bd34:	0800bd8f 	.word	0x0800bd8f
 800bd38:	0800bd49 	.word	0x0800bd49
 800bd3c:	0800bd8f 	.word	0x0800bd8f
 800bd40:	0800bd75 	.word	0x0800bd75
 800bd44:	0800bd5b 	.word	0x0800bd5b
        case B5_AES256_ECB_DEC:
        case B5_AES256_CBC_DEC:
        case B5_AES256_CFB_DEC:
            data_enc = (uint8_t*)datain2;
 800bd48:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bd4a:	62bb      	str	r3, [r7, #40]	; 0x28
            data_dec = dataout;
 800bd4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bd4e:	627b      	str	r3, [r7, #36]	; 0x24
            *dataout_len = datain2_len;
 800bd50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800bd52:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 800bd56:	801a      	strh	r2, [r3, #0]
            break;
 800bd58:	e022      	b.n	800bda0 <se3_algo_Aes_update+0x154>
        case B5_AES256_GCM_DEC:
        	data_ass = (uint8_t*)datain0;
 800bd5a:	687b      	ldr	r3, [r7, #4]
 800bd5c:	62fb      	str	r3, [r7, #44]	; 0x2c
            data_enc = (uint8_t*)datain2;
 800bd5e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bd60:	62bb      	str	r3, [r7, #40]	; 0x28
            data_dec = dataout;
 800bd62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bd64:	627b      	str	r3, [r7, #36]	; 0x24
            *dataout_len = datain2_len-B5_AES_BLK_SIZE;
 800bd66:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800bd6a:	3b10      	subs	r3, #16
 800bd6c:	b29a      	uxth	r2, r3
 800bd6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800bd70:	801a      	strh	r2, [r3, #0]
            break;
 800bd72:	e015      	b.n	800bda0 <se3_algo_Aes_update+0x154>
        case B5_AES256_GCM_ENC:
        	data_ass = (uint8_t*)datain0;
 800bd74:	687b      	ldr	r3, [r7, #4]
 800bd76:	62fb      	str	r3, [r7, #44]	; 0x2c
            data_enc = dataout;
 800bd78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bd7a:	62bb      	str	r3, [r7, #40]	; 0x28
            data_dec = (uint8_t*)datain2;
 800bd7c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bd7e:	627b      	str	r3, [r7, #36]	; 0x24
            *dataout_len = datain2_len+B5_AES_BLK_SIZE;
 800bd80:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800bd84:	3310      	adds	r3, #16
 800bd86:	b29a      	uxth	r2, r3
 800bd88:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800bd8a:	801a      	strh	r2, [r3, #0]
            break;
 800bd8c:	e008      	b.n	800bda0 <se3_algo_Aes_update+0x154>
        case B5_AES256_CBC_ENC:
        case B5_AES256_CFB_ENC:
        case B5_AES256_CTR:
		case B5_AES256_OFB:
        default:
            data_enc = dataout;
 800bd8e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bd90:	62bb      	str	r3, [r7, #40]	; 0x28
            data_dec = (uint8_t*)datain2;
 800bd92:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bd94:	627b      	str	r3, [r7, #36]	; 0x24
            *dataout_len = datain2_len;
 800bd96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800bd98:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 800bd9c:	801a      	strh	r2, [r3, #0]
            break;
 800bd9e:	bf00      	nop
        }

        if (B5_AES256_RES_OK != B5_Aes256_Update(aes, data_ass, data_enc, data_dec, (int16_t) n_ass_blocks,  (int16_t)nblocks)) {
 800bda0:	69bb      	ldr	r3, [r7, #24]
 800bda2:	b21b      	sxth	r3, r3
 800bda4:	69fa      	ldr	r2, [r7, #28]
 800bda6:	b212      	sxth	r2, r2
 800bda8:	9201      	str	r2, [sp, #4]
 800bdaa:	9300      	str	r3, [sp, #0]
 800bdac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bdae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800bdb0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800bdb2:	6a38      	ldr	r0, [r7, #32]
 800bdb4:	f7f7 ff28 	bl	8003c08 <B5_Aes256_Update>
 800bdb8:	4603      	mov	r3, r0
 800bdba:	2b00      	cmp	r3, #0
 800bdbc:	d002      	beq.n	800bdc4 <se3_algo_Aes_update+0x178>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_Update failed\n"));
            return SE3_ERR_HW;
 800bdbe:	f24f 0301 	movw	r3, #61441	; 0xf001
 800bdc2:	e00c      	b.n	800bdde <se3_algo_Aes_update+0x192>
        }

    }

    if (do_finit) {
 800bdc4:	7d7b      	ldrb	r3, [r7, #21]
 800bdc6:	2b00      	cmp	r3, #0
 800bdc8:	d008      	beq.n	800bddc <se3_algo_Aes_update+0x190>
        if (B5_AES256_RES_OK != B5_Aes256_Finit(aes)) {
 800bdca:	6a38      	ldr	r0, [r7, #32]
 800bdcc:	f7f8 f9ce 	bl	800416c <B5_Aes256_Finit>
 800bdd0:	4603      	mov	r3, r0
 800bdd2:	2b00      	cmp	r3, #0
 800bdd4:	d002      	beq.n	800bddc <se3_algo_Aes_update+0x190>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_Finit failed\n"));
            return SE3_ERR_HW;
 800bdd6:	f24f 0301 	movw	r3, #61441	; 0xf001
 800bdda:	e000      	b.n	800bdde <se3_algo_Aes_update+0x192>
        }
    }

    return SE3_OK;
 800bddc:	2300      	movs	r3, #0
}
 800bdde:	4618      	mov	r0, r3
 800bde0:	3730      	adds	r7, #48	; 0x30
 800bde2:	46bd      	mov	sp, r7
 800bde4:	bd80      	pop	{r7, pc}
 800bde6:	bf00      	nop

0800bde8 <se3_algo_AesHmacSha256s_init>:



uint16_t se3_algo_AesHmacSha256s_init(
	se3_flash_key* key, uint16_t mode, uint8_t* ctx)
{
 800bde8:	b580      	push	{r7, lr}
 800bdea:	b08e      	sub	sp, #56	; 0x38
 800bdec:	af00      	add	r7, sp, #0
 800bdee:	60f8      	str	r0, [r7, #12]
 800bdf0:	460b      	mov	r3, r1
 800bdf2:	607a      	str	r2, [r7, #4]
 800bdf4:	817b      	strh	r3, [r7, #10]
	AesHmacSha256s_ctx myctx;
	uint8_t* p = ctx;
 800bdf6:	687b      	ldr	r3, [r7, #4]
 800bdf8:	637b      	str	r3, [r7, #52]	; 0x34

	uint16_t feedback = mode & 0x07;
 800bdfa:	897b      	ldrh	r3, [r7, #10]
 800bdfc:	f003 0307 	and.w	r3, r3, #7
 800be00:	867b      	strh	r3, [r7, #50]	; 0x32
	uint16_t direction = (mode & SE3_DIR_ENCRYPT) ? SE3_DIR_ENCRYPT : SE3_DIR_DECRYPT;
 800be02:	897b      	ldrh	r3, [r7, #10]
 800be04:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800be08:	2b00      	cmp	r3, #0
 800be0a:	d002      	beq.n	800be12 <se3_algo_AesHmacSha256s_init+0x2a>
 800be0c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800be10:	e001      	b.n	800be16 <se3_algo_AesHmacSha256s_init+0x2e>
 800be12:	f44f 7300 	mov.w	r3, #512	; 0x200
 800be16:	863b      	strh	r3, [r7, #48]	; 0x30

	myctx.aes = (B5_tAesCtx*)p; p += sizeof(B5_tAesCtx);
 800be18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be1a:	617b      	str	r3, [r7, #20]
 800be1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be1e:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 800be22:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.hmac = (B5_tHmacSha256Ctx*)p; p += sizeof(B5_tHmacSha256Ctx);
 800be24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be26:	61bb      	str	r3, [r7, #24]
 800be28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be2a:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 800be2e:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.keys = p; p += 64;
 800be30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be32:	61fb      	str	r3, [r7, #28]
 800be34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be36:	3340      	adds	r3, #64	; 0x40
 800be38:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.key_size = (uint16_t*)p; p += sizeof(uint16_t);
 800be3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be3c:	623b      	str	r3, [r7, #32]
 800be3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be40:	3302      	adds	r3, #2
 800be42:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.mode = (uint8_t*)p; p += sizeof(uint8_t);
 800be44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be46:	62bb      	str	r3, [r7, #40]	; 0x28
 800be48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be4a:	3301      	adds	r3, #1
 800be4c:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.state = (uint8_t*)p; p += sizeof(uint8_t);
 800be4e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be50:	627b      	str	r3, [r7, #36]	; 0x24
 800be52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be54:	3301      	adds	r3, #1
 800be56:	637b      	str	r3, [r7, #52]	; 0x34
	myctx.direction = (uint8_t*)p; p += sizeof(uint8_t);
 800be58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be5a:	62fb      	str	r3, [r7, #44]	; 0x2c
 800be5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800be5e:	3301      	adds	r3, #1
 800be60:	637b      	str	r3, [r7, #52]	; 0x34

	switch (key->data_size) {
 800be62:	68fb      	ldr	r3, [r7, #12]
 800be64:	891b      	ldrh	r3, [r3, #8]
 800be66:	2b18      	cmp	r3, #24
 800be68:	d006      	beq.n	800be78 <se3_algo_AesHmacSha256s_init+0x90>
 800be6a:	2b20      	cmp	r3, #32
 800be6c:	d004      	beq.n	800be78 <se3_algo_AesHmacSha256s_init+0x90>
 800be6e:	2b10      	cmp	r3, #16
 800be70:	d002      	beq.n	800be78 <se3_algo_AesHmacSha256s_init+0x90>
	case B5_AES_192:
	case B5_AES_128:
		break;
	default:
		// unsupported key size
		return SE3_ERR_PARAMS;
 800be72:	f24f 0306 	movw	r3, #61446	; 0xf006
 800be76:	e078      	b.n	800bf6a <se3_algo_AesHmacSha256s_init+0x182>
		break;
 800be78:	bf00      	nop
	}

	*myctx.direction = (direction == SE3_DIR_ENCRYPT) ? (0) : (1);
 800be7a:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800be7c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800be80:	bf14      	ite	ne
 800be82:	2301      	movne	r3, #1
 800be84:	2300      	moveq	r3, #0
 800be86:	b2da      	uxtb	r2, r3
 800be88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be8a:	701a      	strb	r2, [r3, #0]

	switch (direction) {
 800be8c:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800be8e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800be92:	d003      	beq.n	800be9c <se3_algo_AesHmacSha256s_init+0xb4>
 800be94:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800be98:	d02a      	beq.n	800bef0 <se3_algo_AesHmacSha256s_init+0x108>
 800be9a:	e053      	b.n	800bf44 <se3_algo_AesHmacSha256s_init+0x15c>
	case (SE3_DIR_ENCRYPT):
		switch (feedback) {
 800be9c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800be9e:	3b01      	subs	r3, #1
 800bea0:	2b04      	cmp	r3, #4
 800bea2:	d821      	bhi.n	800bee8 <se3_algo_AesHmacSha256s_init+0x100>
 800bea4:	a201      	add	r2, pc, #4	; (adr r2, 800beac <se3_algo_AesHmacSha256s_init+0xc4>)
 800bea6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800beaa:	bf00      	nop
 800beac:	0800bec1 	.word	0x0800bec1
 800beb0:	0800bec9 	.word	0x0800bec9
 800beb4:	0800bed9 	.word	0x0800bed9
 800beb8:	0800bed1 	.word	0x0800bed1
 800bebc:	0800bee1 	.word	0x0800bee1
		case SE3_FEEDBACK_ECB: *(myctx.mode) = B5_AES256_ECB_ENC; break;
 800bec0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bec2:	2202      	movs	r2, #2
 800bec4:	701a      	strb	r2, [r3, #0]
 800bec6:	e012      	b.n	800beee <se3_algo_AesHmacSha256s_init+0x106>
		case SE3_FEEDBACK_CBC: *(myctx.mode) = B5_AES256_CBC_ENC; break;
 800bec8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800beca:	2204      	movs	r2, #4
 800becc:	701a      	strb	r2, [r3, #0]
 800bece:	e00e      	b.n	800beee <se3_algo_AesHmacSha256s_init+0x106>
		case SE3_FEEDBACK_CTR: *(myctx.mode) = B5_AES256_CTR; break;
 800bed0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bed2:	2208      	movs	r2, #8
 800bed4:	701a      	strb	r2, [r3, #0]
 800bed6:	e00a      	b.n	800beee <se3_algo_AesHmacSha256s_init+0x106>
		case SE3_FEEDBACK_OFB: *(myctx.mode) = B5_AES256_OFB; break;
 800bed8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800beda:	2201      	movs	r2, #1
 800bedc:	701a      	strb	r2, [r3, #0]
 800bede:	e006      	b.n	800beee <se3_algo_AesHmacSha256s_init+0x106>
		case SE3_FEEDBACK_CFB: *(myctx.mode) = B5_AES256_CFB_ENC; break;
 800bee0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bee2:	2206      	movs	r2, #6
 800bee4:	701a      	strb	r2, [r3, #0]
 800bee6:	e002      	b.n	800beee <se3_algo_AesHmacSha256s_init+0x106>
		default: return SE3_ERR_PARAMS;
 800bee8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800beec:	e03d      	b.n	800bf6a <se3_algo_AesHmacSha256s_init+0x182>
		}
		break;
 800beee:	e02c      	b.n	800bf4a <se3_algo_AesHmacSha256s_init+0x162>
	case (SE3_DIR_DECRYPT):
		switch (feedback) {
 800bef0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800bef2:	3b01      	subs	r3, #1
 800bef4:	2b04      	cmp	r3, #4
 800bef6:	d821      	bhi.n	800bf3c <se3_algo_AesHmacSha256s_init+0x154>
 800bef8:	a201      	add	r2, pc, #4	; (adr r2, 800bf00 <se3_algo_AesHmacSha256s_init+0x118>)
 800befa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800befe:	bf00      	nop
 800bf00:	0800bf15 	.word	0x0800bf15
 800bf04:	0800bf1d 	.word	0x0800bf1d
 800bf08:	0800bf2d 	.word	0x0800bf2d
 800bf0c:	0800bf25 	.word	0x0800bf25
 800bf10:	0800bf35 	.word	0x0800bf35
		case SE3_FEEDBACK_ECB: *(myctx.mode) = B5_AES256_ECB_DEC; break;
 800bf14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bf16:	2203      	movs	r2, #3
 800bf18:	701a      	strb	r2, [r3, #0]
 800bf1a:	e012      	b.n	800bf42 <se3_algo_AesHmacSha256s_init+0x15a>
		case SE3_FEEDBACK_CBC: *(myctx.mode) = B5_AES256_CBC_DEC; break;
 800bf1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bf1e:	2205      	movs	r2, #5
 800bf20:	701a      	strb	r2, [r3, #0]
 800bf22:	e00e      	b.n	800bf42 <se3_algo_AesHmacSha256s_init+0x15a>
		case SE3_FEEDBACK_CTR: *(myctx.mode) = B5_AES256_CTR; break;
 800bf24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bf26:	2208      	movs	r2, #8
 800bf28:	701a      	strb	r2, [r3, #0]
 800bf2a:	e00a      	b.n	800bf42 <se3_algo_AesHmacSha256s_init+0x15a>
		case SE3_FEEDBACK_OFB: *(myctx.mode) = B5_AES256_OFB; break;
 800bf2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bf2e:	2201      	movs	r2, #1
 800bf30:	701a      	strb	r2, [r3, #0]
 800bf32:	e006      	b.n	800bf42 <se3_algo_AesHmacSha256s_init+0x15a>
		case SE3_FEEDBACK_CFB: *(myctx.mode) = B5_AES256_CFB_DEC; break;
 800bf34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bf36:	2207      	movs	r2, #7
 800bf38:	701a      	strb	r2, [r3, #0]
 800bf3a:	e002      	b.n	800bf42 <se3_algo_AesHmacSha256s_init+0x15a>
		default: return SE3_ERR_PARAMS;
 800bf3c:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bf40:	e013      	b.n	800bf6a <se3_algo_AesHmacSha256s_init+0x182>
		}
		break;
 800bf42:	e002      	b.n	800bf4a <se3_algo_AesHmacSha256s_init+0x162>
	default:
		return SE3_ERR_PARAMS;
 800bf44:	f24f 0306 	movw	r3, #61446	; 0xf006
 800bf48:	e00f      	b.n	800bf6a <se3_algo_AesHmacSha256s_init+0x182>
	}

	*(myctx.state) = SE3_ALGO_STATE_KEYS_NOT_INITIALIZED;
 800bf4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bf4c:	2200      	movs	r2, #0
 800bf4e:	701a      	strb	r2, [r3, #0]
	memcpy(myctx.keys, key->data, key->data_size);
 800bf50:	69f8      	ldr	r0, [r7, #28]
 800bf52:	68fb      	ldr	r3, [r7, #12]
 800bf54:	68d9      	ldr	r1, [r3, #12]
 800bf56:	68fb      	ldr	r3, [r7, #12]
 800bf58:	891b      	ldrh	r3, [r3, #8]
 800bf5a:	461a      	mov	r2, r3
 800bf5c:	f00f f823 	bl	801afa6 <memcpy>
	*(myctx.key_size) = key->data_size;
 800bf60:	6a3b      	ldr	r3, [r7, #32]
 800bf62:	68fa      	ldr	r2, [r7, #12]
 800bf64:	8912      	ldrh	r2, [r2, #8]
 800bf66:	801a      	strh	r2, [r3, #0]

	return SE3_OK;
 800bf68:	2300      	movs	r3, #0
}
 800bf6a:	4618      	mov	r0, r3
 800bf6c:	3738      	adds	r7, #56	; 0x38
 800bf6e:	46bd      	mov	sp, r7
 800bf70:	bd80      	pop	{r7, pc}
 800bf72:	bf00      	nop

0800bf74 <se3_algo_AesHmacSha256s_update>:
	uint8_t* ctx, uint16_t flags,
    uint16_t datain0_len, const uint8_t* datain0,
    uint16_t datain1_len, const uint8_t* datain1,
    uint16_t datain2_len, const uint8_t* datain2,
	uint16_t* dataout_len, uint8_t* dataout)
{
 800bf74:	b590      	push	{r4, r7, lr}
 800bf76:	b097      	sub	sp, #92	; 0x5c
 800bf78:	af04      	add	r7, sp, #16
 800bf7a:	60f8      	str	r0, [r7, #12]
 800bf7c:	607b      	str	r3, [r7, #4]
 800bf7e:	460b      	mov	r3, r1
 800bf80:	817b      	strh	r3, [r7, #10]
 800bf82:	4613      	mov	r3, r2
 800bf84:	813b      	strh	r3, [r7, #8]
	AesHmacSha256s_ctx myctx;
	uint8_t* p = ctx;
 800bf86:	68fb      	ldr	r3, [r7, #12]
 800bf88:	63fb      	str	r3, [r7, #60]	; 0x3c

	size_t nblocks = 0;
 800bf8a:	2300      	movs	r3, #0
 800bf8c:	63bb      	str	r3, [r7, #56]	; 0x38
	size_t outsize = 0;
 800bf8e:	2300      	movs	r3, #0
 800bf90:	647b      	str	r3, [r7, #68]	; 0x44
	uint8_t* pdataout = dataout;
 800bf92:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800bf94:	643b      	str	r3, [r7, #64]	; 0x40

	bool do_setnonce = (flags & SE3_CRYPTO_FLAG_SETNONCE);
 800bf96:	897b      	ldrh	r3, [r7, #10]
 800bf98:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800bf9c:	2b00      	cmp	r3, #0
 800bf9e:	bf14      	ite	ne
 800bfa0:	2301      	movne	r3, #1
 800bfa2:	2300      	moveq	r3, #0
 800bfa4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	bool do_update = (datain2_len > 0);
 800bfa8:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800bfac:	2b00      	cmp	r3, #0
 800bfae:	bf14      	ite	ne
 800bfb0:	2301      	movne	r3, #1
 800bfb2:	2300      	moveq	r3, #0
 800bfb4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
	bool do_finit = (flags & SE3_CRYPTO_FLAG_FINIT);
 800bfb8:	897b      	ldrh	r3, [r7, #10]
 800bfba:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800bfbe:	2b00      	cmp	r3, #0
 800bfc0:	bf14      	ite	ne
 800bfc2:	2301      	movne	r3, #1
 800bfc4:	2300      	moveq	r3, #0
 800bfc6:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	bool do_auth = (flags & SE3_CRYPTO_FLAG_AUTH);
 800bfca:	897b      	ldrh	r3, [r7, #10]
 800bfcc:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800bfd0:	2b00      	cmp	r3, #0
 800bfd2:	bf14      	ite	ne
 800bfd4:	2301      	movne	r3, #1
 800bfd6:	2300      	moveq	r3, #0
 800bfd8:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
	bool do_reset = (flags & SE3_CRYPTO_FLAG_RESET);
 800bfdc:	897b      	ldrh	r3, [r7, #10]
 800bfde:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800bfe2:	2b00      	cmp	r3, #0
 800bfe4:	bf14      	ite	ne
 800bfe6:	2301      	movne	r3, #1
 800bfe8:	2300      	moveq	r3, #0
 800bfea:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

	myctx.aes = (B5_tAesCtx*)p; p += sizeof(B5_tAesCtx);
 800bfee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bff0:	617b      	str	r3, [r7, #20]
 800bff2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bff4:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 800bff8:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.hmac = (B5_tHmacSha256Ctx*)p; p += sizeof(B5_tHmacSha256Ctx);
 800bffa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bffc:	61bb      	str	r3, [r7, #24]
 800bffe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c000:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 800c004:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.keys = p; p += 64;
 800c006:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c008:	61fb      	str	r3, [r7, #28]
 800c00a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c00c:	3340      	adds	r3, #64	; 0x40
 800c00e:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.key_size = (uint16_t*)p; p += sizeof(uint16_t);
 800c010:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c012:	623b      	str	r3, [r7, #32]
 800c014:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c016:	3302      	adds	r3, #2
 800c018:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.mode = (uint8_t*)p; p += sizeof(uint8_t);
 800c01a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c01c:	62bb      	str	r3, [r7, #40]	; 0x28
 800c01e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c020:	3301      	adds	r3, #1
 800c022:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.state = (uint8_t*)p; p += sizeof(uint8_t);
 800c024:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c026:	627b      	str	r3, [r7, #36]	; 0x24
 800c028:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c02a:	3301      	adds	r3, #1
 800c02c:	63fb      	str	r3, [r7, #60]	; 0x3c
	myctx.direction = (uint8_t*)p; p += sizeof(uint8_t);
 800c02e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c030:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c032:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c034:	3301      	adds	r3, #1
 800c036:	63fb      	str	r3, [r7, #60]	; 0x3c


	// check params
	if (do_setnonce) {
 800c038:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800c03c:	2b00      	cmp	r3, #0
 800c03e:	d052      	beq.n	800c0e6 <se3_algo_AesHmacSha256s_update+0x172>
		if (*myctx.state == SE3_ALGO_STATE_KEYS_INITIALIZED) return SE3_ERR_STATE;
 800c040:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c042:	781b      	ldrb	r3, [r3, #0]
 800c044:	2b01      	cmp	r3, #1
 800c046:	d102      	bne.n	800c04e <se3_algo_AesHmacSha256s_update+0xda>
 800c048:	f24f 0304 	movw	r3, #61444	; 0xf004
 800c04c:	e152      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		if (do_reset || do_auth || do_update) {
 800c04e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800c052:	2b00      	cmp	r3, #0
 800c054:	d107      	bne.n	800c066 <se3_algo_AesHmacSha256s_update+0xf2>
 800c056:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 800c05a:	2b00      	cmp	r3, #0
 800c05c:	d103      	bne.n	800c066 <se3_algo_AesHmacSha256s_update+0xf2>
 800c05e:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800c062:	2b00      	cmp	r3, #0
 800c064:	d002      	beq.n	800c06c <se3_algo_AesHmacSha256s_update+0xf8>
			return SE3_ERR_PARAMS;
 800c066:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c06a:	e143      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}
		if (do_finit) return SE3_OK;
 800c06c:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 800c070:	2b00      	cmp	r3, #0
 800c072:	d001      	beq.n	800c078 <se3_algo_AesHmacSha256s_update+0x104>
 800c074:	2300      	movs	r3, #0
 800c076:	e13d      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>

		// derive keys
		PBKDF2HmacSha256(myctx.keys, *(myctx.key_size), datain1, datain1_len, 1, myctx.keys, 2 * (*(myctx.key_size)));
 800c078:	69f8      	ldr	r0, [r7, #28]
 800c07a:	6a3b      	ldr	r3, [r7, #32]
 800c07c:	881b      	ldrh	r3, [r3, #0]
 800c07e:	461c      	mov	r4, r3
 800c080:	f8b7 1058 	ldrh.w	r1, [r7, #88]	; 0x58
 800c084:	69fb      	ldr	r3, [r7, #28]
 800c086:	6a3a      	ldr	r2, [r7, #32]
 800c088:	8812      	ldrh	r2, [r2, #0]
 800c08a:	0052      	lsls	r2, r2, #1
 800c08c:	9202      	str	r2, [sp, #8]
 800c08e:	9301      	str	r3, [sp, #4]
 800c090:	2301      	movs	r3, #1
 800c092:	9300      	str	r3, [sp, #0]
 800c094:	460b      	mov	r3, r1
 800c096:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800c098:	4621      	mov	r1, r4
 800c09a:	f7f8 f930 	bl	80042fe <PBKDF2HmacSha256>
		if (B5_AES256_RES_OK != B5_Aes256_Init(myctx.aes, myctx.keys, *(myctx.key_size), *(myctx.mode))) {
 800c09e:	6978      	ldr	r0, [r7, #20]
 800c0a0:	69f9      	ldr	r1, [r7, #28]
 800c0a2:	6a3b      	ldr	r3, [r7, #32]
 800c0a4:	881b      	ldrh	r3, [r3, #0]
 800c0a6:	b21a      	sxth	r2, r3
 800c0a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c0aa:	781b      	ldrb	r3, [r3, #0]
 800c0ac:	f7f7 fc90 	bl	80039d0 <B5_Aes256_Init>
 800c0b0:	4603      	mov	r3, r0
 800c0b2:	2b00      	cmp	r3, #0
 800c0b4:	d002      	beq.n	800c0bc <se3_algo_AesHmacSha256s_update+0x148>
			return SE3_ERR_PARAMS;
 800c0b6:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c0ba:	e11b      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}
		if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Init(myctx.hmac, myctx.keys + (*(myctx.key_size)), *(myctx.key_size))) {
 800c0bc:	69b8      	ldr	r0, [r7, #24]
 800c0be:	69fb      	ldr	r3, [r7, #28]
 800c0c0:	6a3a      	ldr	r2, [r7, #32]
 800c0c2:	8812      	ldrh	r2, [r2, #0]
 800c0c4:	1899      	adds	r1, r3, r2
 800c0c6:	6a3b      	ldr	r3, [r7, #32]
 800c0c8:	881b      	ldrh	r3, [r3, #0]
 800c0ca:	b21b      	sxth	r3, r3
 800c0cc:	461a      	mov	r2, r3
 800c0ce:	f7fa fc1d 	bl	800690c <B5_HmacSha256_Init>
 800c0d2:	4603      	mov	r3, r0
 800c0d4:	2b00      	cmp	r3, #0
 800c0d6:	d002      	beq.n	800c0de <se3_algo_AesHmacSha256s_update+0x16a>
			return SE3_ERR_PARAMS;
 800c0d8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c0dc:	e10a      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}
		*(myctx.state) = SE3_ALGO_STATE_KEYS_INITIALIZED;
 800c0de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c0e0:	2201      	movs	r2, #1
 800c0e2:	701a      	strb	r2, [r3, #0]
 800c0e4:	e105      	b.n	800c2f2 <se3_algo_AesHmacSha256s_update+0x37e>
	}
	else {
		if (do_reset && (datain1_len != B5_AES_BLK_SIZE && datain1_len != 0)) {
 800c0e6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800c0ea:	2b00      	cmp	r3, #0
 800c0ec:	d00a      	beq.n	800c104 <se3_algo_AesHmacSha256s_update+0x190>
 800c0ee:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c0f2:	2b10      	cmp	r3, #16
 800c0f4:	d006      	beq.n	800c104 <se3_algo_AesHmacSha256s_update+0x190>
 800c0f6:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c0fa:	2b00      	cmp	r3, #0
 800c0fc:	d002      	beq.n	800c104 <se3_algo_AesHmacSha256s_update+0x190>
			SE3_TRACE(("[algo_aes256.update] invalid IV size\n"));
			return SE3_ERR_PARAMS;
 800c0fe:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c102:	e0f7      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}
		if (do_update && ((datain2_len % B5_AES_BLK_SIZE) != 0)) {
 800c104:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800c108:	2b00      	cmp	r3, #0
 800c10a:	d009      	beq.n	800c120 <se3_algo_AesHmacSha256s_update+0x1ac>
 800c10c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c110:	f003 030f 	and.w	r3, r3, #15
 800c114:	b29b      	uxth	r3, r3
 800c116:	2b00      	cmp	r3, #0
 800c118:	d002      	beq.n	800c120 <se3_algo_AesHmacSha256s_update+0x1ac>
			return SE3_ERR_PARAMS;
 800c11a:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c11e:	e0e9      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}

		if (*(myctx.state) == SE3_ALGO_STATE_KEYS_NOT_INITIALIZED) {
 800c120:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c122:	781b      	ldrb	r3, [r3, #0]
 800c124:	2b00      	cmp	r3, #0
 800c126:	d132      	bne.n	800c18e <se3_algo_AesHmacSha256s_update+0x21a>
			// derive keys with empty salt
			PBKDF2HmacSha256(myctx.keys, *(myctx.key_size), NULL, 0, 1, myctx.keys, 2 * (*(myctx.key_size)));
 800c128:	69f8      	ldr	r0, [r7, #28]
 800c12a:	6a3b      	ldr	r3, [r7, #32]
 800c12c:	881b      	ldrh	r3, [r3, #0]
 800c12e:	4619      	mov	r1, r3
 800c130:	69fb      	ldr	r3, [r7, #28]
 800c132:	6a3a      	ldr	r2, [r7, #32]
 800c134:	8812      	ldrh	r2, [r2, #0]
 800c136:	0052      	lsls	r2, r2, #1
 800c138:	9202      	str	r2, [sp, #8]
 800c13a:	9301      	str	r3, [sp, #4]
 800c13c:	2301      	movs	r3, #1
 800c13e:	9300      	str	r3, [sp, #0]
 800c140:	2300      	movs	r3, #0
 800c142:	2200      	movs	r2, #0
 800c144:	f7f8 f8db 	bl	80042fe <PBKDF2HmacSha256>
			if (B5_AES256_RES_OK != B5_Aes256_Init(myctx.aes, myctx.keys, *(myctx.key_size), *(myctx.mode))) {
 800c148:	6978      	ldr	r0, [r7, #20]
 800c14a:	69f9      	ldr	r1, [r7, #28]
 800c14c:	6a3b      	ldr	r3, [r7, #32]
 800c14e:	881b      	ldrh	r3, [r3, #0]
 800c150:	b21a      	sxth	r2, r3
 800c152:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c154:	781b      	ldrb	r3, [r3, #0]
 800c156:	f7f7 fc3b 	bl	80039d0 <B5_Aes256_Init>
 800c15a:	4603      	mov	r3, r0
 800c15c:	2b00      	cmp	r3, #0
 800c15e:	d002      	beq.n	800c166 <se3_algo_AesHmacSha256s_update+0x1f2>
				return SE3_ERR_PARAMS;
 800c160:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c164:	e0c6      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
			}
			if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Init(myctx.hmac, myctx.keys + (*(myctx.key_size)), *(myctx.key_size))) {
 800c166:	69b8      	ldr	r0, [r7, #24]
 800c168:	69fb      	ldr	r3, [r7, #28]
 800c16a:	6a3a      	ldr	r2, [r7, #32]
 800c16c:	8812      	ldrh	r2, [r2, #0]
 800c16e:	1899      	adds	r1, r3, r2
 800c170:	6a3b      	ldr	r3, [r7, #32]
 800c172:	881b      	ldrh	r3, [r3, #0]
 800c174:	b21b      	sxth	r3, r3
 800c176:	461a      	mov	r2, r3
 800c178:	f7fa fbc8 	bl	800690c <B5_HmacSha256_Init>
 800c17c:	4603      	mov	r3, r0
 800c17e:	2b00      	cmp	r3, #0
 800c180:	d002      	beq.n	800c188 <se3_algo_AesHmacSha256s_update+0x214>
				return SE3_ERR_PARAMS;
 800c182:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c186:	e0b5      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
			}
			*(myctx.state) = SE3_ALGO_STATE_KEYS_INITIALIZED;
 800c188:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c18a:	2201      	movs	r2, #1
 800c18c:	701a      	strb	r2, [r3, #0]
		}

		// compute output size
		outsize = 0;
 800c18e:	2300      	movs	r3, #0
 800c190:	647b      	str	r3, [r7, #68]	; 0x44
		if (do_update) outsize += datain2_len;
 800c192:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800c196:	2b00      	cmp	r3, #0
 800c198:	d004      	beq.n	800c1a4 <se3_algo_AesHmacSha256s_update+0x230>
 800c19a:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c19e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800c1a0:	4413      	add	r3, r2
 800c1a2:	647b      	str	r3, [r7, #68]	; 0x44
		if (do_auth) outsize += B5_SHA256_DIGEST_SIZE;
 800c1a4:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 800c1a8:	2b00      	cmp	r3, #0
 800c1aa:	d002      	beq.n	800c1b2 <se3_algo_AesHmacSha256s_update+0x23e>
 800c1ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c1ae:	3320      	adds	r3, #32
 800c1b0:	647b      	str	r3, [r7, #68]	; 0x44

		if (outsize > SE3_CRYPTO_MAX_DATAOUT) {
 800c1b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c1b4:	f5b3 5feb 	cmp.w	r3, #7520	; 0x1d60
 800c1b8:	d902      	bls.n	800c1c0 <se3_algo_AesHmacSha256s_update+0x24c>
			return SE3_ERR_PARAMS;
 800c1ba:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c1be:	e099      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
		}

		if (do_reset) {
 800c1c0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800c1c4:	2b00      	cmp	r3, #0
 800c1c6:	d01e      	beq.n	800c206 <se3_algo_AesHmacSha256s_update+0x292>
			if (datain1_len > 0) {
 800c1c8:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c1cc:	2b00      	cmp	r3, #0
 800c1ce:	d004      	beq.n	800c1da <se3_algo_AesHmacSha256s_update+0x266>
				B5_Aes256_SetIV(myctx.aes, datain1);
 800c1d0:	697b      	ldr	r3, [r7, #20]
 800c1d2:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800c1d4:	4618      	mov	r0, r3
 800c1d6:	f7f7 fccf 	bl	8003b78 <B5_Aes256_SetIV>
			}
			B5_HmacSha256_Init(myctx.hmac, myctx.keys + (*(myctx.key_size)), *(myctx.key_size));
 800c1da:	69b8      	ldr	r0, [r7, #24]
 800c1dc:	69fb      	ldr	r3, [r7, #28]
 800c1de:	6a3a      	ldr	r2, [r7, #32]
 800c1e0:	8812      	ldrh	r2, [r2, #0]
 800c1e2:	1899      	adds	r1, r3, r2
 800c1e4:	6a3b      	ldr	r3, [r7, #32]
 800c1e6:	881b      	ldrh	r3, [r3, #0]
 800c1e8:	b21b      	sxth	r3, r3
 800c1ea:	461a      	mov	r2, r3
 800c1ec:	f7fa fb8e 	bl	800690c <B5_HmacSha256_Init>
			if (datain1_len > 0) {
 800c1f0:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c1f4:	2b00      	cmp	r3, #0
 800c1f6:	d006      	beq.n	800c206 <se3_algo_AesHmacSha256s_update+0x292>
				B5_HmacSha256_Update(myctx.hmac, datain1, datain1_len);
 800c1f8:	69bb      	ldr	r3, [r7, #24]
 800c1fa:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 800c1fe:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800c200:	4618      	mov	r0, r3
 800c202:	f7fa fc09 	bl	8006a18 <B5_HmacSha256_Update>
			}
		}

		if (do_update) {
 800c206:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 800c20a:	2b00      	cmp	r3, #0
 800c20c:	d061      	beq.n	800c2d2 <se3_algo_AesHmacSha256s_update+0x35e>
			nblocks = datain2_len / B5_AES_BLK_SIZE;
 800c20e:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c212:	091b      	lsrs	r3, r3, #4
 800c214:	b29b      	uxth	r3, r3
 800c216:	63bb      	str	r3, [r7, #56]	; 0x38

			if (*myctx.direction == 1) {  // decrypt
 800c218:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c21a:	781b      	ldrb	r3, [r3, #0]
 800c21c:	2b01      	cmp	r3, #1
 800c21e:	d134      	bne.n	800c28a <se3_algo_AesHmacSha256s_update+0x316>
				if (B5_AES256_RES_OK != B5_HmacSha256_Update(myctx.hmac, datain2, datain2_len)) {
 800c220:	69bb      	ldr	r3, [r7, #24]
 800c222:	f8b7 2060 	ldrh.w	r2, [r7, #96]	; 0x60
 800c226:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800c228:	4618      	mov	r0, r3
 800c22a:	f7fa fbf5 	bl	8006a18 <B5_HmacSha256_Update>
 800c22e:	4603      	mov	r3, r0
 800c230:	2b00      	cmp	r3, #0
 800c232:	d002      	beq.n	800c23a <se3_algo_AesHmacSha256s_update+0x2c6>
					return SE3_ERR_HW;
 800c234:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c238:	e05c      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
				}
				switch (*myctx.mode)
 800c23a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c23c:	781b      	ldrb	r3, [r3, #0]
 800c23e:	2b01      	cmp	r3, #1
 800c240:	d001      	beq.n	800c246 <se3_algo_AesHmacSha256s_update+0x2d2>
 800c242:	2b08      	cmp	r3, #8
 800c244:	d110      	bne.n	800c268 <se3_algo_AesHmacSha256s_update+0x2f4>
				{
				case B5_AES256_CTR:
				case B5_AES256_OFB:
					if (B5_HMAC_SHA256_RES_OK != B5_Aes256_Update(myctx.aes, NULL, pdataout, (uint8_t*)datain2, 0, (uint16_t)nblocks)) {
 800c246:	6978      	ldr	r0, [r7, #20]
 800c248:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c24a:	b21b      	sxth	r3, r3
 800c24c:	9301      	str	r3, [sp, #4]
 800c24e:	2300      	movs	r3, #0
 800c250:	9300      	str	r3, [sp, #0]
 800c252:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c254:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c256:	2100      	movs	r1, #0
 800c258:	f7f7 fcd6 	bl	8003c08 <B5_Aes256_Update>
 800c25c:	4603      	mov	r3, r0
 800c25e:	2b00      	cmp	r3, #0
 800c260:	d031      	beq.n	800c2c6 <se3_algo_AesHmacSha256s_update+0x352>
						return SE3_ERR_HW;
 800c262:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c266:	e045      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
					}
					break;
				default:
					if (B5_HMAC_SHA256_RES_OK != B5_Aes256_Update(myctx.aes, NULL, (uint8_t*)datain2, pdataout, 0, (uint16_t)nblocks)) {
 800c268:	6978      	ldr	r0, [r7, #20]
 800c26a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c26c:	b21b      	sxth	r3, r3
 800c26e:	9301      	str	r3, [sp, #4]
 800c270:	2300      	movs	r3, #0
 800c272:	9300      	str	r3, [sp, #0]
 800c274:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c276:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800c278:	2100      	movs	r1, #0
 800c27a:	f7f7 fcc5 	bl	8003c08 <B5_Aes256_Update>
 800c27e:	4603      	mov	r3, r0
 800c280:	2b00      	cmp	r3, #0
 800c282:	d021      	beq.n	800c2c8 <se3_algo_AesHmacSha256s_update+0x354>
						return SE3_ERR_HW;
 800c284:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c288:	e034      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
					}
				}

			}
			else {
				if (B5_AES256_RES_OK != B5_Aes256_Update(myctx.aes, NULL, pdataout, (uint8_t*)datain2, 0, (uint16_t)nblocks)) {
 800c28a:	6978      	ldr	r0, [r7, #20]
 800c28c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c28e:	b21b      	sxth	r3, r3
 800c290:	9301      	str	r3, [sp, #4]
 800c292:	2300      	movs	r3, #0
 800c294:	9300      	str	r3, [sp, #0]
 800c296:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c298:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c29a:	2100      	movs	r1, #0
 800c29c:	f7f7 fcb4 	bl	8003c08 <B5_Aes256_Update>
 800c2a0:	4603      	mov	r3, r0
 800c2a2:	2b00      	cmp	r3, #0
 800c2a4:	d002      	beq.n	800c2ac <se3_algo_AesHmacSha256s_update+0x338>
					return SE3_ERR_HW;
 800c2a6:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c2aa:	e023      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
				}
				if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Update(myctx.hmac, pdataout, datain2_len)) {
 800c2ac:	69bb      	ldr	r3, [r7, #24]
 800c2ae:	f8b7 2060 	ldrh.w	r2, [r7, #96]	; 0x60
 800c2b2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800c2b4:	4618      	mov	r0, r3
 800c2b6:	f7fa fbaf 	bl	8006a18 <B5_HmacSha256_Update>
 800c2ba:	4603      	mov	r3, r0
 800c2bc:	2b00      	cmp	r3, #0
 800c2be:	d003      	beq.n	800c2c8 <se3_algo_AesHmacSha256s_update+0x354>
					return SE3_ERR_HW;
 800c2c0:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c2c4:	e016      	b.n	800c2f4 <se3_algo_AesHmacSha256s_update+0x380>
					break;
 800c2c6:	bf00      	nop
				}
			}

			pdataout += datain2_len;
 800c2c8:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c2cc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c2ce:	4413      	add	r3, r2
 800c2d0:	643b      	str	r3, [r7, #64]	; 0x40
		}

		if (do_auth) {
 800c2d2:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 800c2d6:	2b00      	cmp	r3, #0
 800c2d8:	d007      	beq.n	800c2ea <se3_algo_AesHmacSha256s_update+0x376>
			B5_HmacSha256_Finit(myctx.hmac, pdataout);
 800c2da:	69bb      	ldr	r3, [r7, #24]
 800c2dc:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800c2de:	4618      	mov	r0, r3
 800c2e0:	f7fa fbbf 	bl	8006a62 <B5_HmacSha256_Finit>
			pdataout += B5_SHA256_DIGEST_SIZE;
 800c2e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c2e6:	3320      	adds	r3, #32
 800c2e8:	643b      	str	r3, [r7, #64]	; 0x40
		}

		*dataout_len = (uint16_t)outsize;
 800c2ea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c2ec:	b29a      	uxth	r2, r3
 800c2ee:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c2f0:	801a      	strh	r2, [r3, #0]
	}

	return SE3_OK;
 800c2f2:	2300      	movs	r3, #0
}
 800c2f4:	4618      	mov	r0, r3
 800c2f6:	374c      	adds	r7, #76	; 0x4c
 800c2f8:	46bd      	mov	sp, r7
 800c2fa:	bd90      	pop	{r4, r7, pc}

0800c2fc <se3_algo_HmacSha256_init>:
#include "se3_algo_HmacSha256.h"


uint16_t se3_algo_HmacSha256_init(se3_flash_key* key, uint16_t mode, uint8_t* ctx)
{
 800c2fc:	b580      	push	{r7, lr}
 800c2fe:	b086      	sub	sp, #24
 800c300:	af00      	add	r7, sp, #0
 800c302:	60f8      	str	r0, [r7, #12]
 800c304:	460b      	mov	r3, r1
 800c306:	607a      	str	r2, [r7, #4]
 800c308:	817b      	strh	r3, [r7, #10]
	B5_tHmacSha256Ctx* sha_hmac = (B5_tHmacSha256Ctx *) ctx;
 800c30a:	687b      	ldr	r3, [r7, #4]
 800c30c:	617b      	str	r3, [r7, #20]

	if (key->data_size <= 0) {
 800c30e:	68fb      	ldr	r3, [r7, #12]
 800c310:	891b      	ldrh	r3, [r3, #8]
 800c312:	2b00      	cmp	r3, #0
 800c314:	d102      	bne.n	800c31c <se3_algo_HmacSha256_init+0x20>
		return (SE3_ERR_PARAMS);
 800c316:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c31a:	e00f      	b.n	800c33c <se3_algo_HmacSha256_init+0x40>
	}
	if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Init(sha_hmac, key->data, key->data_size)) {
 800c31c:	68fb      	ldr	r3, [r7, #12]
 800c31e:	68d9      	ldr	r1, [r3, #12]
 800c320:	68fb      	ldr	r3, [r7, #12]
 800c322:	891b      	ldrh	r3, [r3, #8]
 800c324:	b21b      	sxth	r3, r3
 800c326:	461a      	mov	r2, r3
 800c328:	6978      	ldr	r0, [r7, #20]
 800c32a:	f7fa faef 	bl	800690c <B5_HmacSha256_Init>
 800c32e:	4603      	mov	r3, r0
 800c330:	2b00      	cmp	r3, #0
 800c332:	d002      	beq.n	800c33a <se3_algo_HmacSha256_init+0x3e>
		SE3_TRACE(("[algo_sha256hmac_init.init] B5_HmacSha256_Init failed\n"));
		return (SE3_ERR_PARAMS);
 800c334:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c338:	e000      	b.n	800c33c <se3_algo_HmacSha256_init+0x40>
	}

	return (SE3_OK);
 800c33a:	2300      	movs	r3, #0
}
 800c33c:	4618      	mov	r0, r3
 800c33e:	3718      	adds	r7, #24
 800c340:	46bd      	mov	sp, r7
 800c342:	bd80      	pop	{r7, pc}

0800c344 <se3_algo_HmacSha256_update>:
	uint8_t* ctx, uint16_t flags,
    uint16_t datain0_len, const uint8_t* datain0,
    uint16_t datain1_len, const uint8_t* datain1,
    uint16_t datain2_len, const uint8_t* datain2,
	uint16_t* dataout_len, uint8_t* dataout)
{
 800c344:	b580      	push	{r7, lr}
 800c346:	b086      	sub	sp, #24
 800c348:	af00      	add	r7, sp, #0
 800c34a:	60f8      	str	r0, [r7, #12]
 800c34c:	607b      	str	r3, [r7, #4]
 800c34e:	460b      	mov	r3, r1
 800c350:	817b      	strh	r3, [r7, #10]
 800c352:	4613      	mov	r3, r2
 800c354:	813b      	strh	r3, [r7, #8]

	B5_tHmacSha256Ctx* sha_hmac = (B5_tHmacSha256Ctx *)ctx;
 800c356:	68fb      	ldr	r3, [r7, #12]
 800c358:	617b      	str	r3, [r7, #20]

	bool do_update = (datain1_len > 0);
 800c35a:	8c3b      	ldrh	r3, [r7, #32]
 800c35c:	2b00      	cmp	r3, #0
 800c35e:	bf14      	ite	ne
 800c360:	2301      	movne	r3, #1
 800c362:	2300      	moveq	r3, #0
 800c364:	74fb      	strb	r3, [r7, #19]
	bool do_finit = (flags & SE3_CRYPTO_FLAG_FINIT);
 800c366:	897b      	ldrh	r3, [r7, #10]
 800c368:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800c36c:	2b00      	cmp	r3, #0
 800c36e:	bf14      	ite	ne
 800c370:	2301      	movne	r3, #1
 800c372:	2300      	moveq	r3, #0
 800c374:	74bb      	strb	r3, [r7, #18]

	if (do_update) {
 800c376:	7cfb      	ldrb	r3, [r7, #19]
 800c378:	2b00      	cmp	r3, #0
 800c37a:	d00b      	beq.n	800c394 <se3_algo_HmacSha256_update+0x50>
		// update
		if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Update(sha_hmac, datain1, datain1_len)) {
 800c37c:	8c3b      	ldrh	r3, [r7, #32]
 800c37e:	461a      	mov	r2, r3
 800c380:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800c382:	6978      	ldr	r0, [r7, #20]
 800c384:	f7fa fb48 	bl	8006a18 <B5_HmacSha256_Update>
 800c388:	4603      	mov	r3, r0
 800c38a:	2b00      	cmp	r3, #0
 800c38c:	d002      	beq.n	800c394 <se3_algo_HmacSha256_update+0x50>
			SE3_TRACE(("[algo_sha256hmac_init.update] B5_HmacSha256_Update failed\n"));
			return SE3_ERR_HW;
 800c38e:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c392:	e010      	b.n	800c3b6 <se3_algo_HmacSha256_update+0x72>
		}
	}

	if (do_finit) {
 800c394:	7cbb      	ldrb	r3, [r7, #18]
 800c396:	2b00      	cmp	r3, #0
 800c398:	d00c      	beq.n	800c3b4 <se3_algo_HmacSha256_update+0x70>
		if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Finit(sha_hmac, dataout)) {
 800c39a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800c39c:	6978      	ldr	r0, [r7, #20]
 800c39e:	f7fa fb60 	bl	8006a62 <B5_HmacSha256_Finit>
 800c3a2:	4603      	mov	r3, r0
 800c3a4:	2b00      	cmp	r3, #0
 800c3a6:	d002      	beq.n	800c3ae <se3_algo_HmacSha256_update+0x6a>
			SE3_TRACE(("[algo_sha256hmac_init.update] B5_HmacSha256_Finit failed\n"));
			return SE3_ERR_HW;
 800c3a8:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c3ac:	e003      	b.n	800c3b6 <se3_algo_HmacSha256_update+0x72>
		}
		*dataout_len = 32;
 800c3ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c3b0:	2220      	movs	r2, #32
 800c3b2:	801a      	strh	r2, [r3, #0]
	}

	return(SE3_OK);
 800c3b4:	2300      	movs	r3, #0
}
 800c3b6:	4618      	mov	r0, r3
 800c3b8:	3718      	adds	r7, #24
 800c3ba:	46bd      	mov	sp, r7
 800c3bc:	bd80      	pop	{r7, pc}
	...

0800c3c0 <se3_algo_aes256hmacsha256_init>:
	0x7f, 0x33, 0x21, 0x3c, 0xc6, 0x5a, 0x37, 0xfc
};

uint16_t se3_algo_aes256hmacsha256_init(
    se3_flash_key* key, uint16_t mode, uint8_t* ctx)
{
 800c3c0:	b580      	push	{r7, lr}
 800c3c2:	b09e      	sub	sp, #120	; 0x78
 800c3c4:	af04      	add	r7, sp, #16
 800c3c6:	60f8      	str	r0, [r7, #12]
 800c3c8:	460b      	mov	r3, r1
 800c3ca:	607a      	str	r2, [r7, #4]
 800c3cc:	817b      	strh	r3, [r7, #10]
    B5_tAesCtx* aes = (B5_tAesCtx*)ctx;
 800c3ce:	687b      	ldr	r3, [r7, #4]
 800c3d0:	663b      	str	r3, [r7, #96]	; 0x60
	
	uint8_t feedback = mode & 0x07;
 800c3d2:	897b      	ldrh	r3, [r7, #10]
 800c3d4:	b2db      	uxtb	r3, r3
 800c3d6:	f003 0307 	and.w	r3, r3, #7
 800c3da:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
	uint16_t direction = (mode & SE3_DIR_ENCRYPT) ? SE3_DIR_ENCRYPT : SE3_DIR_DECRYPT;
 800c3de:	897b      	ldrh	r3, [r7, #10]
 800c3e0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c3e4:	2b00      	cmp	r3, #0
 800c3e6:	d002      	beq.n	800c3ee <se3_algo_aes256hmacsha256_init+0x2e>
 800c3e8:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c3ec:	e001      	b.n	800c3f2 <se3_algo_aes256hmacsha256_init+0x32>
 800c3ee:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c3f2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
	uint8_t b5_mode = 0;
 800c3f6:	2300      	movs	r3, #0
 800c3f8:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
	/*HMAC Authentication support available*/
	B5_tHmacSha256Ctx *hmacCtx = (B5_tHmacSha256Ctx*)(ctx+sizeof(B5_tAesCtx));
 800c3fc:	687b      	ldr	r3, [r7, #4]
 800c3fe:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 800c402:	65bb      	str	r3, [r7, #88]	; 0x58
	uint8_t *k1 = (uint8_t *)(ctx + sizeof(B5_tAesCtx) + sizeof(B5_tHmacSha256Ctx));
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	f503 7345 	add.w	r3, r3, #788	; 0x314
 800c40a:	657b      	str	r3, [r7, #84]	; 0x54
	uint8_t *do_pbkdf2 = (uint8_t *)(ctx + sizeof(B5_tAesCtx) + sizeof(B5_tHmacSha256Ctx) + 32);
 800c40c:	687b      	ldr	r3, [r7, #4]
 800c40e:	f503 734d 	add.w	r3, r3, #820	; 0x334
 800c412:	653b      	str	r3, [r7, #80]	; 0x50
	uint8_t derivated_key[PBKDF2_OUTPUT_KEY_LEN];
	switch (direction) {
 800c414:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 800c418:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c41c:	d003      	beq.n	800c426 <se3_algo_aes256hmacsha256_init+0x66>
 800c41e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800c422:	d025      	beq.n	800c470 <se3_algo_aes256hmacsha256_init+0xb0>
 800c424:	e048      	b.n	800c4b8 <se3_algo_aes256hmacsha256_init+0xf8>
	case (SE3_DIR_ENCRYPT):
		switch (feedback) {
 800c426:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800c42a:	3b01      	subs	r3, #1
 800c42c:	2b03      	cmp	r3, #3
 800c42e:	d81b      	bhi.n	800c468 <se3_algo_aes256hmacsha256_init+0xa8>
 800c430:	a201      	add	r2, pc, #4	; (adr r2, 800c438 <se3_algo_aes256hmacsha256_init+0x78>)
 800c432:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c436:	bf00      	nop
 800c438:	0800c449 	.word	0x0800c449
 800c43c:	0800c451 	.word	0x0800c451
 800c440:	0800c461 	.word	0x0800c461
 800c444:	0800c459 	.word	0x0800c459
		case SE3_FEEDBACK_ECB: b5_mode = B5_AES256_ECB_ENC; break;
 800c448:	2302      	movs	r3, #2
 800c44a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c44e:	e00e      	b.n	800c46e <se3_algo_aes256hmacsha256_init+0xae>
		case SE3_FEEDBACK_CBC: b5_mode = B5_AES256_CBC_ENC; break;
 800c450:	2304      	movs	r3, #4
 800c452:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c456:	e00a      	b.n	800c46e <se3_algo_aes256hmacsha256_init+0xae>
		case SE3_FEEDBACK_CTR: b5_mode = B5_AES256_CTR; break;
 800c458:	2308      	movs	r3, #8
 800c45a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c45e:	e006      	b.n	800c46e <se3_algo_aes256hmacsha256_init+0xae>
		case SE3_FEEDBACK_OFB: b5_mode = B5_AES256_OFB; break;
 800c460:	2301      	movs	r3, #1
 800c462:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c466:	e002      	b.n	800c46e <se3_algo_aes256hmacsha256_init+0xae>
		default: return SE3_ERR_PARAMS;
 800c468:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c46c:	e057      	b.n	800c51e <se3_algo_aes256hmacsha256_init+0x15e>
		}
		break;
 800c46e:	e026      	b.n	800c4be <se3_algo_aes256hmacsha256_init+0xfe>
	case (SE3_DIR_DECRYPT):
		switch (feedback) {
 800c470:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800c474:	3b01      	subs	r3, #1
 800c476:	2b03      	cmp	r3, #3
 800c478:	d81a      	bhi.n	800c4b0 <se3_algo_aes256hmacsha256_init+0xf0>
 800c47a:	a201      	add	r2, pc, #4	; (adr r2, 800c480 <se3_algo_aes256hmacsha256_init+0xc0>)
 800c47c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c480:	0800c491 	.word	0x0800c491
 800c484:	0800c499 	.word	0x0800c499
 800c488:	0800c4a9 	.word	0x0800c4a9
 800c48c:	0800c4a1 	.word	0x0800c4a1
		case SE3_FEEDBACK_ECB: b5_mode = B5_AES256_ECB_DEC; break;
 800c490:	2303      	movs	r3, #3
 800c492:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c496:	e00e      	b.n	800c4b6 <se3_algo_aes256hmacsha256_init+0xf6>
		case SE3_FEEDBACK_CBC: b5_mode = B5_AES256_CBC_DEC; break;
 800c498:	2305      	movs	r3, #5
 800c49a:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c49e:	e00a      	b.n	800c4b6 <se3_algo_aes256hmacsha256_init+0xf6>
		case SE3_FEEDBACK_CTR: b5_mode = B5_AES256_CTR; break;
 800c4a0:	2308      	movs	r3, #8
 800c4a2:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c4a6:	e006      	b.n	800c4b6 <se3_algo_aes256hmacsha256_init+0xf6>
		case SE3_FEEDBACK_OFB: b5_mode = B5_AES256_OFB; break;
 800c4a8:	2301      	movs	r3, #1
 800c4aa:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
 800c4ae:	e002      	b.n	800c4b6 <se3_algo_aes256hmacsha256_init+0xf6>
		default: return SE3_ERR_PARAMS;
 800c4b0:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c4b4:	e033      	b.n	800c51e <se3_algo_aes256hmacsha256_init+0x15e>
		}
		break;
 800c4b6:	e002      	b.n	800c4be <se3_algo_aes256hmacsha256_init+0xfe>
	default:
		return SE3_ERR_PARAMS;
 800c4b8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c4bc:	e02f      	b.n	800c51e <se3_algo_aes256hmacsha256_init+0x15e>
	}
	PBKDF2HmacSha256(key->data, key->data_size, salt, PBKDF2_SALT_LEN, PBKDF2_ITERATION, derivated_key, PBKDF2_OUTPUT_KEY_LEN);
 800c4be:	68fb      	ldr	r3, [r7, #12]
 800c4c0:	68d8      	ldr	r0, [r3, #12]
 800c4c2:	68fb      	ldr	r3, [r7, #12]
 800c4c4:	891b      	ldrh	r3, [r3, #8]
 800c4c6:	4619      	mov	r1, r3
 800c4c8:	2340      	movs	r3, #64	; 0x40
 800c4ca:	9302      	str	r3, [sp, #8]
 800c4cc:	f107 0310 	add.w	r3, r7, #16
 800c4d0:	9301      	str	r3, [sp, #4]
 800c4d2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800c4d6:	9300      	str	r3, [sp, #0]
 800c4d8:	2320      	movs	r3, #32
 800c4da:	4a13      	ldr	r2, [pc, #76]	; (800c528 <se3_algo_aes256hmacsha256_init+0x168>)
 800c4dc:	f7f7 ff0f 	bl	80042fe <PBKDF2HmacSha256>
	if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Init(hmacCtx, derivated_key + PBKDF2_INPUT_KEY_LEN, PBKDF2_INPUT_KEY_LEN)){
 800c4e0:	f107 0310 	add.w	r3, r7, #16
 800c4e4:	3320      	adds	r3, #32
 800c4e6:	2220      	movs	r2, #32
 800c4e8:	4619      	mov	r1, r3
 800c4ea:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800c4ec:	f7fa fa0e 	bl	800690c <B5_HmacSha256_Init>
 800c4f0:	4603      	mov	r3, r0
 800c4f2:	2b00      	cmp	r3, #0
 800c4f4:	d002      	beq.n	800c4fc <se3_algo_aes256hmacsha256_init+0x13c>
		SE3_TRACE(("[algo_aes256.init] B5_HmacSha256_Init failed\n"));
		return SE3_ERR_PARAMS;
 800c4f6:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c4fa:	e010      	b.n	800c51e <se3_algo_aes256hmacsha256_init+0x15e>
	}
	if (B5_AES256_RES_OK != B5_Aes256_Init(aes, key->data, key->data_size, b5_mode)) {
 800c4fc:	68fb      	ldr	r3, [r7, #12]
 800c4fe:	68d9      	ldr	r1, [r3, #12]
 800c500:	68fb      	ldr	r3, [r7, #12]
 800c502:	891b      	ldrh	r3, [r3, #8]
 800c504:	b21a      	sxth	r2, r3
 800c506:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 800c50a:	6e38      	ldr	r0, [r7, #96]	; 0x60
 800c50c:	f7f7 fa60 	bl	80039d0 <B5_Aes256_Init>
 800c510:	4603      	mov	r3, r0
 800c512:	2b00      	cmp	r3, #0
 800c514:	d002      	beq.n	800c51c <se3_algo_aes256hmacsha256_init+0x15c>
		SE3_TRACE(("[algo_aes256.init] B5_Aes256_Init failed\n"));
		return SE3_ERR_PARAMS;
 800c516:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c51a:	e000      	b.n	800c51e <se3_algo_aes256hmacsha256_init+0x15e>
	}
    return SE3_OK;
 800c51c:	2300      	movs	r3, #0
}
 800c51e:	4618      	mov	r0, r3
 800c520:	3768      	adds	r7, #104	; 0x68
 800c522:	46bd      	mov	sp, r7
 800c524:	bd80      	pop	{r7, pc}
 800c526:	bf00      	nop
 800c528:	0801e108 	.word	0x0801e108

0800c52c <se3_algo_aes256hmacsha256_update>:
    uint8_t* ctx, uint16_t flags,
    uint16_t datain0_len, const uint8_t* datain0,
    uint16_t datain1_len, const uint8_t* datain1,
    uint16_t datain2_len, const uint8_t* datain2,
    uint16_t* dataout_len, uint8_t* dataout)
{
 800c52c:	b580      	push	{r7, lr}
 800c52e:	b096      	sub	sp, #88	; 0x58
 800c530:	af02      	add	r7, sp, #8
 800c532:	60f8      	str	r0, [r7, #12]
 800c534:	607b      	str	r3, [r7, #4]
 800c536:	460b      	mov	r3, r1
 800c538:	817b      	strh	r3, [r7, #10]
 800c53a:	4613      	mov	r3, r2
 800c53c:	813b      	strh	r3, [r7, #8]
    B5_tAesCtx* aes = (B5_tAesCtx*)ctx;
 800c53e:	68fb      	ldr	r3, [r7, #12]
 800c540:	63bb      	str	r3, [r7, #56]	; 0x38
    size_t nblocks = 0;
 800c542:	2300      	movs	r3, #0
 800c544:	64fb      	str	r3, [r7, #76]	; 0x4c
    uint8_t* data_enc, *data_dec;
    bool do_setiv = false;
 800c546:	2300      	movs	r3, #0
 800c548:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    bool do_update = false;
 800c54c:	2300      	movs	r3, #0
 800c54e:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
    bool do_finit = false;
 800c552:	2300      	movs	r3, #0
 800c554:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
	/*If we want to add also HMAC digest when encrypting modify next lines*/
	B5_tHmacSha256Ctx *hmacCtx = (B5_tHmacSha256Ctx*)(ctx+sizeof(B5_tAesCtx));
 800c558:	68fb      	ldr	r3, [r7, #12]
 800c55a:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 800c55e:	637b      	str	r3, [r7, #52]	; 0x34
	uint8_t old_auth[32], *data_auth;
	uint16_t direction = (flags & SE3_DIR_ENCRYPT) ? SE3_DIR_ENCRYPT : SE3_DIR_DECRYPT;
 800c560:	897b      	ldrh	r3, [r7, #10]
 800c562:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800c566:	2b00      	cmp	r3, #0
 800c568:	d002      	beq.n	800c570 <se3_algo_aes256hmacsha256_update+0x44>
 800c56a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800c56e:	e001      	b.n	800c574 <se3_algo_aes256hmacsha256_update+0x48>
 800c570:	f44f 7300 	mov.w	r3, #512	; 0x200
 800c574:	867b      	strh	r3, [r7, #50]	; 0x32
	

    // check params
    if (datain1_len > 0) {
 800c576:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c57a:	2b00      	cmp	r3, #0
 800c57c:	d009      	beq.n	800c592 <se3_algo_aes256hmacsha256_update+0x66>
        if (datain1_len != B5_AES_BLK_SIZE) {
 800c57e:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 800c582:	2b10      	cmp	r3, #16
 800c584:	d002      	beq.n	800c58c <se3_algo_aes256hmacsha256_update+0x60>
            SE3_TRACE(("[algo_aes256.update] invalid IV size\n"));
            return SE3_ERR_PARAMS;
 800c586:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c58a:	e0b3      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
        }
        do_setiv = true;
 800c58c:	2301      	movs	r3, #1
 800c58e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    }
	
    if (datain2_len > 0) {
 800c592:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c596:	2b00      	cmp	r3, #0
 800c598:	d019      	beq.n	800c5ce <se3_algo_aes256hmacsha256_update+0xa2>
        if (datain2_len % B5_AES_BLK_SIZE != 0) {
 800c59a:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c59e:	f003 030f 	and.w	r3, r3, #15
 800c5a2:	b29b      	uxth	r3, r3
 800c5a4:	2b00      	cmp	r3, #0
 800c5a6:	d002      	beq.n	800c5ae <se3_algo_aes256hmacsha256_update+0x82>
            SE3_TRACE(("[algo_aes256.update] data size not a multiple of block size\n"));
            return SE3_ERR_PARAMS;
 800c5a8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c5ac:	e0a2      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
        }
        do_update = true;
 800c5ae:	2301      	movs	r3, #1
 800c5b0:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
        nblocks = datain2_len / B5_AES_BLK_SIZE;
 800c5b4:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c5b8:	091b      	lsrs	r3, r3, #4
 800c5ba:	b29b      	uxth	r3, r3
 800c5bc:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (datain2_len > SE3_CRYPTO_MAX_DATAOUT - 32){
 800c5be:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c5c2:	f5b3 5fea 	cmp.w	r3, #7488	; 0x1d40
 800c5c6:	d902      	bls.n	800c5ce <se3_algo_aes256hmacsha256_update+0xa2>
			SE3_TRACE(("[algo_aes256.update] data size too small\n"));
			return SE3_ERR_PARAMS;
 800c5c8:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c5cc:	e092      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
		}
    }
    if (flags & SE3_CRYPTO_FLAG_FINIT) {
 800c5ce:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800c5d2:	2b00      	cmp	r3, #0
 800c5d4:	da02      	bge.n	800c5dc <se3_algo_aes256hmacsha256_update+0xb0>
        do_finit = true;
 800c5d6:	2301      	movs	r3, #1
 800c5d8:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
    }
	
	
	
    if (do_setiv) {
 800c5dc:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800c5e0:	2b00      	cmp	r3, #0
 800c5e2:	d009      	beq.n	800c5f8 <se3_algo_aes256hmacsha256_update+0xcc>
        // set IV

        if (B5_AES256_RES_OK != B5_Aes256_SetIV(aes, datain1)) {
 800c5e4:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800c5e6:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800c5e8:	f7f7 fac6 	bl	8003b78 <B5_Aes256_SetIV>
 800c5ec:	4603      	mov	r3, r0
 800c5ee:	2b00      	cmp	r3, #0
 800c5f0:	d002      	beq.n	800c5f8 <se3_algo_aes256hmacsha256_update+0xcc>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_SetIV failed\n"));
            return SE3_ERR_HW;
 800c5f2:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c5f6:	e07d      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
        }
    }

    if (do_update) {
 800c5f8:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 800c5fc:	2b00      	cmp	r3, #0
 800c5fe:	d03d      	beq.n	800c67c <se3_algo_aes256hmacsha256_update+0x150>
        // update

        switch (aes->mode) {
 800c600:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c602:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 800c606:	2b05      	cmp	r3, #5
 800c608:	d003      	beq.n	800c612 <se3_algo_aes256hmacsha256_update+0xe6>
 800c60a:	2b07      	cmp	r3, #7
 800c60c:	d001      	beq.n	800c612 <se3_algo_aes256hmacsha256_update+0xe6>
 800c60e:	2b03      	cmp	r3, #3
 800c610:	d104      	bne.n	800c61c <se3_algo_aes256hmacsha256_update+0xf0>
        case B5_AES256_ECB_DEC:
        case B5_AES256_CBC_DEC:
        case B5_AES256_CFB_DEC:
            data_enc = (uint8_t*)datain2;
 800c612:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c614:	64bb      	str	r3, [r7, #72]	; 0x48
            data_dec = dataout;
 800c616:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c618:	647b      	str	r3, [r7, #68]	; 0x44
            break;
 800c61a:	e004      	b.n	800c626 <se3_algo_aes256hmacsha256_update+0xfa>
        case B5_AES256_ECB_ENC:
        case B5_AES256_CBC_ENC:
        case B5_AES256_CFB_ENC:
        case B5_AES256_CTR:
        default:
            data_enc = dataout;
 800c61c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c61e:	64bb      	str	r3, [r7, #72]	; 0x48
            data_dec = (uint8_t*)datain2;
 800c620:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c622:	647b      	str	r3, [r7, #68]	; 0x44
            break;
 800c624:	bf00      	nop
        }

        if (B5_AES256_RES_OK != B5_Aes256_Update(aes, NULL, data_enc, data_dec,0, (int16_t)nblocks)) {
 800c626:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c628:	b21b      	sxth	r3, r3
 800c62a:	9301      	str	r3, [sp, #4]
 800c62c:	2300      	movs	r3, #0
 800c62e:	9300      	str	r3, [sp, #0]
 800c630:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c632:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c634:	2100      	movs	r1, #0
 800c636:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800c638:	f7f7 fae6 	bl	8003c08 <B5_Aes256_Update>
 800c63c:	4603      	mov	r3, r0
 800c63e:	2b00      	cmp	r3, #0
 800c640:	d002      	beq.n	800c648 <se3_algo_aes256hmacsha256_update+0x11c>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_Update failed\n"));
            return SE3_ERR_HW;
 800c642:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c646:	e055      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
        }
        *dataout_len = datain2_len;
 800c648:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c64a:	f8b7 2060 	ldrh.w	r2, [r7, #96]	; 0x60
 800c64e:	801a      	strh	r2, [r3, #0]
		
		if (direction == SE3_DIR_ENCRYPT) data_auth = dataout;
 800c650:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800c652:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c656:	d102      	bne.n	800c65e <se3_algo_aes256hmacsha256_update+0x132>
 800c658:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c65a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c65c:	e001      	b.n	800c662 <se3_algo_aes256hmacsha256_update+0x136>
			else data_auth = (uint8_t*)datain2;
 800c65e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c660:	63fb      	str	r3, [r7, #60]	; 0x3c

		if(B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Update(hmacCtx, data_auth, datain2_len)){
 800c662:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c666:	461a      	mov	r2, r3
 800c668:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800c66a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800c66c:	f7fa f9d4 	bl	8006a18 <B5_HmacSha256_Update>
 800c670:	4603      	mov	r3, r0
 800c672:	2b00      	cmp	r3, #0
 800c674:	d002      	beq.n	800c67c <se3_algo_aes256hmacsha256_update+0x150>
			SE3_TRACE(("[algo_aes256.update] B5_HmacSha256_Update failed\n"));
			return SE3_ERR_HW;
 800c676:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c67a:	e03b      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
		}

    }

    if (do_finit) {
 800c67c:	f897 3041 	ldrb.w	r3, [r7, #65]	; 0x41
 800c680:	2b00      	cmp	r3, #0
 800c682:	d036      	beq.n	800c6f2 <se3_algo_aes256hmacsha256_update+0x1c6>
        if (B5_AES256_RES_OK != B5_Aes256_Finit(aes)) {
 800c684:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800c686:	f7f7 fd71 	bl	800416c <B5_Aes256_Finit>
 800c68a:	4603      	mov	r3, r0
 800c68c:	2b00      	cmp	r3, #0
 800c68e:	d002      	beq.n	800c696 <se3_algo_aes256hmacsha256_update+0x16a>
            SE3_TRACE(("[algo_aes256.update] B5_Aes256_Finit failed\n"));
            return SE3_ERR_HW;
 800c690:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c694:	e02e      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
        }
		if (direction == SE3_DIR_ENCRYPT){
 800c696:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800c698:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c69c:	d10d      	bne.n	800c6ba <se3_algo_aes256hmacsha256_update+0x18e>
			if(B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Finit(hmacCtx, data_enc+datain2_len)){
 800c69e:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c6a2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c6a4:	4413      	add	r3, r2
 800c6a6:	4619      	mov	r1, r3
 800c6a8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800c6aa:	f7fa f9da 	bl	8006a62 <B5_HmacSha256_Finit>
 800c6ae:	4603      	mov	r3, r0
 800c6b0:	2b00      	cmp	r3, #0
 800c6b2:	d01e      	beq.n	800c6f2 <se3_algo_aes256hmacsha256_update+0x1c6>
				SE3_TRACE(("[algo_aes256.update] B5_HmacSha256_Finit failed\n"));
				return SE3_ERR_HW;
 800c6b4:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c6b8:	e01c      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
			}
		} else {
			if (B5_HMAC_SHA256_RES_OK != B5_HmacSha256_Finit(hmacCtx, old_auth)){
 800c6ba:	f107 0310 	add.w	r3, r7, #16
 800c6be:	4619      	mov	r1, r3
 800c6c0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800c6c2:	f7fa f9ce 	bl	8006a62 <B5_HmacSha256_Finit>
 800c6c6:	4603      	mov	r3, r0
 800c6c8:	2b00      	cmp	r3, #0
 800c6ca:	d002      	beq.n	800c6d2 <se3_algo_aes256hmacsha256_update+0x1a6>
				SE3_TRACE(("[algo_aes256.update] B5_HmacSha256_Finit failed\n"));
				return SE3_ERR_HW;
 800c6cc:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c6d0:	e010      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
			}
			if (!memcmp(old_auth, (data_enc + datain2_len), 32)){
 800c6d2:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 800c6d6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c6d8:	18d1      	adds	r1, r2, r3
 800c6da:	f107 0310 	add.w	r3, r7, #16
 800c6de:	2220      	movs	r2, #32
 800c6e0:	4618      	mov	r0, r3
 800c6e2:	f00e fc51 	bl	801af88 <memcmp>
 800c6e6:	4603      	mov	r3, r0
 800c6e8:	2b00      	cmp	r3, #0
 800c6ea:	d102      	bne.n	800c6f2 <se3_algo_aes256hmacsha256_update+0x1c6>
				SE3_TRACE(("[algo_aes256.update] B5_HmacSha256_Finit NOT AUTHENTICATED\n"));
				return SE3_ERR_AUTH;
 800c6ec:	f240 1391 	movw	r3, #401	; 0x191
 800c6f0:	e000      	b.n	800c6f4 <se3_algo_aes256hmacsha256_update+0x1c8>
			}
		}		
    }

    return SE3_OK;
 800c6f2:	2300      	movs	r3, #0
}
 800c6f4:	4618      	mov	r0, r3
 800c6f6:	3750      	adds	r7, #80	; 0x50
 800c6f8:	46bd      	mov	sp, r7
 800c6fa:	bd80      	pop	{r7, pc}

0800c6fc <se3_algo_Sha256_init>:
#include "se3_algo_sha256.h"


// key is not used;  mode is not used
uint16_t se3_algo_Sha256_init(se3_flash_key* key, uint16_t mode, uint8_t* ctx) {
 800c6fc:	b580      	push	{r7, lr}
 800c6fe:	b086      	sub	sp, #24
 800c700:	af00      	add	r7, sp, #0
 800c702:	60f8      	str	r0, [r7, #12]
 800c704:	460b      	mov	r3, r1
 800c706:	607a      	str	r2, [r7, #4]
 800c708:	817b      	strh	r3, [r7, #10]
	B5_tSha256Ctx* sha = (B5_tSha256Ctx*)ctx;
 800c70a:	687b      	ldr	r3, [r7, #4]
 800c70c:	617b      	str	r3, [r7, #20]
	
	if (B5_SHA256_RES_OK != B5_Sha256_Init(sha)) {
 800c70e:	6978      	ldr	r0, [r7, #20]
 800c710:	f7f9 ffb6 	bl	8006680 <B5_Sha256_Init>
 800c714:	4603      	mov	r3, r0
 800c716:	2b00      	cmp	r3, #0
 800c718:	d002      	beq.n	800c720 <se3_algo_Sha256_init+0x24>
		SE3_TRACE(("[algo_sha256.init] B5_Sha256_Init failed\n"));
		return (SE3_ERR_PARAMS);
 800c71a:	f24f 0306 	movw	r3, #61446	; 0xf006
 800c71e:	e000      	b.n	800c722 <se3_algo_Sha256_init+0x26>
	}
	
	return (SE3_OK);
 800c720:	2300      	movs	r3, #0
}
 800c722:	4618      	mov	r0, r3
 800c724:	3718      	adds	r7, #24
 800c726:	46bd      	mov	sp, r7
 800c728:	bd80      	pop	{r7, pc}

0800c72a <se3_algo_Sha256_update>:
uint16_t se3_algo_Sha256_update(
	uint8_t* ctx, uint16_t flags,
    uint16_t datain0_len, const uint8_t* datain0,
    uint16_t datain1_len, const uint8_t* datain1,
    uint16_t datain2_len, const uint8_t* datain2,
	uint16_t* dataout_len, uint8_t* dataout) {
 800c72a:	b580      	push	{r7, lr}
 800c72c:	b086      	sub	sp, #24
 800c72e:	af00      	add	r7, sp, #0
 800c730:	60f8      	str	r0, [r7, #12]
 800c732:	607b      	str	r3, [r7, #4]
 800c734:	460b      	mov	r3, r1
 800c736:	817b      	strh	r3, [r7, #10]
 800c738:	4613      	mov	r3, r2
 800c73a:	813b      	strh	r3, [r7, #8]

	B5_tSha256Ctx* sha = (B5_tSha256Ctx*)ctx;
 800c73c:	68fb      	ldr	r3, [r7, #12]
 800c73e:	617b      	str	r3, [r7, #20]

	bool do_update = (datain1_len > 0);
 800c740:	8c3b      	ldrh	r3, [r7, #32]
 800c742:	2b00      	cmp	r3, #0
 800c744:	bf14      	ite	ne
 800c746:	2301      	movne	r3, #1
 800c748:	2300      	moveq	r3, #0
 800c74a:	74fb      	strb	r3, [r7, #19]
	bool do_finit = (flags & SE3_CRYPTO_FLAG_FINIT);
 800c74c:	897b      	ldrh	r3, [r7, #10]
 800c74e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800c752:	2b00      	cmp	r3, #0
 800c754:	bf14      	ite	ne
 800c756:	2301      	movne	r3, #1
 800c758:	2300      	moveq	r3, #0
 800c75a:	74bb      	strb	r3, [r7, #18]

	if (do_update) {
 800c75c:	7cfb      	ldrb	r3, [r7, #19]
 800c75e:	2b00      	cmp	r3, #0
 800c760:	d00b      	beq.n	800c77a <se3_algo_Sha256_update+0x50>
		// update
		if (B5_SHA256_RES_OK != B5_Sha256_Update(sha, datain1, datain1_len)) {
 800c762:	8c3b      	ldrh	r3, [r7, #32]
 800c764:	461a      	mov	r2, r3
 800c766:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800c768:	6978      	ldr	r0, [r7, #20]
 800c76a:	f7f9 ffcd 	bl	8006708 <B5_Sha256_Update>
 800c76e:	4603      	mov	r3, r0
 800c770:	2b00      	cmp	r3, #0
 800c772:	d002      	beq.n	800c77a <se3_algo_Sha256_update+0x50>
			SE3_TRACE(("[algo_sha256.update] B5_Sha256_Update failed\n"));
			return SE3_ERR_HW;
 800c774:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c778:	e010      	b.n	800c79c <se3_algo_Sha256_update+0x72>
		}
	}

	if (do_finit) {
 800c77a:	7cbb      	ldrb	r3, [r7, #18]
 800c77c:	2b00      	cmp	r3, #0
 800c77e:	d00c      	beq.n	800c79a <se3_algo_Sha256_update+0x70>
		if (B5_SHA256_RES_OK != B5_Sha256_Finit(sha, dataout)) {
 800c780:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800c782:	6978      	ldr	r0, [r7, #20]
 800c784:	f7fa f833 	bl	80067ee <B5_Sha256_Finit>
 800c788:	4603      	mov	r3, r0
 800c78a:	2b00      	cmp	r3, #0
 800c78c:	d002      	beq.n	800c794 <se3_algo_Sha256_update+0x6a>
			SE3_TRACE(("[algo_sha256.update] B5_Sha256_Finit failed\n"));
			return SE3_ERR_HW;
 800c78e:	f24f 0301 	movw	r3, #61441	; 0xf001
 800c792:	e003      	b.n	800c79c <se3_algo_Sha256_update+0x72>
		}
		*dataout_len = 32;
 800c794:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c796:	2220      	movs	r2, #32
 800c798:	801a      	strh	r2, [r3, #0]
	}

	return(SE3_OK);
 800c79a:	2300      	movs	r3, #0
}
 800c79c:	4618      	mov	r0, r3
 800c79e:	3718      	adds	r7, #24
 800c7a0:	46bd      	mov	sp, r7
 800c7a2:	bd80      	pop	{r7, pc}

0800c7a4 <se3_communication_core_init>:



/**\brief Initializes the communication core structures */
void se3_communication_core_init()
{
 800c7a4:	b580      	push	{r7, lr}
 800c7a6:	af00      	add	r7, sp, #0
	memset(&comm, 0, sizeof(SE3_COMM_STATUS));
 800c7a8:	226c      	movs	r2, #108	; 0x6c
 800c7aa:	2100      	movs	r1, #0
 800c7ac:	481e      	ldr	r0, [pc, #120]	; (800c828 <se3_communication_core_init+0x84>)
 800c7ae:	f00e fc1e 	bl	801afee <memset>
	memset(&req_hdr, 0, sizeof(se3_comm_req_header));
 800c7b2:	2244      	movs	r2, #68	; 0x44
 800c7b4:	2100      	movs	r1, #0
 800c7b6:	481d      	ldr	r0, [pc, #116]	; (800c82c <se3_communication_core_init+0x88>)
 800c7b8:	f00e fc19 	bl	801afee <memset>
	memset(&resp_hdr, 0, sizeof(se3_comm_resp_header));
 800c7bc:	2244      	movs	r2, #68	; 0x44
 800c7be:	2100      	movs	r1, #0
 800c7c0:	481b      	ldr	r0, [pc, #108]	; (800c830 <se3_communication_core_init+0x8c>)
 800c7c2:	f00e fc14 	bl	801afee <memset>
	memset(&serial, 0, sizeof(SE3_SERIAL));
 800c7c6:	2221      	movs	r2, #33	; 0x21
 800c7c8:	2100      	movs	r1, #0
 800c7ca:	481a      	ldr	r0, [pc, #104]	; (800c834 <se3_communication_core_init+0x90>)
 800c7cc:	f00e fc0f 	bl	801afee <memset>



    comm.req_hdr = se3_comm_request_buffer;
 800c7d0:	4b15      	ldr	r3, [pc, #84]	; (800c828 <se3_communication_core_init+0x84>)
 800c7d2:	4a19      	ldr	r2, [pc, #100]	; (800c838 <se3_communication_core_init+0x94>)
 800c7d4:	659a      	str	r2, [r3, #88]	; 0x58
    comm.req_data = se3_comm_request_buffer + SE3_REQ_SIZE_HEADER;
 800c7d6:	4a19      	ldr	r2, [pc, #100]	; (800c83c <se3_communication_core_init+0x98>)
 800c7d8:	4b13      	ldr	r3, [pc, #76]	; (800c828 <se3_communication_core_init+0x84>)
 800c7da:	655a      	str	r2, [r3, #84]	; 0x54
    comm.resp_hdr = se3_comm_response_buffer;
 800c7dc:	4b12      	ldr	r3, [pc, #72]	; (800c828 <se3_communication_core_init+0x84>)
 800c7de:	4a18      	ldr	r2, [pc, #96]	; (800c840 <se3_communication_core_init+0x9c>)
 800c7e0:	669a      	str	r2, [r3, #104]	; 0x68
    comm.resp_data = se3_comm_response_buffer + SE3_RESP_SIZE_HEADER;
 800c7e2:	4a18      	ldr	r2, [pc, #96]	; (800c844 <se3_communication_core_init+0xa0>)
 800c7e4:	4b10      	ldr	r3, [pc, #64]	; (800c828 <se3_communication_core_init+0x84>)
 800c7e6:	665a      	str	r2, [r3, #100]	; 0x64
    comm.magic_bmap = SE3_BMAP_MAKE(16);
 800c7e8:	4b0f      	ldr	r3, [pc, #60]	; (800c828 <se3_communication_core_init+0x84>)
 800c7ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800c7ee:	605a      	str	r2, [r3, #4]
    comm.magic_ready = false;
 800c7f0:	4b0d      	ldr	r3, [pc, #52]	; (800c828 <se3_communication_core_init+0x84>)
 800c7f2:	2200      	movs	r2, #0
 800c7f4:	701a      	strb	r2, [r3, #0]
    comm.req_bmap = SE3_BMAP_MAKE(1);
 800c7f6:	4b0c      	ldr	r3, [pc, #48]	; (800c828 <se3_communication_core_init+0x84>)
 800c7f8:	2201      	movs	r2, #1
 800c7fa:	651a      	str	r2, [r3, #80]	; 0x50
    comm.locked = false;
 800c7fc:	4b0a      	ldr	r3, [pc, #40]	; (800c828 <se3_communication_core_init+0x84>)
 800c7fe:	2200      	movs	r2, #0
 800c800:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    comm.req_ready = false;
 800c804:	4b08      	ldr	r3, [pc, #32]	; (800c828 <se3_communication_core_init+0x84>)
 800c806:	2200      	movs	r2, #0
 800c808:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
    comm.req_bmap = SE3_BMAP_MAKE(32);
 800c80c:	4b06      	ldr	r3, [pc, #24]	; (800c828 <se3_communication_core_init+0x84>)
 800c80e:	f04f 32ff 	mov.w	r2, #4294967295
 800c812:	651a      	str	r2, [r3, #80]	; 0x50
    comm.resp_ready = true;
 800c814:	4b04      	ldr	r3, [pc, #16]	; (800c828 <se3_communication_core_init+0x84>)
 800c816:	2201      	movs	r2, #1
 800c818:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
    comm.resp_bmap = 0;
 800c81c:	4b02      	ldr	r3, [pc, #8]	; (800c828 <se3_communication_core_init+0x84>)
 800c81e:	2200      	movs	r2, #0
 800c820:	661a      	str	r2, [r3, #96]	; 0x60
}
 800c822:	bf00      	nop
 800c824:	bd80      	pop	{r7, pc}
 800c826:	bf00      	nop
 800c828:	20004638 	.word	0x20004638
 800c82c:	200045f4 	.word	0x200045f4
 800c830:	200005b0 	.word	0x200005b0
 800c834:	200004a4 	.word	0x200004a4
 800c838:	200005f4 	.word	0x200005f4
 800c83c:	20000604 	.word	0x20000604
 800c840:	200025f4 	.word	0x200025f4
 800c844:	20002604 	.word	0x20002604

0800c848 <block_is_magic>:
 *
 *  Check if a block of data contains the magic sequence, used to initialize the special
 *    protocol file.
 */
static bool block_is_magic(const uint8_t* buf)
{
 800c848:	b580      	push	{r7, lr}
 800c84a:	b086      	sub	sp, #24
 800c84c:	af00      	add	r7, sp, #0
 800c84e:	6078      	str	r0, [r7, #4]
	const uint8_t* a = buf;
 800c850:	687b      	ldr	r3, [r7, #4]
 800c852:	617b      	str	r3, [r7, #20]
	const uint8_t* b = se3_magic;
 800c854:	4b12      	ldr	r3, [pc, #72]	; (800c8a0 <block_is_magic+0x58>)
 800c856:	60fb      	str	r3, [r7, #12]
	size_t i;
	for (i = 0; i < SE3_COMM_BLOCK / SE3_MAGIC_SIZE - 1; i++) {
 800c858:	2300      	movs	r3, #0
 800c85a:	613b      	str	r3, [r7, #16]
 800c85c:	e00f      	b.n	800c87e <block_is_magic+0x36>
		if (memcmp(a, b, SE3_MAGIC_SIZE))return false;
 800c85e:	2220      	movs	r2, #32
 800c860:	68f9      	ldr	r1, [r7, #12]
 800c862:	6978      	ldr	r0, [r7, #20]
 800c864:	f00e fb90 	bl	801af88 <memcmp>
 800c868:	4603      	mov	r3, r0
 800c86a:	2b00      	cmp	r3, #0
 800c86c:	d001      	beq.n	800c872 <block_is_magic+0x2a>
 800c86e:	2300      	movs	r3, #0
 800c870:	e011      	b.n	800c896 <block_is_magic+0x4e>
        a += SE3_MAGIC_SIZE;
 800c872:	697b      	ldr	r3, [r7, #20]
 800c874:	3320      	adds	r3, #32
 800c876:	617b      	str	r3, [r7, #20]
	for (i = 0; i < SE3_COMM_BLOCK / SE3_MAGIC_SIZE - 1; i++) {
 800c878:	693b      	ldr	r3, [r7, #16]
 800c87a:	3301      	adds	r3, #1
 800c87c:	613b      	str	r3, [r7, #16]
 800c87e:	693b      	ldr	r3, [r7, #16]
 800c880:	2b0e      	cmp	r3, #14
 800c882:	d9ec      	bls.n	800c85e <block_is_magic+0x16>
	}
	if (buf[SE3_COMM_BLOCK - 1] >= SE3_COMM_N)return false;
 800c884:	687b      	ldr	r3, [r7, #4]
 800c886:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800c88a:	781b      	ldrb	r3, [r3, #0]
 800c88c:	2b0f      	cmp	r3, #15
 800c88e:	d901      	bls.n	800c894 <block_is_magic+0x4c>
 800c890:	2300      	movs	r3, #0
 800c892:	e000      	b.n	800c896 <block_is_magic+0x4e>
	return true;
 800c894:	2301      	movs	r3, #1
}
 800c896:	4618      	mov	r0, r3
 800c898:	3718      	adds	r7, #24
 800c89a:	46bd      	mov	sp, r7
 800c89c:	bd80      	pop	{r7, pc}
 800c89e:	bf00      	nop
 800c8a0:	0801e028 	.word	0x0801e028

0800c8a4 <find_magic_index>:
 *  
 *  The special protocol file is made up of multiple blocks. Each block is mapped to a block
 *    on the physical storage
 */
static int find_magic_index(uint32_t block)
{
 800c8a4:	b480      	push	{r7}
 800c8a6:	b085      	sub	sp, #20
 800c8a8:	af00      	add	r7, sp, #0
 800c8aa:	6078      	str	r0, [r7, #4]
	int i; size_t k;
	for (i = 0, k = comm.block_guess; i < SE3_COMM_N; i++, k = (k+1)%(SE3_COMM_N) ) {
 800c8ac:	2300      	movs	r3, #0
 800c8ae:	60fb      	str	r3, [r7, #12]
 800c8b0:	4b16      	ldr	r3, [pc, #88]	; (800c90c <find_magic_index+0x68>)
 800c8b2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c8b4:	60bb      	str	r3, [r7, #8]
 800c8b6:	e01d      	b.n	800c8f4 <find_magic_index+0x50>
		if (block == comm.blocks[i]) {
 800c8b8:	4a14      	ldr	r2, [pc, #80]	; (800c90c <find_magic_index+0x68>)
 800c8ba:	68fb      	ldr	r3, [r7, #12]
 800c8bc:	3302      	adds	r3, #2
 800c8be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800c8c2:	687a      	ldr	r2, [r7, #4]
 800c8c4:	429a      	cmp	r2, r3
 800c8c6:	d10d      	bne.n	800c8e4 <find_magic_index+0x40>
			comm.block_guess = (size_t)((i + 1) % 16);
 800c8c8:	68fb      	ldr	r3, [r7, #12]
 800c8ca:	3301      	adds	r3, #1
 800c8cc:	425a      	negs	r2, r3
 800c8ce:	f003 030f 	and.w	r3, r3, #15
 800c8d2:	f002 020f 	and.w	r2, r2, #15
 800c8d6:	bf58      	it	pl
 800c8d8:	4253      	negpl	r3, r2
 800c8da:	461a      	mov	r2, r3
 800c8dc:	4b0b      	ldr	r3, [pc, #44]	; (800c90c <find_magic_index+0x68>)
 800c8de:	649a      	str	r2, [r3, #72]	; 0x48
			return i;
 800c8e0:	68fb      	ldr	r3, [r7, #12]
 800c8e2:	e00c      	b.n	800c8fe <find_magic_index+0x5a>
	for (i = 0, k = comm.block_guess; i < SE3_COMM_N; i++, k = (k+1)%(SE3_COMM_N) ) {
 800c8e4:	68fb      	ldr	r3, [r7, #12]
 800c8e6:	3301      	adds	r3, #1
 800c8e8:	60fb      	str	r3, [r7, #12]
 800c8ea:	68bb      	ldr	r3, [r7, #8]
 800c8ec:	3301      	adds	r3, #1
 800c8ee:	f003 030f 	and.w	r3, r3, #15
 800c8f2:	60bb      	str	r3, [r7, #8]
 800c8f4:	68fb      	ldr	r3, [r7, #12]
 800c8f6:	2b0f      	cmp	r3, #15
 800c8f8:	ddde      	ble.n	800c8b8 <find_magic_index+0x14>
		}
	}
	return -1;
 800c8fa:	f04f 33ff 	mov.w	r3, #4294967295
}
 800c8fe:	4618      	mov	r0, r3
 800c900:	3714      	adds	r7, #20
 800c902:	46bd      	mov	sp, r7
 800c904:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c908:	4770      	bx	lr
 800c90a:	bf00      	nop
 800c90c:	20004638 	.word	0x20004638

0800c910 <se3_storage_range_add>:
 *  
 *  Contiguous requests are processed with a single call to the SDIO interface, as soon as
 *    a non-contiguous request is added.
 */
static int32_t se3_storage_range_add(s3_storage_range* range, uint8_t lun, uint8_t* buf, uint32_t block, enum s3_storage_range_direction direction)
{
 800c910:	b580      	push	{r7, lr}
 800c912:	b086      	sub	sp, #24
 800c914:	af00      	add	r7, sp, #0
 800c916:	60f8      	str	r0, [r7, #12]
 800c918:	607a      	str	r2, [r7, #4]
 800c91a:	603b      	str	r3, [r7, #0]
 800c91c:	460b      	mov	r3, r1
 800c91e:	72fb      	strb	r3, [r7, #11]
	bool ret = true;
 800c920:	2301      	movs	r3, #1
 800c922:	75fb      	strb	r3, [r7, #23]
	if (range->count == 0) {
 800c924:	68fb      	ldr	r3, [r7, #12]
 800c926:	689b      	ldr	r3, [r3, #8]
 800c928:	2b00      	cmp	r3, #0
 800c92a:	d109      	bne.n	800c940 <se3_storage_range_add+0x30>
		range->buf = buf;
 800c92c:	68fb      	ldr	r3, [r7, #12]
 800c92e:	687a      	ldr	r2, [r7, #4]
 800c930:	601a      	str	r2, [r3, #0]
		range->first = block;
 800c932:	68fb      	ldr	r3, [r7, #12]
 800c934:	683a      	ldr	r2, [r7, #0]
 800c936:	605a      	str	r2, [r3, #4]
		range->count = 1;
 800c938:	68fb      	ldr	r3, [r7, #12]
 800c93a:	2201      	movs	r2, #1
 800c93c:	609a      	str	r2, [r3, #8]
 800c93e:	e02d      	b.n	800c99c <se3_storage_range_add+0x8c>
	}
	else {
		if (block == range->first + range->count) {
 800c940:	68fb      	ldr	r3, [r7, #12]
 800c942:	685a      	ldr	r2, [r3, #4]
 800c944:	68fb      	ldr	r3, [r7, #12]
 800c946:	689b      	ldr	r3, [r3, #8]
 800c948:	4413      	add	r3, r2
 800c94a:	683a      	ldr	r2, [r7, #0]
 800c94c:	429a      	cmp	r2, r3
 800c94e:	d105      	bne.n	800c95c <se3_storage_range_add+0x4c>
			range->count++;
 800c950:	68fb      	ldr	r3, [r7, #12]
 800c952:	689b      	ldr	r3, [r3, #8]
 800c954:	1c5a      	adds	r2, r3, #1
 800c956:	68fb      	ldr	r3, [r7, #12]
 800c958:	609a      	str	r2, [r3, #8]
 800c95a:	e01f      	b.n	800c99c <se3_storage_range_add+0x8c>
		}
		else {
			if (direction == range_write){
 800c95c:	f897 3020 	ldrb.w	r3, [r7, #32]
 800c960:	2b00      	cmp	r3, #0
 800c962:	d10c      	bne.n	800c97e <se3_storage_range_add+0x6e>
				ret = secube_sdio_write(lun, range->buf, range->first, range->count);
 800c964:	68fb      	ldr	r3, [r7, #12]
 800c966:	6819      	ldr	r1, [r3, #0]
 800c968:	68fb      	ldr	r3, [r7, #12]
 800c96a:	685a      	ldr	r2, [r3, #4]
 800c96c:	68fb      	ldr	r3, [r7, #12]
 800c96e:	689b      	ldr	r3, [r3, #8]
 800c970:	b29b      	uxth	r3, r3
 800c972:	7af8      	ldrb	r0, [r7, #11]
 800c974:	f003 fe98 	bl	80106a8 <secube_sdio_write>
 800c978:	4603      	mov	r3, r0
 800c97a:	75fb      	strb	r3, [r7, #23]
 800c97c:	e00b      	b.n	800c996 <se3_storage_range_add+0x86>
				SE3_TRACE(("%i: write buf=%u count=%u to block=%u", ret, (unsigned)range->buf, range->count, range->first));
			}
			else {
				ret = secube_sdio_read(lun, range->buf, range->first, range->count);
 800c97e:	68fb      	ldr	r3, [r7, #12]
 800c980:	6819      	ldr	r1, [r3, #0]
 800c982:	68fb      	ldr	r3, [r7, #12]
 800c984:	685a      	ldr	r2, [r3, #4]
 800c986:	68fb      	ldr	r3, [r7, #12]
 800c988:	689b      	ldr	r3, [r3, #8]
 800c98a:	b29b      	uxth	r3, r3
 800c98c:	7af8      	ldrb	r0, [r7, #11]
 800c98e:	f003 feb9 	bl	8010704 <secube_sdio_read>
 800c992:	4603      	mov	r3, r0
 800c994:	75fb      	strb	r3, [r7, #23]
				SE3_TRACE(("%d: read buf=%u count=%u from block=%u", ret, (unsigned)range->buf, range->count, range->first));
			}
			range->count = 0;
 800c996:	68fb      	ldr	r3, [r7, #12]
 800c998:	2200      	movs	r2, #0
 800c99a:	609a      	str	r2, [r3, #8]
		}
	}

	return (ret)?(SE3_PROTO_OK):(SE3_PROTO_FAIL);
 800c99c:	7dfb      	ldrb	r3, [r7, #23]
 800c99e:	f083 0301 	eor.w	r3, r3, #1
 800c9a2:	b2db      	uxtb	r3, r3
}
 800c9a4:	4618      	mov	r0, r3
 800c9a6:	3718      	adds	r7, #24
 800c9a8:	46bd      	mov	sp, r7
 800c9aa:	bd80      	pop	{r7, pc}

0800c9ac <handle_req_recv>:
 *  Handle a single block belonging to a protocol request. The data is stored in the
 *    request buffer. As soon as the request data is received completely, the device
 *    will start processing the request
 */
static void handle_req_recv(int index, const uint8_t* blockdata)
{
 800c9ac:	b580      	push	{r7, lr}
 800c9ae:	b084      	sub	sp, #16
 800c9b0:	af00      	add	r7, sp, #0
 800c9b2:	6078      	str	r0, [r7, #4]
 800c9b4:	6039      	str	r1, [r7, #0]
    uint16_t nblocks;
    if (index == SE3_COMM_N - 1) {
 800c9b6:	687b      	ldr	r3, [r7, #4]
 800c9b8:	2b0f      	cmp	r3, #15
 800c9ba:	f000 809d 	beq.w	800caf8 <handle_req_recv+0x14c>
        SE3_TRACE(("P data write to block %d ignored", index));
        return;
    }

    comm.resp_ready = false;
 800c9be:	4b50      	ldr	r3, [pc, #320]	; (800cb00 <handle_req_recv+0x154>)
 800c9c0:	2200      	movs	r2, #0
 800c9c2:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    if (index == 0) {
 800c9c6:	687b      	ldr	r3, [r7, #4]
 800c9c8:	2b00      	cmp	r3, #0
 800c9ca:	d159      	bne.n	800ca80 <handle_req_recv+0xd4>
        // REQ block

        // read and decode header
        memcpy(comm.req_hdr, blockdata, SE3_REQ_SIZE_HEADER);
 800c9cc:	4b4c      	ldr	r3, [pc, #304]	; (800cb00 <handle_req_recv+0x154>)
 800c9ce:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c9d0:	2210      	movs	r2, #16
 800c9d2:	6839      	ldr	r1, [r7, #0]
 800c9d4:	4618      	mov	r0, r3
 800c9d6:	f00e fae6 	bl	801afa6 <memcpy>
        SE3_GET16(comm.req_hdr, SE3_REQ_OFFSET_CMD, req_hdr.cmd);
 800c9da:	4b49      	ldr	r3, [pc, #292]	; (800cb00 <handle_req_recv+0x154>)
 800c9dc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c9de:	881b      	ldrh	r3, [r3, #0]
 800c9e0:	b29a      	uxth	r2, r3
 800c9e2:	4b48      	ldr	r3, [pc, #288]	; (800cb04 <handle_req_recv+0x158>)
 800c9e4:	801a      	strh	r2, [r3, #0]
        SE3_GET16(comm.req_hdr, SE3_REQ_OFFSET_CMDFLAGS, req_hdr.cmd_flags);
 800c9e6:	4b46      	ldr	r3, [pc, #280]	; (800cb00 <handle_req_recv+0x154>)
 800c9e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c9ea:	3302      	adds	r3, #2
 800c9ec:	881b      	ldrh	r3, [r3, #0]
 800c9ee:	b29a      	uxth	r2, r3
 800c9f0:	4b44      	ldr	r3, [pc, #272]	; (800cb04 <handle_req_recv+0x158>)
 800c9f2:	805a      	strh	r2, [r3, #2]
        SE3_GET16(comm.req_hdr, SE3_REQ_OFFSET_LEN, req_hdr.len);
 800c9f4:	4b42      	ldr	r3, [pc, #264]	; (800cb00 <handle_req_recv+0x154>)
 800c9f6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c9f8:	3304      	adds	r3, #4
 800c9fa:	881b      	ldrh	r3, [r3, #0]
 800c9fc:	b29a      	uxth	r2, r3
 800c9fe:	4b41      	ldr	r3, [pc, #260]	; (800cb04 <handle_req_recv+0x158>)
 800ca00:	809a      	strh	r2, [r3, #4]
        SE3_GET32(comm.req_hdr, SE3_REQ_OFFSET_CMDTOKEN, req_hdr.cmdtok[0]);
 800ca02:	4b3f      	ldr	r3, [pc, #252]	; (800cb00 <handle_req_recv+0x154>)
 800ca04:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800ca06:	3306      	adds	r3, #6
 800ca08:	681b      	ldr	r3, [r3, #0]
 800ca0a:	461a      	mov	r2, r3
 800ca0c:	4b3d      	ldr	r3, [pc, #244]	; (800cb04 <handle_req_recv+0x158>)
 800ca0e:	609a      	str	r2, [r3, #8]
#if SE3_CONF_CRC
		SE3_GET16(comm.req_hdr, SE3_REQ_OFFSET_CRC, req_hdr.crc);
#endif
        // read data
        memcpy(comm.req_data, blockdata + SE3_REQ_SIZE_HEADER, SE3_COMM_BLOCK - SE3_REQ_SIZE_HEADER);
 800ca10:	4b3b      	ldr	r3, [pc, #236]	; (800cb00 <handle_req_recv+0x154>)
 800ca12:	6d58      	ldr	r0, [r3, #84]	; 0x54
 800ca14:	683b      	ldr	r3, [r7, #0]
 800ca16:	3310      	adds	r3, #16
 800ca18:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
 800ca1c:	4619      	mov	r1, r3
 800ca1e:	f00e fac2 	bl	801afa6 <memcpy>

        nblocks = req_hdr.len / SE3_COMM_BLOCK;
 800ca22:	4b38      	ldr	r3, [pc, #224]	; (800cb04 <handle_req_recv+0x158>)
 800ca24:	889b      	ldrh	r3, [r3, #4]
 800ca26:	0a5b      	lsrs	r3, r3, #9
 800ca28:	81fb      	strh	r3, [r7, #14]
        if (req_hdr.len%SE3_COMM_BLOCK != 0) {
 800ca2a:	4b36      	ldr	r3, [pc, #216]	; (800cb04 <handle_req_recv+0x158>)
 800ca2c:	889b      	ldrh	r3, [r3, #4]
 800ca2e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800ca32:	b29b      	uxth	r3, r3
 800ca34:	2b00      	cmp	r3, #0
 800ca36:	d002      	beq.n	800ca3e <handle_req_recv+0x92>
            nblocks++;
 800ca38:	89fb      	ldrh	r3, [r7, #14]
 800ca3a:	3301      	adds	r3, #1
 800ca3c:	81fb      	strh	r3, [r7, #14]
        }
        if (nblocks > SE3_COMM_N - 1) {
 800ca3e:	89fb      	ldrh	r3, [r7, #14]
 800ca40:	2b0f      	cmp	r3, #15
 800ca42:	d90a      	bls.n	800ca5a <handle_req_recv+0xae>
            resp_hdr.status = SE3_ERR_COMM;
 800ca44:	4b30      	ldr	r3, [pc, #192]	; (800cb08 <handle_req_recv+0x15c>)
 800ca46:	f24f 0202 	movw	r2, #61442	; 0xf002
 800ca4a:	805a      	strh	r2, [r3, #2]
            comm.req_bmap = 0;
 800ca4c:	4b2c      	ldr	r3, [pc, #176]	; (800cb00 <handle_req_recv+0x154>)
 800ca4e:	2200      	movs	r2, #0
 800ca50:	651a      	str	r2, [r3, #80]	; 0x50
            comm.resp_ready = true;
 800ca52:	4b2b      	ldr	r3, [pc, #172]	; (800cb00 <handle_req_recv+0x154>)
 800ca54:	2201      	movs	r2, #1
 800ca56:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
        }
        // update bit map
        comm.req_bmap &= SE3_BMAP_MAKE(nblocks);
 800ca5a:	4b29      	ldr	r3, [pc, #164]	; (800cb00 <handle_req_recv+0x154>)
 800ca5c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ca5e:	89fb      	ldrh	r3, [r7, #14]
 800ca60:	f1c3 0320 	rsb	r3, r3, #32
 800ca64:	f04f 31ff 	mov.w	r1, #4294967295
 800ca68:	fa21 f303 	lsr.w	r3, r1, r3
 800ca6c:	4013      	ands	r3, r2
 800ca6e:	4a24      	ldr	r2, [pc, #144]	; (800cb00 <handle_req_recv+0x154>)
 800ca70:	6513      	str	r3, [r2, #80]	; 0x50
        SE3_BIT_CLEAR(comm.req_bmap, 0);
 800ca72:	4b23      	ldr	r3, [pc, #140]	; (800cb00 <handle_req_recv+0x154>)
 800ca74:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ca76:	f023 0301 	bic.w	r3, r3, #1
 800ca7a:	4a21      	ldr	r2, [pc, #132]	; (800cb00 <handle_req_recv+0x154>)
 800ca7c:	6513      	str	r3, [r2, #80]	; 0x50
 800ca7e:	e02b      	b.n	800cad8 <handle_req_recv+0x12c>
    }
    else {
        // REQDATA block
        // read header
        SE3_GET32(blockdata, SE3_REQDATA_OFFSET_CMDTOKEN, req_hdr.cmdtok[index]);
 800ca80:	687b      	ldr	r3, [r7, #4]
 800ca82:	3302      	adds	r3, #2
 800ca84:	009b      	lsls	r3, r3, #2
 800ca86:	4a1f      	ldr	r2, [pc, #124]	; (800cb04 <handle_req_recv+0x158>)
 800ca88:	4413      	add	r3, r2
 800ca8a:	683a      	ldr	r2, [r7, #0]
 800ca8c:	6812      	ldr	r2, [r2, #0]
 800ca8e:	601a      	str	r2, [r3, #0]
        // read data
        memcpy(
            comm.req_data + 1 * (SE3_COMM_BLOCK - SE3_REQ_SIZE_HEADER) + (index - 1)*(SE3_COMM_BLOCK - SE3_REQDATA_SIZE_HEADER),
 800ca90:	4b1b      	ldr	r3, [pc, #108]	; (800cb00 <handle_req_recv+0x154>)
 800ca92:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800ca94:	687b      	ldr	r3, [r7, #4]
 800ca96:	1e5a      	subs	r2, r3, #1
 800ca98:	4613      	mov	r3, r2
 800ca9a:	01db      	lsls	r3, r3, #7
 800ca9c:	1a9b      	subs	r3, r3, r2
 800ca9e:	009b      	lsls	r3, r3, #2
 800caa0:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 800caa4:	18c8      	adds	r0, r1, r3
            blockdata + SE3_REQDATA_SIZE_HEADER,
 800caa6:	683b      	ldr	r3, [r7, #0]
 800caa8:	3304      	adds	r3, #4
        memcpy(
 800caaa:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
 800caae:	4619      	mov	r1, r3
 800cab0:	f00e fa79 	bl	801afa6 <memcpy>
            SE3_COMM_BLOCK - SE3_REQDATA_SIZE_HEADER);
        SE3_GET32(blockdata, 0, req_hdr.cmdtok[index]);
 800cab4:	687b      	ldr	r3, [r7, #4]
 800cab6:	3302      	adds	r3, #2
 800cab8:	009b      	lsls	r3, r3, #2
 800caba:	4a12      	ldr	r2, [pc, #72]	; (800cb04 <handle_req_recv+0x158>)
 800cabc:	4413      	add	r3, r2
 800cabe:	683a      	ldr	r2, [r7, #0]
 800cac0:	6812      	ldr	r2, [r2, #0]
 800cac2:	601a      	str	r2, [r3, #0]
        // update bit map
        SE3_BIT_CLEAR(comm.req_bmap, index);
 800cac4:	4b0e      	ldr	r3, [pc, #56]	; (800cb00 <handle_req_recv+0x154>)
 800cac6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800cac8:	2101      	movs	r1, #1
 800caca:	687a      	ldr	r2, [r7, #4]
 800cacc:	fa01 f202 	lsl.w	r2, r1, r2
 800cad0:	43d2      	mvns	r2, r2
 800cad2:	4013      	ands	r3, r2
 800cad4:	4a0a      	ldr	r2, [pc, #40]	; (800cb00 <handle_req_recv+0x154>)
 800cad6:	6513      	str	r3, [r2, #80]	; 0x50
    }

    if (comm.req_bmap == 0) {
 800cad8:	4b09      	ldr	r3, [pc, #36]	; (800cb00 <handle_req_recv+0x154>)
 800cada:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800cadc:	2b00      	cmp	r3, #0
 800cade:	d10c      	bne.n	800cafa <handle_req_recv+0x14e>
        comm.req_ready = true;
 800cae0:	4b07      	ldr	r3, [pc, #28]	; (800cb00 <handle_req_recv+0x154>)
 800cae2:	2201      	movs	r2, #1
 800cae4:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
        comm.req_bmap = SE3_BMAP_MAKE(32);
 800cae8:	4b05      	ldr	r3, [pc, #20]	; (800cb00 <handle_req_recv+0x154>)
 800caea:	f04f 32ff 	mov.w	r2, #4294967295
 800caee:	651a      	str	r2, [r3, #80]	; 0x50
        comm.block_guess = 0;
 800caf0:	4b03      	ldr	r3, [pc, #12]	; (800cb00 <handle_req_recv+0x154>)
 800caf2:	2200      	movs	r2, #0
 800caf4:	649a      	str	r2, [r3, #72]	; 0x48
 800caf6:	e000      	b.n	800cafa <handle_req_recv+0x14e>
        return;
 800caf8:	bf00      	nop
    }
}
 800cafa:	3710      	adds	r7, #16
 800cafc:	46bd      	mov	sp, r7
 800cafe:	bd80      	pop	{r7, pc}
 800cb00:	20004638 	.word	0x20004638
 800cb04:	200045f4 	.word	0x200045f4
 800cb08:	200005b0 	.word	0x200005b0

0800cb0c <se3_proto_recv>:
  *	driver; it forwards the data on the SD card if the data block does not
  *	 contain the magic sequence, otherwise the data block is unpacked for further
  *	 elaborations;
  */
int32_t se3_proto_recv(uint8_t lun, const uint8_t* buf, uint32_t blk_addr, uint16_t blk_len)
{
 800cb0c:	b580      	push	{r7, lr}
 800cb0e:	b08e      	sub	sp, #56	; 0x38
 800cb10:	af02      	add	r7, sp, #8
 800cb12:	60b9      	str	r1, [r7, #8]
 800cb14:	607a      	str	r2, [r7, #4]
 800cb16:	461a      	mov	r2, r3
 800cb18:	4603      	mov	r3, r0
 800cb1a:	73fb      	strb	r3, [r7, #15]
 800cb1c:	4613      	mov	r3, r2
 800cb1e:	81bb      	strh	r3, [r7, #12]
	int32_t r = SE3_PROTO_OK;
 800cb20:	2300      	movs	r3, #0
 800cb22:	623b      	str	r3, [r7, #32]
	uint32_t block;
	int index;
	const uint8_t* data = buf;
 800cb24:	68bb      	ldr	r3, [r7, #8]
 800cb26:	627b      	str	r3, [r7, #36]	; 0x24
    //uint16_t u16tmp;

	s3_storage_range range = {
 800cb28:	f107 0314 	add.w	r3, r7, #20
 800cb2c:	2200      	movs	r2, #0
 800cb2e:	601a      	str	r2, [r3, #0]
 800cb30:	605a      	str	r2, [r3, #4]
 800cb32:	609a      	str	r2, [r3, #8]
		.first = 0,
		.count = 0
	};
	
	for (block = blk_addr; block < blk_addr + blk_len; block++) {
 800cb34:	687b      	ldr	r3, [r7, #4]
 800cb36:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cb38:	e095      	b.n	800cc66 <se3_proto_recv+0x15a>
		if (block == 0) {
 800cb3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb3c:	2b00      	cmp	r3, #0
 800cb3e:	d10e      	bne.n	800cb5e <se3_proto_recv+0x52>
			r = se3_storage_range_add(&range, lun, (uint8_t*)data, block, range_write);
 800cb40:	7bf9      	ldrb	r1, [r7, #15]
 800cb42:	f107 0014 	add.w	r0, r7, #20
 800cb46:	2300      	movs	r3, #0
 800cb48:	9300      	str	r3, [sp, #0]
 800cb4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cb4c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cb4e:	f7ff fedf 	bl	800c910 <se3_storage_range_add>
 800cb52:	6238      	str	r0, [r7, #32]
			if (SE3_PROTO_OK != r) return r;
 800cb54:	6a3b      	ldr	r3, [r7, #32]
 800cb56:	2b00      	cmp	r3, #0
 800cb58:	d07a      	beq.n	800cc50 <se3_proto_recv+0x144>
 800cb5a:	6a3b      	ldr	r3, [r7, #32]
 800cb5c:	e095      	b.n	800cc8a <se3_proto_recv+0x17e>
		}
		else {
            if (block_is_magic(data)) {
 800cb5e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800cb60:	f7ff fe72 	bl	800c848 <block_is_magic>
 800cb64:	4603      	mov	r3, r0
 800cb66:	2b00      	cmp	r3, #0
 800cb68:	d03b      	beq.n	800cbe2 <se3_proto_recv+0xd6>
                // magic block
                if (comm.locked) {
 800cb6a:	4b4a      	ldr	r3, [pc, #296]	; (800cc94 <se3_proto_recv+0x188>)
 800cb6c:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800cb70:	2b00      	cmp	r3, #0
 800cb72:	d172      	bne.n	800cc5a <se3_proto_recv+0x14e>
                    // if locked, prevent initialization
                    continue;
                }
                if (comm.magic_ready) {
 800cb74:	4b47      	ldr	r3, [pc, #284]	; (800cc94 <se3_proto_recv+0x188>)
 800cb76:	781b      	ldrb	r3, [r3, #0]
 800cb78:	2b00      	cmp	r3, #0
 800cb7a:	d015      	beq.n	800cba8 <se3_proto_recv+0x9c>
                    // if magic already initialized, reset
                    comm.magic_ready = false;
 800cb7c:	4b45      	ldr	r3, [pc, #276]	; (800cc94 <se3_proto_recv+0x188>)
 800cb7e:	2200      	movs	r2, #0
 800cb80:	701a      	strb	r2, [r3, #0]
                    comm.magic_bmap = SE3_BMAP_MAKE(16);
 800cb82:	4b44      	ldr	r3, [pc, #272]	; (800cc94 <se3_proto_recv+0x188>)
 800cb84:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800cb88:	605a      	str	r2, [r3, #4]
                    for (index = 0; index < 16; index++)
 800cb8a:	2300      	movs	r3, #0
 800cb8c:	62bb      	str	r3, [r7, #40]	; 0x28
 800cb8e:	e008      	b.n	800cba2 <se3_proto_recv+0x96>
                        comm.blocks[index] = 0;
 800cb90:	4a40      	ldr	r2, [pc, #256]	; (800cc94 <se3_proto_recv+0x188>)
 800cb92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cb94:	3302      	adds	r3, #2
 800cb96:	2100      	movs	r1, #0
 800cb98:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    for (index = 0; index < 16; index++)
 800cb9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cb9e:	3301      	adds	r3, #1
 800cba0:	62bb      	str	r3, [r7, #40]	; 0x28
 800cba2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cba4:	2b0f      	cmp	r3, #15
 800cba6:	ddf3      	ble.n	800cb90 <se3_proto_recv+0x84>
                }
                // store block in blocks map
                index = data[SE3_COMM_BLOCK - 1];
 800cba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cbaa:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800cbae:	781b      	ldrb	r3, [r3, #0]
 800cbb0:	62bb      	str	r3, [r7, #40]	; 0x28
                comm.blocks[index] = block;
 800cbb2:	4938      	ldr	r1, [pc, #224]	; (800cc94 <se3_proto_recv+0x188>)
 800cbb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cbb6:	3302      	adds	r3, #2
 800cbb8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cbba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                SE3_BIT_CLEAR(comm.magic_bmap, index);
 800cbbe:	4b35      	ldr	r3, [pc, #212]	; (800cc94 <se3_proto_recv+0x188>)
 800cbc0:	685b      	ldr	r3, [r3, #4]
 800cbc2:	2101      	movs	r1, #1
 800cbc4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cbc6:	fa01 f202 	lsl.w	r2, r1, r2
 800cbca:	43d2      	mvns	r2, r2
 800cbcc:	4013      	ands	r3, r2
 800cbce:	4a31      	ldr	r2, [pc, #196]	; (800cc94 <se3_proto_recv+0x188>)
 800cbd0:	6053      	str	r3, [r2, #4]
                if (comm.magic_bmap == 0) {
 800cbd2:	4b30      	ldr	r3, [pc, #192]	; (800cc94 <se3_proto_recv+0x188>)
 800cbd4:	685b      	ldr	r3, [r3, #4]
 800cbd6:	2b00      	cmp	r3, #0
 800cbd8:	d13a      	bne.n	800cc50 <se3_proto_recv+0x144>
                    comm.magic_ready = true;
 800cbda:	4b2e      	ldr	r3, [pc, #184]	; (800cc94 <se3_proto_recv+0x188>)
 800cbdc:	2201      	movs	r2, #1
 800cbde:	701a      	strb	r2, [r3, #0]
 800cbe0:	e036      	b.n	800cc50 <se3_proto_recv+0x144>
                }
            }
            else{
                // not a magic block
                if (!comm.magic_ready) {
 800cbe2:	4b2c      	ldr	r3, [pc, #176]	; (800cc94 <se3_proto_recv+0x188>)
 800cbe4:	781b      	ldrb	r3, [r3, #0]
 800cbe6:	f083 0301 	eor.w	r3, r3, #1
 800cbea:	b2db      	uxtb	r3, r3
 800cbec:	2b00      	cmp	r3, #0
 800cbee:	d00e      	beq.n	800cc0e <se3_proto_recv+0x102>
                    // magic file has not been written yet. forward
                    r = se3_storage_range_add(&range, lun, (uint8_t*)data, block, range_write);
 800cbf0:	7bf9      	ldrb	r1, [r7, #15]
 800cbf2:	f107 0014 	add.w	r0, r7, #20
 800cbf6:	2300      	movs	r3, #0
 800cbf8:	9300      	str	r3, [sp, #0]
 800cbfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cbfc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cbfe:	f7ff fe87 	bl	800c910 <se3_storage_range_add>
 800cc02:	6238      	str	r0, [r7, #32]
                    if (SE3_PROTO_OK != r) return r;
 800cc04:	6a3b      	ldr	r3, [r7, #32]
 800cc06:	2b00      	cmp	r3, #0
 800cc08:	d022      	beq.n	800cc50 <se3_proto_recv+0x144>
 800cc0a:	6a3b      	ldr	r3, [r7, #32]
 800cc0c:	e03d      	b.n	800cc8a <se3_proto_recv+0x17e>
                }
                else {
                    // magic file has been written. may be a command
                    index = find_magic_index(block);
 800cc0e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800cc10:	f7ff fe48 	bl	800c8a4 <find_magic_index>
 800cc14:	62b8      	str	r0, [r7, #40]	; 0x28
                    if (index == -1) {
 800cc16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc18:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cc1c:	d10e      	bne.n	800cc3c <se3_proto_recv+0x130>
                        // block is not a request. forward
                        r = se3_storage_range_add(&range, lun, (uint8_t*)data, block, range_write);
 800cc1e:	7bf9      	ldrb	r1, [r7, #15]
 800cc20:	f107 0014 	add.w	r0, r7, #20
 800cc24:	2300      	movs	r3, #0
 800cc26:	9300      	str	r3, [sp, #0]
 800cc28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cc2a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cc2c:	f7ff fe70 	bl	800c910 <se3_storage_range_add>
 800cc30:	6238      	str	r0, [r7, #32]
                        if (SE3_PROTO_OK != r) return r;
 800cc32:	6a3b      	ldr	r3, [r7, #32]
 800cc34:	2b00      	cmp	r3, #0
 800cc36:	d00b      	beq.n	800cc50 <se3_proto_recv+0x144>
 800cc38:	6a3b      	ldr	r3, [r7, #32]
 800cc3a:	e026      	b.n	800cc8a <se3_proto_recv+0x17e>
                    }
                    else {
                        // block is a request
                        if (comm.req_ready) {
 800cc3c:	4b15      	ldr	r3, [pc, #84]	; (800cc94 <se3_proto_recv+0x188>)
 800cc3e:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 800cc42:	b2db      	uxtb	r3, r3
 800cc44:	2b00      	cmp	r3, #0
 800cc46:	d10a      	bne.n	800cc5e <se3_proto_recv+0x152>
                            // already processing request. ignore
                            SE3_TRACE(("P W%02u request already fully received", (unsigned)index));
                            continue;
                        }
                        else {
                            handle_req_recv(index, data);
 800cc48:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800cc4a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800cc4c:	f7ff feae 	bl	800c9ac <handle_req_recv>
                        }
                    }
                }
            }
		}
		data += SE3_COMM_BLOCK;
 800cc50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc52:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800cc56:	627b      	str	r3, [r7, #36]	; 0x24
 800cc58:	e002      	b.n	800cc60 <se3_proto_recv+0x154>
                    continue;
 800cc5a:	bf00      	nop
 800cc5c:	e000      	b.n	800cc60 <se3_proto_recv+0x154>
                            continue;
 800cc5e:	bf00      	nop
	for (block = blk_addr; block < blk_addr + blk_len; block++) {
 800cc60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cc62:	3301      	adds	r3, #1
 800cc64:	62fb      	str	r3, [r7, #44]	; 0x2c
 800cc66:	89ba      	ldrh	r2, [r7, #12]
 800cc68:	687b      	ldr	r3, [r7, #4]
 800cc6a:	4413      	add	r3, r2
 800cc6c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cc6e:	429a      	cmp	r2, r3
 800cc70:	f4ff af63 	bcc.w	800cb3a <se3_proto_recv+0x2e>
	}

	//flush any remaining block
	return se3_storage_range_add(&range, lun, NULL, 0xFFFFFFFF, range_write);
 800cc74:	7bf9      	ldrb	r1, [r7, #15]
 800cc76:	f107 0014 	add.w	r0, r7, #20
 800cc7a:	2300      	movs	r3, #0
 800cc7c:	9300      	str	r3, [sp, #0]
 800cc7e:	f04f 33ff 	mov.w	r3, #4294967295
 800cc82:	2200      	movs	r2, #0
 800cc84:	f7ff fe44 	bl	800c910 <se3_storage_range_add>
 800cc88:	4603      	mov	r3, r0
}
 800cc8a:	4618      	mov	r0, r3
 800cc8c:	3730      	adds	r7, #48	; 0x30
 800cc8e:	46bd      	mov	sp, r7
 800cc90:	bd80      	pop	{r7, pc}
 800cc92:	bf00      	nop
 800cc94:	20004638 	.word	0x20004638

0800cc98 <handle_resp_send>:
 *  Output a single block of a protocol response. If the response is ready,
 *    the data is taken from the response buffer. Otherwise the 'not ready' state is
 *    returned.
 */
static void handle_resp_send(int index, uint8_t* blockdata)
{
 800cc98:	b5b0      	push	{r4, r5, r7, lr}
 800cc9a:	b084      	sub	sp, #16
 800cc9c:	af00      	add	r7, sp, #0
 800cc9e:	6078      	str	r0, [r7, #4]
 800cca0:	6039      	str	r1, [r7, #0]
    uint16_t u16tmp;
    
    if (index == SE3_COMM_N - 1) {
 800cca2:	687b      	ldr	r3, [r7, #4]
 800cca4:	2b0f      	cmp	r3, #15
 800cca6:	d138      	bne.n	800cd1a <handle_resp_send+0x82>
        // discover
        memcpy(blockdata + SE3_DISCO_OFFSET_MAGIC, se3_magic + SE3_MAGIC_SIZE / 2, SE3_MAGIC_SIZE / 2);
 800cca8:	4b50      	ldr	r3, [pc, #320]	; (800cdec <handle_resp_send+0x154>)
 800ccaa:	2210      	movs	r2, #16
 800ccac:	4619      	mov	r1, r3
 800ccae:	6838      	ldr	r0, [r7, #0]
 800ccb0:	f00e f979 	bl	801afa6 <memcpy>
        memcpy(blockdata + SE3_DISCO_OFFSET_MAGIC + SE3_MAGIC_SIZE / 2, se3_magic, SE3_MAGIC_SIZE / 2);
 800ccb4:	683b      	ldr	r3, [r7, #0]
 800ccb6:	3310      	adds	r3, #16
 800ccb8:	2210      	movs	r2, #16
 800ccba:	494d      	ldr	r1, [pc, #308]	; (800cdf0 <handle_resp_send+0x158>)
 800ccbc:	4618      	mov	r0, r3
 800ccbe:	f00e f972 	bl	801afa6 <memcpy>
        memcpy(blockdata + SE3_DISCO_OFFSET_SERIAL, serial.data, SE3_SERIAL_SIZE);
 800ccc2:	683b      	ldr	r3, [r7, #0]
 800ccc4:	3320      	adds	r3, #32
 800ccc6:	4a4b      	ldr	r2, [pc, #300]	; (800cdf4 <handle_resp_send+0x15c>)
 800ccc8:	6815      	ldr	r5, [r2, #0]
 800ccca:	6854      	ldr	r4, [r2, #4]
 800cccc:	6890      	ldr	r0, [r2, #8]
 800ccce:	68d1      	ldr	r1, [r2, #12]
 800ccd0:	601d      	str	r5, [r3, #0]
 800ccd2:	605c      	str	r4, [r3, #4]
 800ccd4:	6098      	str	r0, [r3, #8]
 800ccd6:	60d9      	str	r1, [r3, #12]
 800ccd8:	6915      	ldr	r5, [r2, #16]
 800ccda:	6954      	ldr	r4, [r2, #20]
 800ccdc:	6990      	ldr	r0, [r2, #24]
 800ccde:	69d1      	ldr	r1, [r2, #28]
 800cce0:	611d      	str	r5, [r3, #16]
 800cce2:	615c      	str	r4, [r3, #20]
 800cce4:	6198      	str	r0, [r3, #24]
 800cce6:	61d9      	str	r1, [r3, #28]
        memcpy(blockdata + SE3_DISCO_OFFSET_HELLO, se3_hello, SE3_HELLO_SIZE);
 800cce8:	683b      	ldr	r3, [r7, #0]
 800ccea:	3340      	adds	r3, #64	; 0x40
 800ccec:	4a42      	ldr	r2, [pc, #264]	; (800cdf8 <handle_resp_send+0x160>)
 800ccee:	461c      	mov	r4, r3
 800ccf0:	4615      	mov	r5, r2
 800ccf2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ccf4:	6020      	str	r0, [r4, #0]
 800ccf6:	6061      	str	r1, [r4, #4]
 800ccf8:	60a2      	str	r2, [r4, #8]
 800ccfa:	60e3      	str	r3, [r4, #12]
 800ccfc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ccfe:	6120      	str	r0, [r4, #16]
 800cd00:	6161      	str	r1, [r4, #20]
 800cd02:	61a2      	str	r2, [r4, #24]
 800cd04:	61e3      	str	r3, [r4, #28]
        u16tmp = (comm.locked) ? (1) : (0);
 800cd06:	4b3d      	ldr	r3, [pc, #244]	; (800cdfc <handle_resp_send+0x164>)
 800cd08:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 800cd0c:	b29b      	uxth	r3, r3
 800cd0e:	81fb      	strh	r3, [r7, #14]
        SE3_SET16(blockdata, SE3_DISCO_OFFSET_STATUS, u16tmp);
 800cd10:	683b      	ldr	r3, [r7, #0]
 800cd12:	3360      	adds	r3, #96	; 0x60
 800cd14:	89fa      	ldrh	r2, [r7, #14]
 800cd16:	801a      	strh	r2, [r3, #0]
        else {
            // response not ready
            memset(blockdata, SE3_RESP_OFFSET_READY, sizeof(uint16_t));
        }
    }
}
 800cd18:	e063      	b.n	800cde2 <handle_resp_send+0x14a>
        if (comm.resp_ready) {
 800cd1a:	4b38      	ldr	r3, [pc, #224]	; (800cdfc <handle_resp_send+0x164>)
 800cd1c:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800cd20:	b2db      	uxtb	r3, r3
 800cd22:	2b00      	cmp	r3, #0
 800cd24:	d058      	beq.n	800cdd8 <handle_resp_send+0x140>
            if (SE3_BIT_TEST(comm.resp_bmap, index)) {
 800cd26:	4b35      	ldr	r3, [pc, #212]	; (800cdfc <handle_resp_send+0x164>)
 800cd28:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800cd2a:	2101      	movs	r1, #1
 800cd2c:	687a      	ldr	r2, [r7, #4]
 800cd2e:	fa01 f202 	lsl.w	r2, r1, r2
 800cd32:	4013      	ands	r3, r2
 800cd34:	2b00      	cmp	r3, #0
 800cd36:	d048      	beq.n	800cdca <handle_resp_send+0x132>
                if (index == 0) {
 800cd38:	687b      	ldr	r3, [r7, #4]
 800cd3a:	2b00      	cmp	r3, #0
 800cd3c:	d129      	bne.n	800cd92 <handle_resp_send+0xfa>
                    u16tmp = 1;
 800cd3e:	2301      	movs	r3, #1
 800cd40:	81fb      	strh	r3, [r7, #14]
                    SE3_SET16(comm.resp_hdr, SE3_RESP_OFFSET_READY, u16tmp);
 800cd42:	4b2e      	ldr	r3, [pc, #184]	; (800cdfc <handle_resp_send+0x164>)
 800cd44:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cd46:	89fa      	ldrh	r2, [r7, #14]
 800cd48:	801a      	strh	r2, [r3, #0]
                    SE3_SET16(comm.resp_hdr, SE3_RESP_OFFSET_STATUS, resp_hdr.status);
 800cd4a:	4b2c      	ldr	r3, [pc, #176]	; (800cdfc <handle_resp_send+0x164>)
 800cd4c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cd4e:	3302      	adds	r3, #2
 800cd50:	4a2b      	ldr	r2, [pc, #172]	; (800ce00 <handle_resp_send+0x168>)
 800cd52:	8852      	ldrh	r2, [r2, #2]
 800cd54:	801a      	strh	r2, [r3, #0]
                    SE3_SET16(comm.resp_hdr, SE3_RESP_OFFSET_LEN, resp_hdr.len);
 800cd56:	4b29      	ldr	r3, [pc, #164]	; (800cdfc <handle_resp_send+0x164>)
 800cd58:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cd5a:	3304      	adds	r3, #4
 800cd5c:	4a28      	ldr	r2, [pc, #160]	; (800ce00 <handle_resp_send+0x168>)
 800cd5e:	8892      	ldrh	r2, [r2, #4]
 800cd60:	801a      	strh	r2, [r3, #0]
                    SE3_SET32(comm.resp_hdr, SE3_RESP_OFFSET_CMDTOKEN, resp_hdr.cmdtok[0]);
 800cd62:	4b26      	ldr	r3, [pc, #152]	; (800cdfc <handle_resp_send+0x164>)
 800cd64:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cd66:	3306      	adds	r3, #6
 800cd68:	4a25      	ldr	r2, [pc, #148]	; (800ce00 <handle_resp_send+0x168>)
 800cd6a:	6892      	ldr	r2, [r2, #8]
 800cd6c:	601a      	str	r2, [r3, #0]
                    memcpy(blockdata, comm.resp_hdr, SE3_RESP_SIZE_HEADER);
 800cd6e:	4b23      	ldr	r3, [pc, #140]	; (800cdfc <handle_resp_send+0x164>)
 800cd70:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800cd72:	2210      	movs	r2, #16
 800cd74:	4619      	mov	r1, r3
 800cd76:	6838      	ldr	r0, [r7, #0]
 800cd78:	f00e f915 	bl	801afa6 <memcpy>
                    memcpy(blockdata + SE3_RESP_SIZE_HEADER, comm.resp_data, SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER);
 800cd7c:	683b      	ldr	r3, [r7, #0]
 800cd7e:	f103 0010 	add.w	r0, r3, #16
 800cd82:	4b1e      	ldr	r3, [pc, #120]	; (800cdfc <handle_resp_send+0x164>)
 800cd84:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800cd86:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
 800cd8a:	4619      	mov	r1, r3
 800cd8c:	f00e f90b 	bl	801afa6 <memcpy>
}
 800cd90:	e027      	b.n	800cde2 <handle_resp_send+0x14a>
                    SE3_SET32(blockdata, SE3_RESPDATA_OFFSET_CMDTOKEN, resp_hdr.cmdtok[index]);
 800cd92:	687b      	ldr	r3, [r7, #4]
 800cd94:	3302      	adds	r3, #2
 800cd96:	009b      	lsls	r3, r3, #2
 800cd98:	4a19      	ldr	r2, [pc, #100]	; (800ce00 <handle_resp_send+0x168>)
 800cd9a:	4413      	add	r3, r2
 800cd9c:	681b      	ldr	r3, [r3, #0]
 800cd9e:	461a      	mov	r2, r3
 800cda0:	683b      	ldr	r3, [r7, #0]
 800cda2:	601a      	str	r2, [r3, #0]
                        blockdata + SE3_RESPDATA_SIZE_HEADER,
 800cda4:	683b      	ldr	r3, [r7, #0]
 800cda6:	1d18      	adds	r0, r3, #4
                        comm.resp_data + 1 * (SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER) + (index - 1)*(SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER),
 800cda8:	4b14      	ldr	r3, [pc, #80]	; (800cdfc <handle_resp_send+0x164>)
 800cdaa:	6e59      	ldr	r1, [r3, #100]	; 0x64
 800cdac:	687b      	ldr	r3, [r7, #4]
 800cdae:	1e5a      	subs	r2, r3, #1
 800cdb0:	4613      	mov	r3, r2
 800cdb2:	01db      	lsls	r3, r3, #7
 800cdb4:	1a9b      	subs	r3, r3, r2
 800cdb6:	009b      	lsls	r3, r3, #2
 800cdb8:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 800cdbc:	440b      	add	r3, r1
                    memcpy(
 800cdbe:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
 800cdc2:	4619      	mov	r1, r3
 800cdc4:	f00e f8ef 	bl	801afa6 <memcpy>
}
 800cdc8:	e00b      	b.n	800cde2 <handle_resp_send+0x14a>
                memset(blockdata, 0, SE3_COMM_BLOCK);
 800cdca:	f44f 7200 	mov.w	r2, #512	; 0x200
 800cdce:	2100      	movs	r1, #0
 800cdd0:	6838      	ldr	r0, [r7, #0]
 800cdd2:	f00e f90c 	bl	801afee <memset>
}
 800cdd6:	e004      	b.n	800cde2 <handle_resp_send+0x14a>
            memset(blockdata, SE3_RESP_OFFSET_READY, sizeof(uint16_t));
 800cdd8:	2202      	movs	r2, #2
 800cdda:	2100      	movs	r1, #0
 800cddc:	6838      	ldr	r0, [r7, #0]
 800cdde:	f00e f906 	bl	801afee <memset>
}
 800cde2:	bf00      	nop
 800cde4:	3710      	adds	r7, #16
 800cde6:	46bd      	mov	sp, r7
 800cde8:	bdb0      	pop	{r4, r5, r7, pc}
 800cdea:	bf00      	nop
 800cdec:	0801e038 	.word	0x0801e038
 800cdf0:	0801e028 	.word	0x0801e028
 800cdf4:	200004a4 	.word	0x200004a4
 800cdf8:	0801e128 	.word	0x0801e128
 800cdfc:	20004638 	.word	0x20004638
 800ce00:	200005b0 	.word	0x200005b0

0800ce04 <se3_proto_send>:
/*	User-written USB interface that implements the read operation of the
 * 	driver; it sends the data on the SD card if the data block does not
 *	contain the magic sequence, otherwise it handles the proto request.
 */
int32_t se3_proto_send(uint8_t lun, uint8_t* buf, uint32_t blk_addr, uint16_t blk_len)
{
 800ce04:	b580      	push	{r7, lr}
 800ce06:	b08e      	sub	sp, #56	; 0x38
 800ce08:	af02      	add	r7, sp, #8
 800ce0a:	60b9      	str	r1, [r7, #8]
 800ce0c:	607a      	str	r2, [r7, #4]
 800ce0e:	461a      	mov	r2, r3
 800ce10:	4603      	mov	r3, r0
 800ce12:	73fb      	strb	r3, [r7, #15]
 800ce14:	4613      	mov	r3, r2
 800ce16:	81bb      	strh	r3, [r7, #12]
	int32_t r = SE3_PROTO_OK;
 800ce18:	2300      	movs	r3, #0
 800ce1a:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint32_t block;
	int index;
	uint8_t* data = buf;
 800ce1c:	68bb      	ldr	r3, [r7, #8]
 800ce1e:	627b      	str	r3, [r7, #36]	; 0x24
	s3_storage_range range = {
 800ce20:	f107 0314 	add.w	r3, r7, #20
 800ce24:	2200      	movs	r2, #0
 800ce26:	601a      	str	r2, [r3, #0]
 800ce28:	605a      	str	r2, [r3, #4]
 800ce2a:	609a      	str	r2, [r3, #8]
		.first = 0,
		.count = 0
	};

	for (block = blk_addr; block < blk_addr + blk_len; block++) {
 800ce2c:	687b      	ldr	r3, [r7, #4]
 800ce2e:	62bb      	str	r3, [r7, #40]	; 0x28
 800ce30:	e031      	b.n	800ce96 <se3_proto_send+0x92>
		if(block==0) {
 800ce32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce34:	2b00      	cmp	r3, #0
 800ce36:	d10d      	bne.n	800ce54 <se3_proto_send+0x50>
            // forward
			if (r == SE3_PROTO_OK) r = se3_storage_range_add(&range, lun, data, block, range_read);
 800ce38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ce3a:	2b00      	cmp	r3, #0
 800ce3c:	d124      	bne.n	800ce88 <se3_proto_send+0x84>
 800ce3e:	7bf9      	ldrb	r1, [r7, #15]
 800ce40:	f107 0014 	add.w	r0, r7, #20
 800ce44:	2301      	movs	r3, #1
 800ce46:	9300      	str	r3, [sp, #0]
 800ce48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce4a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ce4c:	f7ff fd60 	bl	800c910 <se3_storage_range_add>
 800ce50:	62f8      	str	r0, [r7, #44]	; 0x2c
 800ce52:	e019      	b.n	800ce88 <se3_proto_send+0x84>
		}
		else{
			index = find_magic_index(block);
 800ce54:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800ce56:	f7ff fd25 	bl	800c8a4 <find_magic_index>
 800ce5a:	6238      	str	r0, [r7, #32]
            if (index == -1) {
 800ce5c:	6a3b      	ldr	r3, [r7, #32]
 800ce5e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ce62:	d10d      	bne.n	800ce80 <se3_proto_send+0x7c>
                // forward
                if (r == SE3_PROTO_OK) r = se3_storage_range_add(&range, lun, data, block, range_read);
 800ce64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ce66:	2b00      	cmp	r3, #0
 800ce68:	d10e      	bne.n	800ce88 <se3_proto_send+0x84>
 800ce6a:	7bf9      	ldrb	r1, [r7, #15]
 800ce6c:	f107 0014 	add.w	r0, r7, #20
 800ce70:	2301      	movs	r3, #1
 800ce72:	9300      	str	r3, [sp, #0]
 800ce74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ce78:	f7ff fd4a 	bl	800c910 <se3_storage_range_add>
 800ce7c:	62f8      	str	r0, [r7, #44]	; 0x2c
 800ce7e:	e003      	b.n	800ce88 <se3_proto_send+0x84>
            }
            else {
                handle_resp_send(index, data);
 800ce80:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800ce82:	6a38      	ldr	r0, [r7, #32]
 800ce84:	f7ff ff08 	bl	800cc98 <handle_resp_send>
            }
		}
		data += SE3_COMM_BLOCK;
 800ce88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce8a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ce8e:	627b      	str	r3, [r7, #36]	; 0x24
	for (block = blk_addr; block < blk_addr + blk_len; block++) {
 800ce90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce92:	3301      	adds	r3, #1
 800ce94:	62bb      	str	r3, [r7, #40]	; 0x28
 800ce96:	89ba      	ldrh	r2, [r7, #12]
 800ce98:	687b      	ldr	r3, [r7, #4]
 800ce9a:	4413      	add	r3, r2
 800ce9c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ce9e:	429a      	cmp	r2, r3
 800cea0:	d3c7      	bcc.n	800ce32 <se3_proto_send+0x2e>
	}

	//flush any remaining block
    if (r == SE3_PROTO_OK) r = se3_storage_range_add(&range, lun, NULL, 0xFFFFFFFF, range_read);
 800cea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cea4:	2b00      	cmp	r3, #0
 800cea6:	d10a      	bne.n	800cebe <se3_proto_send+0xba>
 800cea8:	7bf9      	ldrb	r1, [r7, #15]
 800ceaa:	f107 0014 	add.w	r0, r7, #20
 800ceae:	2301      	movs	r3, #1
 800ceb0:	9300      	str	r3, [sp, #0]
 800ceb2:	f04f 33ff 	mov.w	r3, #4294967295
 800ceb6:	2200      	movs	r2, #0
 800ceb8:	f7ff fd2a 	bl	800c910 <se3_storage_range_add>
 800cebc:	62f8      	str	r0, [r7, #44]	; 0x2c
    return r;
 800cebe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800cec0:	4618      	mov	r0, r3
 800cec2:	3730      	adds	r7, #48	; 0x30
 800cec4:	46bd      	mov	sp, r7
 800cec6:	bd80      	pop	{r7, pc}

0800cec8 <device_init>:

uint8_t se3_sessions_buf[SE3_SESSIONS_BUF];
uint8_t* se3_sessions_index[SE3_SESSIONS_MAX];

void device_init()
{
 800cec8:	b580      	push	{r7, lr}
 800ceca:	af00      	add	r7, sp, #0

	se3_communication_core_init();
 800cecc:	f7ff fc6a 	bl	800c7a4 <se3_communication_core_init>
	se3_time_init();
 800ced0:	f000 f9f2 	bl	800d2b8 <se3_time_init>
	se3_flash_init();
 800ced4:	f001 f9e6 	bl	800e2a4 <se3_flash_init>
    se3_dispatcher_init();
 800ced8:	f000 ff78 	bl	800ddcc <se3_dispatcher_init>

    //se3_create_log_file();
    //se3_write_trace(se3_debug_create_string("\n[se3_core_mio] Device Initalizations complete...\0"), debug_address++);

}
 800cedc:	bf00      	nop
 800cede:	bd80      	pop	{r7, pc}

0800cee0 <device_loop>:

void device_loop()
{
 800cee0:	b580      	push	{r7, lr}
 800cee2:	af00      	add	r7, sp, #0
	//se3_write_trace(se3_debug_create_string("\nEntering in device_loop...\0"), debug_address++);

	for (;;) {

		if (comm.req_ready) {
 800cee4:	4b0a      	ldr	r3, [pc, #40]	; (800cf10 <device_loop+0x30>)
 800cee6:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
 800ceea:	b2db      	uxtb	r3, r3
 800ceec:	2b00      	cmp	r3, #0
 800ceee:	d0f9      	beq.n	800cee4 <device_loop+0x4>
			//se3_write_trace(se3_debug_create_string("\nreq_ready == true, executing cmd...\0"), debug_address++);
			comm.resp_ready = false;
 800cef0:	4b07      	ldr	r3, [pc, #28]	; (800cf10 <device_loop+0x30>)
 800cef2:	2200      	movs	r2, #0
 800cef4:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
            se3_cmd_execute();
 800cef8:	f000 f8b2 	bl	800d060 <se3_cmd_execute>
			comm.req_ready = false;
 800cefc:	4b04      	ldr	r3, [pc, #16]	; (800cf10 <device_loop+0x30>)
 800cefe:	2200      	movs	r2, #0
 800cf00:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
			comm.resp_ready = true;
 800cf04:	4b02      	ldr	r3, [pc, #8]	; (800cf10 <device_loop+0x30>)
 800cf06:	2201      	movs	r2, #1
 800cf08:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
		if (comm.req_ready) {
 800cf0c:	e7ea      	b.n	800cee4 <device_loop+0x4>
 800cf0e:	bf00      	nop
 800cf10:	20004638 	.word	0x20004638

0800cf14 <invalid_cmd_handler>:
	}

}

static uint16_t invalid_cmd_handler(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800cf14:	b480      	push	{r7}
 800cf16:	b085      	sub	sp, #20
 800cf18:	af00      	add	r7, sp, #0
 800cf1a:	60b9      	str	r1, [r7, #8]
 800cf1c:	607a      	str	r2, [r7, #4]
 800cf1e:	603b      	str	r3, [r7, #0]
 800cf20:	4603      	mov	r3, r0
 800cf22:	81fb      	strh	r3, [r7, #14]
    return SE3_ERR_CMD;
 800cf24:	f24f 0305 	movw	r3, #61445	; 0xf005
}
 800cf28:	4618      	mov	r0, r3
 800cf2a:	3714      	adds	r7, #20
 800cf2c:	46bd      	mov	sp, r7
 800cf2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf32:	4770      	bx	lr

0800cf34 <se3_exec>:

static uint16_t se3_exec(se3_cmd_func handler)
{
 800cf34:	b590      	push	{r4, r7, lr}
 800cf36:	b087      	sub	sp, #28
 800cf38:	af00      	add	r7, sp, #0
 800cf3a:	6078      	str	r0, [r7, #4]
    uint16_t resp_size = 0, tmp;
 800cf3c:	2300      	movs	r3, #0
 800cf3e:	81fb      	strh	r3, [r7, #14]
    uint16_t status = SE3_OK;
 800cf40:	2300      	movs	r3, #0
 800cf42:	82fb      	strh	r3, [r7, #22]
    uint16_t nblocks = 0;
 800cf44:	2300      	movs	r3, #0
 800cf46:	82bb      	strh	r3, [r7, #20]
#if SE3_CONF_CRC
	uint16_t crc;
	uint16_t u16tmp;
#endif

    data_len = se3_req_len_data(req_hdr.len);
 800cf48:	4b40      	ldr	r3, [pc, #256]	; (800d04c <se3_exec+0x118>)
 800cf4a:	889b      	ldrh	r3, [r3, #4]
 800cf4c:	4618      	mov	r0, r3
 800cf4e:	f7f7 fa2f 	bl	80043b0 <se3_req_len_data>
 800cf52:	4603      	mov	r3, r0
 800cf54:	827b      	strh	r3, [r7, #18]
		status = SE3_ERR_COMM;
		resp_size = 0;
	}
#endif

	if(status == SE3_OK) {
 800cf56:	8afb      	ldrh	r3, [r7, #22]
 800cf58:	2b00      	cmp	r3, #0
 800cf5a:	d10a      	bne.n	800cf72 <se3_exec+0x3e>
		status = handler(data_len, comm.req_data, &resp_size, comm.resp_data);
 800cf5c:	4b3c      	ldr	r3, [pc, #240]	; (800d050 <se3_exec+0x11c>)
 800cf5e:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800cf60:	4b3b      	ldr	r3, [pc, #236]	; (800d050 <se3_exec+0x11c>)
 800cf62:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800cf64:	f107 020e 	add.w	r2, r7, #14
 800cf68:	8a78      	ldrh	r0, [r7, #18]
 800cf6a:	687c      	ldr	r4, [r7, #4]
 800cf6c:	47a0      	blx	r4
 800cf6e:	4603      	mov	r3, r0
 800cf70:	82fb      	strh	r3, [r7, #22]
	}

    if (hwerror) {
 800cf72:	4b38      	ldr	r3, [pc, #224]	; (800d054 <se3_exec+0x120>)
 800cf74:	881b      	ldrh	r3, [r3, #0]
 800cf76:	2b00      	cmp	r3, #0
 800cf78:	d008      	beq.n	800cf8c <se3_exec+0x58>
        status = SE3_ERR_HW;
 800cf7a:	f24f 0301 	movw	r3, #61441	; 0xf001
 800cf7e:	82fb      	strh	r3, [r7, #22]
        resp_size = 0;
 800cf80:	2300      	movs	r3, #0
 800cf82:	81fb      	strh	r3, [r7, #14]
        hwerror = false;
 800cf84:	4b33      	ldr	r3, [pc, #204]	; (800d054 <se3_exec+0x120>)
 800cf86:	2200      	movs	r2, #0
 800cf88:	801a      	strh	r2, [r3, #0]
 800cf8a:	e009      	b.n	800cfa0 <se3_exec+0x6c>
    }
    else if (resp_size > SE3_RESP_MAX_DATA) {
 800cf8c:	89fb      	ldrh	r3, [r7, #14]
 800cf8e:	f641 52b0 	movw	r2, #7600	; 0x1db0
 800cf92:	4293      	cmp	r3, r2
 800cf94:	d904      	bls.n	800cfa0 <se3_exec+0x6c>
        status = SE3_ERR_HW;
 800cf96:	f24f 0301 	movw	r3, #61441	; 0xf001
 800cf9a:	82fb      	strh	r3, [r7, #22]
        resp_size = 0;
 800cf9c:	2300      	movs	r3, #0
 800cf9e:	81fb      	strh	r3, [r7, #14]
    }

    resp_hdr.status = status;
 800cfa0:	4a2d      	ldr	r2, [pc, #180]	; (800d058 <se3_exec+0x124>)
 800cfa2:	8afb      	ldrh	r3, [r7, #22]
 800cfa4:	8053      	strh	r3, [r2, #2]

    if (resp_size <= SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER) {
 800cfa6:	89fb      	ldrh	r3, [r7, #14]
 800cfa8:	f5b3 7ff8 	cmp.w	r3, #496	; 0x1f0
 800cfac:	d80d      	bhi.n	800cfca <se3_exec+0x96>
        nblocks = 1;
 800cfae:	2301      	movs	r3, #1
 800cfb0:	82bb      	strh	r3, [r7, #20]
        // zero unused memory
        memset(
            comm.resp_data + resp_size, 0,
 800cfb2:	4b27      	ldr	r3, [pc, #156]	; (800d050 <se3_exec+0x11c>)
 800cfb4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
        memset(
 800cfb6:	89fa      	ldrh	r2, [r7, #14]
            comm.resp_data + resp_size, 0,
 800cfb8:	4413      	add	r3, r2
            SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER - resp_size);
 800cfba:	89fa      	ldrh	r2, [r7, #14]
 800cfbc:	f5c2 72f8 	rsb	r2, r2, #496	; 0x1f0
        memset(
 800cfc0:	2100      	movs	r1, #0
 800cfc2:	4618      	mov	r0, r3
 800cfc4:	f00e f813 	bl	801afee <memset>
 800cfc8:	e033      	b.n	800d032 <se3_exec+0xfe>
    }
    else {
        tmp = resp_size - (SE3_COMM_BLOCK - SE3_RESP_SIZE_HEADER);
 800cfca:	89fb      	ldrh	r3, [r7, #14]
 800cfcc:	f5a3 73f8 	sub.w	r3, r3, #496	; 0x1f0
 800cfd0:	823b      	strh	r3, [r7, #16]
        nblocks = 1 + tmp / (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER);
 800cfd2:	8a3b      	ldrh	r3, [r7, #16]
 800cfd4:	089b      	lsrs	r3, r3, #2
 800cfd6:	4a21      	ldr	r2, [pc, #132]	; (800d05c <se3_exec+0x128>)
 800cfd8:	fba2 2303 	umull	r2, r3, r2, r3
 800cfdc:	095b      	lsrs	r3, r3, #5
 800cfde:	b29b      	uxth	r3, r3
 800cfe0:	3301      	adds	r3, #1
 800cfe2:	82bb      	strh	r3, [r7, #20]
        if (tmp % (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER) != 0) {
 800cfe4:	8a3a      	ldrh	r2, [r7, #16]
 800cfe6:	0893      	lsrs	r3, r2, #2
 800cfe8:	491c      	ldr	r1, [pc, #112]	; (800d05c <se3_exec+0x128>)
 800cfea:	fba1 1303 	umull	r1, r3, r1, r3
 800cfee:	0959      	lsrs	r1, r3, #5
 800cff0:	460b      	mov	r3, r1
 800cff2:	01db      	lsls	r3, r3, #7
 800cff4:	1a5b      	subs	r3, r3, r1
 800cff6:	009b      	lsls	r3, r3, #2
 800cff8:	1ad3      	subs	r3, r2, r3
 800cffa:	b29b      	uxth	r3, r3
 800cffc:	2b00      	cmp	r3, #0
 800cffe:	d018      	beq.n	800d032 <se3_exec+0xfe>
            nblocks++;
 800d000:	8abb      	ldrh	r3, [r7, #20]
 800d002:	3301      	adds	r3, #1
 800d004:	82bb      	strh	r3, [r7, #20]
            // zero unused memory
            memset(
                comm.resp_data + resp_size, 0,
 800d006:	4b12      	ldr	r3, [pc, #72]	; (800d050 <se3_exec+0x11c>)
 800d008:	6e5b      	ldr	r3, [r3, #100]	; 0x64
            memset(
 800d00a:	89fa      	ldrh	r2, [r7, #14]
                comm.resp_data + resp_size, 0,
 800d00c:	1898      	adds	r0, r3, r2
                (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER) - (tmp % (SE3_COMM_BLOCK - SE3_RESPDATA_SIZE_HEADER)));
 800d00e:	8a3a      	ldrh	r2, [r7, #16]
 800d010:	0893      	lsrs	r3, r2, #2
 800d012:	4912      	ldr	r1, [pc, #72]	; (800d05c <se3_exec+0x128>)
 800d014:	fba1 1303 	umull	r1, r3, r1, r3
 800d018:	0959      	lsrs	r1, r3, #5
 800d01a:	460b      	mov	r3, r1
 800d01c:	01db      	lsls	r3, r3, #7
 800d01e:	1a5b      	subs	r3, r3, r1
 800d020:	009b      	lsls	r3, r3, #2
 800d022:	1ad3      	subs	r3, r2, r3
 800d024:	b29b      	uxth	r3, r3
 800d026:	f5c3 73fe 	rsb	r3, r3, #508	; 0x1fc
            memset(
 800d02a:	461a      	mov	r2, r3
 800d02c:	2100      	movs	r1, #0
 800d02e:	f00d ffde 	bl	801afee <memset>
        }
    }

	resp_hdr.len = se3_resp_len_data_and_headers(resp_size);
 800d032:	89fb      	ldrh	r3, [r7, #14]
 800d034:	4618      	mov	r0, r3
 800d036:	f7f7 f9e9 	bl	800440c <se3_resp_len_data_and_headers>
 800d03a:	4603      	mov	r3, r0
 800d03c:	461a      	mov	r2, r3
 800d03e:	4b06      	ldr	r3, [pc, #24]	; (800d058 <se3_exec+0x124>)
 800d040:	809a      	strh	r2, [r3, #4]
		crc = se3_crc16_update(resp_size, comm.resp_data, crc);
	}
	resp_hdr.crc = crc;
#endif

    return nblocks;
 800d042:	8abb      	ldrh	r3, [r7, #20]
}
 800d044:	4618      	mov	r0, r3
 800d046:	371c      	adds	r7, #28
 800d048:	46bd      	mov	sp, r7
 800d04a:	bd90      	pop	{r4, r7, pc}
 800d04c:	200045f4 	.word	0x200045f4
 800d050:	20004638 	.word	0x20004638
 800d054:	200004a0 	.word	0x200004a0
 800d058:	200005b0 	.word	0x200005b0
 800d05c:	40810205 	.word	0x40810205

0800d060 <se3_cmd_execute>:

void se3_cmd_execute()
{
 800d060:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d062:	b093      	sub	sp, #76	; 0x4c
 800d064:	af0e      	add	r7, sp, #56	; 0x38
    uint16_t req_blocks = 1, resp_blocks = 1;
 800d066:	2301      	movs	r3, #1
 800d068:	81fb      	strh	r3, [r7, #14]
 800d06a:	2301      	movs	r3, #1
 800d06c:	81bb      	strh	r3, [r7, #12]
    size_t i;
    se3_cmd_func handler = NULL;
 800d06e:	2300      	movs	r3, #0
 800d070:	607b      	str	r3, [r7, #4]
	uint32_t cmdtok0;

    req_blocks = req_hdr.len / SE3_COMM_BLOCK;
 800d072:	4b46      	ldr	r3, [pc, #280]	; (800d18c <se3_cmd_execute+0x12c>)
 800d074:	889b      	ldrh	r3, [r3, #4]
 800d076:	0a5b      	lsrs	r3, r3, #9
 800d078:	81fb      	strh	r3, [r7, #14]
    if (req_hdr.len % SE3_COMM_BLOCK != 0) {
 800d07a:	4b44      	ldr	r3, [pc, #272]	; (800d18c <se3_cmd_execute+0x12c>)
 800d07c:	889b      	ldrh	r3, [r3, #4]
 800d07e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800d082:	b29b      	uxth	r3, r3
 800d084:	2b00      	cmp	r3, #0
 800d086:	d002      	beq.n	800d08e <se3_cmd_execute+0x2e>
        req_blocks++;
 800d088:	89fb      	ldrh	r3, [r7, #14]
 800d08a:	3301      	adds	r3, #1
 800d08c:	81fb      	strh	r3, [r7, #14]
    }
    if (req_blocks > SE3_COMM_N - 1) {
 800d08e:	89fb      	ldrh	r3, [r7, #14]
 800d090:	2b0f      	cmp	r3, #15
 800d092:	d902      	bls.n	800d09a <se3_cmd_execute+0x3a>
        // should not happen anyway
        resp_blocks = 0;
 800d094:	2300      	movs	r3, #0
 800d096:	81bb      	strh	r3, [r7, #12]
        goto update_comm;
 800d098:	e06a      	b.n	800d170 <se3_cmd_execute+0x110>
    }
    for (i = 1; i < req_blocks; i++) {
 800d09a:	2301      	movs	r3, #1
 800d09c:	60bb      	str	r3, [r7, #8]
 800d09e:	e013      	b.n	800d0c8 <se3_cmd_execute+0x68>
        if (req_hdr.cmdtok[i] != req_hdr.cmdtok[i - 1] + 1) {
 800d0a0:	4a3a      	ldr	r2, [pc, #232]	; (800d18c <se3_cmd_execute+0x12c>)
 800d0a2:	68bb      	ldr	r3, [r7, #8]
 800d0a4:	3302      	adds	r3, #2
 800d0a6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800d0aa:	68bb      	ldr	r3, [r7, #8]
 800d0ac:	3b01      	subs	r3, #1
 800d0ae:	4937      	ldr	r1, [pc, #220]	; (800d18c <se3_cmd_execute+0x12c>)
 800d0b0:	3302      	adds	r3, #2
 800d0b2:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800d0b6:	3301      	adds	r3, #1
 800d0b8:	429a      	cmp	r2, r3
 800d0ba:	d002      	beq.n	800d0c2 <se3_cmd_execute+0x62>
            resp_blocks = 0;
 800d0bc:	2300      	movs	r3, #0
 800d0be:	81bb      	strh	r3, [r7, #12]
            goto update_comm;
 800d0c0:	e056      	b.n	800d170 <se3_cmd_execute+0x110>
    for (i = 1; i < req_blocks; i++) {
 800d0c2:	68bb      	ldr	r3, [r7, #8]
 800d0c4:	3301      	adds	r3, #1
 800d0c6:	60bb      	str	r3, [r7, #8]
 800d0c8:	89fb      	ldrh	r3, [r7, #14]
 800d0ca:	68ba      	ldr	r2, [r7, #8]
 800d0cc:	429a      	cmp	r2, r3
 800d0ce:	d3e7      	bcc.n	800d0a0 <se3_cmd_execute+0x40>
        }
    }

	if (handler == NULL) {
 800d0d0:	687b      	ldr	r3, [r7, #4]
 800d0d2:	2b00      	cmp	r3, #0
 800d0d4:	d12f      	bne.n	800d136 <se3_cmd_execute+0xd6>
		switch (req_hdr.cmd) {
 800d0d6:	4b2d      	ldr	r3, [pc, #180]	; (800d18c <se3_cmd_execute+0x12c>)
 800d0d8:	881b      	ldrh	r3, [r3, #0]
 800d0da:	3b01      	subs	r3, #1
 800d0dc:	2b03      	cmp	r3, #3
 800d0de:	d827      	bhi.n	800d130 <se3_cmd_execute+0xd0>
 800d0e0:	a201      	add	r2, pc, #4	; (adr r2, 800d0e8 <se3_cmd_execute+0x88>)
 800d0e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d0e6:	bf00      	nop
 800d0e8:	0800d125 	.word	0x0800d125
 800d0ec:	0800d11f 	.word	0x0800d11f
 800d0f0:	0800d0f9 	.word	0x0800d0f9
 800d0f4:	0800d12b 	.word	0x0800d12b
		case SE3_CMD0_MIX:
			set_req_hdr(req_hdr);
 800d0f8:	4e24      	ldr	r6, [pc, #144]	; (800d18c <se3_cmd_execute+0x12c>)
 800d0fa:	466d      	mov	r5, sp
 800d0fc:	f106 0410 	add.w	r4, r6, #16
 800d100:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800d102:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800d104:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800d106:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800d108:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800d10a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800d10c:	6823      	ldr	r3, [r4, #0]
 800d10e:	602b      	str	r3, [r5, #0]
 800d110:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 800d114:	f000 fe8e 	bl	800de34 <set_req_hdr>
			handler = dispatcher_call;
 800d118:	4b1d      	ldr	r3, [pc, #116]	; (800d190 <se3_cmd_execute+0x130>)
 800d11a:	607b      	str	r3, [r7, #4]
			break;
 800d11c:	e00c      	b.n	800d138 <se3_cmd_execute+0xd8>
		case SE3_CMD0_ECHO:
			handler = echo;
 800d11e:	4b1d      	ldr	r3, [pc, #116]	; (800d194 <se3_cmd_execute+0x134>)
 800d120:	607b      	str	r3, [r7, #4]
			break;
 800d122:	e009      	b.n	800d138 <se3_cmd_execute+0xd8>
		case SE3_CMD0_FACTORY_INIT:
			handler = factory_init;
 800d124:	4b1c      	ldr	r3, [pc, #112]	; (800d198 <se3_cmd_execute+0x138>)
 800d126:	607b      	str	r3, [r7, #4]
			break;
 800d128:	e006      	b.n	800d138 <se3_cmd_execute+0xd8>
		case SE3_CMD0_BOOT_MODE_RESET:
			handler = bootmode_reset;
 800d12a:	4b1c      	ldr	r3, [pc, #112]	; (800d19c <se3_cmd_execute+0x13c>)
 800d12c:	607b      	str	r3, [r7, #4]
			break;
 800d12e:	e003      	b.n	800d138 <se3_cmd_execute+0xd8>
		default:
			handler = invalid_cmd_handler;
 800d130:	4b1b      	ldr	r3, [pc, #108]	; (800d1a0 <se3_cmd_execute+0x140>)
 800d132:	607b      	str	r3, [r7, #4]
 800d134:	e000      	b.n	800d138 <se3_cmd_execute+0xd8>
		}
	}
 800d136:	bf00      	nop

    resp_blocks = se3_exec(handler);
 800d138:	6878      	ldr	r0, [r7, #4]
 800d13a:	f7ff fefb 	bl	800cf34 <se3_exec>
 800d13e:	4603      	mov	r3, r0
 800d140:	81bb      	strh	r3, [r7, #12]

    // set cmdtok
	cmdtok0 = req_hdr.cmdtok[0];
 800d142:	4b12      	ldr	r3, [pc, #72]	; (800d18c <se3_cmd_execute+0x12c>)
 800d144:	689b      	ldr	r3, [r3, #8]
 800d146:	603b      	str	r3, [r7, #0]
    for (i = 0; i < resp_blocks; i++) {
 800d148:	2300      	movs	r3, #0
 800d14a:	60bb      	str	r3, [r7, #8]
 800d14c:	e00b      	b.n	800d166 <se3_cmd_execute+0x106>
        resp_hdr.cmdtok[i] = cmdtok0;
 800d14e:	4915      	ldr	r1, [pc, #84]	; (800d1a4 <se3_cmd_execute+0x144>)
 800d150:	68bb      	ldr	r3, [r7, #8]
 800d152:	3302      	adds	r3, #2
 800d154:	683a      	ldr	r2, [r7, #0]
 800d156:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		cmdtok0++;
 800d15a:	683b      	ldr	r3, [r7, #0]
 800d15c:	3301      	adds	r3, #1
 800d15e:	603b      	str	r3, [r7, #0]
    for (i = 0; i < resp_blocks; i++) {
 800d160:	68bb      	ldr	r3, [r7, #8]
 800d162:	3301      	adds	r3, #1
 800d164:	60bb      	str	r3, [r7, #8]
 800d166:	89bb      	ldrh	r3, [r7, #12]
 800d168:	68ba      	ldr	r2, [r7, #8]
 800d16a:	429a      	cmp	r2, r3
 800d16c:	d3ef      	bcc.n	800d14e <se3_cmd_execute+0xee>
    }


update_comm:
 800d16e:	bf00      	nop
    // update comm response bit map
    comm.resp_bmap = SE3_BMAP_MAKE(resp_blocks);
 800d170:	89bb      	ldrh	r3, [r7, #12]
 800d172:	f1c3 0320 	rsb	r3, r3, #32
 800d176:	f04f 32ff 	mov.w	r2, #4294967295
 800d17a:	fa22 f303 	lsr.w	r3, r2, r3
 800d17e:	4a0a      	ldr	r2, [pc, #40]	; (800d1a8 <se3_cmd_execute+0x148>)
 800d180:	6613      	str	r3, [r2, #96]	; 0x60
}
 800d182:	bf00      	nop
 800d184:	3714      	adds	r7, #20
 800d186:	46bd      	mov	sp, r7
 800d188:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d18a:	bf00      	nop
 800d18c:	200045f4 	.word	0x200045f4
 800d190:	0800daf5 	.word	0x0800daf5
 800d194:	0800d1ad 	.word	0x0800d1ad
 800d198:	0800d1d9 	.word	0x0800d1d9
 800d19c:	0800d281 	.word	0x0800d281
 800d1a0:	0800cf15 	.word	0x0800cf15
 800d1a4:	200005b0 	.word	0x200005b0
 800d1a8:	20004638 	.word	0x20004638

0800d1ac <echo>:

uint16_t echo(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d1ac:	b580      	push	{r7, lr}
 800d1ae:	b084      	sub	sp, #16
 800d1b0:	af00      	add	r7, sp, #0
 800d1b2:	60b9      	str	r1, [r7, #8]
 800d1b4:	607a      	str	r2, [r7, #4]
 800d1b6:	603b      	str	r3, [r7, #0]
 800d1b8:	4603      	mov	r3, r0
 800d1ba:	81fb      	strh	r3, [r7, #14]
    memcpy(resp, req, req_size);
 800d1bc:	89fb      	ldrh	r3, [r7, #14]
 800d1be:	461a      	mov	r2, r3
 800d1c0:	68b9      	ldr	r1, [r7, #8]
 800d1c2:	6838      	ldr	r0, [r7, #0]
 800d1c4:	f00d feef 	bl	801afa6 <memcpy>
    *resp_size = req_size;
 800d1c8:	687b      	ldr	r3, [r7, #4]
 800d1ca:	89fa      	ldrh	r2, [r7, #14]
 800d1cc:	801a      	strh	r2, [r3, #0]
    return SE3_OK;
 800d1ce:	2300      	movs	r3, #0
}
 800d1d0:	4618      	mov	r0, r3
 800d1d2:	3710      	adds	r7, #16
 800d1d4:	46bd      	mov	sp, r7
 800d1d6:	bd80      	pop	{r7, pc}

0800d1d8 <factory_init>:

uint16_t factory_init(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d1d8:	b5b0      	push	{r4, r5, r7, lr}
 800d1da:	b08a      	sub	sp, #40	; 0x28
 800d1dc:	af00      	add	r7, sp, #0
 800d1de:	60b9      	str	r1, [r7, #8]
 800d1e0:	607a      	str	r2, [r7, #4]
 800d1e2:	603b      	str	r3, [r7, #0]
 800d1e4:	4603      	mov	r3, r0
 800d1e6:	81fb      	strh	r3, [r7, #14]
    enum {
        OFF_SERIAL = 0
    };
    const uint8_t* serial_tmp = req + OFF_SERIAL;
 800d1e8:	68bb      	ldr	r3, [r7, #8]
 800d1ea:	627b      	str	r3, [r7, #36]	; 0x24
    se3_flash_it it;

	if (serial.written) {
 800d1ec:	4b23      	ldr	r3, [pc, #140]	; (800d27c <factory_init+0xa4>)
 800d1ee:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d1f2:	2b00      	cmp	r3, #0
 800d1f4:	d002      	beq.n	800d1fc <factory_init+0x24>
		return SE3_ERR_STATE;
 800d1f6:	f24f 0304 	movw	r3, #61444	; 0xf004
 800d1fa:	e03b      	b.n	800d274 <factory_init+0x9c>
	}

    se3_flash_it_init(&it);
 800d1fc:	f107 0314 	add.w	r3, r7, #20
 800d200:	4618      	mov	r0, r3
 800d202:	f001 f914 	bl	800e42e <se3_flash_it_init>
    if (!se3_flash_it_new(&it, SE3_FLASH_TYPE_SERIAL, SE3_SERIAL_SIZE)) {
 800d206:	f107 0314 	add.w	r3, r7, #20
 800d20a:	2220      	movs	r2, #32
 800d20c:	2101      	movs	r1, #1
 800d20e:	4618      	mov	r0, r3
 800d210:	f001 f988 	bl	800e524 <se3_flash_it_new>
 800d214:	4603      	mov	r3, r0
 800d216:	f083 0301 	eor.w	r3, r3, #1
 800d21a:	b2db      	uxtb	r3, r3
 800d21c:	2b00      	cmp	r3, #0
 800d21e:	d002      	beq.n	800d226 <factory_init+0x4e>
        return SE3_ERR_HW;
 800d220:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d224:	e026      	b.n	800d274 <factory_init+0x9c>
    }
    if (!se3_flash_it_write(&it, 0, serial_tmp, SE3_SERIAL_SIZE)) {
 800d226:	f107 0014 	add.w	r0, r7, #20
 800d22a:	2320      	movs	r3, #32
 800d22c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d22e:	2100      	movs	r1, #0
 800d230:	f001 f8da 	bl	800e3e8 <se3_flash_it_write>
 800d234:	4603      	mov	r3, r0
 800d236:	f083 0301 	eor.w	r3, r3, #1
 800d23a:	b2db      	uxtb	r3, r3
 800d23c:	2b00      	cmp	r3, #0
 800d23e:	d002      	beq.n	800d246 <factory_init+0x6e>
        return SE3_ERR_HW;
 800d240:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d244:	e016      	b.n	800d274 <factory_init+0x9c>
    }

    memcpy(serial.data, serial_tmp, SE3_SERIAL_SIZE);
 800d246:	4b0d      	ldr	r3, [pc, #52]	; (800d27c <factory_init+0xa4>)
 800d248:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d24a:	6815      	ldr	r5, [r2, #0]
 800d24c:	6854      	ldr	r4, [r2, #4]
 800d24e:	6890      	ldr	r0, [r2, #8]
 800d250:	68d1      	ldr	r1, [r2, #12]
 800d252:	601d      	str	r5, [r3, #0]
 800d254:	605c      	str	r4, [r3, #4]
 800d256:	6098      	str	r0, [r3, #8]
 800d258:	60d9      	str	r1, [r3, #12]
 800d25a:	6915      	ldr	r5, [r2, #16]
 800d25c:	6954      	ldr	r4, [r2, #20]
 800d25e:	6990      	ldr	r0, [r2, #24]
 800d260:	69d1      	ldr	r1, [r2, #28]
 800d262:	611d      	str	r5, [r3, #16]
 800d264:	615c      	str	r4, [r3, #20]
 800d266:	6198      	str	r0, [r3, #24]
 800d268:	61d9      	str	r1, [r3, #28]
    serial.written = true;
 800d26a:	4b04      	ldr	r3, [pc, #16]	; (800d27c <factory_init+0xa4>)
 800d26c:	2201      	movs	r2, #1
 800d26e:	f883 2020 	strb.w	r2, [r3, #32]
    return SE3_OK;
 800d272:	2300      	movs	r3, #0
}
 800d274:	4618      	mov	r0, r3
 800d276:	3728      	adds	r7, #40	; 0x28
 800d278:	46bd      	mov	sp, r7
 800d27a:	bdb0      	pop	{r4, r5, r7, pc}
 800d27c:	200004a4 	.word	0x200004a4

0800d280 <bootmode_reset>:

uint16_t bootmode_reset(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d280:	b580      	push	{r7, lr}
 800d282:	b084      	sub	sp, #16
 800d284:	af00      	add	r7, sp, #0
 800d286:	60b9      	str	r1, [r7, #8]
 800d288:	607a      	str	r2, [r7, #4]
 800d28a:	603b      	str	r3, [r7, #0]
 800d28c:	4603      	mov	r3, r0
 800d28e:	81fb      	strh	r3, [r7, #14]

	if(!(se3_flash_bootmode_reset(SE3_FLASH_SIGNATURE_ADDR, SE3_FLASH_SIGNATURE_SIZE)))
 800d290:	2140      	movs	r1, #64	; 0x40
 800d292:	4808      	ldr	r0, [pc, #32]	; (800d2b4 <bootmode_reset+0x34>)
 800d294:	f001 fa2c 	bl	800e6f0 <se3_flash_bootmode_reset>
 800d298:	4603      	mov	r3, r0
 800d29a:	f083 0301 	eor.w	r3, r3, #1
 800d29e:	b2db      	uxtb	r3, r3
 800d2a0:	2b00      	cmp	r3, #0
 800d2a2:	d002      	beq.n	800d2aa <bootmode_reset+0x2a>
		return SE3_ERR_HW;
 800d2a4:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d2a8:	e000      	b.n	800d2ac <bootmode_reset+0x2c>

	return SE3_OK;
 800d2aa:	2300      	movs	r3, #0
}
 800d2ac:	4618      	mov	r0, r3
 800d2ae:	3710      	adds	r7, #16
 800d2b0:	46bd      	mov	sp, r7
 800d2b2:	bd80      	pop	{r7, pc}
 800d2b4:	08020000 	.word	0x08020000

0800d2b8 <se3_time_init>:

uint64_t now;  ///< current UNIX time in seconds
bool now_initialized;  ///< time was initialized
int flag = 1;

void se3_time_init(){
 800d2b8:	b490      	push	{r4, r7}
 800d2ba:	af00      	add	r7, sp, #0
	now_initialized = false;
 800d2bc:	4b06      	ldr	r3, [pc, #24]	; (800d2d8 <se3_time_init+0x20>)
 800d2be:	2200      	movs	r2, #0
 800d2c0:	701a      	strb	r2, [r3, #0]
	now = 0;
 800d2c2:	4a06      	ldr	r2, [pc, #24]	; (800d2dc <se3_time_init+0x24>)
 800d2c4:	f04f 0300 	mov.w	r3, #0
 800d2c8:	f04f 0400 	mov.w	r4, #0
 800d2cc:	e9c2 3400 	strd	r3, r4, [r2]
}
 800d2d0:	bf00      	nop
 800d2d2:	46bd      	mov	sp, r7
 800d2d4:	bc90      	pop	{r4, r7}
 800d2d6:	4770      	bx	lr
 800d2d8:	2000cd10 	.word	0x2000cd10
 800d2dc:	2000cd08 	.word	0x2000cd08

0800d2e0 <se3_time_get>:

uint64_t se3_time_get()
{
 800d2e0:	b490      	push	{r4, r7}
 800d2e2:	af00      	add	r7, sp, #0
#ifdef CUBESIM
    now = (uint64_t)time(0);
#endif
    return now;
 800d2e4:	4b03      	ldr	r3, [pc, #12]	; (800d2f4 <se3_time_get+0x14>)
 800d2e6:	e9d3 3400 	ldrd	r3, r4, [r3]
}
 800d2ea:	4618      	mov	r0, r3
 800d2ec:	4621      	mov	r1, r4
 800d2ee:	46bd      	mov	sp, r7
 800d2f0:	bc90      	pop	{r4, r7}
 800d2f2:	4770      	bx	lr
 800d2f4:	2000cd08 	.word	0x2000cd08

0800d2f8 <se3_time_set>:

void se3_time_set(uint64_t t)
{
 800d2f8:	b490      	push	{r4, r7}
 800d2fa:	b082      	sub	sp, #8
 800d2fc:	af00      	add	r7, sp, #0
 800d2fe:	e9c7 0100 	strd	r0, r1, [r7]
    now = t;
 800d302:	4a06      	ldr	r2, [pc, #24]	; (800d31c <se3_time_set+0x24>)
 800d304:	e9d7 3400 	ldrd	r3, r4, [r7]
 800d308:	e9c2 3400 	strd	r3, r4, [r2]
	now_initialized = true;
 800d30c:	4b04      	ldr	r3, [pc, #16]	; (800d320 <se3_time_set+0x28>)
 800d30e:	2201      	movs	r2, #1
 800d310:	701a      	strb	r2, [r3, #0]
}
 800d312:	bf00      	nop
 800d314:	3708      	adds	r7, #8
 800d316:	46bd      	mov	sp, r7
 800d318:	bc90      	pop	{r4, r7}
 800d31a:	4770      	bx	lr
 800d31c:	2000cd08 	.word	0x2000cd08
 800d320:	2000cd10 	.word	0x2000cd10

0800d324 <se3_time_inc>:

void se3_time_inc()
{
 800d324:	b490      	push	{r4, r7}
 800d326:	af00      	add	r7, sp, #0
    static unsigned int ms = 0;
    if (++ms == 1000) {
 800d328:	4b0e      	ldr	r3, [pc, #56]	; (800d364 <se3_time_inc+0x40>)
 800d32a:	681b      	ldr	r3, [r3, #0]
 800d32c:	3301      	adds	r3, #1
 800d32e:	4a0d      	ldr	r2, [pc, #52]	; (800d364 <se3_time_inc+0x40>)
 800d330:	6013      	str	r3, [r2, #0]
 800d332:	4b0c      	ldr	r3, [pc, #48]	; (800d364 <se3_time_inc+0x40>)
 800d334:	681b      	ldr	r3, [r3, #0]
 800d336:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d33a:	d10e      	bne.n	800d35a <se3_time_inc+0x36>
    	flag = 0;
 800d33c:	4b0a      	ldr	r3, [pc, #40]	; (800d368 <se3_time_inc+0x44>)
 800d33e:	2200      	movs	r2, #0
 800d340:	601a      	str	r2, [r3, #0]
        (now)++;
 800d342:	4b0a      	ldr	r3, [pc, #40]	; (800d36c <se3_time_inc+0x48>)
 800d344:	e9d3 1200 	ldrd	r1, r2, [r3]
 800d348:	1c4b      	adds	r3, r1, #1
 800d34a:	f142 0400 	adc.w	r4, r2, #0
 800d34e:	4a07      	ldr	r2, [pc, #28]	; (800d36c <se3_time_inc+0x48>)
 800d350:	e9c2 3400 	strd	r3, r4, [r2]
        ms = 0;
 800d354:	4b03      	ldr	r3, [pc, #12]	; (800d364 <se3_time_inc+0x40>)
 800d356:	2200      	movs	r2, #0
 800d358:	601a      	str	r2, [r3, #0]
    }
}
 800d35a:	bf00      	nop
 800d35c:	46bd      	mov	sp, r7
 800d35e:	bc90      	pop	{r4, r7}
 800d360:	4770      	bx	lr
 800d362:	bf00      	nop
 800d364:	20000484 	.word	0x20000484
 800d368:	20000000 	.word	0x20000000
 800d36c:	2000cd08 	.word	0x2000cd08

0800d370 <get_now_initialized>:

bool get_now_initialized(){
 800d370:	b480      	push	{r7}
 800d372:	af00      	add	r7, sp, #0
	return now_initialized;
 800d374:	4b03      	ldr	r3, [pc, #12]	; (800d384 <get_now_initialized+0x14>)
 800d376:	781b      	ldrb	r3, [r3, #0]
}
 800d378:	4618      	mov	r0, r3
 800d37a:	46bd      	mov	sp, r7
 800d37c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d380:	4770      	bx	lr
 800d382:	bf00      	nop
 800d384:	2000cd10 	.word	0x2000cd10

0800d388 <error>:
se3_comm_req_header req_hdr;

static void login_cleanup();

uint16_t error(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d388:	b480      	push	{r7}
 800d38a:	b085      	sub	sp, #20
 800d38c:	af00      	add	r7, sp, #0
 800d38e:	60b9      	str	r1, [r7, #8]
 800d390:	607a      	str	r2, [r7, #4]
 800d392:	603b      	str	r3, [r7, #0]
 800d394:	4603      	mov	r3, r0
 800d396:	81fb      	strh	r3, [r7, #14]
    return SE3_ERR_CMD;
 800d398:	f24f 0305 	movw	r3, #61445	; 0xf005
}
 800d39c:	4618      	mov	r0, r3
 800d39e:	3714      	adds	r7, #20
 800d3a0:	46bd      	mov	sp, r7
 800d3a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d3a6:	4770      	bx	lr

0800d3a8 <config>:
/** \brief set or get configuration record
 *
 *  config : (type:ui16, op:ui16, value[32]) => (value[32])
 */
uint16_t config(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d3a8:	b580      	push	{r7, lr}
 800d3aa:	b088      	sub	sp, #32
 800d3ac:	af00      	add	r7, sp, #0
 800d3ae:	60b9      	str	r1, [r7, #8]
 800d3b0:	607a      	str	r2, [r7, #4]
 800d3b2:	603b      	str	r3, [r7, #0]
 800d3b4:	4603      	mov	r3, r0
 800d3b6:	81fb      	strh	r3, [r7, #14]
        uint8_t* value;
    } resp_params;

    SE3_TRACE(("[se3_dispatcher_core.c] config"));

    if (!login_struct.y) {
 800d3b8:	4b37      	ldr	r3, [pc, #220]	; (800d498 <config+0xf0>)
 800d3ba:	781b      	ldrb	r3, [r3, #0]
 800d3bc:	f083 0301 	eor.w	r3, r3, #1
 800d3c0:	b2db      	uxtb	r3, r3
 800d3c2:	2b00      	cmp	r3, #0
 800d3c4:	d001      	beq.n	800d3ca <config+0x22>
        SE3_TRACE(("[config] not logged in\n"));
        return SE3_ERR_ACCESS;
 800d3c6:	2364      	movs	r3, #100	; 0x64
 800d3c8:	e062      	b.n	800d490 <config+0xe8>
    }

    SE3_GET16(req, SE3_CMD1_CONFIG_REQ_OFF_ID, req_params.type);
 800d3ca:	68bb      	ldr	r3, [r7, #8]
 800d3cc:	881b      	ldrh	r3, [r3, #0]
 800d3ce:	b29b      	uxth	r3, r3
 800d3d0:	833b      	strh	r3, [r7, #24]
    SE3_GET16(req, SE3_CMD1_CONFIG_REQ_OFF_OP, req_params.op);
 800d3d2:	68bb      	ldr	r3, [r7, #8]
 800d3d4:	3302      	adds	r3, #2
 800d3d6:	881b      	ldrh	r3, [r3, #0]
 800d3d8:	b29b      	uxth	r3, r3
 800d3da:	837b      	strh	r3, [r7, #26]
    req_params.value = req + SE3_CMD1_CONFIG_REQ_OFF_VALUE;
 800d3dc:	68bb      	ldr	r3, [r7, #8]
 800d3de:	3304      	adds	r3, #4
 800d3e0:	61fb      	str	r3, [r7, #28]
    resp_params.value = resp + SE3_CMD1_CONFIG_RESP_OFF_VALUE;
 800d3e2:	683b      	ldr	r3, [r7, #0]
 800d3e4:	617b      	str	r3, [r7, #20]

    // check params
    if (req_params.type >= SE3_RECORD_MAX) {
 800d3e6:	8b3b      	ldrh	r3, [r7, #24]
 800d3e8:	2b01      	cmp	r3, #1
 800d3ea:	d902      	bls.n	800d3f2 <config+0x4a>
        SE3_TRACE(("[config] type out of range\n"));
        //se3_write_trace(se3_debug_create_string("\n[config] type out of range\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d3ec:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d3f0:	e04e      	b.n	800d490 <config+0xe8>
    }
    switch (req_params.op) {
 800d3f2:	8b7b      	ldrh	r3, [r7, #26]
 800d3f4:	3b01      	subs	r3, #1
 800d3f6:	2b01      	cmp	r3, #1
 800d3f8:	d805      	bhi.n	800d406 <config+0x5e>
    case SE3_CONFIG_OP_GET:
    case SE3_CONFIG_OP_SET:
        if (req_size != SE3_CMD1_CONFIG_REQ_OFF_VALUE + SE3_RECORD_SIZE) {
 800d3fa:	89fb      	ldrh	r3, [r7, #14]
 800d3fc:	2b24      	cmp	r3, #36	; 0x24
 800d3fe:	d005      	beq.n	800d40c <config+0x64>
            SE3_TRACE(("[config] req size mismatch\n"));
            //se3_write_trace(se3_debug_create_string("\n[config] req size mismatch\0"), debug_address++);
            return SE3_ERR_PARAMS;
 800d400:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d404:	e044      	b.n	800d490 <config+0xe8>
        }
        break;
    default:
        SE3_TRACE(("[config] op invalid\n"));
        //se3_write_trace(se3_debug_create_string("\n[config] op invalid\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d406:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d40a:	e041      	b.n	800d490 <config+0xe8>
        break;
 800d40c:	bf00      	nop
    }

    if (req_params.op == SE3_CONFIG_OP_GET) {
 800d40e:	8b7b      	ldrh	r3, [r7, #26]
 800d410:	2b01      	cmp	r3, #1
 800d412:	d11c      	bne.n	800d44e <config+0xa6>
        // check access
        if (login_struct.access < se3_security_info.records[req_params.type].read_access) {
 800d414:	4b20      	ldr	r3, [pc, #128]	; (800d498 <config+0xf0>)
 800d416:	885a      	ldrh	r2, [r3, #2]
 800d418:	8b3b      	ldrh	r3, [r7, #24]
 800d41a:	4619      	mov	r1, r3
 800d41c:	4b1f      	ldr	r3, [pc, #124]	; (800d49c <config+0xf4>)
 800d41e:	f833 3021 	ldrh.w	r3, [r3, r1, lsl #2]
 800d422:	429a      	cmp	r2, r3
 800d424:	d201      	bcs.n	800d42a <config+0x82>
            SE3_TRACE(("[config] insufficient access\n"));
            return SE3_ERR_ACCESS;
 800d426:	2364      	movs	r3, #100	; 0x64
 800d428:	e032      	b.n	800d490 <config+0xe8>
        }
        if (!record_get(req_params.type, resp_params.value)) {
 800d42a:	8b3b      	ldrh	r3, [r7, #24]
 800d42c:	697a      	ldr	r2, [r7, #20]
 800d42e:	4611      	mov	r1, r2
 800d430:	4618      	mov	r0, r3
 800d432:	f001 fe0f 	bl	800f054 <record_get>
 800d436:	4603      	mov	r3, r0
 800d438:	f083 0301 	eor.w	r3, r3, #1
 800d43c:	b2db      	uxtb	r3, r3
 800d43e:	2b00      	cmp	r3, #0
 800d440:	d001      	beq.n	800d446 <config+0x9e>
            return SE3_ERR_RESOURCE;
 800d442:	23c8      	movs	r3, #200	; 0xc8
 800d444:	e024      	b.n	800d490 <config+0xe8>
        }
        *resp_size = SE3_RECORD_SIZE;
 800d446:	687b      	ldr	r3, [r7, #4]
 800d448:	2220      	movs	r2, #32
 800d44a:	801a      	strh	r2, [r3, #0]
 800d44c:	e01f      	b.n	800d48e <config+0xe6>
    }
    else if (req_params.op == SE3_CONFIG_OP_SET) {
 800d44e:	8b7b      	ldrh	r3, [r7, #26]
 800d450:	2b02      	cmp	r3, #2
 800d452:	d119      	bne.n	800d488 <config+0xe0>
        // check access
        if (login_struct.access < se3_security_info.records[req_params.type].write_access) {
 800d454:	4b10      	ldr	r3, [pc, #64]	; (800d498 <config+0xf0>)
 800d456:	885a      	ldrh	r2, [r3, #2]
 800d458:	8b3b      	ldrh	r3, [r7, #24]
 800d45a:	4910      	ldr	r1, [pc, #64]	; (800d49c <config+0xf4>)
 800d45c:	009b      	lsls	r3, r3, #2
 800d45e:	440b      	add	r3, r1
 800d460:	885b      	ldrh	r3, [r3, #2]
 800d462:	429a      	cmp	r2, r3
 800d464:	d201      	bcs.n	800d46a <config+0xc2>
            SE3_TRACE(("[config] insufficient access\n"));
            return SE3_ERR_ACCESS;
 800d466:	2364      	movs	r3, #100	; 0x64
 800d468:	e012      	b.n	800d490 <config+0xe8>
        }
        if (!record_set(req_params.type, req_params.value)) {
 800d46a:	8b3b      	ldrh	r3, [r7, #24]
 800d46c:	69fa      	ldr	r2, [r7, #28]
 800d46e:	4611      	mov	r1, r2
 800d470:	4618      	mov	r0, r3
 800d472:	f001 fd82 	bl	800ef7a <record_set>
 800d476:	4603      	mov	r3, r0
 800d478:	f083 0301 	eor.w	r3, r3, #1
 800d47c:	b2db      	uxtb	r3, r3
 800d47e:	2b00      	cmp	r3, #0
 800d480:	d005      	beq.n	800d48e <config+0xe6>
            return SE3_ERR_MEMORY;
 800d482:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d486:	e003      	b.n	800d490 <config+0xe8>
        }
    }
    else {
        SE3_TRACE(("[config] invalid op\n"));
        //se3_write_trace(se3_debug_create_string("\n[config] invalid op 2\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d488:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d48c:	e000      	b.n	800d490 <config+0xe8>
    }

	return SE3_OK;
 800d48e:	2300      	movs	r3, #0
}
 800d490:	4618      	mov	r0, r3
 800d492:	3720      	adds	r7, #32
 800d494:	46bd      	mov	sp, r7
 800d496:	bd80      	pop	{r7, pc}
 800d498:	20004834 	.word	0x20004834
 800d49c:	200004cc 	.word	0x200004cc

0800d4a0 <challenge>:
/** \brief Get a login challenge from the server
 *
 *  challenge : (cc1[32], cc2[32], access:ui16) => (sc[32], sresp[32])
 */
uint16_t challenge(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d4a0:	b580      	push	{r7, lr}
 800d4a2:	b096      	sub	sp, #88	; 0x58
 800d4a4:	af04      	add	r7, sp, #16
 800d4a6:	60b9      	str	r1, [r7, #8]
 800d4a8:	607a      	str	r2, [r7, #4]
 800d4aa:	603b      	str	r3, [r7, #0]
 800d4ac:	4603      	mov	r3, r0
 800d4ae:	81fb      	strh	r3, [r7, #14]
    struct {
        uint8_t* sc;
        uint8_t* sresp;
    } resp_params;

    if (req_size != SE3_CMD1_CHALLENGE_REQ_SIZE) {
 800d4b0:	89fb      	ldrh	r3, [r7, #14]
 800d4b2:	2b42      	cmp	r3, #66	; 0x42
 800d4b4:	d002      	beq.n	800d4bc <challenge+0x1c>
        SE3_TRACE(("[challenge] req size mismatch\n"));
        //se3_write_trace(se3_debug_create_string("\n[challenge] req size mismatch\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d4b6:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d4ba:	e06e      	b.n	800d59a <challenge+0xfa>
    }

    req_params.cc1 = req + SE3_CMD1_CHALLENGE_REQ_OFF_CC1;
 800d4bc:	68bb      	ldr	r3, [r7, #8]
 800d4be:	61fb      	str	r3, [r7, #28]
    req_params.cc2 = req + SE3_CMD1_CHALLENGE_REQ_OFF_CC2;
 800d4c0:	68bb      	ldr	r3, [r7, #8]
 800d4c2:	3320      	adds	r3, #32
 800d4c4:	627b      	str	r3, [r7, #36]	; 0x24
    SE3_GET16(req, SE3_CMD1_CHALLENGE_REQ_OFF_ACCESS, req_params.access);
 800d4c6:	68bb      	ldr	r3, [r7, #8]
 800d4c8:	3340      	adds	r3, #64	; 0x40
 800d4ca:	881b      	ldrh	r3, [r3, #0]
 800d4cc:	b29b      	uxth	r3, r3
 800d4ce:	843b      	strh	r3, [r7, #32]
    resp_params.sc = resp + SE3_CMD1_CHALLENGE_RESP_OFF_SC;
 800d4d0:	683b      	ldr	r3, [r7, #0]
 800d4d2:	617b      	str	r3, [r7, #20]
    resp_params.sresp = resp + SE3_CMD1_CHALLENGE_RESP_OFF_SRESP;
 800d4d4:	683b      	ldr	r3, [r7, #0]
 800d4d6:	3320      	adds	r3, #32
 800d4d8:	61bb      	str	r3, [r7, #24]

	if (login_struct.y) {
 800d4da:	4b32      	ldr	r3, [pc, #200]	; (800d5a4 <challenge+0x104>)
 800d4dc:	781b      	ldrb	r3, [r3, #0]
 800d4de:	2b00      	cmp	r3, #0
 800d4e0:	d002      	beq.n	800d4e8 <challenge+0x48>
		SE3_TRACE(("[challenge] already logged in"));
		return SE3_ERR_STATE;
 800d4e2:	f24f 0304 	movw	r3, #61444	; 0xf004
 800d4e6:	e058      	b.n	800d59a <challenge+0xfa>
	}

    // default pin is zero, if no record is found
    memset(pin, 0, SE3_PIN_SIZE);
 800d4e8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800d4ec:	2220      	movs	r2, #32
 800d4ee:	2100      	movs	r1, #0
 800d4f0:	4618      	mov	r0, r3
 800d4f2:	f00d fd7c 	bl	801afee <memset>
    switch (req_params.access) {
 800d4f6:	8c3b      	ldrh	r3, [r7, #32]
 800d4f8:	2b64      	cmp	r3, #100	; 0x64
 800d4fa:	d003      	beq.n	800d504 <challenge+0x64>
 800d4fc:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d500:	d007      	beq.n	800d512 <challenge+0x72>
 800d502:	e00d      	b.n	800d520 <challenge+0x80>
    case SE3_ACCESS_USER:
        record_get(SE3_RECORD_TYPE_USERPIN, pin);
 800d504:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800d508:	4619      	mov	r1, r3
 800d50a:	2001      	movs	r0, #1
 800d50c:	f001 fda2 	bl	800f054 <record_get>
        break;
 800d510:	e009      	b.n	800d526 <challenge+0x86>
    case SE3_ACCESS_ADMIN:
        record_get(SE3_RECORD_TYPE_ADMINPIN, pin);
 800d512:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800d516:	4619      	mov	r1, r3
 800d518:	2000      	movs	r0, #0
 800d51a:	f001 fd9b 	bl	800f054 <record_get>
        break;
 800d51e:	e002      	b.n	800d526 <challenge+0x86>
    default:
    	SE3_TRACE(("[se3_dispatcher_core.c - challenge] default error login"));
    	//se3_write_trace(se3_debug_create_string("\n[se3_dispatcher_core.c - challenge] default error login\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d520:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d524:	e039      	b.n	800d59a <challenge+0xfa>
	}

	if (SE3_CHALLENGE_SIZE != se3_rand(SE3_CHALLENGE_SIZE, resp_params.sc)) {
 800d526:	697b      	ldr	r3, [r7, #20]
 800d528:	4619      	mov	r1, r3
 800d52a:	2020      	movs	r0, #32
 800d52c:	f003 f86e 	bl	801060c <se3_rand>
 800d530:	4603      	mov	r3, r0
 800d532:	2b20      	cmp	r3, #32
 800d534:	d002      	beq.n	800d53c <challenge+0x9c>
		SE3_TRACE(("[challenge] se3_rand failed"));
		return SE3_ERR_HW;
 800d536:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d53a:	e02e      	b.n	800d59a <challenge+0xfa>
	}

	// cresp = PBKDF2(HMACSHA256, pin, sc, SE3_CHALLENGE_ITERATIONS, SE3_CHALLENGE_SIZE)
	PBKDF2HmacSha256(pin, SE3_PIN_SIZE, resp_params.sc,
 800d53c:	697a      	ldr	r2, [r7, #20]
 800d53e:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d542:	2320      	movs	r3, #32
 800d544:	9302      	str	r3, [sp, #8]
 800d546:	4b18      	ldr	r3, [pc, #96]	; (800d5a8 <challenge+0x108>)
 800d548:	9301      	str	r3, [sp, #4]
 800d54a:	2320      	movs	r3, #32
 800d54c:	9300      	str	r3, [sp, #0]
 800d54e:	2320      	movs	r3, #32
 800d550:	2120      	movs	r1, #32
 800d552:	f7f6 fed4 	bl	80042fe <PBKDF2HmacSha256>
		SE3_CHALLENGE_SIZE, SE3_CHALLENGE_ITERATIONS, login_struct.challenge, SE3_CHALLENGE_SIZE);

	// sresp = PBKDF2(HMACSHA256, pin, cc1, SE3_CHALLENGE_ITERATIONS, SE3_CHALLENGE_SIZE)
	PBKDF2HmacSha256(pin, SE3_PIN_SIZE, req_params.cc1,
 800d556:	69f9      	ldr	r1, [r7, #28]
 800d558:	69bb      	ldr	r3, [r7, #24]
 800d55a:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d55e:	2220      	movs	r2, #32
 800d560:	9202      	str	r2, [sp, #8]
 800d562:	9301      	str	r3, [sp, #4]
 800d564:	2320      	movs	r3, #32
 800d566:	9300      	str	r3, [sp, #0]
 800d568:	2320      	movs	r3, #32
 800d56a:	460a      	mov	r2, r1
 800d56c:	2120      	movs	r1, #32
 800d56e:	f7f6 fec6 	bl	80042fe <PBKDF2HmacSha256>
		SE3_CHALLENGE_SIZE, SE3_CHALLENGE_ITERATIONS, resp_params.sresp, SE3_CHALLENGE_SIZE);

	// key = PBKDF2(HMACSHA256, pin, cc2, 1, SE3_PIN_SIZE)
	PBKDF2HmacSha256(pin, SE3_PIN_SIZE, req_params.cc2,
 800d572:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d574:	f107 0028 	add.w	r0, r7, #40	; 0x28
 800d578:	2320      	movs	r3, #32
 800d57a:	9302      	str	r3, [sp, #8]
 800d57c:	4b0b      	ldr	r3, [pc, #44]	; (800d5ac <challenge+0x10c>)
 800d57e:	9301      	str	r3, [sp, #4]
 800d580:	2301      	movs	r3, #1
 800d582:	9300      	str	r3, [sp, #0]
 800d584:	2320      	movs	r3, #32
 800d586:	2120      	movs	r1, #32
 800d588:	f7f6 feb9 	bl	80042fe <PBKDF2HmacSha256>
		SE3_CHALLENGE_SIZE, 1, login_struct.key, SE3_PIN_SIZE);

	login_struct.challenge_access = req_params.access;
 800d58c:	8c3a      	ldrh	r2, [r7, #32]
 800d58e:	4b05      	ldr	r3, [pc, #20]	; (800d5a4 <challenge+0x104>)
 800d590:	809a      	strh	r2, [r3, #4]

    *resp_size = SE3_CMD1_CHALLENGE_RESP_SIZE;
 800d592:	687b      	ldr	r3, [r7, #4]
 800d594:	2240      	movs	r2, #64	; 0x40
 800d596:	801a      	strh	r2, [r3, #0]
	return SE3_OK;
 800d598:	2300      	movs	r3, #0
}
 800d59a:	4618      	mov	r0, r3
 800d59c:	3748      	adds	r7, #72	; 0x48
 800d59e:	46bd      	mov	sp, r7
 800d5a0:	bd80      	pop	{r7, pc}
 800d5a2:	bf00      	nop
 800d5a4:	20004834 	.word	0x20004834
 800d5a8:	2000483a 	.word	0x2000483a
 800d5ac:	2000485a 	.word	0x2000485a

0800d5b0 <login>:
/** \brief respond to challenge, completing login
 *
 *  login : (cresp[32]) => (tok[16])
 */
uint16_t login(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d5b0:	b590      	push	{r4, r7, lr}
 800d5b2:	b089      	sub	sp, #36	; 0x24
 800d5b4:	af00      	add	r7, sp, #0
 800d5b6:	60b9      	str	r1, [r7, #8]
 800d5b8:	607a      	str	r2, [r7, #4]
 800d5ba:	603b      	str	r3, [r7, #0]
 800d5bc:	4603      	mov	r3, r0
 800d5be:	81fb      	strh	r3, [r7, #14]
    struct {
        uint8_t* token;
    } resp_params;
    uint16_t access;

    if (req_size != SE3_CMD1_LOGIN_REQ_SIZE) {
 800d5c0:	89fb      	ldrh	r3, [r7, #14]
 800d5c2:	2b20      	cmp	r3, #32
 800d5c4:	d002      	beq.n	800d5cc <login+0x1c>
        SE3_TRACE(("[login] req size mismatch\n"));
        //se3_write_trace(se3_debug_create_string("\n[login] req size mismatch\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d5c6:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d5ca:	e044      	b.n	800d656 <login+0xa6>
    }

	if (login_struct.y) {
 800d5cc:	4b24      	ldr	r3, [pc, #144]	; (800d660 <login+0xb0>)
 800d5ce:	781b      	ldrb	r3, [r3, #0]
 800d5d0:	2b00      	cmp	r3, #0
 800d5d2:	d002      	beq.n	800d5da <login+0x2a>
		SE3_TRACE(("[login] already logged in"));
		return SE3_ERR_STATE;
 800d5d4:	f24f 0304 	movw	r3, #61444	; 0xf004
 800d5d8:	e03d      	b.n	800d656 <login+0xa6>
	}
	if (SE3_ACCESS_MAX == login_struct.challenge_access) {
 800d5da:	4b21      	ldr	r3, [pc, #132]	; (800d660 <login+0xb0>)
 800d5dc:	889b      	ldrh	r3, [r3, #4]
 800d5de:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d5e2:	4293      	cmp	r3, r2
 800d5e4:	d102      	bne.n	800d5ec <login+0x3c>
		SE3_TRACE(("[login] not waiting for challenge response"));
		return SE3_ERR_STATE;
 800d5e6:	f24f 0304 	movw	r3, #61444	; 0xf004
 800d5ea:	e034      	b.n	800d656 <login+0xa6>
	}

    req_params.cresp = req + SE3_CMD1_LOGIN_REQ_OFF_CRESP;
 800d5ec:	68bb      	ldr	r3, [r7, #8]
 800d5ee:	61bb      	str	r3, [r7, #24]
    resp_params.token = resp + SE3_CMD1_LOGIN_RESP_OFF_TOKEN;
 800d5f0:	683b      	ldr	r3, [r7, #0]
 800d5f2:	617b      	str	r3, [r7, #20]

	access = login_struct.challenge_access;
 800d5f4:	4b1a      	ldr	r3, [pc, #104]	; (800d660 <login+0xb0>)
 800d5f6:	889b      	ldrh	r3, [r3, #4]
 800d5f8:	83fb      	strh	r3, [r7, #30]
	login_struct.challenge_access = SE3_ACCESS_MAX;
 800d5fa:	4b19      	ldr	r3, [pc, #100]	; (800d660 <login+0xb0>)
 800d5fc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d600:	809a      	strh	r2, [r3, #4]
	if (memcmp(req_params.cresp, (uint8_t*)login_struct.challenge, 32)) {
 800d602:	69bb      	ldr	r3, [r7, #24]
 800d604:	2220      	movs	r2, #32
 800d606:	4917      	ldr	r1, [pc, #92]	; (800d664 <login+0xb4>)
 800d608:	4618      	mov	r0, r3
 800d60a:	f00d fcbd 	bl	801af88 <memcmp>
 800d60e:	4603      	mov	r3, r0
 800d610:	2b00      	cmp	r3, #0
 800d612:	d001      	beq.n	800d618 <login+0x68>
		SE3_TRACE(("[login] challenge response mismatch"));
		return SE3_ERR_PIN;
 800d614:	2365      	movs	r3, #101	; 0x65
 800d616:	e01e      	b.n	800d656 <login+0xa6>
	}

	if (SE3_TOKEN_SIZE != se3_rand(SE3_TOKEN_SIZE, (uint8_t*)login_struct.token)) {
 800d618:	4912      	ldr	r1, [pc, #72]	; (800d664 <login+0xb4>)
 800d61a:	2010      	movs	r0, #16
 800d61c:	f002 fff6 	bl	801060c <se3_rand>
 800d620:	4603      	mov	r3, r0
 800d622:	2b10      	cmp	r3, #16
 800d624:	d002      	beq.n	800d62c <login+0x7c>
		SE3_TRACE(("[login] random failed"));
		return SE3_ERR_HW;
 800d626:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d62a:	e014      	b.n	800d656 <login+0xa6>
	}
	memcpy(resp_params.token, (uint8_t*)login_struct.token, 16);
 800d62c:	697a      	ldr	r2, [r7, #20]
 800d62e:	4b0c      	ldr	r3, [pc, #48]	; (800d660 <login+0xb0>)
 800d630:	3306      	adds	r3, #6
 800d632:	681c      	ldr	r4, [r3, #0]
 800d634:	6858      	ldr	r0, [r3, #4]
 800d636:	6899      	ldr	r1, [r3, #8]
 800d638:	68db      	ldr	r3, [r3, #12]
 800d63a:	6014      	str	r4, [r2, #0]
 800d63c:	6050      	str	r0, [r2, #4]
 800d63e:	6091      	str	r1, [r2, #8]
 800d640:	60d3      	str	r3, [r2, #12]
	login_struct.y = 1;
 800d642:	4b07      	ldr	r3, [pc, #28]	; (800d660 <login+0xb0>)
 800d644:	2201      	movs	r2, #1
 800d646:	701a      	strb	r2, [r3, #0]
	login_struct.access = access;
 800d648:	4a05      	ldr	r2, [pc, #20]	; (800d660 <login+0xb0>)
 800d64a:	8bfb      	ldrh	r3, [r7, #30]
 800d64c:	8053      	strh	r3, [r2, #2]

    *resp_size = SE3_CMD1_LOGIN_RESP_SIZE;
 800d64e:	687b      	ldr	r3, [r7, #4]
 800d650:	2210      	movs	r2, #16
 800d652:	801a      	strh	r2, [r3, #0]
	return SE3_OK;
 800d654:	2300      	movs	r3, #0
}
 800d656:	4618      	mov	r0, r3
 800d658:	3724      	adds	r7, #36	; 0x24
 800d65a:	46bd      	mov	sp, r7
 800d65c:	bd90      	pop	{r4, r7, pc}
 800d65e:	bf00      	nop
 800d660:	20004834 	.word	0x20004834
 800d664:	2000483a 	.word	0x2000483a

0800d668 <logout>:
/** \brief Log out and release resources
 *
 *  logout : () => ()
 */
uint16_t logout(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d668:	b580      	push	{r7, lr}
 800d66a:	b084      	sub	sp, #16
 800d66c:	af00      	add	r7, sp, #0
 800d66e:	60b9      	str	r1, [r7, #8]
 800d670:	607a      	str	r2, [r7, #4]
 800d672:	603b      	str	r3, [r7, #0]
 800d674:	4603      	mov	r3, r0
 800d676:	81fb      	strh	r3, [r7, #14]
    if (req_size != 0) {
 800d678:	89fb      	ldrh	r3, [r7, #14]
 800d67a:	2b00      	cmp	r3, #0
 800d67c:	d002      	beq.n	800d684 <logout+0x1c>
        SE3_TRACE(("[logout] req size mismatch\n"));
        //se3_write_trace(se3_debug_create_string("\n[logout] req size mismatch\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d67e:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d682:	e00b      	b.n	800d69c <logout+0x34>
    }
	if (!login_struct.y) {
 800d684:	4b07      	ldr	r3, [pc, #28]	; (800d6a4 <logout+0x3c>)
 800d686:	781b      	ldrb	r3, [r3, #0]
 800d688:	f083 0301 	eor.w	r3, r3, #1
 800d68c:	b2db      	uxtb	r3, r3
 800d68e:	2b00      	cmp	r3, #0
 800d690:	d001      	beq.n	800d696 <logout+0x2e>
		SE3_TRACE(("[logout] not logged in\n"));
		return SE3_ERR_ACCESS;
 800d692:	2364      	movs	r3, #100	; 0x64
 800d694:	e002      	b.n	800d69c <logout+0x34>
	}
	login_cleanup();
 800d696:	f000 fbe5 	bl	800de64 <login_cleanup>
	return SE3_OK;
 800d69a:	2300      	movs	r3, #0
}
 800d69c:	4618      	mov	r0, r3
 800d69e:	3710      	adds	r7, #16
 800d6a0:	46bd      	mov	sp, r7
 800d6a2:	bd80      	pop	{r7, pc}
 800d6a4:	20004834 	.word	0x20004834

0800d6a8 <key_edit>:
/** \brief insert, delete or update key
 *
 *  key_edit : (op:ui16, id:ui32, validity:ui32, data-len:ui16, name-len:ui16, data[data-len], name[name-len]) => ()
 */
uint16_t key_edit(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d6a8:	b580      	push	{r7, lr}
 800d6aa:	b098      	sub	sp, #96	; 0x60
 800d6ac:	af00      	add	r7, sp, #0
 800d6ae:	60b9      	str	r1, [r7, #8]
 800d6b0:	607a      	str	r2, [r7, #4]
 800d6b2:	603b      	str	r3, [r7, #0]
 800d6b4:	4603      	mov	r3, r0
 800d6b6:	81fb      	strh	r3, [r7, #14]
        const uint8_t* name;
    } req_params;

    se3_flash_key key;
	bool equal;
    se3_flash_it it = { .addr = NULL };
 800d6b8:	f107 0320 	add.w	r3, r7, #32
 800d6bc:	2200      	movs	r2, #0
 800d6be:	601a      	str	r2, [r3, #0]
 800d6c0:	605a      	str	r2, [r3, #4]
 800d6c2:	609a      	str	r2, [r3, #8]
 800d6c4:	60da      	str	r2, [r3, #12]
	se3_flash_it it2 = { .addr = NULL };
 800d6c6:	f107 0310 	add.w	r3, r7, #16
 800d6ca:	2200      	movs	r2, #0
 800d6cc:	601a      	str	r2, [r3, #0]
 800d6ce:	605a      	str	r2, [r3, #4]
 800d6d0:	609a      	str	r2, [r3, #8]
 800d6d2:	60da      	str	r2, [r3, #12]

    if (req_size < SE3_CMD1_KEY_EDIT_REQ_OFF_DATA_AND_NAME) {
 800d6d4:	89fb      	ldrh	r3, [r7, #14]
 800d6d6:	2b0d      	cmp	r3, #13
 800d6d8:	d802      	bhi.n	800d6e0 <key_edit+0x38>
        SE3_TRACE(("[key_edit] req size mismatch\n"));
        //se3_write_trace(se3_debug_create_string("\n[key_edit] req size mismatch\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d6da:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d6de:	e112      	b.n	800d906 <key_edit+0x25e>
    }

    if (!login_struct.y) {
 800d6e0:	4b8b      	ldr	r3, [pc, #556]	; (800d910 <key_edit+0x268>)
 800d6e2:	781b      	ldrb	r3, [r3, #0]
 800d6e4:	f083 0301 	eor.w	r3, r3, #1
 800d6e8:	b2db      	uxtb	r3, r3
 800d6ea:	2b00      	cmp	r3, #0
 800d6ec:	d001      	beq.n	800d6f2 <key_edit+0x4a>
        SE3_TRACE(("[key_edit] not logged in\n"));
        return SE3_ERR_ACCESS;
 800d6ee:	2364      	movs	r3, #100	; 0x64
 800d6f0:	e109      	b.n	800d906 <key_edit+0x25e>
    }

    SE3_GET16(req, SE3_CMD1_KEY_EDIT_REQ_OFF_OP, req_params.op);
 800d6f2:	68bb      	ldr	r3, [r7, #8]
 800d6f4:	881b      	ldrh	r3, [r3, #0]
 800d6f6:	b29b      	uxth	r3, r3
 800d6f8:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    SE3_GET32(req, SE3_CMD1_KEY_EDIT_REQ_OFF_ID, req_params.id);
 800d6fc:	68bb      	ldr	r3, [r7, #8]
 800d6fe:	3302      	adds	r3, #2
 800d700:	681b      	ldr	r3, [r3, #0]
 800d702:	64bb      	str	r3, [r7, #72]	; 0x48
    SE3_GET32(req, SE3_CMD1_KEY_EDIT_REQ_OFF_VALIDITY, req_params.validity);
 800d704:	68bb      	ldr	r3, [r7, #8]
 800d706:	3306      	adds	r3, #6
 800d708:	681b      	ldr	r3, [r3, #0]
 800d70a:	64fb      	str	r3, [r7, #76]	; 0x4c
    SE3_GET16(req, SE3_CMD1_KEY_EDIT_REQ_OFF_DATA_LEN, req_params.data_len);
 800d70c:	68bb      	ldr	r3, [r7, #8]
 800d70e:	330a      	adds	r3, #10
 800d710:	881b      	ldrh	r3, [r3, #0]
 800d712:	b29b      	uxth	r3, r3
 800d714:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    SE3_GET16(req, SE3_CMD1_KEY_EDIT_REQ_OFF_NAME_LEN, req_params.name_len);
 800d718:	68bb      	ldr	r3, [r7, #8]
 800d71a:	330c      	adds	r3, #12
 800d71c:	881b      	ldrh	r3, [r3, #0]
 800d71e:	b29b      	uxth	r3, r3
 800d720:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    req_params.data = req + SE3_CMD1_KEY_EDIT_REQ_OFF_DATA_AND_NAME;
 800d724:	68bb      	ldr	r3, [r7, #8]
 800d726:	330e      	adds	r3, #14
 800d728:	657b      	str	r3, [r7, #84]	; 0x54
    req_params.name = req + SE3_CMD1_KEY_EDIT_REQ_OFF_DATA_AND_NAME + req_params.data_len;
 800d72a:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800d72e:	330e      	adds	r3, #14
 800d730:	68ba      	ldr	r2, [r7, #8]
 800d732:	4413      	add	r3, r2
 800d734:	65bb      	str	r3, [r7, #88]	; 0x58

    // check params
    if ((req_params.data_len > SE3_KEY_DATA_MAX) || (req_params.name_len > SE3_KEY_NAME_MAX)) {
 800d736:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800d73a:	2b20      	cmp	r3, #32
 800d73c:	d902      	bls.n	800d744 <key_edit+0x9c>
    	SE3_TRACE(("[se3_dispatcher_core.c - key_edit] error parameters"));
    	//se3_write_trace(se3_debug_create_string("\n[se3_dispatcher_core.c - key_edit] error parameters\0"), debug_address++);
    	return SE3_ERR_PARAMS;
 800d73e:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d742:	e0e0      	b.n	800d906 <key_edit+0x25e>
    }

    key.id = req_params.id;
 800d744:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d746:	633b      	str	r3, [r7, #48]	; 0x30
    key.data_size = req_params.data_len;
 800d748:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 800d74c:	873b      	strh	r3, [r7, #56]	; 0x38
    key.name_size = req_params.name_len;
 800d74e:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800d752:	877b      	strh	r3, [r7, #58]	; 0x3a
    key.validity = req_params.validity;
 800d754:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d756:	637b      	str	r3, [r7, #52]	; 0x34
    key.data = (uint8_t*)req_params.data;
 800d758:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d75a:	63fb      	str	r3, [r7, #60]	; 0x3c
    key.name = (uint8_t*)req_params.name;
 800d75c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d75e:	643b      	str	r3, [r7, #64]	; 0x40

    se3_flash_it_init(&it);
 800d760:	f107 0320 	add.w	r3, r7, #32
 800d764:	4618      	mov	r0, r3
 800d766:	f000 fe62 	bl	800e42e <se3_flash_it_init>
    if (!se3_key_find(key.id, &it)) {
 800d76a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d76c:	f107 0220 	add.w	r2, r7, #32
 800d770:	4611      	mov	r1, r2
 800d772:	4618      	mov	r0, r3
 800d774:	f000 ffca 	bl	800e70c <se3_key_find>
 800d778:	4603      	mov	r3, r0
 800d77a:	f083 0301 	eor.w	r3, r3, #1
 800d77e:	b2db      	uxtb	r3, r3
 800d780:	2b00      	cmp	r3, #0
 800d782:	d001      	beq.n	800d788 <key_edit+0xe0>
        it.addr = NULL;
 800d784:	2300      	movs	r3, #0
 800d786:	623b      	str	r3, [r7, #32]
    }

    switch (req_params.op) {
 800d788:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800d78c:	3b01      	subs	r3, #1
 800d78e:	2b03      	cmp	r3, #3
 800d790:	f200 80ae 	bhi.w	800d8f0 <key_edit+0x248>
 800d794:	a201      	add	r2, pc, #4	; (adr r2, 800d79c <key_edit+0xf4>)
 800d796:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d79a:	bf00      	nop
 800d79c:	0800d7ad 	.word	0x0800d7ad
 800d7a0:	0800d7db 	.word	0x0800d7db
 800d7a4:	0800d801 	.word	0x0800d801
 800d7a8:	0800d881 	.word	0x0800d881
    case SE3_KEY_OP_INSERT:
        if (NULL != it.addr) {
 800d7ac:	6a3b      	ldr	r3, [r7, #32]
 800d7ae:	2b00      	cmp	r3, #0
 800d7b0:	d001      	beq.n	800d7b6 <key_edit+0x10e>
            return SE3_ERR_RESOURCE;
 800d7b2:	23c8      	movs	r3, #200	; 0xc8
 800d7b4:	e0a7      	b.n	800d906 <key_edit+0x25e>
        }
        if (!se3_key_new(&it, &key)) {
 800d7b6:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800d7ba:	f107 0320 	add.w	r3, r7, #32
 800d7be:	4611      	mov	r1, r2
 800d7c0:	4618      	mov	r0, r3
 800d7c2:	f000 ffc7 	bl	800e754 <se3_key_new>
 800d7c6:	4603      	mov	r3, r0
 800d7c8:	f083 0301 	eor.w	r3, r3, #1
 800d7cc:	b2db      	uxtb	r3, r3
 800d7ce:	2b00      	cmp	r3, #0
 800d7d0:	f000 8091 	beq.w	800d8f6 <key_edit+0x24e>
            SE3_TRACE(("[key_edit] se3_key_new failed\n"));
            return SE3_ERR_MEMORY;
 800d7d4:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d7d8:	e095      	b.n	800d906 <key_edit+0x25e>
        }
        break;
    case SE3_KEY_OP_DELETE:
        if (NULL == it.addr) {
 800d7da:	6a3b      	ldr	r3, [r7, #32]
 800d7dc:	2b00      	cmp	r3, #0
 800d7de:	d101      	bne.n	800d7e4 <key_edit+0x13c>
            return SE3_ERR_RESOURCE;
 800d7e0:	23c8      	movs	r3, #200	; 0xc8
 800d7e2:	e090      	b.n	800d906 <key_edit+0x25e>
        }
        if (!se3_flash_it_delete(&it)) {
 800d7e4:	f107 0320 	add.w	r3, r7, #32
 800d7e8:	4618      	mov	r0, r3
 800d7ea:	f000 ff4f 	bl	800e68c <se3_flash_it_delete>
 800d7ee:	4603      	mov	r3, r0
 800d7f0:	f083 0301 	eor.w	r3, r3, #1
 800d7f4:	b2db      	uxtb	r3, r3
 800d7f6:	2b00      	cmp	r3, #0
 800d7f8:	d07f      	beq.n	800d8fa <key_edit+0x252>
            return SE3_ERR_HW;
 800d7fa:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d7fe:	e082      	b.n	800d906 <key_edit+0x25e>
        }
        break;
    case SE3_KEY_OP_UPSERT:
		equal = false;
 800d800:	2300      	movs	r3, #0
 800d802:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
        if (NULL != it.addr) {
 800d806:	6a3b      	ldr	r3, [r7, #32]
 800d808:	2b00      	cmp	r3, #0
 800d80a:	d01f      	beq.n	800d84c <key_edit+0x1a4>
            // do not replace if equal
			equal = se3_key_equal(&it, &key);
 800d80c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800d810:	f107 0320 	add.w	r3, r7, #32
 800d814:	4611      	mov	r1, r2
 800d816:	4618      	mov	r0, r3
 800d818:	f001 f80c 	bl	800e834 <se3_key_equal>
 800d81c:	4603      	mov	r3, r0
 800d81e:	f887 305f 	strb.w	r3, [r7, #95]	; 0x5f
			if (!equal) {
 800d822:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800d826:	f083 0301 	eor.w	r3, r3, #1
 800d82a:	b2db      	uxtb	r3, r3
 800d82c:	2b00      	cmp	r3, #0
 800d82e:	d00d      	beq.n	800d84c <key_edit+0x1a4>
				if (!se3_flash_it_delete(&it)) {
 800d830:	f107 0320 	add.w	r3, r7, #32
 800d834:	4618      	mov	r0, r3
 800d836:	f000 ff29 	bl	800e68c <se3_flash_it_delete>
 800d83a:	4603      	mov	r3, r0
 800d83c:	f083 0301 	eor.w	r3, r3, #1
 800d840:	b2db      	uxtb	r3, r3
 800d842:	2b00      	cmp	r3, #0
 800d844:	d002      	beq.n	800d84c <key_edit+0x1a4>
					return SE3_ERR_HW;
 800d846:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d84a:	e05c      	b.n	800d906 <key_edit+0x25e>
				}
			}
        }
        it.addr = NULL;
 800d84c:	2300      	movs	r3, #0
 800d84e:	623b      	str	r3, [r7, #32]
		if (!equal) {
 800d850:	f897 305f 	ldrb.w	r3, [r7, #95]	; 0x5f
 800d854:	f083 0301 	eor.w	r3, r3, #1
 800d858:	b2db      	uxtb	r3, r3
 800d85a:	2b00      	cmp	r3, #0
 800d85c:	d04f      	beq.n	800d8fe <key_edit+0x256>
			if (!se3_key_new(&it, &key)) {
 800d85e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800d862:	f107 0320 	add.w	r3, r7, #32
 800d866:	4611      	mov	r1, r2
 800d868:	4618      	mov	r0, r3
 800d86a:	f000 ff73 	bl	800e754 <se3_key_new>
 800d86e:	4603      	mov	r3, r0
 800d870:	f083 0301 	eor.w	r3, r3, #1
 800d874:	b2db      	uxtb	r3, r3
 800d876:	2b00      	cmp	r3, #0
 800d878:	d041      	beq.n	800d8fe <key_edit+0x256>
				SE3_TRACE(("[key_edit] se3_key_new failed\n"));
				return SE3_ERR_MEMORY;
 800d87a:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d87e:	e042      	b.n	800d906 <key_edit+0x25e>
			}
		}
        break;
    case SE3_KEY_OP_DELETE_KEM_KEYPAIR:
    	se3_key_find(SE3_KEYPAIR_ID_OFFSET+2*req_params.id, &it);
 800d880:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d882:	005b      	lsls	r3, r3, #1
 800d884:	3305      	adds	r3, #5
 800d886:	f107 0220 	add.w	r2, r7, #32
 800d88a:	4611      	mov	r1, r2
 800d88c:	4618      	mov	r0, r3
 800d88e:	f000 ff3d 	bl	800e70c <se3_key_find>
    	se3_key_find(SE3_KEYPAIR_ID_OFFSET+2*req_params.id+1, &it2);
 800d892:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d894:	3303      	adds	r3, #3
 800d896:	005b      	lsls	r3, r3, #1
 800d898:	f107 0210 	add.w	r2, r7, #16
 800d89c:	4611      	mov	r1, r2
 800d89e:	4618      	mov	r0, r3
 800d8a0:	f000 ff34 	bl	800e70c <se3_key_find>
        if (NULL == it.addr) {
 800d8a4:	6a3b      	ldr	r3, [r7, #32]
 800d8a6:	2b00      	cmp	r3, #0
 800d8a8:	d101      	bne.n	800d8ae <key_edit+0x206>
            return SE3_ERR_RESOURCE;
 800d8aa:	23c8      	movs	r3, #200	; 0xc8
 800d8ac:	e02b      	b.n	800d906 <key_edit+0x25e>
        }
        else if (!se3_flash_it_delete(&it)) {
 800d8ae:	f107 0320 	add.w	r3, r7, #32
 800d8b2:	4618      	mov	r0, r3
 800d8b4:	f000 feea 	bl	800e68c <se3_flash_it_delete>
 800d8b8:	4603      	mov	r3, r0
 800d8ba:	f083 0301 	eor.w	r3, r3, #1
 800d8be:	b2db      	uxtb	r3, r3
 800d8c0:	2b00      	cmp	r3, #0
 800d8c2:	d002      	beq.n	800d8ca <key_edit+0x222>
            return SE3_ERR_HW;
 800d8c4:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d8c8:	e01d      	b.n	800d906 <key_edit+0x25e>
        }
        if (NULL == it2.addr) {
 800d8ca:	693b      	ldr	r3, [r7, #16]
 800d8cc:	2b00      	cmp	r3, #0
 800d8ce:	d101      	bne.n	800d8d4 <key_edit+0x22c>
            return SE3_ERR_RESOURCE;
 800d8d0:	23c8      	movs	r3, #200	; 0xc8
 800d8d2:	e018      	b.n	800d906 <key_edit+0x25e>
        }
        else if (!se3_flash_it_delete(&it2)) {
 800d8d4:	f107 0310 	add.w	r3, r7, #16
 800d8d8:	4618      	mov	r0, r3
 800d8da:	f000 fed7 	bl	800e68c <se3_flash_it_delete>
 800d8de:	4603      	mov	r3, r0
 800d8e0:	f083 0301 	eor.w	r3, r3, #1
 800d8e4:	b2db      	uxtb	r3, r3
 800d8e6:	2b00      	cmp	r3, #0
 800d8e8:	d00b      	beq.n	800d902 <key_edit+0x25a>
            return SE3_ERR_HW;
 800d8ea:	f24f 0301 	movw	r3, #61441	; 0xf001
 800d8ee:	e00a      	b.n	800d906 <key_edit+0x25e>
        }
        break;
    default:
        SE3_TRACE(("[key_edit] invalid op\n"));
        //se3_write_trace(se3_debug_create_string("\n[key_edit] invalid op\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800d8f0:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d8f4:	e007      	b.n	800d906 <key_edit+0x25e>
        break;
 800d8f6:	bf00      	nop
 800d8f8:	e004      	b.n	800d904 <key_edit+0x25c>
        break;
 800d8fa:	bf00      	nop
 800d8fc:	e002      	b.n	800d904 <key_edit+0x25c>
        break;
 800d8fe:	bf00      	nop
 800d900:	e000      	b.n	800d904 <key_edit+0x25c>
        break;
 800d902:	bf00      	nop
    }

	return SE3_OK;
 800d904:	2300      	movs	r3, #0
}
 800d906:	4618      	mov	r0, r3
 800d908:	3760      	adds	r7, #96	; 0x60
 800d90a:	46bd      	mov	sp, r7
 800d90c:	bd80      	pop	{r7, pc}
 800d90e:	bf00      	nop
 800d910:	20004834 	.word	0x20004834

0800d914 <key_list>:
 *
 *  key_list : (skip:ui16, nmax:ui16, salt[32]) => (count:ui16, keyinfo0, keyinfo1, ...)
 *      keyinfo: (id:ui32, validity:ui32, data-len:ui16, name-len:ui16, name[name-len], fingerprint[32])
 */
uint16_t key_list(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800d914:	b5b0      	push	{r4, r5, r7, lr}
 800d916:	b0b2      	sub	sp, #200	; 0xc8
 800d918:	af00      	add	r7, sp, #0
 800d91a:	60b9      	str	r1, [r7, #8]
 800d91c:	607a      	str	r2, [r7, #4]
 800d91e:	603b      	str	r3, [r7, #0]
 800d920:	4603      	mov	r3, r0
 800d922:	81fb      	strh	r3, [r7, #14]
    struct {
        uint16_t count;
    } resp_params;

    se3_flash_key key;
    se3_flash_it it = { .addr = NULL };
 800d924:	f107 0388 	add.w	r3, r7, #136	; 0x88
 800d928:	2200      	movs	r2, #0
 800d92a:	601a      	str	r2, [r3, #0]
 800d92c:	605a      	str	r2, [r3, #4]
 800d92e:	609a      	str	r2, [r3, #8]
 800d930:	60da      	str	r2, [r3, #12]
    size_t size = 0;
 800d932:	2300      	movs	r3, #0
 800d934:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    size_t key_info_size = 0;
 800d938:	2300      	movs	r3, #0
 800d93a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
    uint16_t skip;
    uint8_t tmp[SE3_KEY_NAME_MAX];
	uint8_t fingerprint[SE3_KEY_FINGERPRINT_SIZE];


    if (req_size != SE3_CMD1_KEY_LIST_REQ_SIZE) {
 800d93e:	89fb      	ldrh	r3, [r7, #14]
 800d940:	2b24      	cmp	r3, #36	; 0x24
 800d942:	d009      	beq.n	800d958 <key_list+0x44>
        SE3_TRACE(("[key_list] req size mismatch\n"));
        char s[50];
        sprintf(s, "\n[key_list] req size mismatch -> %d", req_size);
 800d944:	89fa      	ldrh	r2, [r7, #14]
 800d946:	f107 0314 	add.w	r3, r7, #20
 800d94a:	4968      	ldr	r1, [pc, #416]	; (800daec <key_list+0x1d8>)
 800d94c:	4618      	mov	r0, r3
 800d94e:	f00d fc0f 	bl	801b170 <siprintf>
        ////se3_write_trace(se3_debug_create_string(s), debug_address++);
        return SE3_ERR_PARAMS;
 800d952:	f24f 0306 	movw	r3, #61446	; 0xf006
 800d956:	e0c5      	b.n	800dae4 <key_list+0x1d0>
    }

    if (!login_struct.y) {
 800d958:	4b65      	ldr	r3, [pc, #404]	; (800daf0 <key_list+0x1dc>)
 800d95a:	781b      	ldrb	r3, [r3, #0]
 800d95c:	f083 0301 	eor.w	r3, r3, #1
 800d960:	b2db      	uxtb	r3, r3
 800d962:	2b00      	cmp	r3, #0
 800d964:	d001      	beq.n	800d96a <key_list+0x56>
        SE3_TRACE(("[key_list] not logged in\n"));
        return SE3_ERR_ACCESS;
 800d966:	2364      	movs	r3, #100	; 0x64
 800d968:	e0bc      	b.n	800dae4 <key_list+0x1d0>
    }

    SE3_GET16(req, SE3_CMD1_KEY_LIST_REQ_OFF_SKIP, req_params.skip);
 800d96a:	68bb      	ldr	r3, [r7, #8]
 800d96c:	881b      	ldrh	r3, [r3, #0]
 800d96e:	b29b      	uxth	r3, r3
 800d970:	f8a7 30b0 	strh.w	r3, [r7, #176]	; 0xb0
    SE3_GET16(req, SE3_CMD1_KEY_LIST_REQ_OFF_NMAX, req_params.nmax);
 800d974:	68bb      	ldr	r3, [r7, #8]
 800d976:	3302      	adds	r3, #2
 800d978:	881b      	ldrh	r3, [r3, #0]
 800d97a:	b29b      	uxth	r3, r3
 800d97c:	f8a7 30b2 	strh.w	r3, [r7, #178]	; 0xb2
	req_params.salt = req + SE3_CMD1_KEY_LIST_REQ_OFF_SALT;
 800d980:	68bb      	ldr	r3, [r7, #8]
 800d982:	3304      	adds	r3, #4
 800d984:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4

	/* ! will write key data to request buffer */
	key.data = (uint8_t*)req + ((SE3_CMD1_KEY_LIST_REQ_SIZE / 16) + 1) * 16;
 800d988:	68bb      	ldr	r3, [r7, #8]
 800d98a:	3330      	adds	r3, #48	; 0x30
 800d98c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    key.name = tmp;
 800d990:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800d994:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    resp_params.count = 0;
 800d998:	2300      	movs	r3, #0
 800d99a:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
    skip = req_params.skip;
 800d99e:	f8b7 30b0 	ldrh.w	r3, [r7, #176]	; 0xb0
 800d9a2:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
    size = SE3_CMD1_KEY_LIST_RESP_OFF_KEYINFO;
 800d9a6:	2302      	movs	r3, #2
 800d9a8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    p = resp + SE3_CMD1_KEY_LIST_RESP_OFF_KEYINFO;
 800d9ac:	683b      	ldr	r3, [r7, #0]
 800d9ae:	3302      	adds	r3, #2
 800d9b0:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
    while (se3_flash_it_next(&it)) {
 800d9b4:	e077      	b.n	800daa6 <key_list+0x192>
        if (it.type == SE3_TYPE_KEY) {
 800d9b6:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 800d9ba:	2b64      	cmp	r3, #100	; 0x64
 800d9bc:	d173      	bne.n	800daa6 <key_list+0x192>
            if (skip) {
 800d9be:	f8b7 30be 	ldrh.w	r3, [r7, #190]	; 0xbe
 800d9c2:	2b00      	cmp	r3, #0
 800d9c4:	d005      	beq.n	800d9d2 <key_list+0xbe>
                skip--;
 800d9c6:	f8b7 30be 	ldrh.w	r3, [r7, #190]	; 0xbe
 800d9ca:	3b01      	subs	r3, #1
 800d9cc:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
                continue;
 800d9d0:	e069      	b.n	800daa6 <key_list+0x192>
            }
            se3_key_read(&it, &key);
 800d9d2:	f107 0298 	add.w	r2, r7, #152	; 0x98
 800d9d6:	f107 0388 	add.w	r3, r7, #136	; 0x88
 800d9da:	4611      	mov	r1, r2
 800d9dc:	4618      	mov	r0, r3
 800d9de:	f000 fee4 	bl	800e7aa <se3_key_read>
            key_info_size = SE3_CMD1_KEY_LIST_KEYINFO_OFF_NAME + key.name_size;
 800d9e2:	f8b7 30a2 	ldrh.w	r3, [r7, #162]	; 0xa2
 800d9e6:	332c      	adds	r3, #44	; 0x2c
 800d9e8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
            if (size + key_info_size > SE3_RESP1_MAX_DATA) {
 800d9ec:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800d9f0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800d9f4:	4413      	add	r3, r2
 800d9f6:	f641 5270 	movw	r2, #7536	; 0x1d70
 800d9fa:	4293      	cmp	r3, r2
 800d9fc:	d85d      	bhi.n	800daba <key_list+0x1a6>
                break;
            }
			se3_key_fingerprint(&key, req_params.salt, fingerprint);
 800d9fe:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
 800da02:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800da06:	f107 0398 	add.w	r3, r7, #152	; 0x98
 800da0a:	4618      	mov	r0, r3
 800da0c:	f000 fff1 	bl	800e9f2 <se3_key_fingerprint>
            SE3_SET32(p, SE3_CMD1_KEY_LIST_KEYINFO_OFF_ID, key.id);
 800da10:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 800da14:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da18:	601a      	str	r2, [r3, #0]
            SE3_SET32(p, SE3_CMD1_KEY_LIST_KEYINFO_OFF_VALIDITY, key.validity);
 800da1a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da1e:	3304      	adds	r3, #4
 800da20:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 800da24:	601a      	str	r2, [r3, #0]
            SE3_SET16(p, SE3_CMD1_KEY_LIST_KEYINFO_OFF_DATA_LEN, key.data_size);
 800da26:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da2a:	3308      	adds	r3, #8
 800da2c:	f8b7 20a0 	ldrh.w	r2, [r7, #160]	; 0xa0
 800da30:	801a      	strh	r2, [r3, #0]
            SE3_SET16(p, SE3_CMD1_KEY_LIST_KEYINFO_OFF_NAME_LEN, key.name_size);
 800da32:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da36:	330a      	adds	r3, #10
 800da38:	f8b7 20a2 	ldrh.w	r2, [r7, #162]	; 0xa2
 800da3c:	801a      	strh	r2, [r3, #0]
			memcpy(p + SE3_CMD1_KEY_LIST_KEYINFO_OFF_FINGERPRINT, fingerprint, SE3_KEY_FINGERPRINT_SIZE);
 800da3e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da42:	330c      	adds	r3, #12
 800da44:	461d      	mov	r5, r3
 800da46:	f107 0448 	add.w	r4, r7, #72	; 0x48
 800da4a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800da4c:	6028      	str	r0, [r5, #0]
 800da4e:	6069      	str	r1, [r5, #4]
 800da50:	60aa      	str	r2, [r5, #8]
 800da52:	60eb      	str	r3, [r5, #12]
 800da54:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800da56:	6128      	str	r0, [r5, #16]
 800da58:	6169      	str	r1, [r5, #20]
 800da5a:	61aa      	str	r2, [r5, #24]
 800da5c:	61eb      	str	r3, [r5, #28]
            memcpy(p + SE3_CMD1_KEY_LIST_KEYINFO_OFF_NAME, key.name, key.name_size);
 800da5e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800da62:	332c      	adds	r3, #44	; 0x2c
 800da64:	f8d7 10a8 	ldr.w	r1, [r7, #168]	; 0xa8
 800da68:	f8b7 20a2 	ldrh.w	r2, [r7, #162]	; 0xa2
 800da6c:	4618      	mov	r0, r3
 800da6e:	f00d fa9a 	bl	801afa6 <memcpy>
            p += key_info_size;
 800da72:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800da76:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800da7a:	4413      	add	r3, r2
 800da7c:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
            size += key_info_size;
 800da80:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 800da84:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 800da88:	4413      	add	r3, r2
 800da8a:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
            (resp_params.count)++;
 800da8e:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 800da92:	3301      	adds	r3, #1
 800da94:	b29b      	uxth	r3, r3
 800da96:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
            if (resp_params.count >= req_params.nmax) {
 800da9a:	f8b7 20ac 	ldrh.w	r2, [r7, #172]	; 0xac
 800da9e:	f8b7 30b2 	ldrh.w	r3, [r7, #178]	; 0xb2
 800daa2:	429a      	cmp	r2, r3
 800daa4:	d20b      	bcs.n	800dabe <key_list+0x1aa>
    while (se3_flash_it_next(&it)) {
 800daa6:	f107 0388 	add.w	r3, r7, #136	; 0x88
 800daaa:	4618      	mov	r0, r3
 800daac:	f000 fccc 	bl	800e448 <se3_flash_it_next>
 800dab0:	4603      	mov	r3, r0
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	f47f af7f 	bne.w	800d9b6 <key_list+0xa2>
 800dab8:	e002      	b.n	800dac0 <key_list+0x1ac>
                break;
 800daba:	bf00      	nop
 800dabc:	e000      	b.n	800dac0 <key_list+0x1ac>
                break;
 800dabe:	bf00      	nop
            }
        }
    }
	memset(key.data, 0, SE3_KEY_DATA_MAX);
 800dac0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800dac4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800dac8:	2100      	movs	r1, #0
 800daca:	4618      	mov	r0, r3
 800dacc:	f00d fa8f 	bl	801afee <memset>

    SE3_SET16(resp, SE3_CMD1_KEY_LIST_RESP_OFF_COUNT, resp_params.count);
 800dad0:	f8b7 20ac 	ldrh.w	r2, [r7, #172]	; 0xac
 800dad4:	683b      	ldr	r3, [r7, #0]
 800dad6:	801a      	strh	r2, [r3, #0]
    *resp_size = (uint16_t)size;
 800dad8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800dadc:	b29a      	uxth	r2, r3
 800dade:	687b      	ldr	r3, [r7, #4]
 800dae0:	801a      	strh	r2, [r3, #0]

    return SE3_OK;
 800dae2:	2300      	movs	r3, #0
}
 800dae4:	4618      	mov	r0, r3
 800dae6:	37c8      	adds	r7, #200	; 0xc8
 800dae8:	46bd      	mov	sp, r7
 800daea:	bdb0      	pop	{r4, r5, r7, pc}
 800daec:	0801e148 	.word	0x0801e148
 800daf0:	20004834 	.word	0x20004834

0800daf4 <dispatcher_call>:

uint16_t dispatcher_call(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800daf4:	b5b0      	push	{r4, r5, r7, lr}
 800daf6:	b09a      	sub	sp, #104	; 0x68
 800daf8:	af04      	add	r7, sp, #16
 800dafa:	60b9      	str	r1, [r7, #8]
 800dafc:	607a      	str	r2, [r7, #4]
 800dafe:	603b      	str	r3, [r7, #0]
 800db00:	4603      	mov	r3, r0
 800db02:	81fb      	strh	r3, [r7, #14]
    se3_cmd_func handler = NULL;
 800db04:	2300      	movs	r3, #0
 800db06:	657b      	str	r3, [r7, #84]	; 0x54
        uint16_t len;
        uint16_t status;
        uint8_t* data;
    } resp_params;

    req_params.auth = req + SE3_REQ1_OFFSET_AUTH;
 800db08:	68bb      	ldr	r3, [r7, #8]
 800db0a:	62fb      	str	r3, [r7, #44]	; 0x2c
    req_params.iv = req + SE3_REQ1_OFFSET_IV;
 800db0c:	68bb      	ldr	r3, [r7, #8]
 800db0e:	3310      	adds	r3, #16
 800db10:	633b      	str	r3, [r7, #48]	; 0x30
    req_params.token = req + SE3_REQ1_OFFSET_TOKEN;
 800db12:	68bb      	ldr	r3, [r7, #8]
 800db14:	3320      	adds	r3, #32
 800db16:	637b      	str	r3, [r7, #52]	; 0x34
    req_params.data = req + SE3_REQ1_OFFSET_DATA;
 800db18:	68bb      	ldr	r3, [r7, #8]
 800db1a:	3340      	adds	r3, #64	; 0x40
 800db1c:	63fb      	str	r3, [r7, #60]	; 0x3c

    uint16_t command =0;
 800db1e:	2300      	movs	r3, #0
 800db20:	82fb      	strh	r3, [r7, #22]
    SE3_GET16(req, SE3_REQ1_OFFSET_CMD, command);
 800db22:	68bb      	ldr	r3, [r7, #8]
 800db24:	3332      	adds	r3, #50	; 0x32
 800db26:	881b      	ldrh	r3, [r3, #0]
 800db28:	b29b      	uxth	r3, r3
 800db2a:	82fb      	strh	r3, [r7, #22]

    if (req_size < SE3_REQ1_OFFSET_DATA) {
 800db2c:	89fb      	ldrh	r3, [r7, #14]
 800db2e:	2b3f      	cmp	r3, #63	; 0x3f
 800db30:	d802      	bhi.n	800db38 <dispatcher_call+0x44>
        SE3_TRACE(("[dispatcher_call] insufficient req size\n"));
        return SE3_ERR_COMM;
 800db32:	f24f 0302 	movw	r3, #61442	; 0xf002
 800db36:	e132      	b.n	800dd9e <dispatcher_call+0x2aa>
    }

    //check for authorization
    if(!sekey_get_auth(login_struct.key)){
 800db38:	489b      	ldr	r0, [pc, #620]	; (800dda8 <dispatcher_call+0x2b4>)
 800db3a:	f002 f860 	bl	800fbfe <sekey_get_auth>
 800db3e:	4603      	mov	r3, r0
 800db40:	f083 0301 	eor.w	r3, r3, #1
 800db44:	b2db      	uxtb	r3, r3
 800db46:	2b00      	cmp	r3, #0
 800db48:	d001      	beq.n	800db4e <dispatcher_call+0x5a>
    	return SE3_ERR_ACCESS;
 800db4a:	2364      	movs	r3, #100	; 0x64
 800db4c:	e127      	b.n	800dd9e <dispatcher_call+0x2aa>
    }
    // prepare request
    if (!login_struct.cryptoctx_initialized) {
 800db4e:	4b97      	ldr	r3, [pc, #604]	; (800ddac <dispatcher_call+0x2b8>)
 800db50:	f893 34c8 	ldrb.w	r3, [r3, #1224]	; 0x4c8
 800db54:	f083 0301 	eor.w	r3, r3, #1
 800db58:	b2db      	uxtb	r3, r3
 800db5a:	2b00      	cmp	r3, #0
 800db5c:	d007      	beq.n	800db6e <dispatcher_call+0x7a>
        se3_payload_cryptoinit(&(login_struct.cryptoctx), login_struct.key);
 800db5e:	4992      	ldr	r1, [pc, #584]	; (800dda8 <dispatcher_call+0x2b4>)
 800db60:	4893      	ldr	r0, [pc, #588]	; (800ddb0 <dispatcher_call+0x2bc>)
 800db62:	f001 ff3b 	bl	800f9dc <se3_payload_cryptoinit>
        login_struct.cryptoctx_initialized = true;
 800db66:	4b91      	ldr	r3, [pc, #580]	; (800ddac <dispatcher_call+0x2b8>)
 800db68:	2201      	movs	r2, #1
 800db6a:	f883 24c8 	strb.w	r2, [r3, #1224]	; 0x4c8
    }
    if (!se3_payload_decrypt(
 800db6e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800db70:	6b3c      	ldr	r4, [r7, #48]	; 0x30
        &(login_struct.cryptoctx), req_params.auth, req_params.iv,
        /* !! modifying request */ (uint8_t*)(req  + SE3_AUTH_SIZE + SE3_IV_SIZE),
 800db72:	68bb      	ldr	r3, [r7, #8]
 800db74:	f103 0520 	add.w	r5, r3, #32
        (req_size - SE3_AUTH_SIZE - SE3_IV_SIZE) / SE3_CRYPTOBLOCK_SIZE, req_hdr.cmd_flags, crypto_algo))
 800db78:	89fb      	ldrh	r3, [r7, #14]
 800db7a:	3b20      	subs	r3, #32
 800db7c:	2b00      	cmp	r3, #0
 800db7e:	da00      	bge.n	800db82 <dispatcher_call+0x8e>
 800db80:	330f      	adds	r3, #15
 800db82:	111b      	asrs	r3, r3, #4
    if (!se3_payload_decrypt(
 800db84:	b29b      	uxth	r3, r3
 800db86:	4a8b      	ldr	r2, [pc, #556]	; (800ddb4 <dispatcher_call+0x2c0>)
 800db88:	8852      	ldrh	r2, [r2, #2]
 800db8a:	498b      	ldr	r1, [pc, #556]	; (800ddb8 <dispatcher_call+0x2c4>)
 800db8c:	7809      	ldrb	r1, [r1, #0]
 800db8e:	9102      	str	r1, [sp, #8]
 800db90:	9201      	str	r2, [sp, #4]
 800db92:	9300      	str	r3, [sp, #0]
 800db94:	462b      	mov	r3, r5
 800db96:	4622      	mov	r2, r4
 800db98:	4601      	mov	r1, r0
 800db9a:	4885      	ldr	r0, [pc, #532]	; (800ddb0 <dispatcher_call+0x2bc>)
 800db9c:	f001 ffb5 	bl	800fb0a <se3_payload_decrypt>
 800dba0:	4603      	mov	r3, r0
 800dba2:	f083 0301 	eor.w	r3, r3, #1
 800dba6:	b2db      	uxtb	r3, r3
 800dba8:	2b00      	cmp	r3, #0
 800dbaa:	d002      	beq.n	800dbb2 <dispatcher_call+0xbe>
    {
        SE3_TRACE(("[dispatcher_call] AUTH failed\n"));
        return SE3_ERR_COMM;
 800dbac:	f24f 0302 	movw	r3, #61442	; 0xf002
 800dbb0:	e0f5      	b.n	800dd9e <dispatcher_call+0x2aa>
    }

    if (login_struct.y) {
 800dbb2:	4b7e      	ldr	r3, [pc, #504]	; (800ddac <dispatcher_call+0x2b8>)
 800dbb4:	781b      	ldrb	r3, [r3, #0]
 800dbb6:	2b00      	cmp	r3, #0
 800dbb8:	d01a      	beq.n	800dbf0 <dispatcher_call+0xfc>

        if (memcmp(login_struct.token, req_params.token, SE3_TOKEN_SIZE)) {
 800dbba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800dbbc:	2210      	movs	r2, #16
 800dbbe:	4619      	mov	r1, r3
 800dbc0:	487e      	ldr	r0, [pc, #504]	; (800ddbc <dispatcher_call+0x2c8>)
 800dbc2:	f00d f9e1 	bl	801af88 <memcmp>
 800dbc6:	4603      	mov	r3, r0
 800dbc8:	2b00      	cmp	r3, #0
 800dbca:	d011      	beq.n	800dbf0 <dispatcher_call+0xfc>

        	if (command==SE3_CMD1_CHALLENGE){//someone (maybe same user after a crash) trying to login.
 800dbcc:	8afb      	ldrh	r3, [r7, #22]
 800dbce:	2b01      	cmp	r3, #1
 800dbd0:	d102      	bne.n	800dbd8 <dispatcher_call+0xe4>
				SE3_TRACE(("[dispatcher_call] login token mismatch and trying to login\n"));
				return SE3_ERR_OPENED;//notify host there is already an opened session, if host wants to continue, will call SE3_CMD1_LOGOUT_FORCED
 800dbd2:	f44f 7396 	mov.w	r3, #300	; 0x12c
 800dbd6:	e0e2      	b.n	800dd9e <dispatcher_call+0x2aa>
			}
			else if (command==SE3_CMD1_LOGOUT_FORCED){//if the user agreed to close the existing session by forcing a logout
 800dbd8:	8afb      	ldrh	r3, [r7, #22]
 800dbda:	2b0e      	cmp	r3, #14
 800dbdc:	d106      	bne.n	800dbec <dispatcher_call+0xf8>
				command = SE3_CMD1_LOGOUT;//call logout as usual
 800dbde:	2303      	movs	r3, #3
 800dbe0:	82fb      	strh	r3, [r7, #22]
				SE3_SET16(req, SE3_REQ1_OFFSET_CMD, command);
 800dbe2:	68bb      	ldr	r3, [r7, #8]
 800dbe4:	3332      	adds	r3, #50	; 0x32
 800dbe6:	8afa      	ldrh	r2, [r7, #22]
 800dbe8:	801a      	strh	r2, [r3, #0]
 800dbea:	e001      	b.n	800dbf0 <dispatcher_call+0xfc>
			}
			else{
				SE3_TRACE(("[dispatcher_call] login token mismatch\n"));
				return SE3_ERR_ACCESS;
 800dbec:	2364      	movs	r3, #100	; 0x64
 800dbee:	e0d6      	b.n	800dd9e <dispatcher_call+0x2aa>
			}
        }
    }


    SE3_GET16(req, SE3_REQ1_OFFSET_LEN, req_params.len);
 800dbf0:	68bb      	ldr	r3, [r7, #8]
 800dbf2:	3330      	adds	r3, #48	; 0x30
 800dbf4:	881b      	ldrh	r3, [r3, #0]
 800dbf6:	b29b      	uxth	r3, r3
 800dbf8:	873b      	strh	r3, [r7, #56]	; 0x38
    SE3_GET16(req, SE3_REQ1_OFFSET_CMD, req_params.cmd);
 800dbfa:	68bb      	ldr	r3, [r7, #8]
 800dbfc:	3332      	adds	r3, #50	; 0x32
 800dbfe:	881b      	ldrh	r3, [r3, #0]
 800dc00:	b29b      	uxth	r3, r3
 800dc02:	877b      	strh	r3, [r7, #58]	; 0x3a

    if (req_params.cmd < SE3_CMD1_MAX) {
 800dc04:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800dc06:	2b0f      	cmp	r3, #15
 800dc08:	d823      	bhi.n	800dc52 <dispatcher_call+0x15e>
    	if (req_params.cmd > 6 && req_params.cmd < 11 && !login_struct.y) {   	//
 800dc0a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800dc0c:	2b06      	cmp	r3, #6
 800dc0e:	d90b      	bls.n	800dc28 <dispatcher_call+0x134>
 800dc10:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 800dc12:	2b0a      	cmp	r3, #10
 800dc14:	d808      	bhi.n	800dc28 <dispatcher_call+0x134>
 800dc16:	4b65      	ldr	r3, [pc, #404]	; (800ddac <dispatcher_call+0x2b8>)
 800dc18:	781b      	ldrb	r3, [r3, #0]
 800dc1a:	f083 0301 	eor.w	r3, r3, #1
 800dc1e:	b2db      	uxtb	r3, r3
 800dc20:	2b00      	cmp	r3, #0
 800dc22:	d001      	beq.n	800dc28 <dispatcher_call+0x134>
    		SE3_TRACE(("[crypto_init] not logged in\n"));		   				//
    		return SE3_ERR_ACCESS;                                     			//
 800dc24:	2364      	movs	r3, #100	; 0x64
 800dc26:	e0ba      	b.n	800dd9e <dispatcher_call+0x2aa>
    	}																		//
    																			//
    																			//
    	if(sekey_get_implementation_info(&algo_implementation, 					// SEkey call interface
 800dc28:	4a5f      	ldr	r2, [pc, #380]	; (800dda8 <dispatcher_call+0x2b4>)
 800dc2a:	4963      	ldr	r1, [pc, #396]	; (800ddb8 <dispatcher_call+0x2c4>)
 800dc2c:	4864      	ldr	r0, [pc, #400]	; (800ddc0 <dispatcher_call+0x2cc>)
 800dc2e:	f001 ffcf 	bl	800fbd0 <sekey_get_implementation_info>
 800dc32:	4603      	mov	r3, r0
 800dc34:	2b00      	cmp	r3, #0
 800dc36:	d00a      	beq.n	800dc4e <dispatcher_call+0x15a>
    			&crypto_algo, login_struct.key))								//
    		handler = handlers[algo_implementation][req_params.cmd];			//
 800dc38:	4b61      	ldr	r3, [pc, #388]	; (800ddc0 <dispatcher_call+0x2cc>)
 800dc3a:	781b      	ldrb	r3, [r3, #0]
 800dc3c:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 800dc3e:	4611      	mov	r1, r2
 800dc40:	4a60      	ldr	r2, [pc, #384]	; (800ddc4 <dispatcher_call+0x2d0>)
 800dc42:	011b      	lsls	r3, r3, #4
 800dc44:	440b      	add	r3, r1
 800dc46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dc4a:	657b      	str	r3, [r7, #84]	; 0x54
 800dc4c:	e001      	b.n	800dc52 <dispatcher_call+0x15e>
    	else																	//
    		return SE3_ERR_ACCESS;												//
 800dc4e:	2364      	movs	r3, #100	; 0x64
 800dc50:	e0a5      	b.n	800dd9e <dispatcher_call+0x2aa>
    }																			//
    if (handler == NULL) {
 800dc52:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800dc54:	2b00      	cmp	r3, #0
 800dc56:	d101      	bne.n	800dc5c <dispatcher_call+0x168>
        handler = error;
 800dc58:	4b5b      	ldr	r3, [pc, #364]	; (800ddc8 <dispatcher_call+0x2d4>)
 800dc5a:	657b      	str	r3, [r7, #84]	; 0x54
    }

    req1 = req_params.data;
 800dc5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dc5e:	64fb      	str	r3, [r7, #76]	; 0x4c
    req1_size = req_params.len;
 800dc60:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800dc62:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    resp1 = resp + SE3_RESP1_OFFSET_DATA;
 800dc66:	683b      	ldr	r3, [r7, #0]
 800dc68:	3340      	adds	r3, #64	; 0x40
 800dc6a:	647b      	str	r3, [r7, #68]	; 0x44
    resp1_size = 0;
 800dc6c:	2300      	movs	r3, #0
 800dc6e:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40

    status = handler(req1_size, req1, &resp1_size, resp1);
 800dc72:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800dc76:	f8b7 004a 	ldrh.w	r0, [r7, #74]	; 0x4a
 800dc7a:	6d7c      	ldr	r4, [r7, #84]	; 0x54
 800dc7c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800dc7e:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800dc80:	47a0      	blx	r4
 800dc82:	4603      	mov	r3, r0
 800dc84:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    resp_params.len = resp1_size;
 800dc88:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800dc8c:	84bb      	strh	r3, [r7, #36]	; 0x24
    resp_params.auth = resp + SE3_RESP1_OFFSET_AUTH;
 800dc8e:	683b      	ldr	r3, [r7, #0]
 800dc90:	61bb      	str	r3, [r7, #24]
    resp_params.iv = resp + SE3_RESP1_OFFSET_IV;
 800dc92:	683b      	ldr	r3, [r7, #0]
 800dc94:	3310      	adds	r3, #16
 800dc96:	61fb      	str	r3, [r7, #28]
    resp_params.token = resp + SE3_RESP1_OFFSET_TOKEN;
 800dc98:	683b      	ldr	r3, [r7, #0]
 800dc9a:	3320      	adds	r3, #32
 800dc9c:	623b      	str	r3, [r7, #32]
    resp_params.status = status;
 800dc9e:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 800dca2:	84fb      	strh	r3, [r7, #38]	; 0x26
    resp_params.data = resp1;
 800dca4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800dca6:	62bb      	str	r3, [r7, #40]	; 0x28

    resp1_size_padded = resp1_size;
 800dca8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800dcac:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    if (resp1_size_padded % SE3_CRYPTOBLOCK_SIZE != 0) {
 800dcb0:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800dcb4:	f003 030f 	and.w	r3, r3, #15
 800dcb8:	b29b      	uxth	r3, r3
 800dcba:	2b00      	cmp	r3, #0
 800dcbc:	d015      	beq.n	800dcea <dispatcher_call+0x1f6>
        memset(resp1 + resp1_size_padded, 0, (SE3_CRYPTOBLOCK_SIZE - (resp1_size_padded % SE3_CRYPTOBLOCK_SIZE)));
 800dcbe:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800dcc2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800dcc4:	18d0      	adds	r0, r2, r3
 800dcc6:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800dcca:	f003 030f 	and.w	r3, r3, #15
 800dcce:	f1c3 0310 	rsb	r3, r3, #16
 800dcd2:	461a      	mov	r2, r3
 800dcd4:	2100      	movs	r1, #0
 800dcd6:	f00d f98a 	bl	801afee <memset>
        resp1_size_padded += (SE3_CRYPTOBLOCK_SIZE - (resp1_size_padded % SE3_CRYPTOBLOCK_SIZE));
 800dcda:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800dcde:	f023 030f 	bic.w	r3, r3, #15
 800dce2:	b29b      	uxth	r3, r3
 800dce4:	3310      	adds	r3, #16
 800dce6:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    }

    *resp_size = SE3_RESP1_OFFSET_DATA + resp1_size_padded;
 800dcea:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 800dcee:	3340      	adds	r3, #64	; 0x40
 800dcf0:	b29a      	uxth	r2, r3
 800dcf2:	687b      	ldr	r3, [r7, #4]
 800dcf4:	801a      	strh	r2, [r3, #0]

    // prepare response
    SE3_SET16(resp, SE3_RESP1_OFFSET_LEN, resp_params.len);
 800dcf6:	683b      	ldr	r3, [r7, #0]
 800dcf8:	3330      	adds	r3, #48	; 0x30
 800dcfa:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800dcfc:	801a      	strh	r2, [r3, #0]
    SE3_SET16(resp, SE3_RESP1_OFFSET_STATUS, resp_params.status);
 800dcfe:	683b      	ldr	r3, [r7, #0]
 800dd00:	3332      	adds	r3, #50	; 0x32
 800dd02:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800dd04:	801a      	strh	r2, [r3, #0]
    if (login_struct.y) {
 800dd06:	4b29      	ldr	r3, [pc, #164]	; (800ddac <dispatcher_call+0x2b8>)
 800dd08:	781b      	ldrb	r3, [r3, #0]
 800dd0a:	2b00      	cmp	r3, #0
 800dd0c:	d00d      	beq.n	800dd2a <dispatcher_call+0x236>
        memcpy(resp + SE3_RESP1_OFFSET_TOKEN, login_struct.token, SE3_TOKEN_SIZE);
 800dd0e:	683b      	ldr	r3, [r7, #0]
 800dd10:	f103 0220 	add.w	r2, r3, #32
 800dd14:	4b25      	ldr	r3, [pc, #148]	; (800ddac <dispatcher_call+0x2b8>)
 800dd16:	3306      	adds	r3, #6
 800dd18:	681c      	ldr	r4, [r3, #0]
 800dd1a:	6858      	ldr	r0, [r3, #4]
 800dd1c:	6899      	ldr	r1, [r3, #8]
 800dd1e:	68db      	ldr	r3, [r3, #12]
 800dd20:	6014      	str	r4, [r2, #0]
 800dd22:	6050      	str	r0, [r2, #4]
 800dd24:	6091      	str	r1, [r2, #8]
 800dd26:	60d3      	str	r3, [r2, #12]
 800dd28:	e006      	b.n	800dd38 <dispatcher_call+0x244>
    }
    else {
        memset(resp + SE3_RESP1_OFFSET_TOKEN, 0, SE3_TOKEN_SIZE);
 800dd2a:	683b      	ldr	r3, [r7, #0]
 800dd2c:	3320      	adds	r3, #32
 800dd2e:	2210      	movs	r2, #16
 800dd30:	2100      	movs	r1, #0
 800dd32:	4618      	mov	r0, r3
 800dd34:	f00d f95b 	bl	801afee <memset>
    }
	if (req_hdr.cmd_flags & SE3_CMDFLAG_ENCRYPT) {
 800dd38:	4b1e      	ldr	r3, [pc, #120]	; (800ddb4 <dispatcher_call+0x2c0>)
 800dd3a:	885b      	ldrh	r3, [r3, #2]
 800dd3c:	b21b      	sxth	r3, r3
 800dd3e:	2b00      	cmp	r3, #0
 800dd40:	da05      	bge.n	800dd4e <dispatcher_call+0x25a>
		se3_rand(SE3_IV_SIZE, resp_params.iv);
 800dd42:	69fb      	ldr	r3, [r7, #28]
 800dd44:	4619      	mov	r1, r3
 800dd46:	2010      	movs	r0, #16
 800dd48:	f002 fc60 	bl	801060c <se3_rand>
 800dd4c:	e005      	b.n	800dd5a <dispatcher_call+0x266>
	}
	else {
		memset(resp_params.iv, 0, SE3_IV_SIZE);
 800dd4e:	69fb      	ldr	r3, [r7, #28]
 800dd50:	2210      	movs	r2, #16
 800dd52:	2100      	movs	r1, #0
 800dd54:	4618      	mov	r0, r3
 800dd56:	f00d f94a 	bl	801afee <memset>
	}

	//Implementation choice, depended on the SEkey choice
	switch(algo_implementation){
 800dd5a:	4b19      	ldr	r3, [pc, #100]	; (800ddc0 <dispatcher_call+0x2cc>)
 800dd5c:	781b      	ldrb	r3, [r3, #0]
 800dd5e:	2b00      	cmp	r3, #0
 800dd60:	d11c      	bne.n	800dd9c <dispatcher_call+0x2a8>
	case SE3_SECURITY_CORE: se3_payload_encrypt(
 800dd62:	69b8      	ldr	r0, [r7, #24]
 800dd64:	69fc      	ldr	r4, [r7, #28]
 800dd66:	683b      	ldr	r3, [r7, #0]
 800dd68:	f103 0520 	add.w	r5, r3, #32
						&(login_struct.cryptoctx), resp_params.auth, resp_params.iv,
						resp + SE3_AUTH_SIZE + SE3_IV_SIZE, (*resp_size - SE3_AUTH_SIZE - SE3_IV_SIZE) / SE3_CRYPTOBLOCK_SIZE, req_hdr.cmd_flags, crypto_algo);
 800dd6c:	687b      	ldr	r3, [r7, #4]
 800dd6e:	881b      	ldrh	r3, [r3, #0]
 800dd70:	3b20      	subs	r3, #32
 800dd72:	2b00      	cmp	r3, #0
 800dd74:	da00      	bge.n	800dd78 <dispatcher_call+0x284>
 800dd76:	330f      	adds	r3, #15
 800dd78:	111b      	asrs	r3, r3, #4
	case SE3_SECURITY_CORE: se3_payload_encrypt(
 800dd7a:	b29b      	uxth	r3, r3
 800dd7c:	4a0d      	ldr	r2, [pc, #52]	; (800ddb4 <dispatcher_call+0x2c0>)
 800dd7e:	8852      	ldrh	r2, [r2, #2]
 800dd80:	490d      	ldr	r1, [pc, #52]	; (800ddb8 <dispatcher_call+0x2c4>)
 800dd82:	7809      	ldrb	r1, [r1, #0]
 800dd84:	9102      	str	r1, [sp, #8]
 800dd86:	9201      	str	r2, [sp, #4]
 800dd88:	9300      	str	r3, [sp, #0]
 800dd8a:	462b      	mov	r3, r5
 800dd8c:	4622      	mov	r2, r4
 800dd8e:	4601      	mov	r1, r0
 800dd90:	4807      	ldr	r0, [pc, #28]	; (800ddb0 <dispatcher_call+0x2bc>)
 800dd92:	f001 fe5a 	bl	800fa4a <se3_payload_encrypt>
						break;
 800dd96:	bf00      	nop
	case SE3_FPGA: //TODO: to be implemented

	default: return SE3_ERR_RESOURCE; break;
	}

    return SE3_OK;
 800dd98:	2300      	movs	r3, #0
 800dd9a:	e000      	b.n	800dd9e <dispatcher_call+0x2aa>
	default: return SE3_ERR_RESOURCE; break;
 800dd9c:	23c8      	movs	r3, #200	; 0xc8
}
 800dd9e:	4618      	mov	r0, r3
 800dda0:	3758      	adds	r7, #88	; 0x58
 800dda2:	46bd      	mov	sp, r7
 800dda4:	bdb0      	pop	{r4, r5, r7, pc}
 800dda6:	bf00      	nop
 800dda8:	2000485a 	.word	0x2000485a
 800ddac:	20004834 	.word	0x20004834
 800ddb0:	2000487c 	.word	0x2000487c
 800ddb4:	200045f4 	.word	0x200045f4
 800ddb8:	2000cd11 	.word	0x2000cd11
 800ddbc:	2000483a 	.word	0x2000483a
 800ddc0:	2000cd12 	.word	0x2000cd12
 800ddc4:	20000004 	.word	0x20000004
 800ddc8:	0800d389 	.word	0x0800d389

0800ddcc <se3_dispatcher_init>:

void se3_dispatcher_init()
{
 800ddcc:	b580      	push	{r7, lr}
 800ddce:	b082      	sub	sp, #8
 800ddd0:	af02      	add	r7, sp, #8
	se3_security_core_init();
 800ddd2:	f001 f89b 	bl	800ef0c <se3_security_core_init>

    memset(&login_struct, 0, sizeof(login_struct));
 800ddd6:	f240 42cc 	movw	r2, #1228	; 0x4cc
 800ddda:	2100      	movs	r1, #0
 800dddc:	4810      	ldr	r0, [pc, #64]	; (800de20 <se3_dispatcher_init+0x54>)
 800ddde:	f00d f906 	bl	801afee <memset>


    se3_security_info.records[SE3_RECORD_TYPE_USERPIN].read_access = SE3_ACCESS_MAX;
 800dde2:	4b10      	ldr	r3, [pc, #64]	; (800de24 <se3_dispatcher_init+0x58>)
 800dde4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800dde8:	809a      	strh	r2, [r3, #4]
    se3_security_info.records[SE3_RECORD_TYPE_USERPIN].write_access = SE3_ACCESS_ADMIN;
 800ddea:	4b0e      	ldr	r3, [pc, #56]	; (800de24 <se3_dispatcher_init+0x58>)
 800ddec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800ddf0:	80da      	strh	r2, [r3, #6]

    se3_security_info.records[SE3_RECORD_TYPE_ADMINPIN].read_access = SE3_ACCESS_MAX;
 800ddf2:	4b0c      	ldr	r3, [pc, #48]	; (800de24 <se3_dispatcher_init+0x58>)
 800ddf4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ddf8:	801a      	strh	r2, [r3, #0]
    se3_security_info.records[SE3_RECORD_TYPE_ADMINPIN].write_access = SE3_ACCESS_ADMIN;
 800ddfa:	4b0a      	ldr	r3, [pc, #40]	; (800de24 <se3_dispatcher_init+0x58>)
 800ddfc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800de00:	805a      	strh	r2, [r3, #2]

    se3_mem_init(
 800de02:	4b09      	ldr	r3, [pc, #36]	; (800de28 <se3_dispatcher_init+0x5c>)
 800de04:	9300      	str	r3, [sp, #0]
 800de06:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800de0a:	4a08      	ldr	r2, [pc, #32]	; (800de2c <se3_dispatcher_init+0x60>)
 800de0c:	2164      	movs	r1, #100	; 0x64
 800de0e:	4808      	ldr	r0, [pc, #32]	; (800de30 <se3_dispatcher_init+0x64>)
 800de10:	f000 fe3d 	bl	800ea8e <se3_mem_init>
        &(se3_security_info.sessions),
        SE3_SESSIONS_MAX, se3_sessions_index,
        SE3_SESSIONS_BUF, se3_sessions_buf);

    login_cleanup();
 800de14:	f000 f826 	bl	800de64 <login_cleanup>
}
 800de18:	bf00      	nop
 800de1a:	46bd      	mov	sp, r7
 800de1c:	bd80      	pop	{r7, pc}
 800de1e:	bf00      	nop
 800de20:	20004834 	.word	0x20004834
 800de24:	200004cc 	.word	0x200004cc
 800de28:	20004d00 	.word	0x20004d00
 800de2c:	200046a4 	.word	0x200046a4
 800de30:	200004d4 	.word	0x200004d4

0800de34 <set_req_hdr>:

void set_req_hdr(se3_comm_req_header req_hdr_i){
 800de34:	b084      	sub	sp, #16
 800de36:	b580      	push	{r7, lr}
 800de38:	af00      	add	r7, sp, #0
 800de3a:	f107 0c08 	add.w	ip, r7, #8
 800de3e:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	req_hdr = req_hdr_i;
 800de42:	4b07      	ldr	r3, [pc, #28]	; (800de60 <set_req_hdr+0x2c>)
 800de44:	4618      	mov	r0, r3
 800de46:	f107 0108 	add.w	r1, r7, #8
 800de4a:	2344      	movs	r3, #68	; 0x44
 800de4c:	461a      	mov	r2, r3
 800de4e:	f00d f8aa 	bl	801afa6 <memcpy>
}
 800de52:	bf00      	nop
 800de54:	46bd      	mov	sp, r7
 800de56:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800de5a:	b004      	add	sp, #16
 800de5c:	4770      	bx	lr
 800de5e:	bf00      	nop
 800de60:	200045f4 	.word	0x200045f4

0800de64 <login_cleanup>:

static void login_cleanup()
{
 800de64:	b5b0      	push	{r4, r5, r7, lr}
 800de66:	b082      	sub	sp, #8
 800de68:	af00      	add	r7, sp, #0
    size_t i;
    se3_mem_reset(&(se3_security_info.sessions));
 800de6a:	481f      	ldr	r0, [pc, #124]	; (800dee8 <login_cleanup+0x84>)
 800de6c:	f000 fdda 	bl	800ea24 <se3_mem_reset>
    login_struct.y = false;
 800de70:	4b1e      	ldr	r3, [pc, #120]	; (800deec <login_cleanup+0x88>)
 800de72:	2200      	movs	r2, #0
 800de74:	701a      	strb	r2, [r3, #0]
    login_struct.access = 0;
 800de76:	4b1d      	ldr	r3, [pc, #116]	; (800deec <login_cleanup+0x88>)
 800de78:	2200      	movs	r2, #0
 800de7a:	805a      	strh	r2, [r3, #2]
    login_struct.challenge_access = SE3_ACCESS_MAX;
 800de7c:	4b1b      	ldr	r3, [pc, #108]	; (800deec <login_cleanup+0x88>)
 800de7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800de82:	809a      	strh	r2, [r3, #4]
    login_struct.cryptoctx_initialized = false;
 800de84:	4b19      	ldr	r3, [pc, #100]	; (800deec <login_cleanup+0x88>)
 800de86:	2200      	movs	r2, #0
 800de88:	f883 24c8 	strb.w	r2, [r3, #1224]	; 0x4c8
    //memset(login.key, 0, SE3_KEY_SIZE);
    memcpy(login_struct.key, se3_magic, SE3_KEY_SIZE);
 800de8c:	4b17      	ldr	r3, [pc, #92]	; (800deec <login_cleanup+0x88>)
 800de8e:	4a18      	ldr	r2, [pc, #96]	; (800def0 <login_cleanup+0x8c>)
 800de90:	3326      	adds	r3, #38	; 0x26
 800de92:	6815      	ldr	r5, [r2, #0]
 800de94:	6854      	ldr	r4, [r2, #4]
 800de96:	6890      	ldr	r0, [r2, #8]
 800de98:	68d1      	ldr	r1, [r2, #12]
 800de9a:	601d      	str	r5, [r3, #0]
 800de9c:	605c      	str	r4, [r3, #4]
 800de9e:	6098      	str	r0, [r3, #8]
 800dea0:	60d9      	str	r1, [r3, #12]
 800dea2:	6915      	ldr	r5, [r2, #16]
 800dea4:	6954      	ldr	r4, [r2, #20]
 800dea6:	6990      	ldr	r0, [r2, #24]
 800dea8:	69d1      	ldr	r1, [r2, #28]
 800deaa:	611d      	str	r5, [r3, #16]
 800deac:	615c      	str	r4, [r3, #20]
 800deae:	6198      	str	r0, [r3, #24]
 800deb0:	61d9      	str	r1, [r3, #28]
    memset(login_struct.token, 0, SE3_TOKEN_SIZE);
 800deb2:	2210      	movs	r2, #16
 800deb4:	2100      	movs	r1, #0
 800deb6:	480f      	ldr	r0, [pc, #60]	; (800def4 <login_cleanup+0x90>)
 800deb8:	f00d f899 	bl	801afee <memset>
    for (i = 0; i < SE3_SESSIONS_MAX; i++) {
 800debc:	2300      	movs	r3, #0
 800debe:	607b      	str	r3, [r7, #4]
 800dec0:	e00a      	b.n	800ded8 <login_cleanup+0x74>
        se3_security_info.sessions_algo[i] = SE3_ALGO_INVALID;
 800dec2:	4a0d      	ldr	r2, [pc, #52]	; (800def8 <login_cleanup+0x94>)
 800dec4:	687b      	ldr	r3, [r7, #4]
 800dec6:	330c      	adds	r3, #12
 800dec8:	005b      	lsls	r3, r3, #1
 800deca:	4413      	add	r3, r2
 800decc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ded0:	809a      	strh	r2, [r3, #4]
    for (i = 0; i < SE3_SESSIONS_MAX; i++) {
 800ded2:	687b      	ldr	r3, [r7, #4]
 800ded4:	3301      	adds	r3, #1
 800ded6:	607b      	str	r3, [r7, #4]
 800ded8:	687b      	ldr	r3, [r7, #4]
 800deda:	2b63      	cmp	r3, #99	; 0x63
 800dedc:	d9f1      	bls.n	800dec2 <login_cleanup+0x5e>
    }

}
 800dede:	bf00      	nop
 800dee0:	3708      	adds	r7, #8
 800dee2:	46bd      	mov	sp, r7
 800dee4:	bdb0      	pop	{r4, r5, r7, pc}
 800dee6:	bf00      	nop
 800dee8:	200004d4 	.word	0x200004d4
 800deec:	20004834 	.word	0x20004834
 800def0:	0801e028 	.word	0x0801e028
 800def4:	2000483a 	.word	0x2000483a
 800def8:	200004cc 	.word	0x200004cc

0800defc <flash_fill>:
#include "se3_common.h"

SE3_FLASH_INFO flash;

static bool flash_fill(uint32_t addr, uint8_t val, size_t size)
{
 800defc:	b590      	push	{r4, r7, lr}
 800defe:	b087      	sub	sp, #28
 800df00:	af00      	add	r7, sp, #0
 800df02:	60f8      	str	r0, [r7, #12]
 800df04:	460b      	mov	r3, r1
 800df06:	607a      	str	r2, [r7, #4]
 800df08:	72fb      	strb	r3, [r7, #11]
	bool success = true;
 800df0a:	2301      	movs	r3, #1
 800df0c:	75fb      	strb	r3, [r7, #23]
	HAL_FLASH_Unlock();
 800df0e:	f004 f9ff 	bl	8012310 <HAL_FLASH_Unlock>
	while (size) {
 800df12:	e017      	b.n	800df44 <flash_fill+0x48>
		if (HAL_OK != HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, addr, (uint64_t)val)) {
 800df14:	7afb      	ldrb	r3, [r7, #11]
 800df16:	f04f 0400 	mov.w	r4, #0
 800df1a:	461a      	mov	r2, r3
 800df1c:	4623      	mov	r3, r4
 800df1e:	68f9      	ldr	r1, [r7, #12]
 800df20:	2000      	movs	r0, #0
 800df22:	f004 f9a1 	bl	8012268 <HAL_FLASH_Program>
 800df26:	4603      	mov	r3, r0
 800df28:	2b00      	cmp	r3, #0
 800df2a:	d005      	beq.n	800df38 <flash_fill+0x3c>
			success = false;
 800df2c:	2300      	movs	r3, #0
 800df2e:	75fb      	strb	r3, [r7, #23]
            hwerror = true;
 800df30:	4b09      	ldr	r3, [pc, #36]	; (800df58 <flash_fill+0x5c>)
 800df32:	2201      	movs	r2, #1
 800df34:	801a      	strh	r2, [r3, #0]
			break;
 800df36:	e008      	b.n	800df4a <flash_fill+0x4e>
		}
		size--;
 800df38:	687b      	ldr	r3, [r7, #4]
 800df3a:	3b01      	subs	r3, #1
 800df3c:	607b      	str	r3, [r7, #4]
		addr++;
 800df3e:	68fb      	ldr	r3, [r7, #12]
 800df40:	3301      	adds	r3, #1
 800df42:	60fb      	str	r3, [r7, #12]
	while (size) {
 800df44:	687b      	ldr	r3, [r7, #4]
 800df46:	2b00      	cmp	r3, #0
 800df48:	d1e4      	bne.n	800df14 <flash_fill+0x18>
	}
	HAL_FLASH_Lock();
 800df4a:	f004 f9fb 	bl	8012344 <HAL_FLASH_Lock>
	return success;
 800df4e:	7dfb      	ldrb	r3, [r7, #23]
}
 800df50:	4618      	mov	r0, r3
 800df52:	371c      	adds	r7, #28
 800df54:	46bd      	mov	sp, r7
 800df56:	bd90      	pop	{r4, r7, pc}
 800df58:	200004a0 	.word	0x200004a0

0800df5c <flash_zero>:

static bool flash_zero(uint32_t addr, size_t size)
{
 800df5c:	b580      	push	{r7, lr}
 800df5e:	b084      	sub	sp, #16
 800df60:	af00      	add	r7, sp, #0
 800df62:	6078      	str	r0, [r7, #4]
 800df64:	6039      	str	r1, [r7, #0]
	bool success = true;
 800df66:	2301      	movs	r3, #1
 800df68:	73fb      	strb	r3, [r7, #15]
	HAL_FLASH_Unlock();
 800df6a:	f004 f9d1 	bl	8012310 <HAL_FLASH_Unlock>
	while (size) {
 800df6e:	e016      	b.n	800df9e <flash_zero+0x42>
		if (HAL_OK != HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, addr, 0)) {
 800df70:	f04f 0200 	mov.w	r2, #0
 800df74:	f04f 0300 	mov.w	r3, #0
 800df78:	6879      	ldr	r1, [r7, #4]
 800df7a:	2000      	movs	r0, #0
 800df7c:	f004 f974 	bl	8012268 <HAL_FLASH_Program>
 800df80:	4603      	mov	r3, r0
 800df82:	2b00      	cmp	r3, #0
 800df84:	d005      	beq.n	800df92 <flash_zero+0x36>
			success = false;
 800df86:	2300      	movs	r3, #0
 800df88:	73fb      	strb	r3, [r7, #15]
            hwerror = true;
 800df8a:	4b0a      	ldr	r3, [pc, #40]	; (800dfb4 <flash_zero+0x58>)
 800df8c:	2201      	movs	r2, #1
 800df8e:	801a      	strh	r2, [r3, #0]
			break;
 800df90:	e008      	b.n	800dfa4 <flash_zero+0x48>
		}
		size--;
 800df92:	683b      	ldr	r3, [r7, #0]
 800df94:	3b01      	subs	r3, #1
 800df96:	603b      	str	r3, [r7, #0]
		addr++;
 800df98:	687b      	ldr	r3, [r7, #4]
 800df9a:	3301      	adds	r3, #1
 800df9c:	607b      	str	r3, [r7, #4]
	while (size) {
 800df9e:	683b      	ldr	r3, [r7, #0]
 800dfa0:	2b00      	cmp	r3, #0
 800dfa2:	d1e5      	bne.n	800df70 <flash_zero+0x14>
	}
	HAL_FLASH_Lock();
 800dfa4:	f004 f9ce 	bl	8012344 <HAL_FLASH_Lock>
	return success;
 800dfa8:	7bfb      	ldrb	r3, [r7, #15]
}
 800dfaa:	4618      	mov	r0, r3
 800dfac:	3710      	adds	r7, #16
 800dfae:	46bd      	mov	sp, r7
 800dfb0:	bd80      	pop	{r7, pc}
 800dfb2:	bf00      	nop
 800dfb4:	200004a0 	.word	0x200004a0

0800dfb8 <flash_program>:

static bool flash_program(uint32_t addr, const uint8_t* data, size_t size)
{
 800dfb8:	b590      	push	{r4, r7, lr}
 800dfba:	b087      	sub	sp, #28
 800dfbc:	af00      	add	r7, sp, #0
 800dfbe:	60f8      	str	r0, [r7, #12]
 800dfc0:	60b9      	str	r1, [r7, #8]
 800dfc2:	607a      	str	r2, [r7, #4]
	bool success = true;
 800dfc4:	2301      	movs	r3, #1
 800dfc6:	75fb      	strb	r3, [r7, #23]
	HAL_FLASH_Unlock();
 800dfc8:	f004 f9a2 	bl	8012310 <HAL_FLASH_Unlock>
	while (size) {
 800dfcc:	e019      	b.n	800e002 <flash_program+0x4a>
		if (HAL_OK != HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, addr, (uint64_t)*data)) {
 800dfce:	68bb      	ldr	r3, [r7, #8]
 800dfd0:	781b      	ldrb	r3, [r3, #0]
 800dfd2:	b2db      	uxtb	r3, r3
 800dfd4:	f04f 0400 	mov.w	r4, #0
 800dfd8:	461a      	mov	r2, r3
 800dfda:	4623      	mov	r3, r4
 800dfdc:	68f9      	ldr	r1, [r7, #12]
 800dfde:	2000      	movs	r0, #0
 800dfe0:	f004 f942 	bl	8012268 <HAL_FLASH_Program>
 800dfe4:	4603      	mov	r3, r0
 800dfe6:	2b00      	cmp	r3, #0
 800dfe8:	d002      	beq.n	800dff0 <flash_program+0x38>
			success = false;
 800dfea:	2300      	movs	r3, #0
 800dfec:	75fb      	strb	r3, [r7, #23]
			break;
 800dfee:	e00b      	b.n	800e008 <flash_program+0x50>
		}
		size--;
 800dff0:	687b      	ldr	r3, [r7, #4]
 800dff2:	3b01      	subs	r3, #1
 800dff4:	607b      	str	r3, [r7, #4]
		addr++;
 800dff6:	68fb      	ldr	r3, [r7, #12]
 800dff8:	3301      	adds	r3, #1
 800dffa:	60fb      	str	r3, [r7, #12]
		data++;
 800dffc:	68bb      	ldr	r3, [r7, #8]
 800dffe:	3301      	adds	r3, #1
 800e000:	60bb      	str	r3, [r7, #8]
	while (size) {
 800e002:	687b      	ldr	r3, [r7, #4]
 800e004:	2b00      	cmp	r3, #0
 800e006:	d1e2      	bne.n	800dfce <flash_program+0x16>
	}
	HAL_FLASH_Lock();
 800e008:	f004 f99c 	bl	8012344 <HAL_FLASH_Lock>
    if (!success) {
 800e00c:	7dfb      	ldrb	r3, [r7, #23]
 800e00e:	f083 0301 	eor.w	r3, r3, #1
 800e012:	b2db      	uxtb	r3, r3
 800e014:	2b00      	cmp	r3, #0
 800e016:	d002      	beq.n	800e01e <flash_program+0x66>
        hwerror = true;
 800e018:	4b03      	ldr	r3, [pc, #12]	; (800e028 <flash_program+0x70>)
 800e01a:	2201      	movs	r2, #1
 800e01c:	801a      	strh	r2, [r3, #0]
    }
	return success;
 800e01e:	7dfb      	ldrb	r3, [r7, #23]
}
 800e020:	4618      	mov	r0, r3
 800e022:	371c      	adds	r7, #28
 800e024:	46bd      	mov	sp, r7
 800e026:	bd90      	pop	{r4, r7, pc}
 800e028:	200004a0 	.word	0x200004a0

0800e02c <flash_erase>:

static bool flash_erase(uint32_t sector) {
 800e02c:	b580      	push	{r7, lr}
 800e02e:	b08a      	sub	sp, #40	; 0x28
 800e030:	af00      	add	r7, sp, #0
 800e032:	6078      	str	r0, [r7, #4]
    bool success = true;
 800e034:	2301      	movs	r3, #1
 800e036:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
#else
	FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SectorError;
	HAL_StatusTypeDef result;
	
	HAL_FLASH_Unlock();
 800e03a:	f004 f969 	bl	8012310 <HAL_FLASH_Unlock>

	EraseInitStruct.TypeErase = FLASH_TYPEERASE_SECTORS;
 800e03e:	2300      	movs	r3, #0
 800e040:	613b      	str	r3, [r7, #16]
	EraseInitStruct.VoltageRange = FLASH_VOLTAGE_RANGE_3;
 800e042:	2302      	movs	r3, #2
 800e044:	623b      	str	r3, [r7, #32]
	EraseInitStruct.Sector = sector;
 800e046:	687b      	ldr	r3, [r7, #4]
 800e048:	61bb      	str	r3, [r7, #24]
	EraseInitStruct.NbSectors = 1;
 800e04a:	2301      	movs	r3, #1
 800e04c:	61fb      	str	r3, [r7, #28]
	result = HAL_FLASHEx_Erase(&EraseInitStruct, (uint32_t*)&SectorError);
 800e04e:	f107 020c 	add.w	r2, r7, #12
 800e052:	f107 0310 	add.w	r3, r7, #16
 800e056:	4611      	mov	r1, r2
 800e058:	4618      	mov	r0, r3
 800e05a:	f004 fab9 	bl	80125d0 <HAL_FLASHEx_Erase>
 800e05e:	4603      	mov	r3, r0
 800e060:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	if (result != HAL_OK){
 800e064:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800e068:	2b00      	cmp	r3, #0
 800e06a:	d005      	beq.n	800e078 <flash_erase+0x4c>
        success = false;
 800e06c:	2300      	movs	r3, #0
 800e06e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        hwerror = true;
 800e072:	4b05      	ldr	r3, [pc, #20]	; (800e088 <flash_erase+0x5c>)
 800e074:	2201      	movs	r2, #1
 800e076:	801a      	strh	r2, [r3, #0]
    }
	HAL_FLASH_Lock();
 800e078:	f004 f964 	bl	8012344 <HAL_FLASH_Lock>
#endif
    return success;
 800e07c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 800e080:	4618      	mov	r0, r3
 800e082:	3728      	adds	r7, #40	; 0x28
 800e084:	46bd      	mov	sp, r7
 800e086:	bd80      	pop	{r7, pc}
 800e088:	200004a0 	.word	0x200004a0

0800e08c <flash_swap>:

static bool flash_swap()
{
 800e08c:	b580      	push	{r7, lr}
 800e08e:	b08c      	sub	sp, #48	; 0x30
 800e090:	af00      	add	r7, sp, #0
	size_t other_pos;

	size_t n;
	bool success, b;
	se3_flash_it it;
	if (flash.sector == SE3_FLASH_S0) {
 800e092:	4b6b      	ldr	r3, [pc, #428]	; (800e240 <flash_swap+0x1b4>)
 800e094:	681b      	ldr	r3, [r3, #0]
 800e096:	2b0a      	cmp	r3, #10
 800e098:	d104      	bne.n	800e0a4 <flash_swap+0x18>
		other = SE3_FLASH_S1;
 800e09a:	230b      	movs	r3, #11
 800e09c:	62fb      	str	r3, [r7, #44]	; 0x2c
		other_base = SE3_FLASH_S1_ADDR;
 800e09e:	4b69      	ldr	r3, [pc, #420]	; (800e244 <flash_swap+0x1b8>)
 800e0a0:	62bb      	str	r3, [r7, #40]	; 0x28
 800e0a2:	e00a      	b.n	800e0ba <flash_swap+0x2e>
	}
	else if (flash.sector == SE3_FLASH_S1) {
 800e0a4:	4b66      	ldr	r3, [pc, #408]	; (800e240 <flash_swap+0x1b4>)
 800e0a6:	681b      	ldr	r3, [r3, #0]
 800e0a8:	2b0b      	cmp	r3, #11
 800e0aa:	d104      	bne.n	800e0b6 <flash_swap+0x2a>
		other = SE3_FLASH_S0;
 800e0ac:	230a      	movs	r3, #10
 800e0ae:	62fb      	str	r3, [r7, #44]	; 0x2c
		other_base = SE3_FLASH_S0_ADDR;
 800e0b0:	4b65      	ldr	r3, [pc, #404]	; (800e248 <flash_swap+0x1bc>)
 800e0b2:	62bb      	str	r3, [r7, #40]	; 0x28
 800e0b4:	e001      	b.n	800e0ba <flash_swap+0x2e>
	}
	else {
		return false;
 800e0b6:	2300      	movs	r3, #0
 800e0b8:	e0bd      	b.n	800e236 <flash_swap+0x1aa>
	}
	other_index = other_base + SE3_FLASH_MAGIC_SIZE;
 800e0ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e0bc:	3320      	adds	r3, #32
 800e0be:	61bb      	str	r3, [r7, #24]
	//erase other sector
	flash_erase(other);
 800e0c0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800e0c2:	f7ff ffb3 	bl	800e02c <flash_erase>
	//zero non-programmed slots in index table (first_free_pos to end)
	if (flash.first_free_pos < SE3_FLASH_INDEX_SIZE) {
 800e0c6:	4b5e      	ldr	r3, [pc, #376]	; (800e240 <flash_swap+0x1b4>)
 800e0c8:	691b      	ldr	r3, [r3, #16]
 800e0ca:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e0ce:	d20e      	bcs.n	800e0ee <flash_swap+0x62>
		n = SE3_FLASH_INDEX_SIZE - flash.first_free_pos;
 800e0d0:	4b5b      	ldr	r3, [pc, #364]	; (800e240 <flash_swap+0x1b4>)
 800e0d2:	691b      	ldr	r3, [r3, #16]
 800e0d4:	f5c3 63fc 	rsb	r3, r3, #2016	; 0x7e0
 800e0d8:	617b      	str	r3, [r7, #20]
		flash_zero((uint32_t)flash.index + flash.first_free_pos, n);
 800e0da:	4b59      	ldr	r3, [pc, #356]	; (800e240 <flash_swap+0x1b4>)
 800e0dc:	689b      	ldr	r3, [r3, #8]
 800e0de:	461a      	mov	r2, r3
 800e0e0:	4b57      	ldr	r3, [pc, #348]	; (800e240 <flash_swap+0x1b4>)
 800e0e2:	691b      	ldr	r3, [r3, #16]
 800e0e4:	4413      	add	r3, r2
 800e0e6:	6979      	ldr	r1, [r7, #20]
 800e0e8:	4618      	mov	r0, r3
 800e0ea:	f7ff ff37 	bl	800df5c <flash_zero>
	}

	//copy good blocks to other sector
	success = true;
 800e0ee:	2301      	movs	r3, #1
 800e0f0:	77fb      	strb	r3, [r7, #31]
	other_used = SE3_FLASH_MAGIC_SIZE + SE3_FLASH_INDEX_SIZE;
 800e0f2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800e0f6:	627b      	str	r3, [r7, #36]	; 0x24
	other_pos = 0;
 800e0f8:	2300      	movs	r3, #0
 800e0fa:	623b      	str	r3, [r7, #32]
	se3_flash_it_init(&it);	
 800e0fc:	463b      	mov	r3, r7
 800e0fe:	4618      	mov	r0, r3
 800e100:	f000 f995 	bl	800e42e <se3_flash_it_init>
	while (se3_flash_it_next(&it)) {
 800e104:	e051      	b.n	800e1aa <flash_swap+0x11e>
		if (it.type != SE3_FLASH_TYPE_INVALID) {
 800e106:	793b      	ldrb	r3, [r7, #4]
 800e108:	2b00      	cmp	r3, #0
 800e10a:	d04e      	beq.n	800e1aa <flash_swap+0x11e>
			//copy data
			b = flash_program(
 800e10c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e10e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e110:	18d0      	adds	r0, r2, r3
				other_base + other_used, 
				flash.data + it.pos*SE3_FLASH_BLOCK_SIZE,
 800e112:	4b4b      	ldr	r3, [pc, #300]	; (800e240 <flash_swap+0x1b4>)
 800e114:	68da      	ldr	r2, [r3, #12]
 800e116:	68fb      	ldr	r3, [r7, #12]
 800e118:	019b      	lsls	r3, r3, #6
			b = flash_program(
 800e11a:	4413      	add	r3, r2
				it.blocks*SE3_FLASH_BLOCK_SIZE
 800e11c:	893a      	ldrh	r2, [r7, #8]
 800e11e:	0192      	lsls	r2, r2, #6
			b = flash_program(
 800e120:	4619      	mov	r1, r3
 800e122:	f7ff ff49 	bl	800dfb8 <flash_program>
 800e126:	4603      	mov	r3, r0
 800e128:	74fb      	strb	r3, [r7, #19]
			);
			if (!b) {
 800e12a:	7cfb      	ldrb	r3, [r7, #19]
 800e12c:	f083 0301 	eor.w	r3, r3, #1
 800e130:	b2db      	uxtb	r3, r3
 800e132:	2b00      	cmp	r3, #0
 800e134:	d002      	beq.n	800e13c <flash_swap+0xb0>
				success = false; break;
 800e136:	2300      	movs	r3, #0
 800e138:	77fb      	strb	r3, [r7, #31]
 800e13a:	e03d      	b.n	800e1b8 <flash_swap+0x12c>
			}

			//write index
			b = flash_program(other_index + other_pos, &(it.type), 1);
 800e13c:	69ba      	ldr	r2, [r7, #24]
 800e13e:	6a3b      	ldr	r3, [r7, #32]
 800e140:	18d0      	adds	r0, r2, r3
 800e142:	463b      	mov	r3, r7
 800e144:	3304      	adds	r3, #4
 800e146:	2201      	movs	r2, #1
 800e148:	4619      	mov	r1, r3
 800e14a:	f7ff ff35 	bl	800dfb8 <flash_program>
 800e14e:	4603      	mov	r3, r0
 800e150:	74fb      	strb	r3, [r7, #19]
			if (!b) {
 800e152:	7cfb      	ldrb	r3, [r7, #19]
 800e154:	f083 0301 	eor.w	r3, r3, #1
 800e158:	b2db      	uxtb	r3, r3
 800e15a:	2b00      	cmp	r3, #0
 800e15c:	d002      	beq.n	800e164 <flash_swap+0xd8>
				success = false; break;
 800e15e:	2300      	movs	r3, #0
 800e160:	77fb      	strb	r3, [r7, #31]
 800e162:	e029      	b.n	800e1b8 <flash_swap+0x12c>
			}
			if (it.blocks > 1) {
 800e164:	893b      	ldrh	r3, [r7, #8]
 800e166:	2b01      	cmp	r3, #1
 800e168:	d914      	bls.n	800e194 <flash_swap+0x108>
				b = flash_fill(other_index + other_pos + 1, 0xFE, it.blocks - 1);
 800e16a:	69ba      	ldr	r2, [r7, #24]
 800e16c:	6a3b      	ldr	r3, [r7, #32]
 800e16e:	4413      	add	r3, r2
 800e170:	3301      	adds	r3, #1
 800e172:	893a      	ldrh	r2, [r7, #8]
 800e174:	3a01      	subs	r2, #1
 800e176:	21fe      	movs	r1, #254	; 0xfe
 800e178:	4618      	mov	r0, r3
 800e17a:	f7ff febf 	bl	800defc <flash_fill>
 800e17e:	4603      	mov	r3, r0
 800e180:	74fb      	strb	r3, [r7, #19]
				if (!b) {
 800e182:	7cfb      	ldrb	r3, [r7, #19]
 800e184:	f083 0301 	eor.w	r3, r3, #1
 800e188:	b2db      	uxtb	r3, r3
 800e18a:	2b00      	cmp	r3, #0
 800e18c:	d002      	beq.n	800e194 <flash_swap+0x108>
					success = false; break;
 800e18e:	2300      	movs	r3, #0
 800e190:	77fb      	strb	r3, [r7, #31]
 800e192:	e011      	b.n	800e1b8 <flash_swap+0x12c>
				}
			}

			other_used += it.blocks*SE3_FLASH_BLOCK_SIZE;
 800e194:	893b      	ldrh	r3, [r7, #8]
 800e196:	019b      	lsls	r3, r3, #6
 800e198:	461a      	mov	r2, r3
 800e19a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e19c:	4413      	add	r3, r2
 800e19e:	627b      	str	r3, [r7, #36]	; 0x24
			other_pos += it.blocks;
 800e1a0:	893b      	ldrh	r3, [r7, #8]
 800e1a2:	461a      	mov	r2, r3
 800e1a4:	6a3b      	ldr	r3, [r7, #32]
 800e1a6:	4413      	add	r3, r2
 800e1a8:	623b      	str	r3, [r7, #32]
	while (se3_flash_it_next(&it)) {
 800e1aa:	463b      	mov	r3, r7
 800e1ac:	4618      	mov	r0, r3
 800e1ae:	f000 f94b 	bl	800e448 <se3_flash_it_next>
 800e1b2:	4603      	mov	r3, r0
 800e1b4:	2b00      	cmp	r3, #0
 800e1b6:	d1a6      	bne.n	800e106 <flash_swap+0x7a>
		}
	}
	if (!success) {
 800e1b8:	7ffb      	ldrb	r3, [r7, #31]
 800e1ba:	f083 0301 	eor.w	r3, r3, #1
 800e1be:	b2db      	uxtb	r3, r3
 800e1c0:	2b00      	cmp	r3, #0
 800e1c2:	d001      	beq.n	800e1c8 <flash_swap+0x13c>
		return false;
 800e1c4:	2300      	movs	r3, #0
 800e1c6:	e036      	b.n	800e236 <flash_swap+0x1aa>
	}

	//write magic to other sector
	if (!flash_program(other_base, se3_magic, SE3_FLASH_MAGIC_SIZE)) {
 800e1c8:	2220      	movs	r2, #32
 800e1ca:	4920      	ldr	r1, [pc, #128]	; (800e24c <flash_swap+0x1c0>)
 800e1cc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e1ce:	f7ff fef3 	bl	800dfb8 <flash_program>
 800e1d2:	4603      	mov	r3, r0
 800e1d4:	f083 0301 	eor.w	r3, r3, #1
 800e1d8:	b2db      	uxtb	r3, r3
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d001      	beq.n	800e1e2 <flash_swap+0x156>
		return false;
 800e1de:	2300      	movs	r3, #0
 800e1e0:	e029      	b.n	800e236 <flash_swap+0x1aa>
	}

	//clear magic from this sector
	if (!flash_zero((uint32_t)flash.base, 1)) {
 800e1e2:	4b17      	ldr	r3, [pc, #92]	; (800e240 <flash_swap+0x1b4>)
 800e1e4:	685b      	ldr	r3, [r3, #4]
 800e1e6:	2101      	movs	r1, #1
 800e1e8:	4618      	mov	r0, r3
 800e1ea:	f7ff feb7 	bl	800df5c <flash_zero>
 800e1ee:	4603      	mov	r3, r0
 800e1f0:	f083 0301 	eor.w	r3, r3, #1
 800e1f4:	b2db      	uxtb	r3, r3
 800e1f6:	2b00      	cmp	r3, #0
 800e1f8:	d001      	beq.n	800e1fe <flash_swap+0x172>
		return false;
 800e1fa:	2300      	movs	r3, #0
 800e1fc:	e01b      	b.n	800e236 <flash_swap+0x1aa>
	}

	//swap sectors
	flash.base = (uint8_t*)other_base;
 800e1fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e200:	4a0f      	ldr	r2, [pc, #60]	; (800e240 <flash_swap+0x1b4>)
 800e202:	6053      	str	r3, [r2, #4]
    flash.sector = other;
 800e204:	4a0e      	ldr	r2, [pc, #56]	; (800e240 <flash_swap+0x1b4>)
 800e206:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e208:	6013      	str	r3, [r2, #0]
    flash.index = flash.base + SE3_FLASH_MAGIC_SIZE;
 800e20a:	4b0d      	ldr	r3, [pc, #52]	; (800e240 <flash_swap+0x1b4>)
 800e20c:	685b      	ldr	r3, [r3, #4]
 800e20e:	3320      	adds	r3, #32
 800e210:	4a0b      	ldr	r2, [pc, #44]	; (800e240 <flash_swap+0x1b4>)
 800e212:	6093      	str	r3, [r2, #8]
    flash.data = flash.index + SE3_FLASH_INDEX_SIZE;
 800e214:	4b0a      	ldr	r3, [pc, #40]	; (800e240 <flash_swap+0x1b4>)
 800e216:	689b      	ldr	r3, [r3, #8]
 800e218:	f503 63fc 	add.w	r3, r3, #2016	; 0x7e0
 800e21c:	4a08      	ldr	r2, [pc, #32]	; (800e240 <flash_swap+0x1b4>)
 800e21e:	60d3      	str	r3, [r2, #12]
    flash.allocated = flash.used = other_used;
 800e220:	4a07      	ldr	r2, [pc, #28]	; (800e240 <flash_swap+0x1b4>)
 800e222:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e224:	6153      	str	r3, [r2, #20]
 800e226:	4b06      	ldr	r3, [pc, #24]	; (800e240 <flash_swap+0x1b4>)
 800e228:	695b      	ldr	r3, [r3, #20]
 800e22a:	4a05      	ldr	r2, [pc, #20]	; (800e240 <flash_swap+0x1b4>)
 800e22c:	6193      	str	r3, [r2, #24]
    flash.first_free_pos = other_pos;
 800e22e:	4a04      	ldr	r2, [pc, #16]	; (800e240 <flash_swap+0x1b4>)
 800e230:	6a3b      	ldr	r3, [r7, #32]
 800e232:	6113      	str	r3, [r2, #16]

	return true;
 800e234:	2301      	movs	r3, #1
}
 800e236:	4618      	mov	r0, r3
 800e238:	3730      	adds	r7, #48	; 0x30
 800e23a:	46bd      	mov	sp, r7
 800e23c:	bd80      	pop	{r7, pc}
 800e23e:	bf00      	nop
 800e240:	2000cd14 	.word	0x2000cd14
 800e244:	080e0000 	.word	0x080e0000
 800e248:	080c0000 	.word	0x080c0000
 800e24c:	0801e028 	.word	0x0801e028

0800e250 <se3_flash_info_setup>:

void se3_flash_info_setup(uint32_t sector, const uint8_t* base)
{
 800e250:	b480      	push	{r7}
 800e252:	b083      	sub	sp, #12
 800e254:	af00      	add	r7, sp, #0
 800e256:	6078      	str	r0, [r7, #4]
 800e258:	6039      	str	r1, [r7, #0]
	flash.base = base;
 800e25a:	4a11      	ldr	r2, [pc, #68]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e25c:	683b      	ldr	r3, [r7, #0]
 800e25e:	6053      	str	r3, [r2, #4]
    flash.sector = sector;
 800e260:	4a0f      	ldr	r2, [pc, #60]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e262:	687b      	ldr	r3, [r7, #4]
 800e264:	6013      	str	r3, [r2, #0]
    flash.index = flash.base + SE3_FLASH_MAGIC_SIZE;
 800e266:	4b0e      	ldr	r3, [pc, #56]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e268:	685b      	ldr	r3, [r3, #4]
 800e26a:	3320      	adds	r3, #32
 800e26c:	4a0c      	ldr	r2, [pc, #48]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e26e:	6093      	str	r3, [r2, #8]
    flash.data = flash.index + SE3_FLASH_INDEX_SIZE;
 800e270:	4b0b      	ldr	r3, [pc, #44]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e272:	689b      	ldr	r3, [r3, #8]
 800e274:	f503 63fc 	add.w	r3, r3, #2016	; 0x7e0
 800e278:	4a09      	ldr	r2, [pc, #36]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e27a:	60d3      	str	r3, [r2, #12]
    flash.allocated = flash.used = SE3_FLASH_MAGIC_SIZE + SE3_FLASH_INDEX_SIZE;
 800e27c:	4b08      	ldr	r3, [pc, #32]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e27e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800e282:	615a      	str	r2, [r3, #20]
 800e284:	4b06      	ldr	r3, [pc, #24]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e286:	695b      	ldr	r3, [r3, #20]
 800e288:	4a05      	ldr	r2, [pc, #20]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e28a:	6193      	str	r3, [r2, #24]
    flash.first_free_pos = 0;
 800e28c:	4b04      	ldr	r3, [pc, #16]	; (800e2a0 <se3_flash_info_setup+0x50>)
 800e28e:	2200      	movs	r2, #0
 800e290:	611a      	str	r2, [r3, #16]
}
 800e292:	bf00      	nop
 800e294:	370c      	adds	r7, #12
 800e296:	46bd      	mov	sp, r7
 800e298:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e29c:	4770      	bx	lr
 800e29e:	bf00      	nop
 800e2a0:	2000cd14 	.word	0x2000cd14

0800e2a4 <se3_flash_init>:
	size_t size_on_flash = size + 2;
	return (size_on_flash <= (SE3_FLASH_SECTOR_SIZE - flash.used));
}

bool se3_flash_init()
{
 800e2a4:	b5b0      	push	{r4, r5, r7, lr}
 800e2a6:	b088      	sub	sp, #32
 800e2a8:	af00      	add	r7, sp, #0
	uint8_t* base;
	uint32_t sector;
	//uint16_t record_key;

	// check for flash magic
	bool magic0 = !memcmp((void*)SE3_FLASH_S0_ADDR, se3_magic, SE3_FLASH_MAGIC_SIZE);
 800e2aa:	2220      	movs	r2, #32
 800e2ac:	4948      	ldr	r1, [pc, #288]	; (800e3d0 <se3_flash_init+0x12c>)
 800e2ae:	4849      	ldr	r0, [pc, #292]	; (800e3d4 <se3_flash_init+0x130>)
 800e2b0:	f00c fe6a 	bl	801af88 <memcmp>
 800e2b4:	4603      	mov	r3, r0
 800e2b6:	2b00      	cmp	r3, #0
 800e2b8:	bf0c      	ite	eq
 800e2ba:	2301      	moveq	r3, #1
 800e2bc:	2300      	movne	r3, #0
 800e2be:	75fb      	strb	r3, [r7, #23]
	bool magic1 = !memcmp((void*)SE3_FLASH_S1_ADDR, se3_magic, SE3_FLASH_MAGIC_SIZE);
 800e2c0:	2220      	movs	r2, #32
 800e2c2:	4943      	ldr	r1, [pc, #268]	; (800e3d0 <se3_flash_init+0x12c>)
 800e2c4:	4844      	ldr	r0, [pc, #272]	; (800e3d8 <se3_flash_init+0x134>)
 800e2c6:	f00c fe5f 	bl	801af88 <memcmp>
 800e2ca:	4603      	mov	r3, r0
 800e2cc:	2b00      	cmp	r3, #0
 800e2ce:	bf0c      	ite	eq
 800e2d0:	2301      	moveq	r3, #1
 800e2d2:	2300      	movne	r3, #0
 800e2d4:	75bb      	strb	r3, [r7, #22]
	
	//choose active sector
	if (magic0 && magic1) {
 800e2d6:	7dfb      	ldrb	r3, [r7, #23]
 800e2d8:	2b00      	cmp	r3, #0
 800e2da:	d013      	beq.n	800e304 <se3_flash_init+0x60>
 800e2dc:	7dbb      	ldrb	r3, [r7, #22]
 800e2de:	2b00      	cmp	r3, #0
 800e2e0:	d010      	beq.n	800e304 <se3_flash_init+0x60>
		//both marked, the one with last index programmed should be deleted
		if (0xFF == *((uint8_t*)(SE3_FLASH_S1_ADDR + SE3_FLASH_MAGIC_SIZE + SE3_FLASH_INDEX_SIZE - 1))){
 800e2e2:	4b3e      	ldr	r3, [pc, #248]	; (800e3dc <se3_flash_init+0x138>)
 800e2e4:	781b      	ldrb	r3, [r3, #0]
 800e2e6:	2bff      	cmp	r3, #255	; 0xff
 800e2e8:	d106      	bne.n	800e2f8 <se3_flash_init+0x54>
			magic0 = false;
 800e2ea:	2300      	movs	r3, #0
 800e2ec:	75fb      	strb	r3, [r7, #23]
			flash_zero(SE3_FLASH_S0_ADDR, 1);
 800e2ee:	2101      	movs	r1, #1
 800e2f0:	4838      	ldr	r0, [pc, #224]	; (800e3d4 <se3_flash_init+0x130>)
 800e2f2:	f7ff fe33 	bl	800df5c <flash_zero>
 800e2f6:	e005      	b.n	800e304 <se3_flash_init+0x60>
		}
		else {
			magic1 = false;
 800e2f8:	2300      	movs	r3, #0
 800e2fa:	75bb      	strb	r3, [r7, #22]
			flash_zero(SE3_FLASH_S1_ADDR, 1);
 800e2fc:	2101      	movs	r1, #1
 800e2fe:	4836      	ldr	r0, [pc, #216]	; (800e3d8 <se3_flash_init+0x134>)
 800e300:	f7ff fe2c 	bl	800df5c <flash_zero>
		}
	}

	if (magic0) {
 800e304:	7dfb      	ldrb	r3, [r7, #23]
 800e306:	2b00      	cmp	r3, #0
 800e308:	d004      	beq.n	800e314 <se3_flash_init+0x70>
		base = (uint8_t*)SE3_FLASH_S0_ADDR;
 800e30a:	4b32      	ldr	r3, [pc, #200]	; (800e3d4 <se3_flash_init+0x130>)
 800e30c:	61fb      	str	r3, [r7, #28]
		sector = SE3_FLASH_S0;
 800e30e:	230a      	movs	r3, #10
 800e310:	61bb      	str	r3, [r7, #24]
 800e312:	e013      	b.n	800e33c <se3_flash_init+0x98>
	}
	else if (magic1) {
 800e314:	7dbb      	ldrb	r3, [r7, #22]
 800e316:	2b00      	cmp	r3, #0
 800e318:	d004      	beq.n	800e324 <se3_flash_init+0x80>
		base = (uint8_t*)SE3_FLASH_S1_ADDR;
 800e31a:	4b2f      	ldr	r3, [pc, #188]	; (800e3d8 <se3_flash_init+0x134>)
 800e31c:	61fb      	str	r3, [r7, #28]
		sector = SE3_FLASH_S1;
 800e31e:	230b      	movs	r3, #11
 800e320:	61bb      	str	r3, [r7, #24]
 800e322:	e00b      	b.n	800e33c <se3_flash_init+0x98>
	}
	else {
		// initialize S0 as active sector
		flash_erase(SE3_FLASH_S0);
 800e324:	200a      	movs	r0, #10
 800e326:	f7ff fe81 	bl	800e02c <flash_erase>
		flash_program(SE3_FLASH_S0_ADDR, se3_magic, SE3_FLASH_MAGIC_SIZE);
 800e32a:	2220      	movs	r2, #32
 800e32c:	4928      	ldr	r1, [pc, #160]	; (800e3d0 <se3_flash_init+0x12c>)
 800e32e:	4829      	ldr	r0, [pc, #164]	; (800e3d4 <se3_flash_init+0x130>)
 800e330:	f7ff fe42 	bl	800dfb8 <flash_program>
		base = (uint8_t*)SE3_FLASH_S0_ADDR;
 800e334:	4b27      	ldr	r3, [pc, #156]	; (800e3d4 <se3_flash_init+0x130>)
 800e336:	61fb      	str	r3, [r7, #28]
		sector = SE3_FLASH_S0;
 800e338:	230a      	movs	r3, #10
 800e33a:	61bb      	str	r3, [r7, #24]
	}
	se3_flash_info_setup(sector, base);
 800e33c:	69f9      	ldr	r1, [r7, #28]
 800e33e:	69b8      	ldr	r0, [r7, #24]
 800e340:	f7ff ff86 	bl	800e250 <se3_flash_info_setup>

	//scan flash
	se3_flash_it_init(&it);
 800e344:	1d3b      	adds	r3, r7, #4
 800e346:	4618      	mov	r0, r3
 800e348:	f000 f871 	bl	800e42e <se3_flash_it_init>
	while (se3_flash_it_next(&it)) {
 800e34c:	e029      	b.n	800e3a2 <se3_flash_init+0xfe>
		flash.allocated += it.blocks*SE3_FLASH_BLOCK_SIZE;
 800e34e:	4b24      	ldr	r3, [pc, #144]	; (800e3e0 <se3_flash_init+0x13c>)
 800e350:	699b      	ldr	r3, [r3, #24]
 800e352:	89ba      	ldrh	r2, [r7, #12]
 800e354:	0192      	lsls	r2, r2, #6
 800e356:	4413      	add	r3, r2
 800e358:	4a21      	ldr	r2, [pc, #132]	; (800e3e0 <se3_flash_init+0x13c>)
 800e35a:	6193      	str	r3, [r2, #24]
		if (it.type != 0) {
 800e35c:	7a3b      	ldrb	r3, [r7, #8]
 800e35e:	2b00      	cmp	r3, #0
 800e360:	d01f      	beq.n	800e3a2 <se3_flash_init+0xfe>
			flash.used += it.blocks*SE3_FLASH_BLOCK_SIZE;
 800e362:	4b1f      	ldr	r3, [pc, #124]	; (800e3e0 <se3_flash_init+0x13c>)
 800e364:	695b      	ldr	r3, [r3, #20]
 800e366:	89ba      	ldrh	r2, [r7, #12]
 800e368:	0192      	lsls	r2, r2, #6
 800e36a:	4413      	add	r3, r2
 800e36c:	4a1c      	ldr	r2, [pc, #112]	; (800e3e0 <se3_flash_init+0x13c>)
 800e36e:	6153      	str	r3, [r2, #20]
            if (it.type == SE3_FLASH_TYPE_SERIAL) {
 800e370:	7a3b      	ldrb	r3, [r7, #8]
 800e372:	2b01      	cmp	r3, #1
 800e374:	d115      	bne.n	800e3a2 <se3_flash_init+0xfe>
                memcpy(serial.data, it.addr, SE3_SERIAL_SIZE);
 800e376:	687a      	ldr	r2, [r7, #4]
 800e378:	4b1a      	ldr	r3, [pc, #104]	; (800e3e4 <se3_flash_init+0x140>)
 800e37a:	6815      	ldr	r5, [r2, #0]
 800e37c:	6854      	ldr	r4, [r2, #4]
 800e37e:	6890      	ldr	r0, [r2, #8]
 800e380:	68d1      	ldr	r1, [r2, #12]
 800e382:	601d      	str	r5, [r3, #0]
 800e384:	605c      	str	r4, [r3, #4]
 800e386:	6098      	str	r0, [r3, #8]
 800e388:	60d9      	str	r1, [r3, #12]
 800e38a:	6915      	ldr	r5, [r2, #16]
 800e38c:	6954      	ldr	r4, [r2, #20]
 800e38e:	6990      	ldr	r0, [r2, #24]
 800e390:	69d1      	ldr	r1, [r2, #28]
 800e392:	611d      	str	r5, [r3, #16]
 800e394:	615c      	str	r4, [r3, #20]
 800e396:	6198      	str	r0, [r3, #24]
 800e398:	61d9      	str	r1, [r3, #28]
                serial.written = true;
 800e39a:	4b12      	ldr	r3, [pc, #72]	; (800e3e4 <se3_flash_init+0x140>)
 800e39c:	2201      	movs	r2, #1
 800e39e:	f883 2020 	strb.w	r2, [r3, #32]
	while (se3_flash_it_next(&it)) {
 800e3a2:	1d3b      	adds	r3, r7, #4
 800e3a4:	4618      	mov	r0, r3
 800e3a6:	f000 f84f 	bl	800e448 <se3_flash_it_next>
 800e3aa:	4603      	mov	r3, r0
 800e3ac:	2b00      	cmp	r3, #0
 800e3ae:	d1ce      	bne.n	800e34e <se3_flash_init+0xaa>
            }
		}
	}
	if (it.pos > SE3_FLASH_INDEX_SIZE) {
 800e3b0:	693b      	ldr	r3, [r7, #16]
 800e3b2:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e3b6:	d902      	bls.n	800e3be <se3_flash_init+0x11a>
		it.pos = SE3_FLASH_INDEX_SIZE;
 800e3b8:	f44f 63fc 	mov.w	r3, #2016	; 0x7e0
 800e3bc:	613b      	str	r3, [r7, #16]
	}
	flash.first_free_pos = it.pos;
 800e3be:	693b      	ldr	r3, [r7, #16]
 800e3c0:	4a07      	ldr	r2, [pc, #28]	; (800e3e0 <se3_flash_init+0x13c>)
 800e3c2:	6113      	str	r3, [r2, #16]

	return true;
 800e3c4:	2301      	movs	r3, #1
}
 800e3c6:	4618      	mov	r0, r3
 800e3c8:	3720      	adds	r7, #32
 800e3ca:	46bd      	mov	sp, r7
 800e3cc:	bdb0      	pop	{r4, r5, r7, pc}
 800e3ce:	bf00      	nop
 800e3d0:	0801e028 	.word	0x0801e028
 800e3d4:	080c0000 	.word	0x080c0000
 800e3d8:	080e0000 	.word	0x080e0000
 800e3dc:	080e07ff 	.word	0x080e07ff
 800e3e0:	2000cd14 	.word	0x2000cd14
 800e3e4:	200004a4 	.word	0x200004a4

0800e3e8 <se3_flash_it_write>:

bool se3_flash_it_write(se3_flash_it* it, uint16_t off, const uint8_t* data, uint16_t size)
{
 800e3e8:	b580      	push	{r7, lr}
 800e3ea:	b084      	sub	sp, #16
 800e3ec:	af00      	add	r7, sp, #0
 800e3ee:	60f8      	str	r0, [r7, #12]
 800e3f0:	607a      	str	r2, [r7, #4]
 800e3f2:	461a      	mov	r2, r3
 800e3f4:	460b      	mov	r3, r1
 800e3f6:	817b      	strh	r3, [r7, #10]
 800e3f8:	4613      	mov	r3, r2
 800e3fa:	813b      	strh	r3, [r7, #8]
	if (off + size > 2 + it->size)return false;
 800e3fc:	897a      	ldrh	r2, [r7, #10]
 800e3fe:	893b      	ldrh	r3, [r7, #8]
 800e400:	441a      	add	r2, r3
 800e402:	68fb      	ldr	r3, [r7, #12]
 800e404:	88db      	ldrh	r3, [r3, #6]
 800e406:	3302      	adds	r3, #2
 800e408:	429a      	cmp	r2, r3
 800e40a:	dd01      	ble.n	800e410 <se3_flash_it_write+0x28>
 800e40c:	2300      	movs	r3, #0
 800e40e:	e00a      	b.n	800e426 <se3_flash_it_write+0x3e>
    return flash_program((uint32_t)it->addr + off, data, size);
 800e410:	68fb      	ldr	r3, [r7, #12]
 800e412:	681b      	ldr	r3, [r3, #0]
 800e414:	461a      	mov	r2, r3
 800e416:	897b      	ldrh	r3, [r7, #10]
 800e418:	4413      	add	r3, r2
 800e41a:	893a      	ldrh	r2, [r7, #8]
 800e41c:	6879      	ldr	r1, [r7, #4]
 800e41e:	4618      	mov	r0, r3
 800e420:	f7ff fdca 	bl	800dfb8 <flash_program>
 800e424:	4603      	mov	r3, r0
}
 800e426:	4618      	mov	r0, r3
 800e428:	3710      	adds	r7, #16
 800e42a:	46bd      	mov	sp, r7
 800e42c:	bd80      	pop	{r7, pc}

0800e42e <se3_flash_it_init>:

void se3_flash_it_init(se3_flash_it* it)
{
 800e42e:	b480      	push	{r7}
 800e430:	b083      	sub	sp, #12
 800e432:	af00      	add	r7, sp, #0
 800e434:	6078      	str	r0, [r7, #4]
	it->addr = NULL;
 800e436:	687b      	ldr	r3, [r7, #4]
 800e438:	2200      	movs	r2, #0
 800e43a:	601a      	str	r2, [r3, #0]
}
 800e43c:	bf00      	nop
 800e43e:	370c      	adds	r7, #12
 800e440:	46bd      	mov	sp, r7
 800e442:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e446:	4770      	bx	lr

0800e448 <se3_flash_it_next>:

bool se3_flash_it_next(se3_flash_it* it)
{
 800e448:	b480      	push	{r7}
 800e44a:	b087      	sub	sp, #28
 800e44c:	af00      	add	r7, sp, #0
 800e44e:	6078      	str	r0, [r7, #4]
	uint8_t type;
	const uint8_t* node;
	size_t pos2;
	if (it->addr == NULL) {
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	681b      	ldr	r3, [r3, #0]
 800e454:	2b00      	cmp	r3, #0
 800e456:	d108      	bne.n	800e46a <se3_flash_it_next+0x22>
		it->pos = 0;
 800e458:	687b      	ldr	r3, [r7, #4]
 800e45a:	2200      	movs	r2, #0
 800e45c:	60da      	str	r2, [r3, #12]
		it->addr = flash.data + 2;
 800e45e:	4b30      	ldr	r3, [pc, #192]	; (800e520 <se3_flash_it_next+0xd8>)
 800e460:	68db      	ldr	r3, [r3, #12]
 800e462:	1c9a      	adds	r2, r3, #2
 800e464:	687b      	ldr	r3, [r7, #4]
 800e466:	601a      	str	r2, [r3, #0]
 800e468:	e04d      	b.n	800e506 <se3_flash_it_next+0xbe>
	}
	else {
		(it->pos)+=it->blocks;
 800e46a:	687b      	ldr	r3, [r7, #4]
 800e46c:	68db      	ldr	r3, [r3, #12]
 800e46e:	687a      	ldr	r2, [r7, #4]
 800e470:	8912      	ldrh	r2, [r2, #8]
 800e472:	441a      	add	r2, r3
 800e474:	687b      	ldr	r3, [r7, #4]
 800e476:	60da      	str	r2, [r3, #12]
	}
	while (it->pos < SE3_FLASH_INDEX_SIZE) {
 800e478:	e045      	b.n	800e506 <se3_flash_it_next+0xbe>
		type = *(flash.index + it->pos);
 800e47a:	4b29      	ldr	r3, [pc, #164]	; (800e520 <se3_flash_it_next+0xd8>)
 800e47c:	689a      	ldr	r2, [r3, #8]
 800e47e:	687b      	ldr	r3, [r7, #4]
 800e480:	68db      	ldr	r3, [r3, #12]
 800e482:	4413      	add	r3, r2
 800e484:	781b      	ldrb	r3, [r3, #0]
 800e486:	74fb      	strb	r3, [r7, #19]
		if (type == 0xFF) return false;
 800e488:	7cfb      	ldrb	r3, [r7, #19]
 800e48a:	2bff      	cmp	r3, #255	; 0xff
 800e48c:	d101      	bne.n	800e492 <se3_flash_it_next+0x4a>
 800e48e:	2300      	movs	r3, #0
 800e490:	e03f      	b.n	800e512 <se3_flash_it_next+0xca>
		if (type != 0xFE) {
 800e492:	7cfb      	ldrb	r3, [r7, #19]
 800e494:	2bfe      	cmp	r3, #254	; 0xfe
 800e496:	d031      	beq.n	800e4fc <se3_flash_it_next+0xb4>
			node = flash.data + (it->pos) * SE3_FLASH_BLOCK_SIZE;
 800e498:	4b21      	ldr	r3, [pc, #132]	; (800e520 <se3_flash_it_next+0xd8>)
 800e49a:	68da      	ldr	r2, [r3, #12]
 800e49c:	687b      	ldr	r3, [r7, #4]
 800e49e:	68db      	ldr	r3, [r3, #12]
 800e4a0:	019b      	lsls	r3, r3, #6
 800e4a2:	4413      	add	r3, r2
 800e4a4:	60fb      	str	r3, [r7, #12]
			it->addr = node + 2;
 800e4a6:	68fb      	ldr	r3, [r7, #12]
 800e4a8:	1c9a      	adds	r2, r3, #2
 800e4aa:	687b      	ldr	r3, [r7, #4]
 800e4ac:	601a      	str	r2, [r3, #0]
            SE3_GET16(node, 0, it->size);
 800e4ae:	687b      	ldr	r3, [r7, #4]
 800e4b0:	3306      	adds	r3, #6
 800e4b2:	68fa      	ldr	r2, [r7, #12]
 800e4b4:	8812      	ldrh	r2, [r2, #0]
 800e4b6:	b292      	uxth	r2, r2
 800e4b8:	801a      	strh	r2, [r3, #0]
			it->type = type;
 800e4ba:	687b      	ldr	r3, [r7, #4]
 800e4bc:	7cfa      	ldrb	r2, [r7, #19]
 800e4be:	711a      	strb	r2, [r3, #4]

			//count 'CONT' nodes after
			pos2 = it->pos + 1;
 800e4c0:	687b      	ldr	r3, [r7, #4]
 800e4c2:	68db      	ldr	r3, [r3, #12]
 800e4c4:	3301      	adds	r3, #1
 800e4c6:	617b      	str	r3, [r7, #20]
			while (pos2 < SE3_FLASH_INDEX_SIZE && *(flash.index + pos2) == 0xFE)pos2++;
 800e4c8:	e002      	b.n	800e4d0 <se3_flash_it_next+0x88>
 800e4ca:	697b      	ldr	r3, [r7, #20]
 800e4cc:	3301      	adds	r3, #1
 800e4ce:	617b      	str	r3, [r7, #20]
 800e4d0:	697b      	ldr	r3, [r7, #20]
 800e4d2:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e4d6:	d206      	bcs.n	800e4e6 <se3_flash_it_next+0x9e>
 800e4d8:	4b11      	ldr	r3, [pc, #68]	; (800e520 <se3_flash_it_next+0xd8>)
 800e4da:	689a      	ldr	r2, [r3, #8]
 800e4dc:	697b      	ldr	r3, [r7, #20]
 800e4de:	4413      	add	r3, r2
 800e4e0:	781b      	ldrb	r3, [r3, #0]
 800e4e2:	2bfe      	cmp	r3, #254	; 0xfe
 800e4e4:	d0f1      	beq.n	800e4ca <se3_flash_it_next+0x82>
			it->blocks = (uint16_t)(pos2 - it->pos);
 800e4e6:	697b      	ldr	r3, [r7, #20]
 800e4e8:	b29a      	uxth	r2, r3
 800e4ea:	687b      	ldr	r3, [r7, #4]
 800e4ec:	68db      	ldr	r3, [r3, #12]
 800e4ee:	b29b      	uxth	r3, r3
 800e4f0:	1ad3      	subs	r3, r2, r3
 800e4f2:	b29a      	uxth	r2, r3
 800e4f4:	687b      	ldr	r3, [r7, #4]
 800e4f6:	811a      	strh	r2, [r3, #8]
			return true;
 800e4f8:	2301      	movs	r3, #1
 800e4fa:	e00a      	b.n	800e512 <se3_flash_it_next+0xca>
		}
		(it->pos)++;
 800e4fc:	687b      	ldr	r3, [r7, #4]
 800e4fe:	68db      	ldr	r3, [r3, #12]
 800e500:	1c5a      	adds	r2, r3, #1
 800e502:	687b      	ldr	r3, [r7, #4]
 800e504:	60da      	str	r2, [r3, #12]
	while (it->pos < SE3_FLASH_INDEX_SIZE) {
 800e506:	687b      	ldr	r3, [r7, #4]
 800e508:	68db      	ldr	r3, [r3, #12]
 800e50a:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e50e:	d3b4      	bcc.n	800e47a <se3_flash_it_next+0x32>
	}
	return false;
 800e510:	2300      	movs	r3, #0
}
 800e512:	4618      	mov	r0, r3
 800e514:	371c      	adds	r7, #28
 800e516:	46bd      	mov	sp, r7
 800e518:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e51c:	4770      	bx	lr
 800e51e:	bf00      	nop
 800e520:	2000cd14 	.word	0x2000cd14

0800e524 <se3_flash_it_new>:
{
	return SE3_FLASH_SECTOR_SIZE - flash.used;
}

bool se3_flash_it_new(se3_flash_it* it, uint8_t type, uint16_t size)
{
 800e524:	b580      	push	{r7, lr}
 800e526:	b088      	sub	sp, #32
 800e528:	af00      	add	r7, sp, #0
 800e52a:	6078      	str	r0, [r7, #4]
 800e52c:	460b      	mov	r3, r1
 800e52e:	70fb      	strb	r3, [r7, #3]
 800e530:	4613      	mov	r3, r2
 800e532:	803b      	strh	r3, [r7, #0]
	size_t pos, nblocks;
	const uint8_t* node;
	size_t avail = SE3_FLASH_SECTOR_SIZE - flash.allocated;
 800e534:	4b54      	ldr	r3, [pc, #336]	; (800e688 <se3_flash_it_new+0x164>)
 800e536:	699b      	ldr	r3, [r3, #24]
 800e538:	f5c3 3300 	rsb	r3, r3, #131072	; 0x20000
 800e53c:	61bb      	str	r3, [r7, #24]
	uint16_t size_on_flash = size + 2;
 800e53e:	883b      	ldrh	r3, [r7, #0]
 800e540:	3302      	adds	r3, #2
 800e542:	82fb      	strh	r3, [r7, #22]
	if (size_on_flash > SE3_FLASH_NODE_MAX)return false;
 800e544:	8afb      	ldrh	r3, [r7, #22]
 800e546:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e54a:	d901      	bls.n	800e550 <se3_flash_it_new+0x2c>
 800e54c:	2300      	movs	r3, #0
 800e54e:	e096      	b.n	800e67e <se3_flash_it_new+0x15a>
	if (size_on_flash > (SE3_FLASH_SECTOR_SIZE - flash.used)) {
 800e550:	8afa      	ldrh	r2, [r7, #22]
 800e552:	4b4d      	ldr	r3, [pc, #308]	; (800e688 <se3_flash_it_new+0x164>)
 800e554:	695b      	ldr	r3, [r3, #20]
 800e556:	f5c3 3300 	rsb	r3, r3, #131072	; 0x20000
 800e55a:	429a      	cmp	r2, r3
 800e55c:	d901      	bls.n	800e562 <se3_flash_it_new+0x3e>
		return false;
 800e55e:	2300      	movs	r3, #0
 800e560:	e08d      	b.n	800e67e <se3_flash_it_new+0x15a>
	}
	if (size_on_flash > avail) {
 800e562:	8afb      	ldrh	r3, [r7, #22]
 800e564:	69ba      	ldr	r2, [r7, #24]
 800e566:	429a      	cmp	r2, r3
 800e568:	d209      	bcs.n	800e57e <se3_flash_it_new+0x5a>
		// swap sector
		if (!flash_swap()) {
 800e56a:	f7ff fd8f 	bl	800e08c <flash_swap>
 800e56e:	4603      	mov	r3, r0
 800e570:	f083 0301 	eor.w	r3, r3, #1
 800e574:	b2db      	uxtb	r3, r3
 800e576:	2b00      	cmp	r3, #0
 800e578:	d001      	beq.n	800e57e <se3_flash_it_new+0x5a>
			return false;
 800e57a:	2300      	movs	r3, #0
 800e57c:	e07f      	b.n	800e67e <se3_flash_it_new+0x15a>
		}
	}
	if (flash.first_free_pos >= SE3_FLASH_INDEX_SIZE) {
 800e57e:	4b42      	ldr	r3, [pc, #264]	; (800e688 <se3_flash_it_new+0x164>)
 800e580:	691b      	ldr	r3, [r3, #16]
 800e582:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e586:	d301      	bcc.n	800e58c <se3_flash_it_new+0x68>
		return false;
 800e588:	2300      	movs	r3, #0
 800e58a:	e078      	b.n	800e67e <se3_flash_it_new+0x15a>
	}
	pos = flash.first_free_pos;
 800e58c:	4b3e      	ldr	r3, [pc, #248]	; (800e688 <se3_flash_it_new+0x164>)
 800e58e:	691b      	ldr	r3, [r3, #16]
 800e590:	613b      	str	r3, [r7, #16]
	node = flash.data + pos*SE3_FLASH_BLOCK_SIZE;
 800e592:	4b3d      	ldr	r3, [pc, #244]	; (800e688 <se3_flash_it_new+0x164>)
 800e594:	68da      	ldr	r2, [r3, #12]
 800e596:	693b      	ldr	r3, [r7, #16]
 800e598:	019b      	lsls	r3, r3, #6
 800e59a:	4413      	add	r3, r2
 800e59c:	60fb      	str	r3, [r7, #12]

	nblocks = size_on_flash / SE3_FLASH_BLOCK_SIZE;
 800e59e:	8afb      	ldrh	r3, [r7, #22]
 800e5a0:	099b      	lsrs	r3, r3, #6
 800e5a2:	b29b      	uxth	r3, r3
 800e5a4:	61fb      	str	r3, [r7, #28]
	if (size_on_flash % SE3_FLASH_BLOCK_SIZE)nblocks++;
 800e5a6:	8afb      	ldrh	r3, [r7, #22]
 800e5a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800e5ac:	b29b      	uxth	r3, r3
 800e5ae:	2b00      	cmp	r3, #0
 800e5b0:	d002      	beq.n	800e5b8 <se3_flash_it_new+0x94>
 800e5b2:	69fb      	ldr	r3, [r7, #28]
 800e5b4:	3301      	adds	r3, #1
 800e5b6:	61fb      	str	r3, [r7, #28]
	if (!flash_program((uint32_t)flash.index + pos, &type, 1)) {
 800e5b8:	4b33      	ldr	r3, [pc, #204]	; (800e688 <se3_flash_it_new+0x164>)
 800e5ba:	689b      	ldr	r3, [r3, #8]
 800e5bc:	461a      	mov	r2, r3
 800e5be:	693b      	ldr	r3, [r7, #16]
 800e5c0:	4413      	add	r3, r2
 800e5c2:	1cf9      	adds	r1, r7, #3
 800e5c4:	2201      	movs	r2, #1
 800e5c6:	4618      	mov	r0, r3
 800e5c8:	f7ff fcf6 	bl	800dfb8 <flash_program>
 800e5cc:	4603      	mov	r3, r0
 800e5ce:	f083 0301 	eor.w	r3, r3, #1
 800e5d2:	b2db      	uxtb	r3, r3
 800e5d4:	2b00      	cmp	r3, #0
 800e5d6:	d001      	beq.n	800e5dc <se3_flash_it_new+0xb8>
		return false;
 800e5d8:	2300      	movs	r3, #0
 800e5da:	e050      	b.n	800e67e <se3_flash_it_new+0x15a>
	}
	flash.first_free_pos += 1;
 800e5dc:	4b2a      	ldr	r3, [pc, #168]	; (800e688 <se3_flash_it_new+0x164>)
 800e5de:	691b      	ldr	r3, [r3, #16]
 800e5e0:	3301      	adds	r3, #1
 800e5e2:	4a29      	ldr	r2, [pc, #164]	; (800e688 <se3_flash_it_new+0x164>)
 800e5e4:	6113      	str	r3, [r2, #16]
	if (nblocks > 1) {
 800e5e6:	69fb      	ldr	r3, [r7, #28]
 800e5e8:	2b01      	cmp	r3, #1
 800e5ea:	d91a      	bls.n	800e622 <se3_flash_it_new+0xfe>
		if (!flash_fill((uint32_t)flash.index + pos + 1, 0xFE, nblocks - 1)) {
 800e5ec:	4b26      	ldr	r3, [pc, #152]	; (800e688 <se3_flash_it_new+0x164>)
 800e5ee:	689b      	ldr	r3, [r3, #8]
 800e5f0:	461a      	mov	r2, r3
 800e5f2:	693b      	ldr	r3, [r7, #16]
 800e5f4:	4413      	add	r3, r2
 800e5f6:	1c58      	adds	r0, r3, #1
 800e5f8:	69fb      	ldr	r3, [r7, #28]
 800e5fa:	3b01      	subs	r3, #1
 800e5fc:	461a      	mov	r2, r3
 800e5fe:	21fe      	movs	r1, #254	; 0xfe
 800e600:	f7ff fc7c 	bl	800defc <flash_fill>
 800e604:	4603      	mov	r3, r0
 800e606:	f083 0301 	eor.w	r3, r3, #1
 800e60a:	b2db      	uxtb	r3, r3
 800e60c:	2b00      	cmp	r3, #0
 800e60e:	d001      	beq.n	800e614 <se3_flash_it_new+0xf0>
			return false;
 800e610:	2300      	movs	r3, #0
 800e612:	e034      	b.n	800e67e <se3_flash_it_new+0x15a>
		}
		flash.first_free_pos += nblocks - 1;
 800e614:	4b1c      	ldr	r3, [pc, #112]	; (800e688 <se3_flash_it_new+0x164>)
 800e616:	691a      	ldr	r2, [r3, #16]
 800e618:	69fb      	ldr	r3, [r7, #28]
 800e61a:	4413      	add	r3, r2
 800e61c:	3b01      	subs	r3, #1
 800e61e:	4a1a      	ldr	r2, [pc, #104]	; (800e688 <se3_flash_it_new+0x164>)
 800e620:	6113      	str	r3, [r2, #16]
	}
	
	if (!flash_program((uint32_t)node, (uint8_t*)&size, 2)) {
 800e622:	68fb      	ldr	r3, [r7, #12]
 800e624:	4639      	mov	r1, r7
 800e626:	2202      	movs	r2, #2
 800e628:	4618      	mov	r0, r3
 800e62a:	f7ff fcc5 	bl	800dfb8 <flash_program>
 800e62e:	4603      	mov	r3, r0
 800e630:	f083 0301 	eor.w	r3, r3, #1
 800e634:	b2db      	uxtb	r3, r3
 800e636:	2b00      	cmp	r3, #0
 800e638:	d001      	beq.n	800e63e <se3_flash_it_new+0x11a>
		return false;
 800e63a:	2300      	movs	r3, #0
 800e63c:	e01f      	b.n	800e67e <se3_flash_it_new+0x15a>
	}
	it->addr = node + 2;
 800e63e:	68fb      	ldr	r3, [r7, #12]
 800e640:	1c9a      	adds	r2, r3, #2
 800e642:	687b      	ldr	r3, [r7, #4]
 800e644:	601a      	str	r2, [r3, #0]
	it->pos = pos;
 800e646:	687b      	ldr	r3, [r7, #4]
 800e648:	693a      	ldr	r2, [r7, #16]
 800e64a:	60da      	str	r2, [r3, #12]
	it->size = size;
 800e64c:	883a      	ldrh	r2, [r7, #0]
 800e64e:	687b      	ldr	r3, [r7, #4]
 800e650:	80da      	strh	r2, [r3, #6]
	it->type = type;
 800e652:	78fa      	ldrb	r2, [r7, #3]
 800e654:	687b      	ldr	r3, [r7, #4]
 800e656:	711a      	strb	r2, [r3, #4]
	it->blocks = (uint16_t)nblocks;
 800e658:	69fb      	ldr	r3, [r7, #28]
 800e65a:	b29a      	uxth	r2, r3
 800e65c:	687b      	ldr	r3, [r7, #4]
 800e65e:	811a      	strh	r2, [r3, #8]

	flash.used += nblocks*SE3_FLASH_BLOCK_SIZE;
 800e660:	4b09      	ldr	r3, [pc, #36]	; (800e688 <se3_flash_it_new+0x164>)
 800e662:	695a      	ldr	r2, [r3, #20]
 800e664:	69fb      	ldr	r3, [r7, #28]
 800e666:	019b      	lsls	r3, r3, #6
 800e668:	4413      	add	r3, r2
 800e66a:	4a07      	ldr	r2, [pc, #28]	; (800e688 <se3_flash_it_new+0x164>)
 800e66c:	6153      	str	r3, [r2, #20]
	flash.allocated += nblocks*SE3_FLASH_BLOCK_SIZE;
 800e66e:	4b06      	ldr	r3, [pc, #24]	; (800e688 <se3_flash_it_new+0x164>)
 800e670:	699a      	ldr	r2, [r3, #24]
 800e672:	69fb      	ldr	r3, [r7, #28]
 800e674:	019b      	lsls	r3, r3, #6
 800e676:	4413      	add	r3, r2
 800e678:	4a03      	ldr	r2, [pc, #12]	; (800e688 <se3_flash_it_new+0x164>)
 800e67a:	6193      	str	r3, [r2, #24]

	return true;
 800e67c:	2301      	movs	r3, #1
}
 800e67e:	4618      	mov	r0, r3
 800e680:	3720      	adds	r7, #32
 800e682:	46bd      	mov	sp, r7
 800e684:	bd80      	pop	{r7, pc}
 800e686:	bf00      	nop
 800e688:	2000cd14 	.word	0x2000cd14

0800e68c <se3_flash_it_delete>:
	flash.used -= blocks*SE3_FLASH_BLOCK_SIZE;
	return true;
}

bool se3_flash_it_delete(se3_flash_it* it)
{
 800e68c:	b580      	push	{r7, lr}
 800e68e:	b082      	sub	sp, #8
 800e690:	af00      	add	r7, sp, #0
 800e692:	6078      	str	r0, [r7, #4]
	if (it->pos + it->blocks > SE3_FLASH_INDEX_SIZE) {
 800e694:	687b      	ldr	r3, [r7, #4]
 800e696:	68db      	ldr	r3, [r3, #12]
 800e698:	687a      	ldr	r2, [r7, #4]
 800e69a:	8912      	ldrh	r2, [r2, #8]
 800e69c:	4413      	add	r3, r2
 800e69e:	f5b3 6ffc 	cmp.w	r3, #2016	; 0x7e0
 800e6a2:	d901      	bls.n	800e6a8 <se3_flash_it_delete+0x1c>
		return false;
 800e6a4:	2300      	movs	r3, #0
 800e6a6:	e01c      	b.n	800e6e2 <se3_flash_it_delete+0x56>
	}
	if (!flash_zero((uint32_t)flash.index + it->pos, it->blocks)) {
 800e6a8:	4b10      	ldr	r3, [pc, #64]	; (800e6ec <se3_flash_it_delete+0x60>)
 800e6aa:	689b      	ldr	r3, [r3, #8]
 800e6ac:	461a      	mov	r2, r3
 800e6ae:	687b      	ldr	r3, [r7, #4]
 800e6b0:	68db      	ldr	r3, [r3, #12]
 800e6b2:	441a      	add	r2, r3
 800e6b4:	687b      	ldr	r3, [r7, #4]
 800e6b6:	891b      	ldrh	r3, [r3, #8]
 800e6b8:	4619      	mov	r1, r3
 800e6ba:	4610      	mov	r0, r2
 800e6bc:	f7ff fc4e 	bl	800df5c <flash_zero>
 800e6c0:	4603      	mov	r3, r0
 800e6c2:	f083 0301 	eor.w	r3, r3, #1
 800e6c6:	b2db      	uxtb	r3, r3
 800e6c8:	2b00      	cmp	r3, #0
 800e6ca:	d001      	beq.n	800e6d0 <se3_flash_it_delete+0x44>
		return false;
 800e6cc:	2300      	movs	r3, #0
 800e6ce:	e008      	b.n	800e6e2 <se3_flash_it_delete+0x56>
	}
	flash.used -= it->blocks*SE3_FLASH_BLOCK_SIZE;
 800e6d0:	4b06      	ldr	r3, [pc, #24]	; (800e6ec <se3_flash_it_delete+0x60>)
 800e6d2:	695b      	ldr	r3, [r3, #20]
 800e6d4:	687a      	ldr	r2, [r7, #4]
 800e6d6:	8912      	ldrh	r2, [r2, #8]
 800e6d8:	0192      	lsls	r2, r2, #6
 800e6da:	1a9b      	subs	r3, r3, r2
 800e6dc:	4a03      	ldr	r2, [pc, #12]	; (800e6ec <se3_flash_it_delete+0x60>)
 800e6de:	6153      	str	r3, [r2, #20]
	return true;
 800e6e0:	2301      	movs	r3, #1
}
 800e6e2:	4618      	mov	r0, r3
 800e6e4:	3708      	adds	r7, #8
 800e6e6:	46bd      	mov	sp, r7
 800e6e8:	bd80      	pop	{r7, pc}
 800e6ea:	bf00      	nop
 800e6ec:	2000cd14 	.word	0x2000cd14

0800e6f0 <se3_flash_bootmode_reset>:

bool se3_flash_bootmode_reset(uint32_t addr, size_t size){
 800e6f0:	b580      	push	{r7, lr}
 800e6f2:	b082      	sub	sp, #8
 800e6f4:	af00      	add	r7, sp, #0
 800e6f6:	6078      	str	r0, [r7, #4]
 800e6f8:	6039      	str	r1, [r7, #0]
	return flash_zero(addr, size);
 800e6fa:	6839      	ldr	r1, [r7, #0]
 800e6fc:	6878      	ldr	r0, [r7, #4]
 800e6fe:	f7ff fc2d 	bl	800df5c <flash_zero>
 800e702:	4603      	mov	r3, r0
}
 800e704:	4618      	mov	r0, r3
 800e706:	3708      	adds	r7, #8
 800e708:	46bd      	mov	sp, r7
 800e70a:	bd80      	pop	{r7, pc}

0800e70c <se3_key_find>:
	SE3_KEY_OFFSET_NAMELEN = 10,
	SE3_KEY_OFFSET_DATA = 12
};

bool se3_key_find(uint32_t id, se3_flash_it* it)
{
 800e70c:	b580      	push	{r7, lr}
 800e70e:	b084      	sub	sp, #16
 800e710:	af00      	add	r7, sp, #0
 800e712:	6078      	str	r0, [r7, #4]
 800e714:	6039      	str	r1, [r7, #0]
    uint32_t key_id = 0;
 800e716:	2300      	movs	r3, #0
 800e718:	60fb      	str	r3, [r7, #12]
	se3_flash_it_init(it);
 800e71a:	6838      	ldr	r0, [r7, #0]
 800e71c:	f7ff fe87 	bl	800e42e <se3_flash_it_init>
	while (se3_flash_it_next(it)) {
 800e720:	e00d      	b.n	800e73e <se3_key_find+0x32>
		if (it->type == SE3_TYPE_KEY) {
 800e722:	683b      	ldr	r3, [r7, #0]
 800e724:	791b      	ldrb	r3, [r3, #4]
 800e726:	2b64      	cmp	r3, #100	; 0x64
 800e728:	d109      	bne.n	800e73e <se3_key_find+0x32>
            SE3_GET32(it->addr, SE3_KEY_OFFSET_ID, key_id);
 800e72a:	683b      	ldr	r3, [r7, #0]
 800e72c:	681b      	ldr	r3, [r3, #0]
 800e72e:	681b      	ldr	r3, [r3, #0]
 800e730:	60fb      	str	r3, [r7, #12]
			if (key_id == id) {
 800e732:	68fb      	ldr	r3, [r7, #12]
 800e734:	687a      	ldr	r2, [r7, #4]
 800e736:	429a      	cmp	r2, r3
 800e738:	d101      	bne.n	800e73e <se3_key_find+0x32>
				return true;
 800e73a:	2301      	movs	r3, #1
 800e73c:	e006      	b.n	800e74c <se3_key_find+0x40>
	while (se3_flash_it_next(it)) {
 800e73e:	6838      	ldr	r0, [r7, #0]
 800e740:	f7ff fe82 	bl	800e448 <se3_flash_it_next>
 800e744:	4603      	mov	r3, r0
 800e746:	2b00      	cmp	r3, #0
 800e748:	d1eb      	bne.n	800e722 <se3_key_find+0x16>
			}
		}
	}
	return false;
 800e74a:	2300      	movs	r3, #0
}
 800e74c:	4618      	mov	r0, r3
 800e74e:	3710      	adds	r7, #16
 800e750:	46bd      	mov	sp, r7
 800e752:	bd80      	pop	{r7, pc}

0800e754 <se3_key_new>:
	}
	return true;
}

bool se3_key_new(se3_flash_it* it, se3_flash_key* key)
{
 800e754:	b580      	push	{r7, lr}
 800e756:	b084      	sub	sp, #16
 800e758:	af00      	add	r7, sp, #0
 800e75a:	6078      	str	r0, [r7, #4]
 800e75c:	6039      	str	r1, [r7, #0]
	uint16_t size = (SE3_FLASH_KEY_SIZE_HEADER + key->data_size + key->name_size);
 800e75e:	683b      	ldr	r3, [r7, #0]
 800e760:	891a      	ldrh	r2, [r3, #8]
 800e762:	683b      	ldr	r3, [r7, #0]
 800e764:	895b      	ldrh	r3, [r3, #10]
 800e766:	4413      	add	r3, r2
 800e768:	b29b      	uxth	r3, r3
 800e76a:	330c      	adds	r3, #12
 800e76c:	81fb      	strh	r3, [r7, #14]
    if (size > SE3_FLASH_NODE_DATA_MAX) {
 800e76e:	89fb      	ldrh	r3, [r7, #14]
 800e770:	f640 72fe 	movw	r2, #4094	; 0xffe
 800e774:	4293      	cmp	r3, r2
 800e776:	d901      	bls.n	800e77c <se3_key_new+0x28>
        return false;
 800e778:	2300      	movs	r3, #0
 800e77a:	e012      	b.n	800e7a2 <se3_key_new+0x4e>
    }
	if (!se3_flash_it_new(it, SE3_TYPE_KEY, size)) {
 800e77c:	89fb      	ldrh	r3, [r7, #14]
 800e77e:	461a      	mov	r2, r3
 800e780:	2164      	movs	r1, #100	; 0x64
 800e782:	6878      	ldr	r0, [r7, #4]
 800e784:	f7ff fece 	bl	800e524 <se3_flash_it_new>
 800e788:	4603      	mov	r3, r0
 800e78a:	f083 0301 	eor.w	r3, r3, #1
 800e78e:	b2db      	uxtb	r3, r3
 800e790:	2b00      	cmp	r3, #0
 800e792:	d001      	beq.n	800e798 <se3_key_new+0x44>
		SE3_TRACE(("E key_new cannot allocate flash block\n"));
		return false;
 800e794:	2300      	movs	r3, #0
 800e796:	e004      	b.n	800e7a2 <se3_key_new+0x4e>
	}
	return se3_key_write(it, key);
 800e798:	6839      	ldr	r1, [r7, #0]
 800e79a:	6878      	ldr	r0, [r7, #4]
 800e79c:	f000 f8b7 	bl	800e90e <se3_key_write>
 800e7a0:	4603      	mov	r3, r0
}
 800e7a2:	4618      	mov	r0, r3
 800e7a4:	3710      	adds	r7, #16
 800e7a6:	46bd      	mov	sp, r7
 800e7a8:	bd80      	pop	{r7, pc}

0800e7aa <se3_key_read>:

void se3_key_read(se3_flash_it* it, se3_flash_key* key)
{
 800e7aa:	b580      	push	{r7, lr}
 800e7ac:	b082      	sub	sp, #8
 800e7ae:	af00      	add	r7, sp, #0
 800e7b0:	6078      	str	r0, [r7, #4]
 800e7b2:	6039      	str	r1, [r7, #0]
    SE3_GET32(it->addr, SE3_KEY_OFFSET_ID, key->id);
 800e7b4:	683b      	ldr	r3, [r7, #0]
 800e7b6:	687a      	ldr	r2, [r7, #4]
 800e7b8:	6812      	ldr	r2, [r2, #0]
 800e7ba:	6812      	ldr	r2, [r2, #0]
 800e7bc:	601a      	str	r2, [r3, #0]
    SE3_GET32(it->addr, SE3_KEY_OFFSET_VALIDITY, key->validity);
 800e7be:	683b      	ldr	r3, [r7, #0]
 800e7c0:	3304      	adds	r3, #4
 800e7c2:	687a      	ldr	r2, [r7, #4]
 800e7c4:	6812      	ldr	r2, [r2, #0]
 800e7c6:	3204      	adds	r2, #4
 800e7c8:	6812      	ldr	r2, [r2, #0]
 800e7ca:	601a      	str	r2, [r3, #0]
    SE3_GET16(it->addr, SE3_KEY_OFFSET_DATALEN, key->data_size);
 800e7cc:	683b      	ldr	r3, [r7, #0]
 800e7ce:	3308      	adds	r3, #8
 800e7d0:	687a      	ldr	r2, [r7, #4]
 800e7d2:	6812      	ldr	r2, [r2, #0]
 800e7d4:	3208      	adds	r2, #8
 800e7d6:	8812      	ldrh	r2, [r2, #0]
 800e7d8:	b292      	uxth	r2, r2
 800e7da:	801a      	strh	r2, [r3, #0]
    SE3_GET16(it->addr, SE3_KEY_OFFSET_NAMELEN, key->name_size);
 800e7dc:	683b      	ldr	r3, [r7, #0]
 800e7de:	330a      	adds	r3, #10
 800e7e0:	687a      	ldr	r2, [r7, #4]
 800e7e2:	6812      	ldr	r2, [r2, #0]
 800e7e4:	320a      	adds	r2, #10
 800e7e6:	8812      	ldrh	r2, [r2, #0]
 800e7e8:	b292      	uxth	r2, r2
 800e7ea:	801a      	strh	r2, [r3, #0]

	if (key->data) {
 800e7ec:	683b      	ldr	r3, [r7, #0]
 800e7ee:	68db      	ldr	r3, [r3, #12]
 800e7f0:	2b00      	cmp	r3, #0
 800e7f2:	d00a      	beq.n	800e80a <se3_key_read+0x60>
		memcpy(key->data, it->addr + 12, key->data_size);
 800e7f4:	683b      	ldr	r3, [r7, #0]
 800e7f6:	68d8      	ldr	r0, [r3, #12]
 800e7f8:	687b      	ldr	r3, [r7, #4]
 800e7fa:	681b      	ldr	r3, [r3, #0]
 800e7fc:	f103 010c 	add.w	r1, r3, #12
 800e800:	683b      	ldr	r3, [r7, #0]
 800e802:	891b      	ldrh	r3, [r3, #8]
 800e804:	461a      	mov	r2, r3
 800e806:	f00c fbce 	bl	801afa6 <memcpy>
	}
	if (key->name) {
 800e80a:	683b      	ldr	r3, [r7, #0]
 800e80c:	691b      	ldr	r3, [r3, #16]
 800e80e:	2b00      	cmp	r3, #0
 800e810:	d00c      	beq.n	800e82c <se3_key_read+0x82>
		memcpy(key->name, it->addr + 12 + key->data_size, key->name_size);
 800e812:	683b      	ldr	r3, [r7, #0]
 800e814:	6918      	ldr	r0, [r3, #16]
 800e816:	687b      	ldr	r3, [r7, #4]
 800e818:	681a      	ldr	r2, [r3, #0]
 800e81a:	683b      	ldr	r3, [r7, #0]
 800e81c:	891b      	ldrh	r3, [r3, #8]
 800e81e:	330c      	adds	r3, #12
 800e820:	18d1      	adds	r1, r2, r3
 800e822:	683b      	ldr	r3, [r7, #0]
 800e824:	895b      	ldrh	r3, [r3, #10]
 800e826:	461a      	mov	r2, r3
 800e828:	f00c fbbd 	bl	801afa6 <memcpy>
	}
}
 800e82c:	bf00      	nop
 800e82e:	3708      	adds	r7, #8
 800e830:	46bd      	mov	sp, r7
 800e832:	bd80      	pop	{r7, pc}

0800e834 <se3_key_equal>:

bool se3_key_equal(se3_flash_it* it, se3_flash_key* key)
{
 800e834:	b580      	push	{r7, lr}
 800e836:	b084      	sub	sp, #16
 800e838:	af00      	add	r7, sp, #0
 800e83a:	6078      	str	r0, [r7, #4]
 800e83c:	6039      	str	r1, [r7, #0]
	uint32_t u32tmp = 0;
 800e83e:	2300      	movs	r3, #0
 800e840:	60fb      	str	r3, [r7, #12]
	uint16_t u16tmp = 0;
 800e842:	2300      	movs	r3, #0
 800e844:	817b      	strh	r3, [r7, #10]
	
	if (key->name == NULL)return false;
 800e846:	683b      	ldr	r3, [r7, #0]
 800e848:	691b      	ldr	r3, [r3, #16]
 800e84a:	2b00      	cmp	r3, #0
 800e84c:	d101      	bne.n	800e852 <se3_key_equal+0x1e>
 800e84e:	2300      	movs	r3, #0
 800e850:	e059      	b.n	800e906 <se3_key_equal+0xd2>
	if (key->data == NULL)return false;
 800e852:	683b      	ldr	r3, [r7, #0]
 800e854:	68db      	ldr	r3, [r3, #12]
 800e856:	2b00      	cmp	r3, #0
 800e858:	d101      	bne.n	800e85e <se3_key_equal+0x2a>
 800e85a:	2300      	movs	r3, #0
 800e85c:	e053      	b.n	800e906 <se3_key_equal+0xd2>
	
	SE3_GET32(it->addr, SE3_KEY_OFFSET_ID, u32tmp);
 800e85e:	687b      	ldr	r3, [r7, #4]
 800e860:	681b      	ldr	r3, [r3, #0]
 800e862:	681b      	ldr	r3, [r3, #0]
 800e864:	60fb      	str	r3, [r7, #12]
	if (u32tmp != key->id) return false;
 800e866:	683b      	ldr	r3, [r7, #0]
 800e868:	681a      	ldr	r2, [r3, #0]
 800e86a:	68fb      	ldr	r3, [r7, #12]
 800e86c:	429a      	cmp	r2, r3
 800e86e:	d001      	beq.n	800e874 <se3_key_equal+0x40>
 800e870:	2300      	movs	r3, #0
 800e872:	e048      	b.n	800e906 <se3_key_equal+0xd2>
	SE3_GET32(it->addr, SE3_KEY_OFFSET_VALIDITY, u32tmp);
 800e874:	687b      	ldr	r3, [r7, #4]
 800e876:	681b      	ldr	r3, [r3, #0]
 800e878:	3304      	adds	r3, #4
 800e87a:	681b      	ldr	r3, [r3, #0]
 800e87c:	60fb      	str	r3, [r7, #12]
	if (u32tmp != key->validity) return false;
 800e87e:	683b      	ldr	r3, [r7, #0]
 800e880:	685a      	ldr	r2, [r3, #4]
 800e882:	68fb      	ldr	r3, [r7, #12]
 800e884:	429a      	cmp	r2, r3
 800e886:	d001      	beq.n	800e88c <se3_key_equal+0x58>
 800e888:	2300      	movs	r3, #0
 800e88a:	e03c      	b.n	800e906 <se3_key_equal+0xd2>
	SE3_GET16(it->addr, SE3_KEY_OFFSET_DATALEN, u16tmp);
 800e88c:	687b      	ldr	r3, [r7, #4]
 800e88e:	681b      	ldr	r3, [r3, #0]
 800e890:	3308      	adds	r3, #8
 800e892:	881b      	ldrh	r3, [r3, #0]
 800e894:	b29b      	uxth	r3, r3
 800e896:	817b      	strh	r3, [r7, #10]
	if (u16tmp != key->data_size) return false;
 800e898:	683b      	ldr	r3, [r7, #0]
 800e89a:	891a      	ldrh	r2, [r3, #8]
 800e89c:	897b      	ldrh	r3, [r7, #10]
 800e89e:	429a      	cmp	r2, r3
 800e8a0:	d001      	beq.n	800e8a6 <se3_key_equal+0x72>
 800e8a2:	2300      	movs	r3, #0
 800e8a4:	e02f      	b.n	800e906 <se3_key_equal+0xd2>
	SE3_GET16(it->addr, SE3_KEY_OFFSET_NAMELEN, u16tmp);
 800e8a6:	687b      	ldr	r3, [r7, #4]
 800e8a8:	681b      	ldr	r3, [r3, #0]
 800e8aa:	330a      	adds	r3, #10
 800e8ac:	881b      	ldrh	r3, [r3, #0]
 800e8ae:	b29b      	uxth	r3, r3
 800e8b0:	817b      	strh	r3, [r7, #10]
	if (u16tmp != key->name_size) return false;
 800e8b2:	683b      	ldr	r3, [r7, #0]
 800e8b4:	895a      	ldrh	r2, [r3, #10]
 800e8b6:	897b      	ldrh	r3, [r7, #10]
 800e8b8:	429a      	cmp	r2, r3
 800e8ba:	d001      	beq.n	800e8c0 <se3_key_equal+0x8c>
 800e8bc:	2300      	movs	r3, #0
 800e8be:	e022      	b.n	800e906 <se3_key_equal+0xd2>

	if (memcmp(it->addr + SE3_KEY_OFFSET_DATA, key->data, key->data_size)) {
 800e8c0:	687b      	ldr	r3, [r7, #4]
 800e8c2:	681b      	ldr	r3, [r3, #0]
 800e8c4:	f103 000c 	add.w	r0, r3, #12
 800e8c8:	683b      	ldr	r3, [r7, #0]
 800e8ca:	68d9      	ldr	r1, [r3, #12]
 800e8cc:	683b      	ldr	r3, [r7, #0]
 800e8ce:	891b      	ldrh	r3, [r3, #8]
 800e8d0:	461a      	mov	r2, r3
 800e8d2:	f00c fb59 	bl	801af88 <memcmp>
 800e8d6:	4603      	mov	r3, r0
 800e8d8:	2b00      	cmp	r3, #0
 800e8da:	d001      	beq.n	800e8e0 <se3_key_equal+0xac>
		return false;
 800e8dc:	2300      	movs	r3, #0
 800e8de:	e012      	b.n	800e906 <se3_key_equal+0xd2>
	}
	if (memcmp(it->addr + SE3_KEY_OFFSET_DATA + key->data_size, key->name, key->name_size)) {
 800e8e0:	687b      	ldr	r3, [r7, #4]
 800e8e2:	681a      	ldr	r2, [r3, #0]
 800e8e4:	683b      	ldr	r3, [r7, #0]
 800e8e6:	891b      	ldrh	r3, [r3, #8]
 800e8e8:	330c      	adds	r3, #12
 800e8ea:	18d0      	adds	r0, r2, r3
 800e8ec:	683b      	ldr	r3, [r7, #0]
 800e8ee:	6919      	ldr	r1, [r3, #16]
 800e8f0:	683b      	ldr	r3, [r7, #0]
 800e8f2:	895b      	ldrh	r3, [r3, #10]
 800e8f4:	461a      	mov	r2, r3
 800e8f6:	f00c fb47 	bl	801af88 <memcmp>
 800e8fa:	4603      	mov	r3, r0
 800e8fc:	2b00      	cmp	r3, #0
 800e8fe:	d001      	beq.n	800e904 <se3_key_equal+0xd0>
		return false;
 800e900:	2300      	movs	r3, #0
 800e902:	e000      	b.n	800e906 <se3_key_equal+0xd2>
	}
	return true;
 800e904:	2301      	movs	r3, #1
}
 800e906:	4618      	mov	r0, r3
 800e908:	3710      	adds	r7, #16
 800e90a:	46bd      	mov	sp, r7
 800e90c:	bd80      	pop	{r7, pc}

0800e90e <se3_key_write>:
{
	memcpy(data, it->addr + 12, data_size);
}

bool se3_key_write(se3_flash_it* it, se3_flash_key* key)
{
 800e90e:	b580      	push	{r7, lr}
 800e910:	b084      	sub	sp, #16
 800e912:	af00      	add	r7, sp, #0
 800e914:	6078      	str	r0, [r7, #4]
 800e916:	6039      	str	r1, [r7, #0]
	uint8_t tmp[4];
	bool success = false;
 800e918:	2300      	movs	r3, #0
 800e91a:	73fb      	strb	r3, [r7, #15]
	do {
		if (!se3_flash_it_write(it, 0, (uint8_t*)&(key->id), 4)) {
 800e91c:	683a      	ldr	r2, [r7, #0]
 800e91e:	2304      	movs	r3, #4
 800e920:	2100      	movs	r1, #0
 800e922:	6878      	ldr	r0, [r7, #4]
 800e924:	f7ff fd60 	bl	800e3e8 <se3_flash_it_write>
 800e928:	4603      	mov	r3, r0
 800e92a:	f083 0301 	eor.w	r3, r3, #1
 800e92e:	b2db      	uxtb	r3, r3
 800e930:	2b00      	cmp	r3, #0
 800e932:	d150      	bne.n	800e9d6 <se3_key_write+0xc8>
			break;
		}
		if (!se3_flash_it_write(it, 4, (uint8_t*)&(key->validity), 4)) {
 800e934:	683b      	ldr	r3, [r7, #0]
 800e936:	1d1a      	adds	r2, r3, #4
 800e938:	2304      	movs	r3, #4
 800e93a:	2104      	movs	r1, #4
 800e93c:	6878      	ldr	r0, [r7, #4]
 800e93e:	f7ff fd53 	bl	800e3e8 <se3_flash_it_write>
 800e942:	4603      	mov	r3, r0
 800e944:	f083 0301 	eor.w	r3, r3, #1
 800e948:	b2db      	uxtb	r3, r3
 800e94a:	2b00      	cmp	r3, #0
 800e94c:	d145      	bne.n	800e9da <se3_key_write+0xcc>
			break;
		}
        SE3_SET16(tmp, 0, key->data_size);
 800e94e:	683b      	ldr	r3, [r7, #0]
 800e950:	3308      	adds	r3, #8
 800e952:	881b      	ldrh	r3, [r3, #0]
 800e954:	b29b      	uxth	r3, r3
 800e956:	813b      	strh	r3, [r7, #8]
        SE3_SET16(tmp, 2, key->name_size);
 800e958:	f107 0308 	add.w	r3, r7, #8
 800e95c:	3302      	adds	r3, #2
 800e95e:	683a      	ldr	r2, [r7, #0]
 800e960:	320a      	adds	r2, #10
 800e962:	8812      	ldrh	r2, [r2, #0]
 800e964:	b292      	uxth	r2, r2
 800e966:	801a      	strh	r2, [r3, #0]
		if (!se3_flash_it_write(it, 8, tmp, 4)) {
 800e968:	f107 0208 	add.w	r2, r7, #8
 800e96c:	2304      	movs	r3, #4
 800e96e:	2108      	movs	r1, #8
 800e970:	6878      	ldr	r0, [r7, #4]
 800e972:	f7ff fd39 	bl	800e3e8 <se3_flash_it_write>
 800e976:	4603      	mov	r3, r0
 800e978:	f083 0301 	eor.w	r3, r3, #1
 800e97c:	b2db      	uxtb	r3, r3
 800e97e:	2b00      	cmp	r3, #0
 800e980:	d12d      	bne.n	800e9de <se3_key_write+0xd0>
			break;
		}

		if (key->data_size) {
 800e982:	683b      	ldr	r3, [r7, #0]
 800e984:	891b      	ldrh	r3, [r3, #8]
 800e986:	2b00      	cmp	r3, #0
 800e988:	d00d      	beq.n	800e9a6 <se3_key_write+0x98>
			if (!se3_flash_it_write(it, 12, key->data, key->data_size)) {
 800e98a:	683b      	ldr	r3, [r7, #0]
 800e98c:	68da      	ldr	r2, [r3, #12]
 800e98e:	683b      	ldr	r3, [r7, #0]
 800e990:	891b      	ldrh	r3, [r3, #8]
 800e992:	210c      	movs	r1, #12
 800e994:	6878      	ldr	r0, [r7, #4]
 800e996:	f7ff fd27 	bl	800e3e8 <se3_flash_it_write>
 800e99a:	4603      	mov	r3, r0
 800e99c:	f083 0301 	eor.w	r3, r3, #1
 800e9a0:	b2db      	uxtb	r3, r3
 800e9a2:	2b00      	cmp	r3, #0
 800e9a4:	d11d      	bne.n	800e9e2 <se3_key_write+0xd4>
				break;
			}
		}
		if (key->name_size) {
 800e9a6:	683b      	ldr	r3, [r7, #0]
 800e9a8:	895b      	ldrh	r3, [r3, #10]
 800e9aa:	2b00      	cmp	r3, #0
 800e9ac:	d010      	beq.n	800e9d0 <se3_key_write+0xc2>
			if (!se3_flash_it_write(it, 12 + key->data_size, key->name, key->name_size)) {
 800e9ae:	683b      	ldr	r3, [r7, #0]
 800e9b0:	891b      	ldrh	r3, [r3, #8]
 800e9b2:	330c      	adds	r3, #12
 800e9b4:	b299      	uxth	r1, r3
 800e9b6:	683b      	ldr	r3, [r7, #0]
 800e9b8:	691a      	ldr	r2, [r3, #16]
 800e9ba:	683b      	ldr	r3, [r7, #0]
 800e9bc:	895b      	ldrh	r3, [r3, #10]
 800e9be:	6878      	ldr	r0, [r7, #4]
 800e9c0:	f7ff fd12 	bl	800e3e8 <se3_flash_it_write>
 800e9c4:	4603      	mov	r3, r0
 800e9c6:	f083 0301 	eor.w	r3, r3, #1
 800e9ca:	b2db      	uxtb	r3, r3
 800e9cc:	2b00      	cmp	r3, #0
 800e9ce:	d10a      	bne.n	800e9e6 <se3_key_write+0xd8>
				break;
			}
		}
		success = true;
 800e9d0:	2301      	movs	r3, #1
 800e9d2:	73fb      	strb	r3, [r7, #15]
 800e9d4:	e008      	b.n	800e9e8 <se3_key_write+0xda>
			break;
 800e9d6:	bf00      	nop
 800e9d8:	e006      	b.n	800e9e8 <se3_key_write+0xda>
			break;
 800e9da:	bf00      	nop
 800e9dc:	e004      	b.n	800e9e8 <se3_key_write+0xda>
			break;
 800e9de:	bf00      	nop
 800e9e0:	e002      	b.n	800e9e8 <se3_key_write+0xda>
				break;
 800e9e2:	bf00      	nop
 800e9e4:	e000      	b.n	800e9e8 <se3_key_write+0xda>
				break;
 800e9e6:	bf00      	nop
	} while (0);

	if (!success) {
        SE3_TRACE(("[se3_key_write] cannot write to flash block\n"));
	}
	return success;
 800e9e8:	7bfb      	ldrb	r3, [r7, #15]
}
 800e9ea:	4618      	mov	r0, r3
 800e9ec:	3710      	adds	r7, #16
 800e9ee:	46bd      	mov	sp, r7
 800e9f0:	bd80      	pop	{r7, pc}

0800e9f2 <se3_key_fingerprint>:

void se3_key_fingerprint(se3_flash_key* key, const uint8_t* salt, uint8_t* fingerprint)
{
 800e9f2:	b580      	push	{r7, lr}
 800e9f4:	b088      	sub	sp, #32
 800e9f6:	af04      	add	r7, sp, #16
 800e9f8:	60f8      	str	r0, [r7, #12]
 800e9fa:	60b9      	str	r1, [r7, #8]
 800e9fc:	607a      	str	r2, [r7, #4]
	PBKDF2HmacSha256(key->data, key->data_size, salt, SE3_KEY_SALT_SIZE, 1, fingerprint, SE3_KEY_FINGERPRINT_SIZE);
 800e9fe:	68fb      	ldr	r3, [r7, #12]
 800ea00:	68d8      	ldr	r0, [r3, #12]
 800ea02:	68fb      	ldr	r3, [r7, #12]
 800ea04:	891b      	ldrh	r3, [r3, #8]
 800ea06:	4619      	mov	r1, r3
 800ea08:	2320      	movs	r3, #32
 800ea0a:	9302      	str	r3, [sp, #8]
 800ea0c:	687b      	ldr	r3, [r7, #4]
 800ea0e:	9301      	str	r3, [sp, #4]
 800ea10:	2301      	movs	r3, #1
 800ea12:	9300      	str	r3, [sp, #0]
 800ea14:	2320      	movs	r3, #32
 800ea16:	68ba      	ldr	r2, [r7, #8]
 800ea18:	f7f5 fc71 	bl	80042fe <PBKDF2HmacSha256>
}
 800ea1c:	bf00      	nop
 800ea1e:	3710      	adds	r7, #16
 800ea20:	46bd      	mov	sp, r7
 800ea22:	bd80      	pop	{r7, pc}

0800ea24 <se3_mem_reset>:
#define SE3_MEM_INFO_MAKE(id, valid) ((id) | ((valid)?(1):(0)) << 15 )
#define SE3_MEM_INFO_ISVALID(info) SE3_BIT_TEST(info, 15)
#define SE3_MEM_INFO_ID(info) ((info) & ~(1<<15))

void se3_mem_reset(se3_mem* mem)
{
 800ea24:	b580      	push	{r7, lr}
 800ea26:	b084      	sub	sp, #16
 800ea28:	af00      	add	r7, sp, #0
 800ea2a:	6078      	str	r0, [r7, #4]
	size_t i;
	uint16_t tmp;
    mem->used = 0;
 800ea2c:	687b      	ldr	r3, [r7, #4]
 800ea2e:	2200      	movs	r2, #0
 800ea30:	611a      	str	r2, [r3, #16]
    memset(mem->dat, 0, (mem->dat_size)*SE3_MEM_BLOCK);
 800ea32:	687b      	ldr	r3, [r7, #4]
 800ea34:	6898      	ldr	r0, [r3, #8]
 800ea36:	687b      	ldr	r3, [r7, #4]
 800ea38:	68db      	ldr	r3, [r3, #12]
 800ea3a:	015b      	lsls	r3, r3, #5
 800ea3c:	461a      	mov	r2, r3
 800ea3e:	2100      	movs	r1, #0
 800ea40:	f00c fad5 	bl	801afee <memset>
	
	for (i = 0; i < mem->max_count; i++) {
 800ea44:	2300      	movs	r3, #0
 800ea46:	60fb      	str	r3, [r7, #12]
 800ea48:	e009      	b.n	800ea5e <se3_mem_reset+0x3a>
		mem->ptr[i] = NULL;
 800ea4a:	687b      	ldr	r3, [r7, #4]
 800ea4c:	685a      	ldr	r2, [r3, #4]
 800ea4e:	68fb      	ldr	r3, [r7, #12]
 800ea50:	009b      	lsls	r3, r3, #2
 800ea52:	4413      	add	r3, r2
 800ea54:	2200      	movs	r2, #0
 800ea56:	601a      	str	r2, [r3, #0]
	for (i = 0; i < mem->max_count; i++) {
 800ea58:	68fb      	ldr	r3, [r7, #12]
 800ea5a:	3301      	adds	r3, #1
 800ea5c:	60fb      	str	r3, [r7, #12]
 800ea5e:	687b      	ldr	r3, [r7, #4]
 800ea60:	681b      	ldr	r3, [r3, #0]
 800ea62:	68fa      	ldr	r2, [r7, #12]
 800ea64:	429a      	cmp	r2, r3
 800ea66:	d3f0      	bcc.n	800ea4a <se3_mem_reset+0x26>
	}

    // first entry is an invalid entry filling the whole buffer
    tmp = (uint16_t)mem->dat_size;
 800ea68:	687b      	ldr	r3, [r7, #4]
 800ea6a:	68db      	ldr	r3, [r3, #12]
 800ea6c:	b29b      	uxth	r3, r3
 800ea6e:	817b      	strh	r3, [r7, #10]
    SE3_MEM_SIZE_SET(mem->dat, tmp);
 800ea70:	687b      	ldr	r3, [r7, #4]
 800ea72:	689b      	ldr	r3, [r3, #8]
 800ea74:	897a      	ldrh	r2, [r7, #10]
 800ea76:	801a      	strh	r2, [r3, #0]
    tmp = SE3_MEM_INFO_MAKE(0, 0);
 800ea78:	2300      	movs	r3, #0
 800ea7a:	817b      	strh	r3, [r7, #10]
    SE3_MEM_INFO_SET(mem->dat, tmp);
 800ea7c:	687b      	ldr	r3, [r7, #4]
 800ea7e:	689b      	ldr	r3, [r3, #8]
 800ea80:	3302      	adds	r3, #2
 800ea82:	897a      	ldrh	r2, [r7, #10]
 800ea84:	801a      	strh	r2, [r3, #0]
}
 800ea86:	bf00      	nop
 800ea88:	3710      	adds	r7, #16
 800ea8a:	46bd      	mov	sp, r7
 800ea8c:	bd80      	pop	{r7, pc}

0800ea8e <se3_mem_init>:

void se3_mem_init(se3_mem* mem, size_t index_size, uint8_t** index, size_t buf_size, uint8_t* buf)
{
 800ea8e:	b580      	push	{r7, lr}
 800ea90:	b086      	sub	sp, #24
 800ea92:	af00      	add	r7, sp, #0
 800ea94:	60f8      	str	r0, [r7, #12]
 800ea96:	60b9      	str	r1, [r7, #8]
 800ea98:	607a      	str	r2, [r7, #4]
 800ea9a:	603b      	str	r3, [r7, #0]
    uint16_t nblocks;
	mem->max_count = index_size;
 800ea9c:	68fb      	ldr	r3, [r7, #12]
 800ea9e:	68ba      	ldr	r2, [r7, #8]
 800eaa0:	601a      	str	r2, [r3, #0]
	mem->ptr = index;
 800eaa2:	68fb      	ldr	r3, [r7, #12]
 800eaa4:	687a      	ldr	r2, [r7, #4]
 800eaa6:	605a      	str	r2, [r3, #4]

    nblocks = (uint16_t)(buf_size / SE3_MEM_BLOCK);
 800eaa8:	683b      	ldr	r3, [r7, #0]
 800eaaa:	095b      	lsrs	r3, r3, #5
 800eaac:	82fb      	strh	r3, [r7, #22]
    mem->dat_size = nblocks;
 800eaae:	8afa      	ldrh	r2, [r7, #22]
 800eab0:	68fb      	ldr	r3, [r7, #12]
 800eab2:	60da      	str	r2, [r3, #12]
    mem->dat = buf;
 800eab4:	68fb      	ldr	r3, [r7, #12]
 800eab6:	6a3a      	ldr	r2, [r7, #32]
 800eab8:	609a      	str	r2, [r3, #8]

    se3_mem_reset(mem);
 800eaba:	68f8      	ldr	r0, [r7, #12]
 800eabc:	f7ff ffb2 	bl	800ea24 <se3_mem_reset>
}
 800eac0:	bf00      	nop
 800eac2:	3718      	adds	r7, #24
 800eac4:	46bd      	mov	sp, r7
 800eac6:	bd80      	pop	{r7, pc}

0800eac8 <se3_mem_compact>:

static void se3_mem_compact(uint8_t* p, uint8_t* end)
{
 800eac8:	b480      	push	{r7}
 800eaca:	b087      	sub	sp, #28
 800eacc:	af00      	add	r7, sp, #0
 800eace:	6078      	str	r0, [r7, #4]
 800ead0:	6039      	str	r1, [r7, #0]
	uint8_t* p2 = p;
 800ead2:	687b      	ldr	r3, [r7, #4]
 800ead4:	617b      	str	r3, [r7, #20]
	bool empty = false;
 800ead6:	2300      	movs	r3, #0
 800ead8:	74fb      	strb	r3, [r7, #19]
    uint16_t size;
    uint16_t info;

	while (p2 < end) {
 800eada:	e014      	b.n	800eb06 <se3_mem_compact+0x3e>
        SE3_MEM_INFO_GET(p2, info);
 800eadc:	697b      	ldr	r3, [r7, #20]
 800eade:	3302      	adds	r3, #2
 800eae0:	881b      	ldrh	r3, [r3, #0]
 800eae2:	b29b      	uxth	r3, r3
 800eae4:	81fb      	strh	r3, [r7, #14]
        if (SE3_MEM_INFO_ISVALID(info)) {
 800eae6:	89fb      	ldrh	r3, [r7, #14]
 800eae8:	b21b      	sxth	r3, r3
 800eaea:	2b00      	cmp	r3, #0
 800eaec:	db10      	blt.n	800eb10 <se3_mem_compact+0x48>
            break;
        }
        SE3_MEM_SIZE_GET(p2, size);
 800eaee:	697b      	ldr	r3, [r7, #20]
 800eaf0:	881b      	ldrh	r3, [r3, #0]
 800eaf2:	b29b      	uxth	r3, r3
 800eaf4:	823b      	strh	r3, [r7, #16]
        p2 += size*SE3_MEM_BLOCK;
 800eaf6:	8a3b      	ldrh	r3, [r7, #16]
 800eaf8:	015b      	lsls	r3, r3, #5
 800eafa:	461a      	mov	r2, r3
 800eafc:	697b      	ldr	r3, [r7, #20]
 800eafe:	4413      	add	r3, r2
 800eb00:	617b      	str	r3, [r7, #20]
		empty = true;
 800eb02:	2301      	movs	r3, #1
 800eb04:	74fb      	strb	r3, [r7, #19]
	while (p2 < end) {
 800eb06:	697a      	ldr	r2, [r7, #20]
 800eb08:	683b      	ldr	r3, [r7, #0]
 800eb0a:	429a      	cmp	r2, r3
 800eb0c:	d3e6      	bcc.n	800eadc <se3_mem_compact+0x14>
 800eb0e:	e000      	b.n	800eb12 <se3_mem_compact+0x4a>
            break;
 800eb10:	bf00      	nop
	}
	if (empty) {
 800eb12:	7cfb      	ldrb	r3, [r7, #19]
 800eb14:	2b00      	cmp	r3, #0
 800eb16:	d008      	beq.n	800eb2a <se3_mem_compact+0x62>
        size = (uint16_t)(((uint32_t)(p2 - p)) / SE3_MEM_BLOCK);
 800eb18:	697a      	ldr	r2, [r7, #20]
 800eb1a:	687b      	ldr	r3, [r7, #4]
 800eb1c:	1ad3      	subs	r3, r2, r3
 800eb1e:	095b      	lsrs	r3, r3, #5
 800eb20:	b29b      	uxth	r3, r3
 800eb22:	823b      	strh	r3, [r7, #16]
		SE3_MEM_SIZE_SET(p, size);
 800eb24:	8a3a      	ldrh	r2, [r7, #16]
 800eb26:	687b      	ldr	r3, [r7, #4]
 800eb28:	801a      	strh	r2, [r3, #0]
	}
}
 800eb2a:	bf00      	nop
 800eb2c:	371c      	adds	r7, #28
 800eb2e:	46bd      	mov	sp, r7
 800eb30:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb34:	4770      	bx	lr

0800eb36 <se3_mem_defrag>:

static uint8_t* se3_mem_defrag(se3_mem* mem)
{
 800eb36:	b580      	push	{r7, lr}
 800eb38:	b088      	sub	sp, #32
 800eb3a:	af00      	add	r7, sp, #0
 800eb3c:	6078      	str	r0, [r7, #4]
	uint8_t* p1, *p2;
	uint16_t p2_size;
	bool p2_valid;
	uint16_t id;
	uint8_t* end = mem->dat + mem->dat_size*SE3_MEM_BLOCK;
 800eb3e:	687b      	ldr	r3, [r7, #4]
 800eb40:	689a      	ldr	r2, [r3, #8]
 800eb42:	687b      	ldr	r3, [r7, #4]
 800eb44:	68db      	ldr	r3, [r3, #12]
 800eb46:	015b      	lsls	r3, r3, #5
 800eb48:	4413      	add	r3, r2
 800eb4a:	617b      	str	r3, [r7, #20]
    uint16_t info, size;

	//find first free block
	p1 = mem->dat;
 800eb4c:	687b      	ldr	r3, [r7, #4]
 800eb4e:	689b      	ldr	r3, [r3, #8]
 800eb50:	61fb      	str	r3, [r7, #28]
	while (p1 < end) {
 800eb52:	e012      	b.n	800eb7a <se3_mem_defrag+0x44>
        SE3_MEM_INFO_GET(p1, info);
 800eb54:	69fb      	ldr	r3, [r7, #28]
 800eb56:	3302      	adds	r3, #2
 800eb58:	881b      	ldrh	r3, [r3, #0]
 800eb5a:	b29b      	uxth	r3, r3
 800eb5c:	81bb      	strh	r3, [r7, #12]
		if (!SE3_MEM_INFO_ISVALID(info)) {
 800eb5e:	89bb      	ldrh	r3, [r7, #12]
 800eb60:	b21b      	sxth	r3, r3
 800eb62:	2b00      	cmp	r3, #0
 800eb64:	da0e      	bge.n	800eb84 <se3_mem_defrag+0x4e>
			break;
		}
        SE3_MEM_SIZE_GET(p1, size);
 800eb66:	69fb      	ldr	r3, [r7, #28]
 800eb68:	881b      	ldrh	r3, [r3, #0]
 800eb6a:	b29b      	uxth	r3, r3
 800eb6c:	817b      	strh	r3, [r7, #10]
        p1 += size*SE3_MEM_BLOCK;
 800eb6e:	897b      	ldrh	r3, [r7, #10]
 800eb70:	015b      	lsls	r3, r3, #5
 800eb72:	461a      	mov	r2, r3
 800eb74:	69fb      	ldr	r3, [r7, #28]
 800eb76:	4413      	add	r3, r2
 800eb78:	61fb      	str	r3, [r7, #28]
	while (p1 < end) {
 800eb7a:	69fa      	ldr	r2, [r7, #28]
 800eb7c:	697b      	ldr	r3, [r7, #20]
 800eb7e:	429a      	cmp	r2, r3
 800eb80:	d3e8      	bcc.n	800eb54 <se3_mem_defrag+0x1e>
 800eb82:	e000      	b.n	800eb86 <se3_mem_defrag+0x50>
			break;
 800eb84:	bf00      	nop
	}
	if (p1 >= end) {
 800eb86:	69fa      	ldr	r2, [r7, #28]
 800eb88:	697b      	ldr	r3, [r7, #20]
 800eb8a:	429a      	cmp	r2, r3
 800eb8c:	d301      	bcc.n	800eb92 <se3_mem_defrag+0x5c>
		return p1;
 800eb8e:	69fb      	ldr	r3, [r7, #28]
 800eb90:	e077      	b.n	800ec82 <se3_mem_defrag+0x14c>
	}

    SE3_MEM_SIZE_GET(p1, size);
 800eb92:	69fb      	ldr	r3, [r7, #28]
 800eb94:	881b      	ldrh	r3, [r3, #0]
 800eb96:	b29b      	uxth	r3, r3
 800eb98:	817b      	strh	r3, [r7, #10]
	p2 = p1 + size*SE3_MEM_BLOCK;
 800eb9a:	897b      	ldrh	r3, [r7, #10]
 800eb9c:	015b      	lsls	r3, r3, #5
 800eb9e:	461a      	mov	r2, r3
 800eba0:	69fb      	ldr	r3, [r7, #28]
 800eba2:	4413      	add	r3, r2
 800eba4:	61bb      	str	r3, [r7, #24]
	while(p2<end) {
 800eba6:	e026      	b.n	800ebf6 <se3_mem_defrag+0xc0>
        SE3_MEM_SIZE_GET(p2, p2_size);
 800eba8:	69bb      	ldr	r3, [r7, #24]
 800ebaa:	881b      	ldrh	r3, [r3, #0]
 800ebac:	b29b      	uxth	r3, r3
 800ebae:	81fb      	strh	r3, [r7, #14]
        SE3_MEM_INFO_GET(p2, info);
 800ebb0:	69bb      	ldr	r3, [r7, #24]
 800ebb2:	3302      	adds	r3, #2
 800ebb4:	881b      	ldrh	r3, [r3, #0]
 800ebb6:	b29b      	uxth	r3, r3
 800ebb8:	81bb      	strh	r3, [r7, #12]
        p2_valid = SE3_MEM_INFO_ISVALID(info);
 800ebba:	89bb      	ldrh	r3, [r7, #12]
 800ebbc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800ebc0:	2b00      	cmp	r3, #0
 800ebc2:	bf14      	ite	ne
 800ebc4:	2301      	movne	r3, #1
 800ebc6:	2300      	moveq	r3, #0
 800ebc8:	747b      	strb	r3, [r7, #17]
		if ( p2_valid ) {
 800ebca:	7c7b      	ldrb	r3, [r7, #17]
 800ebcc:	2b00      	cmp	r3, #0
 800ebce:	d00c      	beq.n	800ebea <se3_mem_defrag+0xb4>
			memmove(p1, p2, p2_size*SE3_MEM_BLOCK);
 800ebd0:	89fb      	ldrh	r3, [r7, #14]
 800ebd2:	015b      	lsls	r3, r3, #5
 800ebd4:	461a      	mov	r2, r3
 800ebd6:	69b9      	ldr	r1, [r7, #24]
 800ebd8:	69f8      	ldr	r0, [r7, #28]
 800ebda:	f00c f9ef 	bl	801afbc <memmove>
			p1 += p2_size*SE3_MEM_BLOCK;
 800ebde:	89fb      	ldrh	r3, [r7, #14]
 800ebe0:	015b      	lsls	r3, r3, #5
 800ebe2:	461a      	mov	r2, r3
 800ebe4:	69fb      	ldr	r3, [r7, #28]
 800ebe6:	4413      	add	r3, r2
 800ebe8:	61fb      	str	r3, [r7, #28]
		}
		p2 += p2_size*SE3_MEM_BLOCK;
 800ebea:	89fb      	ldrh	r3, [r7, #14]
 800ebec:	015b      	lsls	r3, r3, #5
 800ebee:	461a      	mov	r2, r3
 800ebf0:	69bb      	ldr	r3, [r7, #24]
 800ebf2:	4413      	add	r3, r2
 800ebf4:	61bb      	str	r3, [r7, #24]
	while(p2<end) {
 800ebf6:	69ba      	ldr	r2, [r7, #24]
 800ebf8:	697b      	ldr	r3, [r7, #20]
 800ebfa:	429a      	cmp	r2, r3
 800ebfc:	d3d4      	bcc.n	800eba8 <se3_mem_defrag+0x72>
	}
	if (p1 < end) {
 800ebfe:	69fa      	ldr	r2, [r7, #28]
 800ec00:	697b      	ldr	r3, [r7, #20]
 800ec02:	429a      	cmp	r2, r3
 800ec04:	d216      	bcs.n	800ec34 <se3_mem_defrag+0xfe>
        size = (uint16_t)(((uint32_t)(end - p1))/SE3_MEM_BLOCK);
 800ec06:	697a      	ldr	r2, [r7, #20]
 800ec08:	69fb      	ldr	r3, [r7, #28]
 800ec0a:	1ad3      	subs	r3, r2, r3
 800ec0c:	095b      	lsrs	r3, r3, #5
 800ec0e:	b29b      	uxth	r3, r3
 800ec10:	817b      	strh	r3, [r7, #10]
		SE3_MEM_SIZE_SET(p1, size);
 800ec12:	897a      	ldrh	r2, [r7, #10]
 800ec14:	69fb      	ldr	r3, [r7, #28]
 800ec16:	801a      	strh	r2, [r3, #0]

        // clear valid
        SE3_MEM_INFO_GET(p1, info);
 800ec18:	69fb      	ldr	r3, [r7, #28]
 800ec1a:	3302      	adds	r3, #2
 800ec1c:	881b      	ldrh	r3, [r3, #0]
 800ec1e:	b29b      	uxth	r3, r3
 800ec20:	81bb      	strh	r3, [r7, #12]
        info = SE3_MEM_INFO_MAKE(SE3_MEM_INFO_ID(info), 0);
 800ec22:	89bb      	ldrh	r3, [r7, #12]
 800ec24:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800ec28:	b29b      	uxth	r3, r3
 800ec2a:	81bb      	strh	r3, [r7, #12]
        SE3_MEM_INFO_SET(p1, info);
 800ec2c:	69fb      	ldr	r3, [r7, #28]
 800ec2e:	3302      	adds	r3, #2
 800ec30:	89ba      	ldrh	r2, [r7, #12]
 800ec32:	801a      	strh	r2, [r3, #0]
	}
	
	//rebuild ptr table
	
	p2 = mem->dat;
 800ec34:	687b      	ldr	r3, [r7, #4]
 800ec36:	689b      	ldr	r3, [r3, #8]
 800ec38:	61bb      	str	r3, [r7, #24]
	while (p2 < end) {
 800ec3a:	e01d      	b.n	800ec78 <se3_mem_defrag+0x142>
        SE3_MEM_INFO_GET(p2, info);
 800ec3c:	69bb      	ldr	r3, [r7, #24]
 800ec3e:	3302      	adds	r3, #2
 800ec40:	881b      	ldrh	r3, [r3, #0]
 800ec42:	b29b      	uxth	r3, r3
 800ec44:	81bb      	strh	r3, [r7, #12]
		if (SE3_MEM_INFO_ISVALID(info)) {
 800ec46:	89bb      	ldrh	r3, [r7, #12]
 800ec48:	b21b      	sxth	r3, r3
 800ec4a:	2b00      	cmp	r3, #0
 800ec4c:	da0a      	bge.n	800ec64 <se3_mem_defrag+0x12e>
			id = SE3_MEM_INFO_ID(info);
 800ec4e:	89bb      	ldrh	r3, [r7, #12]
 800ec50:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800ec54:	827b      	strh	r3, [r7, #18]
			mem->ptr[id] = p2;
 800ec56:	687b      	ldr	r3, [r7, #4]
 800ec58:	685a      	ldr	r2, [r3, #4]
 800ec5a:	8a7b      	ldrh	r3, [r7, #18]
 800ec5c:	009b      	lsls	r3, r3, #2
 800ec5e:	4413      	add	r3, r2
 800ec60:	69ba      	ldr	r2, [r7, #24]
 800ec62:	601a      	str	r2, [r3, #0]
		}
        SE3_MEM_SIZE_GET(p2, size);
 800ec64:	69bb      	ldr	r3, [r7, #24]
 800ec66:	881b      	ldrh	r3, [r3, #0]
 800ec68:	b29b      	uxth	r3, r3
 800ec6a:	817b      	strh	r3, [r7, #10]
        p2 += size*SE3_MEM_BLOCK;
 800ec6c:	897b      	ldrh	r3, [r7, #10]
 800ec6e:	015b      	lsls	r3, r3, #5
 800ec70:	461a      	mov	r2, r3
 800ec72:	69bb      	ldr	r3, [r7, #24]
 800ec74:	4413      	add	r3, r2
 800ec76:	61bb      	str	r3, [r7, #24]
	while (p2 < end) {
 800ec78:	69ba      	ldr	r2, [r7, #24]
 800ec7a:	697b      	ldr	r3, [r7, #20]
 800ec7c:	429a      	cmp	r2, r3
 800ec7e:	d3dd      	bcc.n	800ec3c <se3_mem_defrag+0x106>
	}

	//return first empty block;
	return p1;
 800ec80:	69fb      	ldr	r3, [r7, #28]
}
 800ec82:	4618      	mov	r0, r3
 800ec84:	3720      	adds	r7, #32
 800ec86:	46bd      	mov	sp, r7
 800ec88:	bd80      	pop	{r7, pc}

0800ec8a <se3_mem_alloc>:

int32_t se3_mem_alloc(se3_mem* mem, size_t size)
{
 800ec8a:	b580      	push	{r7, lr}
 800ec8c:	b08a      	sub	sp, #40	; 0x28
 800ec8e:	af00      	add	r7, sp, #0
 800ec90:	6078      	str	r0, [r7, #4]
 800ec92:	6039      	str	r1, [r7, #0]
	uint8_t* p = mem->dat, *p2;
 800ec94:	687b      	ldr	r3, [r7, #4]
 800ec96:	689b      	ldr	r3, [r3, #8]
 800ec98:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t* dat_end = mem->dat + (mem->dat_size)*SE3_MEM_BLOCK;
 800ec9a:	687b      	ldr	r3, [r7, #4]
 800ec9c:	689a      	ldr	r2, [r3, #8]
 800ec9e:	687b      	ldr	r3, [r7, #4]
 800eca0:	68db      	ldr	r3, [r3, #12]
 800eca2:	015b      	lsls	r3, r3, #5
 800eca4:	4413      	add	r3, r2
 800eca6:	61fb      	str	r3, [r7, #28]
    uint16_t u16tmp;
    uint16_t nblocks;
	bool valid;

	// header size
	size += SE3_MEM_HEADER;
 800eca8:	683b      	ldr	r3, [r7, #0]
 800ecaa:	3304      	adds	r3, #4
 800ecac:	603b      	str	r3, [r7, #0]

    // number of blocks
    nblocks = (uint16_t)(size / SE3_MEM_BLOCK);
 800ecae:	683b      	ldr	r3, [r7, #0]
 800ecb0:	095b      	lsrs	r3, r3, #5
 800ecb2:	b29b      	uxth	r3, r3
 800ecb4:	81bb      	strh	r3, [r7, #12]
    if (size % SE3_MEM_BLOCK != 0) {
 800ecb6:	683b      	ldr	r3, [r7, #0]
 800ecb8:	f003 031f 	and.w	r3, r3, #31
 800ecbc:	2b00      	cmp	r3, #0
 800ecbe:	d003      	beq.n	800ecc8 <se3_mem_alloc+0x3e>
        nblocks++;
 800ecc0:	89bb      	ldrh	r3, [r7, #12]
 800ecc2:	3301      	adds	r3, #1
 800ecc4:	b29b      	uxth	r3, r3
 800ecc6:	81bb      	strh	r3, [r7, #12]
    }
    
	if (mem->used + nblocks > mem->dat_size) {
 800ecc8:	687b      	ldr	r3, [r7, #4]
 800ecca:	691b      	ldr	r3, [r3, #16]
 800eccc:	89ba      	ldrh	r2, [r7, #12]
 800ecce:	441a      	add	r2, r3
 800ecd0:	687b      	ldr	r3, [r7, #4]
 800ecd2:	68db      	ldr	r3, [r3, #12]
 800ecd4:	429a      	cmp	r2, r3
 800ecd6:	d902      	bls.n	800ecde <se3_mem_alloc+0x54>
		//no more space
		return -1;
 800ecd8:	f04f 33ff 	mov.w	r3, #4294967295
 800ecdc:	e0af      	b.n	800ee3e <se3_mem_alloc+0x1b4>
	}
	
	for (i = 0; i < mem->max_count; i++) {
 800ecde:	2300      	movs	r3, #0
 800ece0:	623b      	str	r3, [r7, #32]
 800ece2:	e00a      	b.n	800ecfa <se3_mem_alloc+0x70>
		if (mem->ptr[i] == NULL) {
 800ece4:	687b      	ldr	r3, [r7, #4]
 800ece6:	685a      	ldr	r2, [r3, #4]
 800ece8:	6a3b      	ldr	r3, [r7, #32]
 800ecea:	009b      	lsls	r3, r3, #2
 800ecec:	4413      	add	r3, r2
 800ecee:	681b      	ldr	r3, [r3, #0]
 800ecf0:	2b00      	cmp	r3, #0
 800ecf2:	d008      	beq.n	800ed06 <se3_mem_alloc+0x7c>
	for (i = 0; i < mem->max_count; i++) {
 800ecf4:	6a3b      	ldr	r3, [r7, #32]
 800ecf6:	3301      	adds	r3, #1
 800ecf8:	623b      	str	r3, [r7, #32]
 800ecfa:	687b      	ldr	r3, [r7, #4]
 800ecfc:	681b      	ldr	r3, [r3, #0]
 800ecfe:	6a3a      	ldr	r2, [r7, #32]
 800ed00:	429a      	cmp	r2, r3
 800ed02:	d3ef      	bcc.n	800ece4 <se3_mem_alloc+0x5a>
 800ed04:	e000      	b.n	800ed08 <se3_mem_alloc+0x7e>
			break;
 800ed06:	bf00      	nop
		}
	}
	if (i >= mem->max_count) {
 800ed08:	687b      	ldr	r3, [r7, #4]
 800ed0a:	681b      	ldr	r3, [r3, #0]
 800ed0c:	6a3a      	ldr	r2, [r7, #32]
 800ed0e:	429a      	cmp	r2, r3
 800ed10:	d34a      	bcc.n	800eda8 <se3_mem_alloc+0x11e>
		// no more slots
		return -1;
 800ed12:	f04f 33ff 	mov.w	r3, #4294967295
 800ed16:	e092      	b.n	800ee3e <se3_mem_alloc+0x1b4>
	}
	while (p < dat_end) {
        SE3_MEM_SIZE_GET(p, p_size);
 800ed18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ed1a:	881b      	ldrh	r3, [r3, #0]
 800ed1c:	b29b      	uxth	r3, r3
 800ed1e:	823b      	strh	r3, [r7, #16]
        SE3_MEM_INFO_GET(p, p_info);
 800ed20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ed22:	3302      	adds	r3, #2
 800ed24:	881b      	ldrh	r3, [r3, #0]
 800ed26:	b29b      	uxth	r3, r3
 800ed28:	827b      	strh	r3, [r7, #18]
		valid = SE3_MEM_INFO_ISVALID(p_info);
 800ed2a:	8a7b      	ldrh	r3, [r7, #18]
 800ed2c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800ed30:	2b00      	cmp	r3, #0
 800ed32:	bf14      	ite	ne
 800ed34:	2301      	movne	r3, #1
 800ed36:	2300      	moveq	r3, #0
 800ed38:	76fb      	strb	r3, [r7, #27]
		if (p_size == 0 ) {
 800ed3a:	8a3b      	ldrh	r3, [r7, #16]
 800ed3c:	2b00      	cmp	r3, #0
 800ed3e:	d102      	bne.n	800ed46 <se3_mem_alloc+0xbc>
			SE3_TRACE(("E mem_alloc memory corrupted, block with size=0\n"));
			return -1;
 800ed40:	f04f 33ff 	mov.w	r3, #4294967295
 800ed44:	e07b      	b.n	800ee3e <se3_mem_alloc+0x1b4>
		}
		else if (!valid) {
 800ed46:	7efb      	ldrb	r3, [r7, #27]
 800ed48:	f083 0301 	eor.w	r3, r3, #1
 800ed4c:	b2db      	uxtb	r3, r3
 800ed4e:	2b00      	cmp	r3, #0
 800ed50:	d024      	beq.n	800ed9c <se3_mem_alloc+0x112>
			// try to aggregate blocks ahead
            if (p_size < nblocks) {
 800ed52:	8a3a      	ldrh	r2, [r7, #16]
 800ed54:	89bb      	ldrh	r3, [r7, #12]
 800ed56:	429a      	cmp	r2, r3
 800ed58:	d203      	bcs.n	800ed62 <se3_mem_alloc+0xd8>
				se3_mem_compact(p, dat_end);
 800ed5a:	69f9      	ldr	r1, [r7, #28]
 800ed5c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ed5e:	f7ff feb3 	bl	800eac8 <se3_mem_compact>
			}
            
			if (p_size == nblocks) {
 800ed62:	8a3a      	ldrh	r2, [r7, #16]
 800ed64:	89bb      	ldrh	r3, [r7, #12]
 800ed66:	429a      	cmp	r2, r3
 800ed68:	d023      	beq.n	800edb2 <se3_mem_alloc+0x128>
                // ok, no need to resize entry
				break;
			}
            else if (p_size > nblocks) {
 800ed6a:	8a3a      	ldrh	r2, [r7, #16]
 800ed6c:	89bb      	ldrh	r3, [r7, #12]
 800ed6e:	429a      	cmp	r2, r3
 800ed70:	d914      	bls.n	800ed9c <se3_mem_alloc+0x112>
                // ok, resize entry
                p2 = p + nblocks*SE3_MEM_BLOCK;
 800ed72:	89bb      	ldrh	r3, [r7, #12]
 800ed74:	015b      	lsls	r3, r3, #5
 800ed76:	461a      	mov	r2, r3
 800ed78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ed7a:	4413      	add	r3, r2
 800ed7c:	617b      	str	r3, [r7, #20]
                u16tmp = p_size - nblocks;
 800ed7e:	8a3a      	ldrh	r2, [r7, #16]
 800ed80:	89bb      	ldrh	r3, [r7, #12]
 800ed82:	1ad3      	subs	r3, r2, r3
 800ed84:	b29b      	uxth	r3, r3
 800ed86:	81fb      	strh	r3, [r7, #14]
                SE3_MEM_SIZE_SET(p2, u16tmp);
 800ed88:	89fa      	ldrh	r2, [r7, #14]
 800ed8a:	697b      	ldr	r3, [r7, #20]
 800ed8c:	801a      	strh	r2, [r3, #0]
                u16tmp = SE3_MEM_INFO_MAKE(0, 0);
 800ed8e:	2300      	movs	r3, #0
 800ed90:	81fb      	strh	r3, [r7, #14]
                SE3_MEM_INFO_SET(p2, u16tmp);
 800ed92:	697b      	ldr	r3, [r7, #20]
 800ed94:	3302      	adds	r3, #2
 800ed96:	89fa      	ldrh	r2, [r7, #14]
 800ed98:	801a      	strh	r2, [r3, #0]
                break;
 800ed9a:	e00b      	b.n	800edb4 <se3_mem_alloc+0x12a>
            }
		}
        p += p_size*SE3_MEM_BLOCK;
 800ed9c:	8a3b      	ldrh	r3, [r7, #16]
 800ed9e:	015b      	lsls	r3, r3, #5
 800eda0:	461a      	mov	r2, r3
 800eda2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eda4:	4413      	add	r3, r2
 800eda6:	627b      	str	r3, [r7, #36]	; 0x24
	while (p < dat_end) {
 800eda8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800edaa:	69fb      	ldr	r3, [r7, #28]
 800edac:	429a      	cmp	r2, r3
 800edae:	d3b3      	bcc.n	800ed18 <se3_mem_alloc+0x8e>
 800edb0:	e000      	b.n	800edb4 <se3_mem_alloc+0x12a>
				break;
 800edb2:	bf00      	nop
	}
	if (p >= dat_end) {
 800edb4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800edb6:	69fb      	ldr	r3, [r7, #28]
 800edb8:	429a      	cmp	r2, r3
 800edba:	d323      	bcc.n	800ee04 <se3_mem_alloc+0x17a>
        // there enough free memory but it is fragmented
		p = se3_mem_defrag(mem);
 800edbc:	6878      	ldr	r0, [r7, #4]
 800edbe:	f7ff feba 	bl	800eb36 <se3_mem_defrag>
 800edc2:	6278      	str	r0, [r7, #36]	; 0x24
		SE3_TRACE(("[se3_mem_alloc] defragging session memory\n"));

		if (p < dat_end) {
 800edc4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800edc6:	69fb      	ldr	r3, [r7, #28]
 800edc8:	429a      	cmp	r2, r3
 800edca:	d218      	bcs.n	800edfe <se3_mem_alloc+0x174>
			SE3_MEM_SIZE_GET(p, p_size);
 800edcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800edce:	881b      	ldrh	r3, [r3, #0]
 800edd0:	b29b      	uxth	r3, r3
 800edd2:	823b      	strh	r3, [r7, #16]
			p2 = p + nblocks*SE3_MEM_BLOCK;
 800edd4:	89bb      	ldrh	r3, [r7, #12]
 800edd6:	015b      	lsls	r3, r3, #5
 800edd8:	461a      	mov	r2, r3
 800edda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eddc:	4413      	add	r3, r2
 800edde:	617b      	str	r3, [r7, #20]
			u16tmp = p_size - nblocks;
 800ede0:	8a3a      	ldrh	r2, [r7, #16]
 800ede2:	89bb      	ldrh	r3, [r7, #12]
 800ede4:	1ad3      	subs	r3, r2, r3
 800ede6:	b29b      	uxth	r3, r3
 800ede8:	81fb      	strh	r3, [r7, #14]
			SE3_MEM_SIZE_SET(p2, u16tmp);
 800edea:	89fa      	ldrh	r2, [r7, #14]
 800edec:	697b      	ldr	r3, [r7, #20]
 800edee:	801a      	strh	r2, [r3, #0]
			u16tmp = SE3_MEM_INFO_MAKE(0, 0);
 800edf0:	2300      	movs	r3, #0
 800edf2:	81fb      	strh	r3, [r7, #14]
			SE3_MEM_INFO_SET(p2, u16tmp);
 800edf4:	697b      	ldr	r3, [r7, #20]
 800edf6:	3302      	adds	r3, #2
 800edf8:	89fa      	ldrh	r2, [r7, #14]
 800edfa:	801a      	strh	r2, [r3, #0]
 800edfc:	e002      	b.n	800ee04 <se3_mem_alloc+0x17a>
		}
		else {
			SE3_TRACE(("[se3_mem_alloc] memory corrupted, usage reports free memory while none\n"));
			return -1;
 800edfe:	f04f 33ff 	mov.w	r3, #4294967295
 800ee02:	e01c      	b.n	800ee3e <se3_mem_alloc+0x1b4>
		}
	}

    // update entry header
    SE3_MEM_SIZE_SET(p, nblocks);
 800ee04:	89ba      	ldrh	r2, [r7, #12]
 800ee06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee08:	801a      	strh	r2, [r3, #0]
    u16tmp = SE3_MEM_INFO_MAKE((uint16_t)i, 1);
 800ee0a:	6a3b      	ldr	r3, [r7, #32]
 800ee0c:	b29b      	uxth	r3, r3
 800ee0e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800ee12:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800ee16:	b29b      	uxth	r3, r3
 800ee18:	81fb      	strh	r3, [r7, #14]
    SE3_MEM_INFO_SET(p, u16tmp);
 800ee1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee1c:	3302      	adds	r3, #2
 800ee1e:	89fa      	ldrh	r2, [r7, #14]
 800ee20:	801a      	strh	r2, [r3, #0]

    // update index
	mem->ptr[i] = p;
 800ee22:	687b      	ldr	r3, [r7, #4]
 800ee24:	685a      	ldr	r2, [r3, #4]
 800ee26:	6a3b      	ldr	r3, [r7, #32]
 800ee28:	009b      	lsls	r3, r3, #2
 800ee2a:	4413      	add	r3, r2
 800ee2c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800ee2e:	601a      	str	r2, [r3, #0]
	(mem->used) += nblocks;
 800ee30:	687b      	ldr	r3, [r7, #4]
 800ee32:	691b      	ldr	r3, [r3, #16]
 800ee34:	89ba      	ldrh	r2, [r7, #12]
 800ee36:	441a      	add	r2, r3
 800ee38:	687b      	ldr	r3, [r7, #4]
 800ee3a:	611a      	str	r2, [r3, #16]

	return (int32_t)i;
 800ee3c:	6a3b      	ldr	r3, [r7, #32]
}
 800ee3e:	4618      	mov	r0, r3
 800ee40:	3728      	adds	r7, #40	; 0x28
 800ee42:	46bd      	mov	sp, r7
 800ee44:	bd80      	pop	{r7, pc}

0800ee46 <se3_mem_ptr>:

uint8_t* se3_mem_ptr(se3_mem* mem, int32_t id)
{
 800ee46:	b480      	push	{r7}
 800ee48:	b083      	sub	sp, #12
 800ee4a:	af00      	add	r7, sp, #0
 800ee4c:	6078      	str	r0, [r7, #4]
 800ee4e:	6039      	str	r1, [r7, #0]
    if (id < 0) {
 800ee50:	683b      	ldr	r3, [r7, #0]
 800ee52:	2b00      	cmp	r3, #0
 800ee54:	da01      	bge.n	800ee5a <se3_mem_ptr+0x14>
        return NULL;
 800ee56:	2300      	movs	r3, #0
 800ee58:	e017      	b.n	800ee8a <se3_mem_ptr+0x44>
    }
	if ((uint32_t)id < mem->max_count) {
 800ee5a:	687b      	ldr	r3, [r7, #4]
 800ee5c:	681a      	ldr	r2, [r3, #0]
 800ee5e:	683b      	ldr	r3, [r7, #0]
 800ee60:	429a      	cmp	r2, r3
 800ee62:	d911      	bls.n	800ee88 <se3_mem_ptr+0x42>
		if (mem->ptr[id] == NULL) {
 800ee64:	687b      	ldr	r3, [r7, #4]
 800ee66:	685a      	ldr	r2, [r3, #4]
 800ee68:	683b      	ldr	r3, [r7, #0]
 800ee6a:	009b      	lsls	r3, r3, #2
 800ee6c:	4413      	add	r3, r2
 800ee6e:	681b      	ldr	r3, [r3, #0]
 800ee70:	2b00      	cmp	r3, #0
 800ee72:	d101      	bne.n	800ee78 <se3_mem_ptr+0x32>
			SE3_TRACE(("E mem_ptr index points to NULL\n"));
			return NULL;
 800ee74:	2300      	movs	r3, #0
 800ee76:	e008      	b.n	800ee8a <se3_mem_ptr+0x44>
		}
        return mem->ptr[id] + SE3_MEM_HEADER;
 800ee78:	687b      	ldr	r3, [r7, #4]
 800ee7a:	685a      	ldr	r2, [r3, #4]
 800ee7c:	683b      	ldr	r3, [r7, #0]
 800ee7e:	009b      	lsls	r3, r3, #2
 800ee80:	4413      	add	r3, r2
 800ee82:	681b      	ldr	r3, [r3, #0]
 800ee84:	3304      	adds	r3, #4
 800ee86:	e000      	b.n	800ee8a <se3_mem_ptr+0x44>
	}
	else {
		SE3_TRACE(("E mem_ptr index out of range\n"));
	}
	return NULL;
 800ee88:	2300      	movs	r3, #0
}
 800ee8a:	4618      	mov	r0, r3
 800ee8c:	370c      	adds	r7, #12
 800ee8e:	46bd      	mov	sp, r7
 800ee90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee94:	4770      	bx	lr

0800ee96 <se3_mem_free>:

void se3_mem_free(se3_mem* mem, int32_t id)
{
 800ee96:	b480      	push	{r7}
 800ee98:	b085      	sub	sp, #20
 800ee9a:	af00      	add	r7, sp, #0
 800ee9c:	6078      	str	r0, [r7, #4]
 800ee9e:	6039      	str	r1, [r7, #0]
	uint8_t* p;
    uint16_t info;
    uint16_t size;
    if (id < 0) {
 800eea0:	683b      	ldr	r3, [r7, #0]
 800eea2:	2b00      	cmp	r3, #0
 800eea4:	db2b      	blt.n	800eefe <se3_mem_free+0x68>
        return;
    }
	if ((uint32_t)id < mem->max_count) {
 800eea6:	687b      	ldr	r3, [r7, #4]
 800eea8:	681a      	ldr	r2, [r3, #0]
 800eeaa:	683b      	ldr	r3, [r7, #0]
 800eeac:	429a      	cmp	r2, r3
 800eeae:	d927      	bls.n	800ef00 <se3_mem_free+0x6a>
		p = mem->ptr[id];
 800eeb0:	687b      	ldr	r3, [r7, #4]
 800eeb2:	685a      	ldr	r2, [r3, #4]
 800eeb4:	683b      	ldr	r3, [r7, #0]
 800eeb6:	009b      	lsls	r3, r3, #2
 800eeb8:	4413      	add	r3, r2
 800eeba:	681b      	ldr	r3, [r3, #0]
 800eebc:	60fb      	str	r3, [r7, #12]
		mem->ptr[id] = NULL;
 800eebe:	687b      	ldr	r3, [r7, #4]
 800eec0:	685a      	ldr	r2, [r3, #4]
 800eec2:	683b      	ldr	r3, [r7, #0]
 800eec4:	009b      	lsls	r3, r3, #2
 800eec6:	4413      	add	r3, r2
 800eec8:	2200      	movs	r2, #0
 800eeca:	601a      	str	r2, [r3, #0]
        SE3_MEM_SIZE_GET(p, size);
 800eecc:	68fb      	ldr	r3, [r7, #12]
 800eece:	881b      	ldrh	r3, [r3, #0]
 800eed0:	b29b      	uxth	r3, r3
 800eed2:	813b      	strh	r3, [r7, #8]
        SE3_MEM_INFO_GET(p, info);
 800eed4:	68fb      	ldr	r3, [r7, #12]
 800eed6:	3302      	adds	r3, #2
 800eed8:	881b      	ldrh	r3, [r3, #0]
 800eeda:	b29b      	uxth	r3, r3
 800eedc:	817b      	strh	r3, [r7, #10]
        info = SE3_MEM_INFO_MAKE(SE3_MEM_INFO_ID(info), 0);
 800eede:	897b      	ldrh	r3, [r7, #10]
 800eee0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800eee4:	b29b      	uxth	r3, r3
 800eee6:	817b      	strh	r3, [r7, #10]
        SE3_MEM_INFO_SET(p, info);
 800eee8:	68fb      	ldr	r3, [r7, #12]
 800eeea:	3302      	adds	r3, #2
 800eeec:	897a      	ldrh	r2, [r7, #10]
 800eeee:	801a      	strh	r2, [r3, #0]
        (mem->used) -= size;
 800eef0:	687b      	ldr	r3, [r7, #4]
 800eef2:	691b      	ldr	r3, [r3, #16]
 800eef4:	893a      	ldrh	r2, [r7, #8]
 800eef6:	1a9a      	subs	r2, r3, r2
 800eef8:	687b      	ldr	r3, [r7, #4]
 800eefa:	611a      	str	r2, [r3, #16]
 800eefc:	e000      	b.n	800ef00 <se3_mem_free+0x6a>
        return;
 800eefe:	bf00      	nop
	}
}
 800ef00:	3714      	adds	r7, #20
 800ef02:	46bd      	mov	sp, r7
 800ef04:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef08:	4770      	bx	lr
	...

0800ef0c <se3_security_core_init>:
union {
    B5_tSha256Ctx sha;
    B5_tAesCtx aes;
} ctx;

void se3_security_core_init(){
 800ef0c:	b580      	push	{r7, lr}
 800ef0e:	af00      	add	r7, sp, #0
    memset(&ctx, 0, sizeof(ctx));
 800ef10:	f44f 72b4 	mov.w	r2, #360	; 0x168
 800ef14:	2100      	movs	r1, #0
 800ef16:	4805      	ldr	r0, [pc, #20]	; (800ef2c <se3_security_core_init+0x20>)
 800ef18:	f00c f869 	bl	801afee <memset>
    memset((void*)&se3_security_info, 0, sizeof(SE3_SECURITY_INFO));
 800ef1c:	22e4      	movs	r2, #228	; 0xe4
 800ef1e:	2100      	movs	r1, #0
 800ef20:	4803      	ldr	r0, [pc, #12]	; (800ef30 <se3_security_core_init+0x24>)
 800ef22:	f00c f864 	bl	801afee <memset>
}
 800ef26:	bf00      	nop
 800ef28:	bd80      	pop	{r7, pc}
 800ef2a:	bf00      	nop
 800ef2c:	2000cd30 	.word	0x2000cd30
 800ef30:	200004cc 	.word	0x200004cc

0800ef34 <record_find>:

static bool record_find(uint16_t record_type, se3_flash_it* it)
{
 800ef34:	b580      	push	{r7, lr}
 800ef36:	b084      	sub	sp, #16
 800ef38:	af00      	add	r7, sp, #0
 800ef3a:	4603      	mov	r3, r0
 800ef3c:	6039      	str	r1, [r7, #0]
 800ef3e:	80fb      	strh	r3, [r7, #6]
    uint16_t it_record_type = 0;
 800ef40:	2300      	movs	r3, #0
 800ef42:	81fb      	strh	r3, [r7, #14]
    while (se3_flash_it_next(it)) {
 800ef44:	e00e      	b.n	800ef64 <record_find+0x30>
        if (it->type == SE3_FLASH_TYPE_RECORD) {
 800ef46:	683b      	ldr	r3, [r7, #0]
 800ef48:	791b      	ldrb	r3, [r3, #4]
 800ef4a:	2bf0      	cmp	r3, #240	; 0xf0
 800ef4c:	d10a      	bne.n	800ef64 <record_find+0x30>
            SE3_GET16(it->addr, SE3_RECORD_OFFSET_TYPE, it_record_type);
 800ef4e:	683b      	ldr	r3, [r7, #0]
 800ef50:	681b      	ldr	r3, [r3, #0]
 800ef52:	881b      	ldrh	r3, [r3, #0]
 800ef54:	b29b      	uxth	r3, r3
 800ef56:	81fb      	strh	r3, [r7, #14]
            if (it_record_type == record_type) {
 800ef58:	89fb      	ldrh	r3, [r7, #14]
 800ef5a:	88fa      	ldrh	r2, [r7, #6]
 800ef5c:	429a      	cmp	r2, r3
 800ef5e:	d101      	bne.n	800ef64 <record_find+0x30>
                return true;
 800ef60:	2301      	movs	r3, #1
 800ef62:	e006      	b.n	800ef72 <record_find+0x3e>
    while (se3_flash_it_next(it)) {
 800ef64:	6838      	ldr	r0, [r7, #0]
 800ef66:	f7ff fa6f 	bl	800e448 <se3_flash_it_next>
 800ef6a:	4603      	mov	r3, r0
 800ef6c:	2b00      	cmp	r3, #0
 800ef6e:	d1ea      	bne.n	800ef46 <record_find+0x12>
            }
        }
    }
    return false;
 800ef70:	2300      	movs	r3, #0
}
 800ef72:	4618      	mov	r0, r3
 800ef74:	3710      	adds	r7, #16
 800ef76:	46bd      	mov	sp, r7
 800ef78:	bd80      	pop	{r7, pc}

0800ef7a <record_set>:

bool record_set(uint16_t type, const uint8_t* data)
{
 800ef7a:	b590      	push	{r4, r7, lr}
 800ef7c:	b08d      	sub	sp, #52	; 0x34
 800ef7e:	af00      	add	r7, sp, #0
 800ef80:	4603      	mov	r3, r0
 800ef82:	6039      	str	r1, [r7, #0]
 800ef84:	80fb      	strh	r3, [r7, #6]
    se3_flash_it it;
    bool found = false;
 800ef86:	2300      	movs	r3, #0
 800ef88:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    se3_flash_it it2;
    uint8_t tmp[2];
    if (type >= SE3_RECORD_MAX) {
 800ef8c:	88fb      	ldrh	r3, [r7, #6]
 800ef8e:	2b01      	cmp	r3, #1
 800ef90:	d901      	bls.n	800ef96 <record_set+0x1c>
        return false;
 800ef92:	2300      	movs	r3, #0
 800ef94:	e05a      	b.n	800f04c <record_set+0xd2>
    }
    se3_flash_it_init(&it);
 800ef96:	f107 031c 	add.w	r3, r7, #28
 800ef9a:	4618      	mov	r0, r3
 800ef9c:	f7ff fa47 	bl	800e42e <se3_flash_it_init>
    if (record_find(type, &it)) {
 800efa0:	88fb      	ldrh	r3, [r7, #6]
 800efa2:	f107 021c 	add.w	r2, r7, #28
 800efa6:	4611      	mov	r1, r2
 800efa8:	4618      	mov	r0, r3
 800efaa:	f7ff ffc3 	bl	800ef34 <record_find>
 800efae:	4603      	mov	r3, r0
 800efb0:	2b00      	cmp	r3, #0
 800efb2:	d002      	beq.n	800efba <record_set+0x40>
        found = true;
 800efb4:	2301      	movs	r3, #1
 800efb6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }

    // allocate new flash block
    memcpy(&it2, &it, sizeof(se3_flash_it));
 800efba:	f107 040c 	add.w	r4, r7, #12
 800efbe:	f107 031c 	add.w	r3, r7, #28
 800efc2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800efc4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if (!se3_flash_it_new(&it2, SE3_FLASH_TYPE_RECORD, SE3_RECORD_SIZE_TYPE + SE3_RECORD_SIZE)) {
 800efc8:	f107 030c 	add.w	r3, r7, #12
 800efcc:	2222      	movs	r2, #34	; 0x22
 800efce:	21f0      	movs	r1, #240	; 0xf0
 800efd0:	4618      	mov	r0, r3
 800efd2:	f7ff faa7 	bl	800e524 <se3_flash_it_new>
 800efd6:	4603      	mov	r3, r0
 800efd8:	f083 0301 	eor.w	r3, r3, #1
 800efdc:	b2db      	uxtb	r3, r3
 800efde:	2b00      	cmp	r3, #0
 800efe0:	d001      	beq.n	800efe6 <record_set+0x6c>
        return false;
 800efe2:	2300      	movs	r3, #0
 800efe4:	e032      	b.n	800f04c <record_set+0xd2>
    }
    // write record type and data
    if (!se3_flash_it_write(&it2, SE3_RECORD_OFFSET_DATA, data, SE3_RECORD_SIZE)) {
 800efe6:	f107 000c 	add.w	r0, r7, #12
 800efea:	2320      	movs	r3, #32
 800efec:	683a      	ldr	r2, [r7, #0]
 800efee:	2102      	movs	r1, #2
 800eff0:	f7ff f9fa 	bl	800e3e8 <se3_flash_it_write>
 800eff4:	4603      	mov	r3, r0
 800eff6:	f083 0301 	eor.w	r3, r3, #1
 800effa:	b2db      	uxtb	r3, r3
 800effc:	2b00      	cmp	r3, #0
 800effe:	d001      	beq.n	800f004 <record_set+0x8a>
        return false;
 800f000:	2300      	movs	r3, #0
 800f002:	e023      	b.n	800f04c <record_set+0xd2>
    }
    SE3_SET16(tmp, 0, type);
 800f004:	88fb      	ldrh	r3, [r7, #6]
 800f006:	813b      	strh	r3, [r7, #8]
    if (!se3_flash_it_write(&it2, SE3_RECORD_OFFSET_TYPE, tmp, SE3_RECORD_SIZE_TYPE)) {
 800f008:	f107 0208 	add.w	r2, r7, #8
 800f00c:	f107 000c 	add.w	r0, r7, #12
 800f010:	2302      	movs	r3, #2
 800f012:	2100      	movs	r1, #0
 800f014:	f7ff f9e8 	bl	800e3e8 <se3_flash_it_write>
 800f018:	4603      	mov	r3, r0
 800f01a:	f083 0301 	eor.w	r3, r3, #1
 800f01e:	b2db      	uxtb	r3, r3
 800f020:	2b00      	cmp	r3, #0
 800f022:	d001      	beq.n	800f028 <record_set+0xae>
        return false;
 800f024:	2300      	movs	r3, #0
 800f026:	e011      	b.n	800f04c <record_set+0xd2>
    }

    if (found) {
 800f028:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800f02c:	2b00      	cmp	r3, #0
 800f02e:	d00c      	beq.n	800f04a <record_set+0xd0>
        // delete previously found flash block
        if (!se3_flash_it_delete(&it)) {
 800f030:	f107 031c 	add.w	r3, r7, #28
 800f034:	4618      	mov	r0, r3
 800f036:	f7ff fb29 	bl	800e68c <se3_flash_it_delete>
 800f03a:	4603      	mov	r3, r0
 800f03c:	f083 0301 	eor.w	r3, r3, #1
 800f040:	b2db      	uxtb	r3, r3
 800f042:	2b00      	cmp	r3, #0
 800f044:	d001      	beq.n	800f04a <record_set+0xd0>
            return false;
 800f046:	2300      	movs	r3, #0
 800f048:	e000      	b.n	800f04c <record_set+0xd2>
        }
    }

    return true;
 800f04a:	2301      	movs	r3, #1
}
 800f04c:	4618      	mov	r0, r3
 800f04e:	3734      	adds	r7, #52	; 0x34
 800f050:	46bd      	mov	sp, r7
 800f052:	bd90      	pop	{r4, r7, pc}

0800f054 <record_get>:

bool record_get(uint16_t type, uint8_t* data)
{
 800f054:	b580      	push	{r7, lr}
 800f056:	b086      	sub	sp, #24
 800f058:	af00      	add	r7, sp, #0
 800f05a:	4603      	mov	r3, r0
 800f05c:	6039      	str	r1, [r7, #0]
 800f05e:	80fb      	strh	r3, [r7, #6]
    se3_flash_it it;
    if (type >= SE3_RECORD_MAX) {
 800f060:	88fb      	ldrh	r3, [r7, #6]
 800f062:	2b01      	cmp	r3, #1
 800f064:	d901      	bls.n	800f06a <record_get+0x16>
        return false;
 800f066:	2300      	movs	r3, #0
 800f068:	e01b      	b.n	800f0a2 <record_get+0x4e>
    }
    se3_flash_it_init(&it);
 800f06a:	f107 0308 	add.w	r3, r7, #8
 800f06e:	4618      	mov	r0, r3
 800f070:	f7ff f9dd 	bl	800e42e <se3_flash_it_init>
    if (!record_find(type, &it)) {
 800f074:	f107 0208 	add.w	r2, r7, #8
 800f078:	88fb      	ldrh	r3, [r7, #6]
 800f07a:	4611      	mov	r1, r2
 800f07c:	4618      	mov	r0, r3
 800f07e:	f7ff ff59 	bl	800ef34 <record_find>
 800f082:	4603      	mov	r3, r0
 800f084:	f083 0301 	eor.w	r3, r3, #1
 800f088:	b2db      	uxtb	r3, r3
 800f08a:	2b00      	cmp	r3, #0
 800f08c:	d001      	beq.n	800f092 <record_get+0x3e>
        return false;
 800f08e:	2300      	movs	r3, #0
 800f090:	e007      	b.n	800f0a2 <record_get+0x4e>
    }
    memcpy(data, it.addr + SE3_RECORD_OFFSET_DATA, SE3_RECORD_SIZE);
 800f092:	68bb      	ldr	r3, [r7, #8]
 800f094:	3302      	adds	r3, #2
 800f096:	2220      	movs	r2, #32
 800f098:	4619      	mov	r1, r3
 800f09a:	6838      	ldr	r0, [r7, #0]
 800f09c:	f00b ff83 	bl	801afa6 <memcpy>
    return true;
 800f0a0:	2301      	movs	r3, #1
}
 800f0a2:	4618      	mov	r0, r3
 800f0a4:	3718      	adds	r7, #24
 800f0a6:	46bd      	mov	sp, r7
 800f0a8:	bd80      	pop	{r7, pc}

0800f0aa <concat>:

char* concat(char *s1, char *s2)
{
 800f0aa:	b580      	push	{r7, lr}
 800f0ac:	b086      	sub	sp, #24
 800f0ae:	af00      	add	r7, sp, #0
 800f0b0:	6078      	str	r0, [r7, #4]
 800f0b2:	6039      	str	r1, [r7, #0]
    size_t len1 = strlen(s1);
 800f0b4:	6878      	ldr	r0, [r7, #4]
 800f0b6:	f7f1 f89b 	bl	80001f0 <strlen>
 800f0ba:	6178      	str	r0, [r7, #20]
    size_t len2 = strlen(s2);
 800f0bc:	6838      	ldr	r0, [r7, #0]
 800f0be:	f7f1 f897 	bl	80001f0 <strlen>
 800f0c2:	6138      	str	r0, [r7, #16]
    char *result = malloc(len1+len2+1);//+1 for the zero-terminator
 800f0c4:	697a      	ldr	r2, [r7, #20]
 800f0c6:	693b      	ldr	r3, [r7, #16]
 800f0c8:	4413      	add	r3, r2
 800f0ca:	3301      	adds	r3, #1
 800f0cc:	4618      	mov	r0, r3
 800f0ce:	f00b ff4b 	bl	801af68 <malloc>
 800f0d2:	4603      	mov	r3, r0
 800f0d4:	60fb      	str	r3, [r7, #12]
    //in real code you would check for errors in malloc here
    memcpy(result, s1, len1);
 800f0d6:	697a      	ldr	r2, [r7, #20]
 800f0d8:	6879      	ldr	r1, [r7, #4]
 800f0da:	68f8      	ldr	r0, [r7, #12]
 800f0dc:	f00b ff63 	bl	801afa6 <memcpy>
    memcpy(result+len1, s2, len2+1);//+1 to copy the null-terminator
 800f0e0:	68fa      	ldr	r2, [r7, #12]
 800f0e2:	697b      	ldr	r3, [r7, #20]
 800f0e4:	18d0      	adds	r0, r2, r3
 800f0e6:	693b      	ldr	r3, [r7, #16]
 800f0e8:	3301      	adds	r3, #1
 800f0ea:	461a      	mov	r2, r3
 800f0ec:	6839      	ldr	r1, [r7, #0]
 800f0ee:	f00b ff5a 	bl	801afa6 <memcpy>
    return result;
 800f0f2:	68fb      	ldr	r3, [r7, #12]
}
 800f0f4:	4618      	mov	r0, r3
 800f0f6:	3718      	adds	r7, #24
 800f0f8:	46bd      	mov	sp, r7
 800f0fa:	bd80      	pop	{r7, pc}

0800f0fc <crypto_kem_keypair>:
/** \brief initialize a crypto context
 *
 *  crypto_init : (algo:ui16, mode:ui16, key_id:ui32) => (sid:ui32)
 */
uint16_t crypto_kem_keypair(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800f0fc:	b580      	push	{r7, lr}
 800f0fe:	b09a      	sub	sp, #104	; 0x68
 800f100:	af00      	add	r7, sp, #0
 800f102:	60b9      	str	r1, [r7, #8]
 800f104:	607a      	str	r2, [r7, #4]
 800f106:	603b      	str	r3, [r7, #0]
 800f108:	4603      	mov	r3, r0
 800f10a:	81fb      	strh	r3, [r7, #14]
        uint8_t* pk;
    } resp_params;

    se3_flash_key sk;
    se3_flash_key pk;
    se3_flash_it it = { .addr = NULL };
 800f10c:	f107 0314 	add.w	r3, r7, #20
 800f110:	2200      	movs	r2, #0
 800f112:	601a      	str	r2, [r3, #0]
 800f114:	605a      	str	r2, [r3, #4]
 800f116:	609a      	str	r2, [r3, #8]
 800f118:	60da      	str	r2, [r3, #12]
    se3_crypto_kem_keypair_handler handler = NULL;
 800f11a:	2300      	movs	r3, #0
 800f11c:	667b      	str	r3, [r7, #100]	; 0x64
    uint32_t status;

    if (req_size != SE3_CMD1_CRYPTO_KEM_KEYPAIR_REQ_SIZE) {
 800f11e:	89fb      	ldrh	r3, [r7, #14]
 800f120:	2b0a      	cmp	r3, #10
 800f122:	d002      	beq.n	800f12a <crypto_kem_keypair+0x2e>
        SE3_TRACE(("[crypto_kem_keypair] req size mismatch\n"));
        return SE3_ERR_PARAMS;
 800f124:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f128:	e105      	b.n	800f336 <crypto_kem_keypair+0x23a>
    }

    SE3_GET16(req, SE3_CMD1_CRYPTO_KEM_KEYPAIR_REQ_OFF_ALGORITHM, req_params.algo);
 800f12a:	68bb      	ldr	r3, [r7, #8]
 800f12c:	881b      	ldrh	r3, [r3, #0]
 800f12e:	b29b      	uxth	r3, r3
 800f130:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    SE3_GET32(req, SE3_CMD1_CRYPTO_KEM_KEYPAIR_REQ_OFF_KEY_VALID, req_params.key_valid);
 800f134:	68bb      	ldr	r3, [r7, #8]
 800f136:	3302      	adds	r3, #2
 800f138:	681b      	ldr	r3, [r3, #0]
 800f13a:	65bb      	str	r3, [r7, #88]	; 0x58
    SE3_GET32(req, SE3_CMD1_CRYPTO_KEM_KEYPAIR_REQ_OFF_SK_ID, req_params.sk_id);
 800f13c:	68bb      	ldr	r3, [r7, #8]
 800f13e:	3306      	adds	r3, #6
 800f140:	681b      	ldr	r3, [r3, #0]
 800f142:	65fb      	str	r3, [r7, #92]	; 0x5c

    if (req_params.algo < SE3_KEM_ALGO_MAX) {
 800f144:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f148:	2b07      	cmp	r3, #7
 800f14a:	d80a      	bhi.n	800f162 <crypto_kem_keypair+0x66>
        handler = kem_table[req_params.algo].keypair;
 800f14c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f150:	4619      	mov	r1, r3
 800f152:	4a7b      	ldr	r2, [pc, #492]	; (800f340 <crypto_kem_keypair+0x244>)
 800f154:	460b      	mov	r3, r1
 800f156:	009b      	lsls	r3, r3, #2
 800f158:	440b      	add	r3, r1
 800f15a:	00db      	lsls	r3, r3, #3
 800f15c:	4413      	add	r3, r2
 800f15e:	681b      	ldr	r3, [r3, #0]
 800f160:	667b      	str	r3, [r7, #100]	; 0x64
    }
    if (handler == NULL) {
 800f162:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800f164:	2b00      	cmp	r3, #0
 800f166:	d102      	bne.n	800f16e <crypto_kem_keypair+0x72>
        SE3_TRACE(("[crypto_kem_keypair] algo not found\n"));
        return SE3_ERR_PARAMS;
 800f168:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f16c:	e0e3      	b.n	800f336 <crypto_kem_keypair+0x23a>
    }


    pk.data=resp+SE3_CMD1_CRYPTO_KEM_KEYPAIR_RESP_OFF_PK_DATA;
 800f16e:	683b      	ldr	r3, [r7, #0]
 800f170:	3310      	adds	r3, #16
 800f172:	633b      	str	r3, [r7, #48]	; 0x30
    sk.data=malloc(kem_table[req_params.algo].display_secret_key_size);
 800f174:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f178:	4619      	mov	r1, r3
 800f17a:	4a71      	ldr	r2, [pc, #452]	; (800f340 <crypto_kem_keypair+0x244>)
 800f17c:	460b      	mov	r3, r1
 800f17e:	009b      	lsls	r3, r3, #2
 800f180:	440b      	add	r3, r1
 800f182:	00db      	lsls	r3, r3, #3
 800f184:	4413      	add	r3, r2
 800f186:	3324      	adds	r3, #36	; 0x24
 800f188:	881b      	ldrh	r3, [r3, #0]
 800f18a:	4618      	mov	r0, r3
 800f18c:	f00b feec 	bl	801af68 <malloc>
 800f190:	4603      	mov	r3, r0
 800f192:	647b      	str	r3, [r7, #68]	; 0x44
    status = handler(pk.data, sk.data);
 800f194:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f196:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800f198:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800f19a:	4610      	mov	r0, r2
 800f19c:	4798      	blx	r3
 800f19e:	4603      	mov	r3, r0
 800f1a0:	663b      	str	r3, [r7, #96]	; 0x60

	pk.data_size=kem_table[req_params.algo].display_public_key_size;
 800f1a2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f1a6:	4619      	mov	r1, r3
 800f1a8:	4a65      	ldr	r2, [pc, #404]	; (800f340 <crypto_kem_keypair+0x244>)
 800f1aa:	460b      	mov	r3, r1
 800f1ac:	009b      	lsls	r3, r3, #2
 800f1ae:	440b      	add	r3, r1
 800f1b0:	00db      	lsls	r3, r3, #3
 800f1b2:	4413      	add	r3, r2
 800f1b4:	3322      	adds	r3, #34	; 0x22
 800f1b6:	881b      	ldrh	r3, [r3, #0]
 800f1b8:	85bb      	strh	r3, [r7, #44]	; 0x2c
	sk.data_size=kem_table[req_params.algo].display_secret_key_size;
 800f1ba:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f1be:	4619      	mov	r1, r3
 800f1c0:	4a5f      	ldr	r2, [pc, #380]	; (800f340 <crypto_kem_keypair+0x244>)
 800f1c2:	460b      	mov	r3, r1
 800f1c4:	009b      	lsls	r3, r3, #2
 800f1c6:	440b      	add	r3, r1
 800f1c8:	00db      	lsls	r3, r3, #3
 800f1ca:	4413      	add	r3, r2
 800f1cc:	3324      	adds	r3, #36	; 0x24
 800f1ce:	881b      	ldrh	r3, [r3, #0]
 800f1d0:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
	pk.name = concat(kem_table[req_params.algo].display_name, ", public key");
 800f1d4:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f1d8:	461a      	mov	r2, r3
 800f1da:	4613      	mov	r3, r2
 800f1dc:	009b      	lsls	r3, r3, #2
 800f1de:	4413      	add	r3, r2
 800f1e0:	00db      	lsls	r3, r3, #3
 800f1e2:	3308      	adds	r3, #8
 800f1e4:	4a56      	ldr	r2, [pc, #344]	; (800f340 <crypto_kem_keypair+0x244>)
 800f1e6:	4413      	add	r3, r2
 800f1e8:	3304      	adds	r3, #4
 800f1ea:	4956      	ldr	r1, [pc, #344]	; (800f344 <crypto_kem_keypair+0x248>)
 800f1ec:	4618      	mov	r0, r3
 800f1ee:	f7ff ff5c 	bl	800f0aa <concat>
 800f1f2:	4603      	mov	r3, r0
 800f1f4:	637b      	str	r3, [r7, #52]	; 0x34
	sk.name = concat(kem_table[req_params.algo].display_name, ", secret key");
 800f1f6:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 800f1fa:	461a      	mov	r2, r3
 800f1fc:	4613      	mov	r3, r2
 800f1fe:	009b      	lsls	r3, r3, #2
 800f200:	4413      	add	r3, r2
 800f202:	00db      	lsls	r3, r3, #3
 800f204:	3308      	adds	r3, #8
 800f206:	4a4e      	ldr	r2, [pc, #312]	; (800f340 <crypto_kem_keypair+0x244>)
 800f208:	4413      	add	r3, r2
 800f20a:	3304      	adds	r3, #4
 800f20c:	494e      	ldr	r1, [pc, #312]	; (800f348 <crypto_kem_keypair+0x24c>)
 800f20e:	4618      	mov	r0, r3
 800f210:	f7ff ff4b 	bl	800f0aa <concat>
 800f214:	4603      	mov	r3, r0
 800f216:	64bb      	str	r3, [r7, #72]	; 0x48
    pk.id = SE3_KEYPAIR_ID_OFFSET  + 2 * req_params.sk_id + 1;
 800f218:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f21a:	3303      	adds	r3, #3
 800f21c:	005b      	lsls	r3, r3, #1
 800f21e:	627b      	str	r3, [r7, #36]	; 0x24
    sk.id = SE3_KEYPAIR_ID_OFFSET  + 2 * req_params.sk_id;
 800f220:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f222:	005b      	lsls	r3, r3, #1
 800f224:	3305      	adds	r3, #5
 800f226:	63bb      	str	r3, [r7, #56]	; 0x38
    pk.validity = req_params.key_valid;
 800f228:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f22a:	62bb      	str	r3, [r7, #40]	; 0x28
    sk.validity = req_params.key_valid;
 800f22c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800f22e:	63fb      	str	r3, [r7, #60]	; 0x3c
    pk.name_size = strlen(pk.name);
 800f230:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f232:	4618      	mov	r0, r3
 800f234:	f7f0 ffdc 	bl	80001f0 <strlen>
 800f238:	4603      	mov	r3, r0
 800f23a:	b29b      	uxth	r3, r3
 800f23c:	85fb      	strh	r3, [r7, #46]	; 0x2e
    sk.name_size = strlen(sk.name);
 800f23e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f240:	4618      	mov	r0, r3
 800f242:	f7f0 ffd5 	bl	80001f0 <strlen>
 800f246:	4603      	mov	r3, r0
 800f248:	b29b      	uxth	r3, r3
 800f24a:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    if (pk.id == SE3_KEY_INVALID) {
 800f24e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f250:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f254:	d10e      	bne.n	800f274 <crypto_kem_keypair+0x178>
        memset(pk.data, 0, SE3_KEY_DATA_MAX);
 800f256:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f258:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800f25c:	2100      	movs	r1, #0
 800f25e:	4618      	mov	r0, r3
 800f260:	f00b fec5 	bl	801afee <memset>
        memset(sk.data, 0, SE3_KEY_DATA_MAX);
 800f264:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f266:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800f26a:	2100      	movs	r1, #0
 800f26c:	4618      	mov	r0, r3
 800f26e:	f00b febe 	bl	801afee <memset>
 800f272:	e04a      	b.n	800f30a <crypto_kem_keypair+0x20e>
    }

    else {
        se3_flash_it_init(&it);
 800f274:	f107 0314 	add.w	r3, r7, #20
 800f278:	4618      	mov	r0, r3
 800f27a:	f7ff f8d8 	bl	800e42e <se3_flash_it_init>
        if (!se3_key_find(pk.id, &it)) {
 800f27e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f280:	f107 0214 	add.w	r2, r7, #20
 800f284:	4611      	mov	r1, r2
 800f286:	4618      	mov	r0, r3
 800f288:	f7ff fa40 	bl	800e70c <se3_key_find>
 800f28c:	4603      	mov	r3, r0
 800f28e:	f083 0301 	eor.w	r3, r3, #1
 800f292:	b2db      	uxtb	r3, r3
 800f294:	2b00      	cmp	r3, #0
 800f296:	d010      	beq.n	800f2ba <crypto_kem_keypair+0x1be>
            it.addr = NULL;
 800f298:	2300      	movs	r3, #0
 800f29a:	617b      	str	r3, [r7, #20]
        }
        else {
            SE3_TRACE(("[crypto_kem_keypair] public key cannot be written \n"));
            return SE3_ERR_RESOURCE;
        }
        if (!se3_key_new(&it, &pk)) {
 800f29c:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800f2a0:	f107 0314 	add.w	r3, r7, #20
 800f2a4:	4611      	mov	r1, r2
 800f2a6:	4618      	mov	r0, r3
 800f2a8:	f7ff fa54 	bl	800e754 <se3_key_new>
 800f2ac:	4603      	mov	r3, r0
 800f2ae:	f083 0301 	eor.w	r3, r3, #1
 800f2b2:	b2db      	uxtb	r3, r3
 800f2b4:	2b00      	cmp	r3, #0
 800f2b6:	d005      	beq.n	800f2c4 <crypto_kem_keypair+0x1c8>
 800f2b8:	e001      	b.n	800f2be <crypto_kem_keypair+0x1c2>
            return SE3_ERR_RESOURCE;
 800f2ba:	23c8      	movs	r3, #200	; 0xc8
 800f2bc:	e03b      	b.n	800f336 <crypto_kem_keypair+0x23a>
            SE3_TRACE(("[crypto_kem_keypair] pk se3_key_new failed\n"));
            return SE3_ERR_MEMORY;
 800f2be:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800f2c2:	e038      	b.n	800f336 <crypto_kem_keypair+0x23a>
        }
        if (!se3_key_find(sk.id, &it)) {
 800f2c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2c6:	f107 0214 	add.w	r2, r7, #20
 800f2ca:	4611      	mov	r1, r2
 800f2cc:	4618      	mov	r0, r3
 800f2ce:	f7ff fa1d 	bl	800e70c <se3_key_find>
 800f2d2:	4603      	mov	r3, r0
 800f2d4:	f083 0301 	eor.w	r3, r3, #1
 800f2d8:	b2db      	uxtb	r3, r3
 800f2da:	2b00      	cmp	r3, #0
 800f2dc:	d010      	beq.n	800f300 <crypto_kem_keypair+0x204>
            it.addr = NULL;
 800f2de:	2300      	movs	r3, #0
 800f2e0:	617b      	str	r3, [r7, #20]
        }
        else{
            SE3_TRACE(("[crypto_kem_keypair] secret key cannot be written \n"));
            return SE3_ERR_RESOURCE;
        }
        if (!se3_key_new(&it, &sk)) {
 800f2e2:	f107 0238 	add.w	r2, r7, #56	; 0x38
 800f2e6:	f107 0314 	add.w	r3, r7, #20
 800f2ea:	4611      	mov	r1, r2
 800f2ec:	4618      	mov	r0, r3
 800f2ee:	f7ff fa31 	bl	800e754 <se3_key_new>
 800f2f2:	4603      	mov	r3, r0
 800f2f4:	f083 0301 	eor.w	r3, r3, #1
 800f2f8:	b2db      	uxtb	r3, r3
 800f2fa:	2b00      	cmp	r3, #0
 800f2fc:	d005      	beq.n	800f30a <crypto_kem_keypair+0x20e>
 800f2fe:	e001      	b.n	800f304 <crypto_kem_keypair+0x208>
            return SE3_ERR_RESOURCE;
 800f300:	23c8      	movs	r3, #200	; 0xc8
 800f302:	e018      	b.n	800f336 <crypto_kem_keypair+0x23a>
            SE3_TRACE(("[crypto_kem_keypair] sk se3_key_new failed\n"));
            return SE3_ERR_MEMORY;
 800f304:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800f308:	e015      	b.n	800f336 <crypto_kem_keypair+0x23a>
        }
    }


    SE3_SET32(resp, SE3_CMD1_CRYPTO_KEM_KEYPAIR_RESP_OFF_PK_LEN, pk.data_size);
 800f30a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f30c:	683b      	ldr	r3, [r7, #0]
 800f30e:	601a      	str	r2, [r3, #0]
    *resp_size = SE3_CMD1_CRYPTO_KEM_KEYPAIR_RESP_OFF_PK_DATA+pk.data_size;
 800f310:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800f312:	3310      	adds	r3, #16
 800f314:	b29a      	uxth	r2, r3
 800f316:	687b      	ldr	r3, [r7, #4]
 800f318:	801a      	strh	r2, [r3, #0]
    free(sk.data);
 800f31a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f31c:	4618      	mov	r0, r3
 800f31e:	f00b fe2b 	bl	801af78 <free>
    free(sk.name);
 800f322:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f324:	4618      	mov	r0, r3
 800f326:	f00b fe27 	bl	801af78 <free>
    free(pk.name);
 800f32a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f32c:	4618      	mov	r0, r3
 800f32e:	f00b fe23 	bl	801af78 <free>

	return status;
 800f332:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800f334:	b29b      	uxth	r3, r3
}
 800f336:	4618      	mov	r0, r3
 800f338:	3768      	adds	r7, #104	; 0x68
 800f33a:	46bd      	mov	sp, r7
 800f33c:	bd80      	pop	{r7, pc}
 800f33e:	bf00      	nop
 800f340:	200000c4 	.word	0x200000c4
 800f344:	0801e16c 	.word	0x0801e16c
 800f348:	0801e17c 	.word	0x0801e17c

0800f34c <crypto_kem_enc>:
uint16_t crypto_kem_enc(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp){
 800f34c:	b580      	push	{r7, lr}
 800f34e:	b08e      	sub	sp, #56	; 0x38
 800f350:	af00      	add	r7, sp, #0
 800f352:	60b9      	str	r1, [r7, #8]
 800f354:	607a      	str	r2, [r7, #4]
 800f356:	603b      	str	r3, [r7, #0]
 800f358:	4603      	mov	r3, r0
 800f35a:	81fb      	strh	r3, [r7, #14]
        uint8_t* ct;
        uint32_t ss_len;
        uint8_t* ss;
    } resp_params;

    se3_crypto_kem_enc_handler handler = NULL;
 800f35c:	2300      	movs	r3, #0
 800f35e:	637b      	str	r3, [r7, #52]	; 0x34
    uint32_t status;

    if (req_size < SE3_CMD1_CRYPTO_KEM_ENC_REQ_OFF_PK_DATA) {
 800f360:	89fb      	ldrh	r3, [r7, #14]
 800f362:	2b05      	cmp	r3, #5
 800f364:	d802      	bhi.n	800f36c <crypto_kem_enc+0x20>
        SE3_TRACE(("[crypto_kem_enc] req size mismatch\n"));
        return SE3_ERR_PARAMS;
 800f366:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f36a:	e056      	b.n	800f41a <crypto_kem_enc+0xce>
    }

    SE3_GET16(req, SE3_CMD1_CRYPTO_KEM_ENC_REQ_OFF_ALGORITHM, req_params.algo);
 800f36c:	68bb      	ldr	r3, [r7, #8]
 800f36e:	881b      	ldrh	r3, [r3, #0]
 800f370:	b29b      	uxth	r3, r3
 800f372:	84bb      	strh	r3, [r7, #36]	; 0x24
    SE3_GET32(req, SE3_CMD1_CRYPTO_KEM_ENC_REQ_OFF_PK_LEN, req_params.pk_len);
 800f374:	68bb      	ldr	r3, [r7, #8]
 800f376:	3302      	adds	r3, #2
 800f378:	681b      	ldr	r3, [r3, #0]
 800f37a:	62bb      	str	r3, [r7, #40]	; 0x28
    req_params.pk = req + SE3_CMD1_CRYPTO_KEM_ENC_REQ_OFF_PK_DATA;
 800f37c:	68bb      	ldr	r3, [r7, #8]
 800f37e:	3306      	adds	r3, #6
 800f380:	62fb      	str	r3, [r7, #44]	; 0x2c


    if (req_params.algo < SE3_KEM_ALGO_MAX) {
 800f382:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800f384:	2b07      	cmp	r3, #7
 800f386:	d80a      	bhi.n	800f39e <crypto_kem_enc+0x52>
        handler = kem_table[req_params.algo].enc;
 800f388:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800f38a:	4619      	mov	r1, r3
 800f38c:	4a25      	ldr	r2, [pc, #148]	; (800f424 <crypto_kem_enc+0xd8>)
 800f38e:	460b      	mov	r3, r1
 800f390:	009b      	lsls	r3, r3, #2
 800f392:	440b      	add	r3, r1
 800f394:	00db      	lsls	r3, r3, #3
 800f396:	4413      	add	r3, r2
 800f398:	3304      	adds	r3, #4
 800f39a:	681b      	ldr	r3, [r3, #0]
 800f39c:	637b      	str	r3, [r7, #52]	; 0x34
    }
    if (handler == NULL) {
 800f39e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f3a0:	2b00      	cmp	r3, #0
 800f3a2:	d102      	bne.n	800f3aa <crypto_kem_enc+0x5e>
        SE3_TRACE(("[crypto_kem_enc] algo not found\n"));
        return SE3_ERR_PARAMS;
 800f3a4:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f3a8:	e037      	b.n	800f41a <crypto_kem_enc+0xce>
    }

	resp_params.ct_len=kem_table[req_params.algo].display_ciphertext_size;
 800f3aa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800f3ac:	4619      	mov	r1, r3
 800f3ae:	4a1d      	ldr	r2, [pc, #116]	; (800f424 <crypto_kem_enc+0xd8>)
 800f3b0:	460b      	mov	r3, r1
 800f3b2:	009b      	lsls	r3, r3, #2
 800f3b4:	440b      	add	r3, r1
 800f3b6:	00db      	lsls	r3, r3, #3
 800f3b8:	4413      	add	r3, r2
 800f3ba:	3320      	adds	r3, #32
 800f3bc:	881b      	ldrh	r3, [r3, #0]
 800f3be:	617b      	str	r3, [r7, #20]
	resp_params.ss_len=kem_table[req_params.algo].display_size;
 800f3c0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800f3c2:	4619      	mov	r1, r3
 800f3c4:	4a17      	ldr	r2, [pc, #92]	; (800f424 <crypto_kem_enc+0xd8>)
 800f3c6:	460b      	mov	r3, r1
 800f3c8:	009b      	lsls	r3, r3, #2
 800f3ca:	440b      	add	r3, r1
 800f3cc:	00db      	lsls	r3, r3, #3
 800f3ce:	4413      	add	r3, r2
 800f3d0:	331e      	adds	r3, #30
 800f3d2:	881b      	ldrh	r3, [r3, #0]
 800f3d4:	61fb      	str	r3, [r7, #28]
	resp_params.ct=resp+SE3_CMD1_CRYPTO_KEM_ENC_RESP_OFF_DATA;
 800f3d6:	683b      	ldr	r3, [r7, #0]
 800f3d8:	3308      	adds	r3, #8
 800f3da:	61bb      	str	r3, [r7, #24]
	resp_params.ss=resp+SE3_CMD1_CRYPTO_KEM_ENC_RESP_OFF_DATA+resp_params.ct_len;
 800f3dc:	697b      	ldr	r3, [r7, #20]
 800f3de:	3308      	adds	r3, #8
 800f3e0:	683a      	ldr	r2, [r7, #0]
 800f3e2:	4413      	add	r3, r2
 800f3e4:	623b      	str	r3, [r7, #32]

    status = handler(resp_params.ct, resp_params.ss, req_params.pk);
 800f3e6:	69b8      	ldr	r0, [r7, #24]
 800f3e8:	6a39      	ldr	r1, [r7, #32]
 800f3ea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f3ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f3ee:	4798      	blx	r3
 800f3f0:	4603      	mov	r3, r0
 800f3f2:	633b      	str	r3, [r7, #48]	; 0x30

    SE3_SET32(resp, SE3_CMD1_CRYPTO_KEM_ENC_RESP_OFF_CT_LEN, resp_params.ct_len);
 800f3f4:	697a      	ldr	r2, [r7, #20]
 800f3f6:	683b      	ldr	r3, [r7, #0]
 800f3f8:	601a      	str	r2, [r3, #0]
    SE3_SET32(resp, SE3_CMD1_CRYPTO_KEM_ENC_RESP_OFF_SS_LEN, resp_params.ss_len);
 800f3fa:	683b      	ldr	r3, [r7, #0]
 800f3fc:	3304      	adds	r3, #4
 800f3fe:	69fa      	ldr	r2, [r7, #28]
 800f400:	601a      	str	r2, [r3, #0]

    *resp_size = SE3_CMD1_CRYPTO_KEM_ENC_RESP_OFF_DATA+resp_params.ss_len+resp_params.ct_len;
 800f402:	69fb      	ldr	r3, [r7, #28]
 800f404:	b29a      	uxth	r2, r3
 800f406:	697b      	ldr	r3, [r7, #20]
 800f408:	b29b      	uxth	r3, r3
 800f40a:	4413      	add	r3, r2
 800f40c:	b29b      	uxth	r3, r3
 800f40e:	3308      	adds	r3, #8
 800f410:	b29a      	uxth	r2, r3
 800f412:	687b      	ldr	r3, [r7, #4]
 800f414:	801a      	strh	r2, [r3, #0]

    return status;
 800f416:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f418:	b29b      	uxth	r3, r3
}
 800f41a:	4618      	mov	r0, r3
 800f41c:	3738      	adds	r7, #56	; 0x38
 800f41e:	46bd      	mov	sp, r7
 800f420:	bd80      	pop	{r7, pc}
 800f422:	bf00      	nop
 800f424:	200000c4 	.word	0x200000c4

0800f428 <crypto_kem_dec>:

uint16_t crypto_kem_dec(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp){
 800f428:	b5b0      	push	{r4, r5, r7, lr}
 800f42a:	b096      	sub	sp, #88	; 0x58
 800f42c:	af00      	add	r7, sp, #0
 800f42e:	60b9      	str	r1, [r7, #8]
 800f430:	607a      	str	r2, [r7, #4]
 800f432:	603b      	str	r3, [r7, #0]
 800f434:	4603      	mov	r3, r0
 800f436:	81fb      	strh	r3, [r7, #14]
	    struct {
	        uint32_t ss_len;
	        uint8_t* ss;
	    } resp_params;

	    se3_crypto_kem_enc_handler handler = NULL;
 800f438:	2300      	movs	r3, #0
 800f43a:	657b      	str	r3, [r7, #84]	; 0x54
	    uint32_t status;

	    if (req_size < SE3_CMD1_CRYPTO_KEM_DEC_REQ_OFF_CT_DATA) {
 800f43c:	89fb      	ldrh	r3, [r7, #14]
 800f43e:	2b09      	cmp	r3, #9
 800f440:	d802      	bhi.n	800f448 <crypto_kem_dec+0x20>
	        SE3_TRACE(("[crypto_kem_dec] req size mismatch\n"));
	        return SE3_ERR_PARAMS;
 800f442:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f446:	e08e      	b.n	800f566 <crypto_kem_dec+0x13e>
	    }

	    SE3_GET16(req, SE3_CMD1_CRYPTO_KEM_DEC_REQ_OFF_ALGORITHM, req_params.algo);
 800f448:	68bb      	ldr	r3, [r7, #8]
 800f44a:	881b      	ldrh	r3, [r3, #0]
 800f44c:	b29b      	uxth	r3, r3
 800f44e:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
	    SE3_GET32(req, SE3_CMD1_CRYPTO_KEM_DEC_REQ_OFF_SK_ID, req_params.sk_id);
 800f452:	68bb      	ldr	r3, [r7, #8]
 800f454:	3302      	adds	r3, #2
 800f456:	681b      	ldr	r3, [r3, #0]
 800f458:	647b      	str	r3, [r7, #68]	; 0x44
	    SE3_GET32(req, SE3_CMD1_CRYPTO_KEM_DEC_REQ_OFF_CT_LEN, req_params.ct_len);
 800f45a:	68bb      	ldr	r3, [r7, #8]
 800f45c:	3306      	adds	r3, #6
 800f45e:	681b      	ldr	r3, [r3, #0]
 800f460:	64bb      	str	r3, [r7, #72]	; 0x48
	    req_params.ct = req + SE3_CMD1_CRYPTO_KEM_DEC_REQ_OFF_CT_DATA;
 800f462:	68bb      	ldr	r3, [r7, #8]
 800f464:	330a      	adds	r3, #10
 800f466:	64fb      	str	r3, [r7, #76]	; 0x4c


	    if (req_params.algo < SE3_KEM_ALGO_MAX) {
 800f468:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800f46c:	2b07      	cmp	r3, #7
 800f46e:	d80b      	bhi.n	800f488 <crypto_kem_dec+0x60>
	        handler = kem_table[req_params.algo].dec;
 800f470:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800f474:	4619      	mov	r1, r3
 800f476:	4a3e      	ldr	r2, [pc, #248]	; (800f570 <crypto_kem_dec+0x148>)
 800f478:	460b      	mov	r3, r1
 800f47a:	009b      	lsls	r3, r3, #2
 800f47c:	440b      	add	r3, r1
 800f47e:	00db      	lsls	r3, r3, #3
 800f480:	4413      	add	r3, r2
 800f482:	3308      	adds	r3, #8
 800f484:	681b      	ldr	r3, [r3, #0]
 800f486:	657b      	str	r3, [r7, #84]	; 0x54
	    }
	    if (handler == NULL) {
 800f488:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f48a:	2b00      	cmp	r3, #0
 800f48c:	d102      	bne.n	800f494 <crypto_kem_dec+0x6c>
	        SE3_TRACE(("[crypto_kem_dec] algo not found\n"));
	        return SE3_ERR_PARAMS;
 800f48e:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f492:	e068      	b.n	800f566 <crypto_kem_dec+0x13e>
	    }

		resp_params.ss_len=kem_table[req_params.algo].display_size;
 800f494:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 800f498:	4619      	mov	r1, r3
 800f49a:	4a35      	ldr	r2, [pc, #212]	; (800f570 <crypto_kem_dec+0x148>)
 800f49c:	460b      	mov	r3, r1
 800f49e:	009b      	lsls	r3, r3, #2
 800f4a0:	440b      	add	r3, r1
 800f4a2:	00db      	lsls	r3, r3, #3
 800f4a4:	4413      	add	r3, r2
 800f4a6:	331e      	adds	r3, #30
 800f4a8:	881b      	ldrh	r3, [r3, #0]
 800f4aa:	63bb      	str	r3, [r7, #56]	; 0x38
		resp_params.ss=resp+SE3_CMD1_CRYPTO_KEM_DEC_RESP_OFF_SS_DATA;
 800f4ac:	683b      	ldr	r3, [r7, #0]
 800f4ae:	3304      	adds	r3, #4
 800f4b0:	63fb      	str	r3, [r7, #60]	; 0x3c


	    se3_flash_key key;
	    se3_flash_it it = { .addr = NULL };
 800f4b2:	f107 0314 	add.w	r3, r7, #20
 800f4b6:	2200      	movs	r2, #0
 800f4b8:	601a      	str	r2, [r3, #0]
 800f4ba:	605a      	str	r2, [r3, #4]
 800f4bc:	609a      	str	r2, [r3, #8]
 800f4be:	60da      	str	r2, [r3, #12]

	    key.name = NULL;
 800f4c0:	2300      	movs	r3, #0
 800f4c2:	637b      	str	r3, [r7, #52]	; 0x34
	    key.id = SE3_KEYPAIR_ID_OFFSET  + 2 * req_params.sk_id;
 800f4c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f4c6:	005b      	lsls	r3, r3, #1
 800f4c8:	3305      	adds	r3, #5
 800f4ca:	627b      	str	r3, [r7, #36]	; 0x24

	    if (key.id == SE3_KEY_INVALID) {
 800f4cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f4ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f4d2:	d102      	bne.n	800f4da <crypto_kem_dec+0xb2>
            SE3_TRACE(("[crypto_kem_dec] key id invalid\n"));
	        return SE3_ERR_PARAMS;
 800f4d4:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f4d8:	e045      	b.n	800f566 <crypto_kem_dec+0x13e>
	    }
	    else {
	        se3_flash_it_init(&it);
 800f4da:	f107 0314 	add.w	r3, r7, #20
 800f4de:	4618      	mov	r0, r3
 800f4e0:	f7fe ffa5 	bl	800e42e <se3_flash_it_init>
	        if (!se3_key_find(key.id, &it)) {
 800f4e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f4e6:	f107 0214 	add.w	r2, r7, #20
 800f4ea:	4611      	mov	r1, r2
 800f4ec:	4618      	mov	r0, r3
 800f4ee:	f7ff f90d 	bl	800e70c <se3_key_find>
 800f4f2:	4603      	mov	r3, r0
 800f4f4:	f083 0301 	eor.w	r3, r3, #1
 800f4f8:	b2db      	uxtb	r3, r3
 800f4fa:	2b00      	cmp	r3, #0
 800f4fc:	d003      	beq.n	800f506 <crypto_kem_dec+0xde>
	            it.addr = NULL;
 800f4fe:	2300      	movs	r3, #0
 800f500:	617b      	str	r3, [r7, #20]
	            SE3_TRACE(("[crypto_kem_dec] key not found\n"));
	            return SE3_ERR_RESOURCE;
 800f502:	23c8      	movs	r3, #200	; 0xc8
 800f504:	e02f      	b.n	800f566 <crypto_kem_dec+0x13e>
	        }
	        se3_key_read(&it, &key);
 800f506:	f107 0224 	add.w	r2, r7, #36	; 0x24
 800f50a:	f107 0314 	add.w	r3, r7, #20
 800f50e:	4611      	mov	r1, r2
 800f510:	4618      	mov	r0, r3
 800f512:	f7ff f94a 	bl	800e7aa <se3_key_read>

			if (key.validity < se3_time_get() || !(get_now_initialized())) {
 800f516:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f518:	461c      	mov	r4, r3
 800f51a:	f04f 0500 	mov.w	r5, #0
 800f51e:	f7fd fedf 	bl	800d2e0 <se3_time_get>
 800f522:	4602      	mov	r2, r0
 800f524:	460b      	mov	r3, r1
 800f526:	429d      	cmp	r5, r3
 800f528:	bf08      	it	eq
 800f52a:	4294      	cmpeq	r4, r2
 800f52c:	d307      	bcc.n	800f53e <crypto_kem_dec+0x116>
 800f52e:	f7fd ff1f 	bl	800d370 <get_now_initialized>
 800f532:	4603      	mov	r3, r0
 800f534:	f083 0301 	eor.w	r3, r3, #1
 800f538:	b2db      	uxtb	r3, r3
 800f53a:	2b00      	cmp	r3, #0
 800f53c:	d001      	beq.n	800f542 <crypto_kem_dec+0x11a>
				SE3_TRACE(("[crypto_kem_dec] key expired\n"));
				return SE3_ERR_EXPIRED;
 800f53e:	23c9      	movs	r3, #201	; 0xc9
 800f540:	e011      	b.n	800f566 <crypto_kem_dec+0x13e>
			}
	    }

	    status = handler(resp_params.ss, req_params.ct, key.data);
 800f542:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800f544:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800f546:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f548:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f54a:	4798      	blx	r3
 800f54c:	4603      	mov	r3, r0
 800f54e:	653b      	str	r3, [r7, #80]	; 0x50

	    SE3_SET32(resp, SE3_CMD1_CRYPTO_KEM_DEC_RESP_OFF_SS_LEN, resp_params.ss_len);
 800f550:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800f552:	683b      	ldr	r3, [r7, #0]
 800f554:	601a      	str	r2, [r3, #0]

	    *resp_size = SE3_CMD1_CRYPTO_KEM_DEC_RESP_OFF_SS_DATA+resp_params.ss_len;
 800f556:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f558:	b29b      	uxth	r3, r3
 800f55a:	3304      	adds	r3, #4
 800f55c:	b29a      	uxth	r2, r3
 800f55e:	687b      	ldr	r3, [r7, #4]
 800f560:	801a      	strh	r2, [r3, #0]

	    return status;
 800f562:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f564:	b29b      	uxth	r3, r3
}
 800f566:	4618      	mov	r0, r3
 800f568:	3758      	adds	r7, #88	; 0x58
 800f56a:	46bd      	mov	sp, r7
 800f56c:	bdb0      	pop	{r4, r5, r7, pc}
 800f56e:	bf00      	nop
 800f570:	200000c4 	.word	0x200000c4

0800f574 <crypto_init>:
/** \brief initialize a crypto context
 *
 *  crypto_init : (algo:ui16, mode:ui16, key_id:ui32) => (sid:ui32)
 */
uint16_t crypto_init(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800f574:	b5b0      	push	{r4, r5, r7, lr}
 800f576:	b094      	sub	sp, #80	; 0x50
 800f578:	af00      	add	r7, sp, #0
 800f57a:	60b9      	str	r1, [r7, #8]
 800f57c:	607a      	str	r2, [r7, #4]
 800f57e:	603b      	str	r3, [r7, #0]
 800f580:	4603      	mov	r3, r0
 800f582:	81fb      	strh	r3, [r7, #14]
    struct {
        uint32_t sid;
    } resp_params;

    se3_flash_key key;
    se3_flash_it it = { .addr = NULL };
 800f584:	f107 0310 	add.w	r3, r7, #16
 800f588:	2200      	movs	r2, #0
 800f58a:	601a      	str	r2, [r3, #0]
 800f58c:	605a      	str	r2, [r3, #4]
 800f58e:	609a      	str	r2, [r3, #8]
 800f590:	60da      	str	r2, [r3, #12]
    se3_crypto_init_handler handler = NULL;
 800f592:	2300      	movs	r3, #0
 800f594:	64fb      	str	r3, [r7, #76]	; 0x4c
    uint32_t status;
    int sid;
    uint8_t* ctx;

    if (req_size != SE3_CMD1_CRYPTO_INIT_REQ_SIZE) {
 800f596:	89fb      	ldrh	r3, [r7, #14]
 800f598:	2b08      	cmp	r3, #8
 800f59a:	d002      	beq.n	800f5a2 <crypto_init+0x2e>
        SE3_TRACE(("[crypto_init] req size mismatch\n"));
        return SE3_ERR_PARAMS;
 800f59c:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f5a0:	e0ac      	b.n	800f6fc <crypto_init+0x188>
//    if (!se3_security_info.login.y) {
//        SE3_TRACE(("[crypto_init] not logged in\n"));
//        return SE3_ERR_ACCESS;
//    }

    SE3_GET16(req, SE3_CMD1_CRYPTO_INIT_REQ_OFF_ALGO, req_params.algo);
 800f5a2:	68bb      	ldr	r3, [r7, #8]
 800f5a4:	881b      	ldrh	r3, [r3, #0]
 800f5a6:	b29b      	uxth	r3, r3
 800f5a8:	873b      	strh	r3, [r7, #56]	; 0x38
    SE3_GET16(req, SE3_CMD1_CRYPTO_INIT_REQ_OFF_MODE, req_params.mode);
 800f5aa:	68bb      	ldr	r3, [r7, #8]
 800f5ac:	3302      	adds	r3, #2
 800f5ae:	881b      	ldrh	r3, [r3, #0]
 800f5b0:	b29b      	uxth	r3, r3
 800f5b2:	877b      	strh	r3, [r7, #58]	; 0x3a
    SE3_GET32(req, SE3_CMD1_CRYPTO_INIT_REQ_OFF_KEY_ID, req_params.key_id);
 800f5b4:	68bb      	ldr	r3, [r7, #8]
 800f5b6:	3304      	adds	r3, #4
 800f5b8:	681b      	ldr	r3, [r3, #0]
 800f5ba:	63fb      	str	r3, [r7, #60]	; 0x3c

    if (req_params.algo < SE3_ALGO_MAX) {
 800f5bc:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f5be:	2b07      	cmp	r3, #7
 800f5c0:	d805      	bhi.n	800f5ce <crypto_init+0x5a>
        handler = algo_table[req_params.algo].init;
 800f5c2:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f5c4:	4a4f      	ldr	r2, [pc, #316]	; (800f704 <crypto_init+0x190>)
 800f5c6:	015b      	lsls	r3, r3, #5
 800f5c8:	4413      	add	r3, r2
 800f5ca:	681b      	ldr	r3, [r3, #0]
 800f5cc:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    if (handler == NULL) {
 800f5ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f5d0:	2b00      	cmp	r3, #0
 800f5d2:	d102      	bne.n	800f5da <crypto_init+0x66>
        SE3_TRACE(("[crypto_init] algo not found\n"));
        return SE3_ERR_PARAMS;
 800f5d4:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f5d8:	e090      	b.n	800f6fc <crypto_init+0x188>
    }

    // use request buffer to temporarily store key data
    // !! modifying request buffer
    key.data = (uint8_t*)req + 16;
 800f5da:	68bb      	ldr	r3, [r7, #8]
 800f5dc:	3310      	adds	r3, #16
 800f5de:	62fb      	str	r3, [r7, #44]	; 0x2c
    key.name = NULL;
 800f5e0:	2300      	movs	r3, #0
 800f5e2:	633b      	str	r3, [r7, #48]	; 0x30
    key.id = req_params.key_id;
 800f5e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f5e6:	623b      	str	r3, [r7, #32]

    if (key.id == SE3_KEY_INVALID) {
 800f5e8:	6a3b      	ldr	r3, [r7, #32]
 800f5ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f5ee:	d107      	bne.n	800f600 <crypto_init+0x8c>
        memset(key.data, 0, SE3_KEY_DATA_MAX);
 800f5f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f5f2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800f5f6:	2100      	movs	r1, #0
 800f5f8:	4618      	mov	r0, r3
 800f5fa:	f00b fcf8 	bl	801afee <memset>
 800f5fe:	e036      	b.n	800f66e <crypto_init+0xfa>
    }
    else {
        se3_flash_it_init(&it);
 800f600:	f107 0310 	add.w	r3, r7, #16
 800f604:	4618      	mov	r0, r3
 800f606:	f7fe ff12 	bl	800e42e <se3_flash_it_init>
        if (!se3_key_find(key.id, &it)) {
 800f60a:	6a3b      	ldr	r3, [r7, #32]
 800f60c:	f107 0210 	add.w	r2, r7, #16
 800f610:	4611      	mov	r1, r2
 800f612:	4618      	mov	r0, r3
 800f614:	f7ff f87a 	bl	800e70c <se3_key_find>
 800f618:	4603      	mov	r3, r0
 800f61a:	f083 0301 	eor.w	r3, r3, #1
 800f61e:	b2db      	uxtb	r3, r3
 800f620:	2b00      	cmp	r3, #0
 800f622:	d001      	beq.n	800f628 <crypto_init+0xb4>
            it.addr = NULL;
 800f624:	2300      	movs	r3, #0
 800f626:	613b      	str	r3, [r7, #16]
        }
        if (NULL == it.addr) {
 800f628:	693b      	ldr	r3, [r7, #16]
 800f62a:	2b00      	cmp	r3, #0
 800f62c:	d101      	bne.n	800f632 <crypto_init+0xbe>
            SE3_TRACE(("[crypto_init] key not found\n"));
            return SE3_ERR_RESOURCE;
 800f62e:	23c8      	movs	r3, #200	; 0xc8
 800f630:	e064      	b.n	800f6fc <crypto_init+0x188>
        }
        se3_key_read(&it, &key);
 800f632:	f107 0220 	add.w	r2, r7, #32
 800f636:	f107 0310 	add.w	r3, r7, #16
 800f63a:	4611      	mov	r1, r2
 800f63c:	4618      	mov	r0, r3
 800f63e:	f7ff f8b4 	bl	800e7aa <se3_key_read>

		if (key.validity < se3_time_get() || !(get_now_initialized())) {
 800f642:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f644:	461c      	mov	r4, r3
 800f646:	f04f 0500 	mov.w	r5, #0
 800f64a:	f7fd fe49 	bl	800d2e0 <se3_time_get>
 800f64e:	4602      	mov	r2, r0
 800f650:	460b      	mov	r3, r1
 800f652:	429d      	cmp	r5, r3
 800f654:	bf08      	it	eq
 800f656:	4294      	cmpeq	r4, r2
 800f658:	d307      	bcc.n	800f66a <crypto_init+0xf6>
 800f65a:	f7fd fe89 	bl	800d370 <get_now_initialized>
 800f65e:	4603      	mov	r3, r0
 800f660:	f083 0301 	eor.w	r3, r3, #1
 800f664:	b2db      	uxtb	r3, r3
 800f666:	2b00      	cmp	r3, #0
 800f668:	d001      	beq.n	800f66e <crypto_init+0xfa>
			SE3_TRACE(("[crypto_init] key expired\n"));
			return SE3_ERR_EXPIRED;
 800f66a:	23c9      	movs	r3, #201	; 0xc9
 800f66c:	e046      	b.n	800f6fc <crypto_init+0x188>
		}
    }

    resp_params.sid = SE3_SESSION_INVALID;
 800f66e:	f04f 33ff 	mov.w	r3, #4294967295
 800f672:	637b      	str	r3, [r7, #52]	; 0x34
    sid = se3_mem_alloc(&(se3_security_info.sessions), algo_table[req_params.algo].size);
 800f674:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 800f676:	4a23      	ldr	r2, [pc, #140]	; (800f704 <crypto_init+0x190>)
 800f678:	015b      	lsls	r3, r3, #5
 800f67a:	4413      	add	r3, r2
 800f67c:	3308      	adds	r3, #8
 800f67e:	881b      	ldrh	r3, [r3, #0]
 800f680:	4619      	mov	r1, r3
 800f682:	4821      	ldr	r0, [pc, #132]	; (800f708 <crypto_init+0x194>)
 800f684:	f7ff fb01 	bl	800ec8a <se3_mem_alloc>
 800f688:	64b8      	str	r0, [r7, #72]	; 0x48
    if (sid >= 0) {
 800f68a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f68c:	2b00      	cmp	r3, #0
 800f68e:	db01      	blt.n	800f694 <crypto_init+0x120>
        resp_params.sid = (uint32_t)sid;
 800f690:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f692:	637b      	str	r3, [r7, #52]	; 0x34
    }

    if (resp_params.sid == SE3_SESSION_INVALID) {
 800f694:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f696:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f69a:	d102      	bne.n	800f6a2 <crypto_init+0x12e>
        SE3_TRACE(("[crypto_init] cannot allocate session\n"));
        return SE3_ERR_MEMORY;
 800f69c:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800f6a0:	e02c      	b.n	800f6fc <crypto_init+0x188>
    }

    ctx = se3_mem_ptr(&(se3_security_info.sessions), sid);
 800f6a2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800f6a4:	4818      	ldr	r0, [pc, #96]	; (800f708 <crypto_init+0x194>)
 800f6a6:	f7ff fbce 	bl	800ee46 <se3_mem_ptr>
 800f6aa:	6478      	str	r0, [r7, #68]	; 0x44
    if (ctx == NULL) {
 800f6ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f6ae:	2b00      	cmp	r3, #0
 800f6b0:	d102      	bne.n	800f6b8 <crypto_init+0x144>
        // this should not happen
        SE3_TRACE(("[crypto_init] NULL session pointer\n"));
        return SE3_ERR_HW;
 800f6b2:	f24f 0301 	movw	r3, #61441	; 0xf001
 800f6b6:	e021      	b.n	800f6fc <crypto_init+0x188>
    }

    status = handler(&key, req_params.mode, ctx);
 800f6b8:	8f79      	ldrh	r1, [r7, #58]	; 0x3a
 800f6ba:	f107 0020 	add.w	r0, r7, #32
 800f6be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f6c0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f6c2:	4798      	blx	r3
 800f6c4:	4603      	mov	r3, r0
 800f6c6:	643b      	str	r3, [r7, #64]	; 0x40

    if (SE3_OK != status) {
 800f6c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6ca:	2b00      	cmp	r3, #0
 800f6cc:	d007      	beq.n	800f6de <crypto_init+0x16a>
        // free the allocated session
        se3_mem_free(&(se3_security_info.sessions), (int32_t)resp_params.sid);
 800f6ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6d0:	4619      	mov	r1, r3
 800f6d2:	480d      	ldr	r0, [pc, #52]	; (800f708 <crypto_init+0x194>)
 800f6d4:	f7ff fbdf 	bl	800ee96 <se3_mem_free>

        SE3_TRACE(("[crypto_init] crypto handler failed\n"));
        return status;
 800f6d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6da:	b29b      	uxth	r3, r3
 800f6dc:	e00e      	b.n	800f6fc <crypto_init+0x188>
    }

    // link session to algo
    se3_security_info.sessions_algo[resp_params.sid] = req_params.algo;
 800f6de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f6e0:	8f39      	ldrh	r1, [r7, #56]	; 0x38
 800f6e2:	4a0a      	ldr	r2, [pc, #40]	; (800f70c <crypto_init+0x198>)
 800f6e4:	330c      	adds	r3, #12
 800f6e6:	005b      	lsls	r3, r3, #1
 800f6e8:	4413      	add	r3, r2
 800f6ea:	460a      	mov	r2, r1
 800f6ec:	809a      	strh	r2, [r3, #4]

    SE3_SET32(resp, SE3_CMD1_CRYPTO_INIT_RESP_OFF_SID, resp_params.sid);
 800f6ee:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800f6f0:	683b      	ldr	r3, [r7, #0]
 800f6f2:	601a      	str	r2, [r3, #0]

    *resp_size = SE3_CMD1_CRYPTO_INIT_RESP_SIZE;
 800f6f4:	687b      	ldr	r3, [r7, #4]
 800f6f6:	2204      	movs	r2, #4
 800f6f8:	801a      	strh	r2, [r3, #0]

	return SE3_OK;
 800f6fa:	2300      	movs	r3, #0
}
 800f6fc:	4618      	mov	r0, r3
 800f6fe:	3750      	adds	r7, #80	; 0x50
 800f700:	46bd      	mov	sp, r7
 800f702:	bdb0      	pop	{r4, r5, r7, pc}
 800f704:	20000204 	.word	0x20000204
 800f708:	200004d4 	.word	0x200004d4
 800f70c:	200004cc 	.word	0x200004cc

0800f710 <crypto_update>:
 *      sid:ui32, flags:ui16, datain1-len:ui16, datain2-len:ui16, pad-to-16[6],
 *      datain1[datain1-len], pad-to-16[...], datain2[datain2-len])
 *  => (dataout-len, pad-to-16[14], dataout[dataout-len])
 */
uint16_t crypto_update(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800f710:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f712:	b09b      	sub	sp, #108	; 0x6c
 800f714:	af06      	add	r7, sp, #24
 800f716:	6139      	str	r1, [r7, #16]
 800f718:	60fa      	str	r2, [r7, #12]
 800f71a:	60bb      	str	r3, [r7, #8]
 800f71c:	4603      	mov	r3, r0
 800f71e:	82fb      	strh	r3, [r7, #22]
        uint16_t dataout_len;
        uint8_t* dataout;
    } resp_params;
    uint16_t datain0_len_padded;
    uint16_t datain1_len_padded;
    se3_crypto_update_handler handler = NULL;
 800f720:	2300      	movs	r3, #0
 800f722:	64bb      	str	r3, [r7, #72]	; 0x48
    uint8_t* ctx;
    uint16_t status;

    //se3_write_trace(se3_debug_create_string("\n[crypto_update] Start!\0"), debug_address++);

    if (req_size < SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA) {
 800f724:	8afb      	ldrh	r3, [r7, #22]
 800f726:	2b0f      	cmp	r3, #15
 800f728:	d802      	bhi.n	800f730 <crypto_update+0x20>
        SE3_TRACE(("[crypto_update] req size mismatch\n"));
        //se3_write_trace(se3_debug_create_string("\n[crypto_update] req size mismatch\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800f72a:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f72e:	e0ba      	b.n	800f8a6 <crypto_update+0x196>
//    if (!se3_security_info.login.y) {
//        SE3_TRACE(("[crypto_update] not logged in\n"));
//        return SE3_ERR_ACCESS;
//    }

    SE3_GET32(req, SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_SID, req_params.sid);
 800f730:	693b      	ldr	r3, [r7, #16]
 800f732:	681b      	ldr	r3, [r3, #0]
 800f734:	627b      	str	r3, [r7, #36]	; 0x24
    SE3_GET16(req, SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_FLAGS, req_params.flags);
 800f736:	693b      	ldr	r3, [r7, #16]
 800f738:	3304      	adds	r3, #4
 800f73a:	881b      	ldrh	r3, [r3, #0]
 800f73c:	b29b      	uxth	r3, r3
 800f73e:	853b      	strh	r3, [r7, #40]	; 0x28
    SE3_GET16(req, SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN0_LEN, req_params.datain0_len);
 800f740:	693b      	ldr	r3, [r7, #16]
 800f742:	3306      	adds	r3, #6
 800f744:	881b      	ldrh	r3, [r3, #0]
 800f746:	b29b      	uxth	r3, r3
 800f748:	857b      	strh	r3, [r7, #42]	; 0x2a
    SE3_GET16(req, SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN1_LEN, req_params.datain1_len);
 800f74a:	693b      	ldr	r3, [r7, #16]
 800f74c:	3308      	adds	r3, #8
 800f74e:	881b      	ldrh	r3, [r3, #0]
 800f750:	b29b      	uxth	r3, r3
 800f752:	85bb      	strh	r3, [r7, #44]	; 0x2c
    SE3_GET16(req, SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATAIN2_LEN, req_params.datain2_len);
 800f754:	693b      	ldr	r3, [r7, #16]
 800f756:	330a      	adds	r3, #10
 800f758:	881b      	ldrh	r3, [r3, #0]
 800f75a:	b29b      	uxth	r3, r3
 800f75c:	85fb      	strh	r3, [r7, #46]	; 0x2e
    req_params.datain0 = req + SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA;
 800f75e:	693b      	ldr	r3, [r7, #16]
 800f760:	3310      	adds	r3, #16
 800f762:	633b      	str	r3, [r7, #48]	; 0x30
    if (req_params.datain0_len % 16) {
 800f764:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800f766:	f003 030f 	and.w	r3, r3, #15
 800f76a:	b29b      	uxth	r3, r3
 800f76c:	2b00      	cmp	r3, #0
 800f76e:	d007      	beq.n	800f780 <crypto_update+0x70>
        datain0_len_padded = req_params.datain0_len + (16 - (req_params.datain0_len % 16));
 800f770:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800f772:	f023 030f 	bic.w	r3, r3, #15
 800f776:	b29b      	uxth	r3, r3
 800f778:	3310      	adds	r3, #16
 800f77a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 800f77e:	e002      	b.n	800f786 <crypto_update+0x76>
    }
    else {
        datain0_len_padded = req_params.datain0_len;
 800f780:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800f782:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    }
    req_params.datain1 = req + SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA + datain0_len_padded;
 800f786:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800f78a:	3310      	adds	r3, #16
 800f78c:	693a      	ldr	r2, [r7, #16]
 800f78e:	4413      	add	r3, r2
 800f790:	637b      	str	r3, [r7, #52]	; 0x34

    if (req_params.datain1_len % 16) {
 800f792:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800f794:	f003 030f 	and.w	r3, r3, #15
 800f798:	b29b      	uxth	r3, r3
 800f79a:	2b00      	cmp	r3, #0
 800f79c:	d007      	beq.n	800f7ae <crypto_update+0x9e>
        datain1_len_padded = req_params.datain1_len + (16 - (req_params.datain1_len % 16));
 800f79e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800f7a0:	f023 030f 	bic.w	r3, r3, #15
 800f7a4:	b29b      	uxth	r3, r3
 800f7a6:	3310      	adds	r3, #16
 800f7a8:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 800f7ac:	e002      	b.n	800f7b4 <crypto_update+0xa4>
    }
    else {
        datain1_len_padded = req_params.datain1_len;
 800f7ae:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800f7b0:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    }
    req_params.datain2 = req + SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA + datain0_len_padded + datain1_len_padded;
 800f7b4:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800f7b8:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800f7bc:	4413      	add	r3, r2
 800f7be:	3310      	adds	r3, #16
 800f7c0:	693a      	ldr	r2, [r7, #16]
 800f7c2:	4413      	add	r3, r2
 800f7c4:	63bb      	str	r3, [r7, #56]	; 0x38

    if (SE3_CMD1_CRYPTO_UPDATE_REQ_OFF_DATA + datain0_len_padded + datain1_len_padded + req_params.datain2_len > SE3_REQ1_MAX_DATA) {
 800f7c6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800f7ca:	f103 0210 	add.w	r2, r3, #16
 800f7ce:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800f7d2:	4413      	add	r3, r2
 800f7d4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 800f7d6:	4413      	add	r3, r2
 800f7d8:	f641 5270 	movw	r2, #7536	; 0x1d70
 800f7dc:	4293      	cmp	r3, r2
 800f7de:	dd02      	ble.n	800f7e6 <crypto_update+0xd6>
        SE3_TRACE(("[crypto_update] data size exceeds packet limit\n"));
        //se3_write_trace(se3_debug_create_string("\n[crypto_update] data size exceeds packet limit\0"), debug_address++);
        return SE3_ERR_PARAMS;
 800f7e0:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f7e4:	e05f      	b.n	800f8a6 <crypto_update+0x196>
    }

    if (req_params.sid >= SE3_SESSIONS_MAX) {
 800f7e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f7e8:	2b63      	cmp	r3, #99	; 0x63
 800f7ea:	d901      	bls.n	800f7f0 <crypto_update+0xe0>
        SE3_TRACE(("[crypto_update] invalid sid\n"));
        return SE3_ERR_RESOURCE;
 800f7ec:	23c8      	movs	r3, #200	; 0xc8
 800f7ee:	e05a      	b.n	800f8a6 <crypto_update+0x196>
    }

    algo = se3_security_info.sessions_algo[req_params.sid];
 800f7f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f7f2:	4a2f      	ldr	r2, [pc, #188]	; (800f8b0 <crypto_update+0x1a0>)
 800f7f4:	330c      	adds	r3, #12
 800f7f6:	005b      	lsls	r3, r3, #1
 800f7f8:	4413      	add	r3, r2
 800f7fa:	889b      	ldrh	r3, [r3, #4]
 800f7fc:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    if (algo >= SE3_ALGO_MAX) {
 800f800:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 800f804:	2b07      	cmp	r3, #7
 800f806:	d901      	bls.n	800f80c <crypto_update+0xfc>
        SE3_TRACE(("[crypto_update] invalid algo for this sid (wrong sid?)\n"));
        return SE3_ERR_RESOURCE;
 800f808:	23c8      	movs	r3, #200	; 0xc8
 800f80a:	e04c      	b.n	800f8a6 <crypto_update+0x196>
    }

    handler = algo_table[algo].update;
 800f80c:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 800f810:	4a28      	ldr	r2, [pc, #160]	; (800f8b4 <crypto_update+0x1a4>)
 800f812:	015b      	lsls	r3, r3, #5
 800f814:	4413      	add	r3, r2
 800f816:	3304      	adds	r3, #4
 800f818:	681b      	ldr	r3, [r3, #0]
 800f81a:	64bb      	str	r3, [r7, #72]	; 0x48
    if (handler == NULL) {
 800f81c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f81e:	2b00      	cmp	r3, #0
 800f820:	d101      	bne.n	800f826 <crypto_update+0x116>
        SE3_TRACE(("[crypto_update] invalid crypto handler for this algo (wrong sid?)\n"));
        return SE3_ERR_RESOURCE;
 800f822:	23c8      	movs	r3, #200	; 0xc8
 800f824:	e03f      	b.n	800f8a6 <crypto_update+0x196>
    }

    ctx = se3_mem_ptr(&(se3_security_info.sessions), (int32_t)req_params.sid);
 800f826:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f828:	4619      	mov	r1, r3
 800f82a:	4823      	ldr	r0, [pc, #140]	; (800f8b8 <crypto_update+0x1a8>)
 800f82c:	f7ff fb0b 	bl	800ee46 <se3_mem_ptr>
 800f830:	6438      	str	r0, [r7, #64]	; 0x40
    if (ctx == NULL) {
 800f832:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f834:	2b00      	cmp	r3, #0
 800f836:	d101      	bne.n	800f83c <crypto_update+0x12c>
        SE3_TRACE(("[crypto_update] session not found\n"));
        return SE3_ERR_RESOURCE;
 800f838:	23c8      	movs	r3, #200	; 0xc8
 800f83a:	e034      	b.n	800f8a6 <crypto_update+0x196>
    }

    resp_params.dataout_len = 0;
 800f83c:	2300      	movs	r3, #0
 800f83e:	83bb      	strh	r3, [r7, #28]
    resp_params.dataout = resp + SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA;
 800f840:	68bb      	ldr	r3, [r7, #8]
 800f842:	3310      	adds	r3, #16
 800f844:	623b      	str	r3, [r7, #32]

    status = handler(
 800f846:	8d3d      	ldrh	r5, [r7, #40]	; 0x28
 800f848:	8d7e      	ldrh	r6, [r7, #42]	; 0x2a
 800f84a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f84c:	607b      	str	r3, [r7, #4]
 800f84e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800f850:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800f852:	8df9      	ldrh	r1, [r7, #46]	; 0x2e
 800f854:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800f856:	6a3c      	ldr	r4, [r7, #32]
 800f858:	9405      	str	r4, [sp, #20]
 800f85a:	f107 041c 	add.w	r4, r7, #28
 800f85e:	9404      	str	r4, [sp, #16]
 800f860:	9003      	str	r0, [sp, #12]
 800f862:	9102      	str	r1, [sp, #8]
 800f864:	9201      	str	r2, [sp, #4]
 800f866:	9300      	str	r3, [sp, #0]
 800f868:	6cbc      	ldr	r4, [r7, #72]	; 0x48
 800f86a:	687b      	ldr	r3, [r7, #4]
 800f86c:	4632      	mov	r2, r6
 800f86e:	4629      	mov	r1, r5
 800f870:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800f872:	47a0      	blx	r4
 800f874:	4603      	mov	r3, r0
 800f876:	87fb      	strh	r3, [r7, #62]	; 0x3e
        req_params.datain0_len, req_params.datain0,
        req_params.datain1_len, req_params.datain1,
        req_params.datain2_len, req_params.datain2,
        &(resp_params.dataout_len), resp_params.dataout);

    if (SE3_OK != status) {
 800f878:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800f87a:	2b00      	cmp	r3, #0
 800f87c:	d001      	beq.n	800f882 <crypto_update+0x172>
        SE3_TRACE(("[crypto_update] crypto handler failed\n"));
        //se3_write_trace(se3_debug_create_string("\n[crypto_update] crypto handler failed\0"), debug_address++);
        return status;
 800f87e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800f880:	e011      	b.n	800f8a6 <crypto_update+0x196>
    }

    if (req_params.flags & SE3_CRYPTO_FLAG_FINIT) {
 800f882:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800f884:	b21b      	sxth	r3, r3
 800f886:	2b00      	cmp	r3, #0
 800f888:	da04      	bge.n	800f894 <crypto_update+0x184>
        se3_mem_free(&(se3_security_info.sessions), (int32_t)req_params.sid);
 800f88a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f88c:	4619      	mov	r1, r3
 800f88e:	480a      	ldr	r0, [pc, #40]	; (800f8b8 <crypto_update+0x1a8>)
 800f890:	f7ff fb01 	bl	800ee96 <se3_mem_free>
    }

    SE3_SET16(resp, SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATAOUT_LEN, resp_params.dataout_len);
 800f894:	8bba      	ldrh	r2, [r7, #28]
 800f896:	68bb      	ldr	r3, [r7, #8]
 800f898:	801a      	strh	r2, [r3, #0]
    *resp_size = SE3_CMD1_CRYPTO_UPDATE_RESP_OFF_DATA + resp_params.dataout_len;
 800f89a:	8bbb      	ldrh	r3, [r7, #28]
 800f89c:	3310      	adds	r3, #16
 800f89e:	b29a      	uxth	r2, r3
 800f8a0:	68fb      	ldr	r3, [r7, #12]
 800f8a2:	801a      	strh	r2, [r3, #0]

    return SE3_OK;
 800f8a4:	2300      	movs	r3, #0
}
 800f8a6:	4618      	mov	r0, r3
 800f8a8:	3754      	adds	r7, #84	; 0x54
 800f8aa:	46bd      	mov	sp, r7
 800f8ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f8ae:	bf00      	nop
 800f8b0:	200004cc 	.word	0x200004cc
 800f8b4:	20000204 	.word	0x20000204
 800f8b8:	200004d4 	.word	0x200004d4

0800f8bc <crypto_set_time>:
/** \brief set device time for key validity
 *
 *  crypto_set_time : (devtime:ui32) => ()
 */
uint16_t crypto_set_time(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800f8bc:	b590      	push	{r4, r7, lr}
 800f8be:	b087      	sub	sp, #28
 800f8c0:	af00      	add	r7, sp, #0
 800f8c2:	60b9      	str	r1, [r7, #8]
 800f8c4:	607a      	str	r2, [r7, #4]
 800f8c6:	603b      	str	r3, [r7, #0]
 800f8c8:	4603      	mov	r3, r0
 800f8ca:	81fb      	strh	r3, [r7, #14]
    struct {
        uint32_t devtime;
    } req_params;

    if (req_size != SE3_CMD1_CRYPTO_SET_TIME_REQ_SIZE) {
 800f8cc:	89fb      	ldrh	r3, [r7, #14]
 800f8ce:	2b04      	cmp	r3, #4
 800f8d0:	d002      	beq.n	800f8d8 <crypto_set_time+0x1c>
        SE3_TRACE(("[crypto_set_time] req size mismatch\n"));
        return SE3_ERR_PARAMS;
 800f8d2:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f8d6:	e00a      	b.n	800f8ee <crypto_set_time+0x32>
//    if (!se3_security_info.login.y) {
//        SE3_TRACE(("[crypto_set_time] not logged in\n"));
//        return SE3_ERR_ACCESS;
//    }

    SE3_GET32(req, SE3_CMD1_CRYPTO_SET_TIME_REQ_OFF_DEVTIME, req_params.devtime);
 800f8d8:	68bb      	ldr	r3, [r7, #8]
 800f8da:	681b      	ldr	r3, [r3, #0]
 800f8dc:	617b      	str	r3, [r7, #20]

    se3_time_set((uint64_t)req_params.devtime);
 800f8de:	697b      	ldr	r3, [r7, #20]
 800f8e0:	f04f 0400 	mov.w	r4, #0
 800f8e4:	4618      	mov	r0, r3
 800f8e6:	4621      	mov	r1, r4
 800f8e8:	f7fd fd06 	bl	800d2f8 <se3_time_set>

    return SE3_OK;
 800f8ec:	2300      	movs	r3, #0
}
 800f8ee:	4618      	mov	r0, r3
 800f8f0:	371c      	adds	r7, #28
 800f8f2:	46bd      	mov	sp, r7
 800f8f4:	bd90      	pop	{r4, r7, pc}
	...

0800f8f8 <crypto_list>:
 *
 *  crypto_list : () => (count:ui16, algoinfo0, algoinfo1, ...)
 *      algoinfo : (name[16], type:u16, block_size:u16, key_size:u16)
 */
uint16_t crypto_list(uint16_t req_size, const uint8_t* req, uint16_t* resp_size, uint8_t* resp)
{
 800f8f8:	b580      	push	{r7, lr}
 800f8fa:	b08a      	sub	sp, #40	; 0x28
 800f8fc:	af00      	add	r7, sp, #0
 800f8fe:	60b9      	str	r1, [r7, #8]
 800f900:	607a      	str	r2, [r7, #4]
 800f902:	603b      	str	r3, [r7, #0]
 800f904:	4603      	mov	r3, r0
 800f906:	81fb      	strh	r3, [r7, #14]
    } resp_params;
    uint8_t* p;
    size_t i;
    uint16_t size;

    if (req_size != SE3_CMD1_CRYPTO_LIST_REQ_SIZE) {
 800f908:	89fb      	ldrh	r3, [r7, #14]
 800f90a:	2b00      	cmp	r3, #0
 800f90c:	d002      	beq.n	800f914 <crypto_list+0x1c>
        SE3_TRACE(("[crypto_list] req size mismatch\n"));
        return SE3_ERR_PARAMS;
 800f90e:	f24f 0306 	movw	r3, #61446	; 0xf006
 800f912:	e05d      	b.n	800f9d0 <crypto_list+0xd8>
//    if (!se3_security_info.login.y) {
//        SE3_TRACE(("[crypto_list] not logged in\n"));
//        return SE3_ERR_ACCESS;
//    }

    resp_params.algoinfo = resp + SE3_CMD1_CRYPTO_LIST_RESP_OFF_ALGOINFO;
 800f914:	683b      	ldr	r3, [r7, #0]
 800f916:	3302      	adds	r3, #2
 800f918:	61bb      	str	r3, [r7, #24]

    size = SE3_CMD1_CRYPTO_LIST_RESP_OFF_ALGOINFO;
 800f91a:	2302      	movs	r3, #2
 800f91c:	83fb      	strh	r3, [r7, #30]
    resp_params.count = 0;
 800f91e:	2300      	movs	r3, #0
 800f920:	82bb      	strh	r3, [r7, #20]
    p = resp_params.algoinfo;
 800f922:	69bb      	ldr	r3, [r7, #24]
 800f924:	627b      	str	r3, [r7, #36]	; 0x24
    for (i = 0; i < SE3_ALGO_MAX; i++) {
 800f926:	2300      	movs	r3, #0
 800f928:	623b      	str	r3, [r7, #32]
 800f92a:	e047      	b.n	800f9bc <crypto_list+0xc4>
        if ((algo_table[i].init != NULL) && (algo_table[i].update != NULL)) {
 800f92c:	4a2a      	ldr	r2, [pc, #168]	; (800f9d8 <crypto_list+0xe0>)
 800f92e:	6a3b      	ldr	r3, [r7, #32]
 800f930:	015b      	lsls	r3, r3, #5
 800f932:	4413      	add	r3, r2
 800f934:	681b      	ldr	r3, [r3, #0]
 800f936:	2b00      	cmp	r3, #0
 800f938:	d03d      	beq.n	800f9b6 <crypto_list+0xbe>
 800f93a:	4a27      	ldr	r2, [pc, #156]	; (800f9d8 <crypto_list+0xe0>)
 800f93c:	6a3b      	ldr	r3, [r7, #32]
 800f93e:	015b      	lsls	r3, r3, #5
 800f940:	4413      	add	r3, r2
 800f942:	3304      	adds	r3, #4
 800f944:	681b      	ldr	r3, [r3, #0]
 800f946:	2b00      	cmp	r3, #0
 800f948:	d035      	beq.n	800f9b6 <crypto_list+0xbe>
            memcpy(p + SE3_CMD1_CRYPTO_ALGOINFO_OFF_NAME, algo_table[i].display_name, SE3_CMD1_CRYPTO_ALGOINFO_NAME_SIZE);
 800f94a:	6a3b      	ldr	r3, [r7, #32]
 800f94c:	015b      	lsls	r3, r3, #5
 800f94e:	3308      	adds	r3, #8
 800f950:	4a21      	ldr	r2, [pc, #132]	; (800f9d8 <crypto_list+0xe0>)
 800f952:	4413      	add	r3, r2
 800f954:	3302      	adds	r3, #2
 800f956:	2210      	movs	r2, #16
 800f958:	4619      	mov	r1, r3
 800f95a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800f95c:	f00b fb23 	bl	801afa6 <memcpy>
            SE3_SET16(p, SE3_CMD1_CRYPTO_ALGOINFO_OFF_TYPE, algo_table[i].display_type);
 800f960:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f962:	3310      	adds	r3, #16
 800f964:	6a3a      	ldr	r2, [r7, #32]
 800f966:	0152      	lsls	r2, r2, #5
 800f968:	3218      	adds	r2, #24
 800f96a:	491b      	ldr	r1, [pc, #108]	; (800f9d8 <crypto_list+0xe0>)
 800f96c:	440a      	add	r2, r1
 800f96e:	3202      	adds	r2, #2
 800f970:	8812      	ldrh	r2, [r2, #0]
 800f972:	b292      	uxth	r2, r2
 800f974:	801a      	strh	r2, [r3, #0]
            SE3_SET16(p, SE3_CMD1_CRYPTO_ALGOINFO_OFF_BLOCK_SIZE, algo_table[i].display_block_size);
 800f976:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f978:	3312      	adds	r3, #18
 800f97a:	6a3a      	ldr	r2, [r7, #32]
 800f97c:	0152      	lsls	r2, r2, #5
 800f97e:	3218      	adds	r2, #24
 800f980:	4915      	ldr	r1, [pc, #84]	; (800f9d8 <crypto_list+0xe0>)
 800f982:	440a      	add	r2, r1
 800f984:	3204      	adds	r2, #4
 800f986:	8812      	ldrh	r2, [r2, #0]
 800f988:	b292      	uxth	r2, r2
 800f98a:	801a      	strh	r2, [r3, #0]
            SE3_SET16(p, SE3_CMD1_CRYPTO_ALGOINFO_OFF_KEY_SIZE, algo_table[i].display_key_size);
 800f98c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f98e:	3314      	adds	r3, #20
 800f990:	6a3a      	ldr	r2, [r7, #32]
 800f992:	0152      	lsls	r2, r2, #5
 800f994:	3218      	adds	r2, #24
 800f996:	4910      	ldr	r1, [pc, #64]	; (800f9d8 <crypto_list+0xe0>)
 800f998:	440a      	add	r2, r1
 800f99a:	3206      	adds	r2, #6
 800f99c:	8812      	ldrh	r2, [r2, #0]
 800f99e:	b292      	uxth	r2, r2
 800f9a0:	801a      	strh	r2, [r3, #0]

            (resp_params.count)++;
 800f9a2:	8abb      	ldrh	r3, [r7, #20]
 800f9a4:	3301      	adds	r3, #1
 800f9a6:	b29b      	uxth	r3, r3
 800f9a8:	82bb      	strh	r3, [r7, #20]
            size += SE3_CMD1_CRYPTO_ALGOINFO_SIZE;
 800f9aa:	8bfb      	ldrh	r3, [r7, #30]
 800f9ac:	3316      	adds	r3, #22
 800f9ae:	83fb      	strh	r3, [r7, #30]
            p += SE3_CMD1_CRYPTO_ALGOINFO_SIZE;
 800f9b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f9b2:	3316      	adds	r3, #22
 800f9b4:	627b      	str	r3, [r7, #36]	; 0x24
    for (i = 0; i < SE3_ALGO_MAX; i++) {
 800f9b6:	6a3b      	ldr	r3, [r7, #32]
 800f9b8:	3301      	adds	r3, #1
 800f9ba:	623b      	str	r3, [r7, #32]
 800f9bc:	6a3b      	ldr	r3, [r7, #32]
 800f9be:	2b07      	cmp	r3, #7
 800f9c0:	d9b4      	bls.n	800f92c <crypto_list+0x34>
        }
    }
    SE3_SET16(resp, SE3_CMD1_CRYPTO_LIST_RESP_OFF_COUNT, resp_params.count);
 800f9c2:	8aba      	ldrh	r2, [r7, #20]
 800f9c4:	683b      	ldr	r3, [r7, #0]
 800f9c6:	801a      	strh	r2, [r3, #0]
    *resp_size = size;
 800f9c8:	687b      	ldr	r3, [r7, #4]
 800f9ca:	8bfa      	ldrh	r2, [r7, #30]
 800f9cc:	801a      	strh	r2, [r3, #0]
    return SE3_OK;
 800f9ce:	2300      	movs	r3, #0
}
 800f9d0:	4618      	mov	r0, r3
 800f9d2:	3728      	adds	r7, #40	; 0x28
 800f9d4:	46bd      	mov	sp, r7
 800f9d6:	bd80      	pop	{r7, pc}
 800f9d8:	20000204 	.word	0x20000204

0800f9dc <se3_payload_cryptoinit>:

void se3_payload_cryptoinit(se3_payload_cryptoctx* ctx, const uint8_t* key)
{
 800f9dc:	b580      	push	{r7, lr}
 800f9de:	b096      	sub	sp, #88	; 0x58
 800f9e0:	af04      	add	r7, sp, #16
 800f9e2:	6078      	str	r0, [r7, #4]
 800f9e4:	6039      	str	r1, [r7, #0]
	uint8_t keys[2 * B5_AES_256];

	PBKDF2HmacSha256(key, B5_AES_256, NULL, 0, 1, keys, 2 * B5_AES_256);
 800f9e6:	2340      	movs	r3, #64	; 0x40
 800f9e8:	9302      	str	r3, [sp, #8]
 800f9ea:	f107 0308 	add.w	r3, r7, #8
 800f9ee:	9301      	str	r3, [sp, #4]
 800f9f0:	2301      	movs	r3, #1
 800f9f2:	9300      	str	r3, [sp, #0]
 800f9f4:	2300      	movs	r3, #0
 800f9f6:	2200      	movs	r2, #0
 800f9f8:	2120      	movs	r1, #32
 800f9fa:	6838      	ldr	r0, [r7, #0]
 800f9fc:	f7f4 fc7f 	bl	80042fe <PBKDF2HmacSha256>
    B5_Aes256_Init(&(ctx->aesenc), keys, B5_AES_256, B5_AES256_CBC_ENC);
 800fa00:	6878      	ldr	r0, [r7, #4]
 800fa02:	f107 0108 	add.w	r1, r7, #8
 800fa06:	2304      	movs	r3, #4
 800fa08:	2220      	movs	r2, #32
 800fa0a:	f7f3 ffe1 	bl	80039d0 <B5_Aes256_Init>
    B5_Aes256_Init(&(ctx->aesdec), keys, B5_AES_256, B5_AES256_CBC_DEC);
 800fa0e:	687b      	ldr	r3, [r7, #4]
 800fa10:	f503 7096 	add.w	r0, r3, #300	; 0x12c
 800fa14:	f107 0108 	add.w	r1, r7, #8
 800fa18:	2305      	movs	r3, #5
 800fa1a:	2220      	movs	r2, #32
 800fa1c:	f7f3 ffd8 	bl	80039d0 <B5_Aes256_Init>
	memcpy(ctx->hmac_key, keys + B5_AES_256, B5_AES_256);
 800fa20:	687b      	ldr	r3, [r7, #4]
 800fa22:	f503 6088 	add.w	r0, r3, #1088	; 0x440
 800fa26:	f107 0308 	add.w	r3, r7, #8
 800fa2a:	3320      	adds	r3, #32
 800fa2c:	2220      	movs	r2, #32
 800fa2e:	4619      	mov	r1, r3
 800fa30:	f00b fab9 	bl	801afa6 <memcpy>
	memset(keys, 0, 2 * B5_AES_256);
 800fa34:	f107 0308 	add.w	r3, r7, #8
 800fa38:	2240      	movs	r2, #64	; 0x40
 800fa3a:	2100      	movs	r1, #0
 800fa3c:	4618      	mov	r0, r3
 800fa3e:	f00b fad6 	bl	801afee <memset>
}
 800fa42:	bf00      	nop
 800fa44:	3748      	adds	r7, #72	; 0x48
 800fa46:	46bd      	mov	sp, r7
 800fa48:	bd80      	pop	{r7, pc}

0800fa4a <se3_payload_encrypt>:

bool se3_payload_encrypt(se3_payload_cryptoctx* ctx, uint8_t* auth, uint8_t* iv, uint8_t* data, uint16_t nblocks, uint16_t flags, uint8_t crypto_algo)
{
 800fa4a:	b580      	push	{r7, lr}
 800fa4c:	b086      	sub	sp, #24
 800fa4e:	af02      	add	r7, sp, #8
 800fa50:	60f8      	str	r0, [r7, #12]
 800fa52:	60b9      	str	r1, [r7, #8]
 800fa54:	607a      	str	r2, [r7, #4]
 800fa56:	603b      	str	r3, [r7, #0]
	switch(crypto_algo){
 800fa58:	f897 3020 	ldrb.w	r3, [r7, #32]
 800fa5c:	2b00      	cmp	r3, #0
 800fa5e:	d114      	bne.n	800fa8a <se3_payload_encrypt+0x40>
		case SE3_AES256:
		    if (flags & SE3_CMDFLAG_ENCRYPT) {
 800fa60:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800fa64:	2b00      	cmp	r3, #0
 800fa66:	da12      	bge.n	800fa8e <se3_payload_encrypt+0x44>
		        B5_Aes256_SetIV(&(ctx->aesenc), iv);
 800fa68:	68fb      	ldr	r3, [r7, #12]
 800fa6a:	6879      	ldr	r1, [r7, #4]
 800fa6c:	4618      	mov	r0, r3
 800fa6e:	f7f4 f883 	bl	8003b78 <B5_Aes256_SetIV>
		        B5_Aes256_Update(&(ctx->aesenc),NULL, data, data, 0, nblocks);
 800fa72:	68f8      	ldr	r0, [r7, #12]
 800fa74:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800fa78:	9301      	str	r3, [sp, #4]
 800fa7a:	2300      	movs	r3, #0
 800fa7c:	9300      	str	r3, [sp, #0]
 800fa7e:	683b      	ldr	r3, [r7, #0]
 800fa80:	683a      	ldr	r2, [r7, #0]
 800fa82:	2100      	movs	r1, #0
 800fa84:	f7f4 f8c0 	bl	8003c08 <B5_Aes256_Update>
		    } break;
 800fa88:	e001      	b.n	800fa8e <se3_payload_encrypt+0x44>
			//to be implemented

		case SE3_SHA256:
			//to be implemented

		default: return false; break;
 800fa8a:	2300      	movs	r3, #0
 800fa8c:	e039      	b.n	800fb02 <se3_payload_encrypt+0xb8>
		    } break;
 800fa8e:	bf00      	nop
	}

    if (flags & SE3_CMDFLAG_SIGN) {
 800fa90:	8bbb      	ldrh	r3, [r7, #28]
 800fa92:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800fa96:	2b00      	cmp	r3, #0
 800fa98:	d02d      	beq.n	800faf6 <se3_payload_encrypt+0xac>
        B5_HmacSha256_Init(&(ctx->hmac), ctx->hmac_key, B5_AES_256);
 800fa9a:	68fb      	ldr	r3, [r7, #12]
 800fa9c:	f503 7016 	add.w	r0, r3, #600	; 0x258
 800faa0:	68fb      	ldr	r3, [r7, #12]
 800faa2:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 800faa6:	2220      	movs	r2, #32
 800faa8:	4619      	mov	r1, r3
 800faaa:	f7f6 ff2f 	bl	800690c <B5_HmacSha256_Init>
        B5_HmacSha256_Update(&(ctx->hmac), iv, B5_AES_IV_SIZE);
 800faae:	68fb      	ldr	r3, [r7, #12]
 800fab0:	f503 7316 	add.w	r3, r3, #600	; 0x258
 800fab4:	2210      	movs	r2, #16
 800fab6:	6879      	ldr	r1, [r7, #4]
 800fab8:	4618      	mov	r0, r3
 800faba:	f7f6 ffad 	bl	8006a18 <B5_HmacSha256_Update>
        B5_HmacSha256_Update(&(ctx->hmac), data, nblocks*B5_AES_BLK_SIZE);
 800fabe:	68fb      	ldr	r3, [r7, #12]
 800fac0:	f503 7016 	add.w	r0, r3, #600	; 0x258
 800fac4:	8b3b      	ldrh	r3, [r7, #24]
 800fac6:	011b      	lsls	r3, r3, #4
 800fac8:	461a      	mov	r2, r3
 800faca:	6839      	ldr	r1, [r7, #0]
 800facc:	f7f6 ffa4 	bl	8006a18 <B5_HmacSha256_Update>
        B5_HmacSha256_Finit(&(ctx->hmac), ctx->auth);
 800fad0:	68fb      	ldr	r3, [r7, #12]
 800fad2:	f503 7216 	add.w	r2, r3, #600	; 0x258
 800fad6:	68fb      	ldr	r3, [r7, #12]
 800fad8:	f503 638c 	add.w	r3, r3, #1120	; 0x460
 800fadc:	4619      	mov	r1, r3
 800fade:	4610      	mov	r0, r2
 800fae0:	f7f6 ffbf 	bl	8006a62 <B5_HmacSha256_Finit>
        memcpy(auth, ctx->auth, 16);
 800fae4:	68fb      	ldr	r3, [r7, #12]
 800fae6:	f503 638c 	add.w	r3, r3, #1120	; 0x460
 800faea:	2210      	movs	r2, #16
 800faec:	4619      	mov	r1, r3
 800faee:	68b8      	ldr	r0, [r7, #8]
 800faf0:	f00b fa59 	bl	801afa6 <memcpy>
 800faf4:	e004      	b.n	800fb00 <se3_payload_encrypt+0xb6>
    }
    else {
        memset(auth, 0, 16);
 800faf6:	2210      	movs	r2, #16
 800faf8:	2100      	movs	r1, #0
 800fafa:	68b8      	ldr	r0, [r7, #8]
 800fafc:	f00b fa77 	bl	801afee <memset>
    }
    return true;
 800fb00:	2301      	movs	r3, #1
}
 800fb02:	4618      	mov	r0, r3
 800fb04:	3710      	adds	r7, #16
 800fb06:	46bd      	mov	sp, r7
 800fb08:	bd80      	pop	{r7, pc}

0800fb0a <se3_payload_decrypt>:

bool se3_payload_decrypt(se3_payload_cryptoctx* ctx, const uint8_t* auth, const uint8_t* iv, uint8_t* data, uint16_t nblocks, uint16_t flags, uint8_t crypto_algo)
{
 800fb0a:	b580      	push	{r7, lr}
 800fb0c:	b086      	sub	sp, #24
 800fb0e:	af02      	add	r7, sp, #8
 800fb10:	60f8      	str	r0, [r7, #12]
 800fb12:	60b9      	str	r1, [r7, #8]
 800fb14:	607a      	str	r2, [r7, #4]
 800fb16:	603b      	str	r3, [r7, #0]
    if (flags & SE3_CMDFLAG_SIGN) {
 800fb18:	8bbb      	ldrh	r3, [r7, #28]
 800fb1a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800fb1e:	2b00      	cmp	r3, #0
 800fb20:	d031      	beq.n	800fb86 <se3_payload_decrypt+0x7c>
        B5_HmacSha256_Init(&(ctx->hmac), ctx->hmac_key, B5_AES_256);
 800fb22:	68fb      	ldr	r3, [r7, #12]
 800fb24:	f503 7016 	add.w	r0, r3, #600	; 0x258
 800fb28:	68fb      	ldr	r3, [r7, #12]
 800fb2a:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 800fb2e:	2220      	movs	r2, #32
 800fb30:	4619      	mov	r1, r3
 800fb32:	f7f6 feeb 	bl	800690c <B5_HmacSha256_Init>
        B5_HmacSha256_Update(&(ctx->hmac), iv, B5_AES_IV_SIZE);
 800fb36:	68fb      	ldr	r3, [r7, #12]
 800fb38:	f503 7316 	add.w	r3, r3, #600	; 0x258
 800fb3c:	2210      	movs	r2, #16
 800fb3e:	6879      	ldr	r1, [r7, #4]
 800fb40:	4618      	mov	r0, r3
 800fb42:	f7f6 ff69 	bl	8006a18 <B5_HmacSha256_Update>
        B5_HmacSha256_Update(&(ctx->hmac), data, nblocks*B5_AES_BLK_SIZE);
 800fb46:	68fb      	ldr	r3, [r7, #12]
 800fb48:	f503 7016 	add.w	r0, r3, #600	; 0x258
 800fb4c:	8b3b      	ldrh	r3, [r7, #24]
 800fb4e:	011b      	lsls	r3, r3, #4
 800fb50:	461a      	mov	r2, r3
 800fb52:	6839      	ldr	r1, [r7, #0]
 800fb54:	f7f6 ff60 	bl	8006a18 <B5_HmacSha256_Update>
        B5_HmacSha256_Finit(&(ctx->hmac), ctx->auth);
 800fb58:	68fb      	ldr	r3, [r7, #12]
 800fb5a:	f503 7216 	add.w	r2, r3, #600	; 0x258
 800fb5e:	68fb      	ldr	r3, [r7, #12]
 800fb60:	f503 638c 	add.w	r3, r3, #1120	; 0x460
 800fb64:	4619      	mov	r1, r3
 800fb66:	4610      	mov	r0, r2
 800fb68:	f7f6 ff7b 	bl	8006a62 <B5_HmacSha256_Finit>
        if (memcmp(auth, ctx->auth, 16)) {
 800fb6c:	68fb      	ldr	r3, [r7, #12]
 800fb6e:	f503 638c 	add.w	r3, r3, #1120	; 0x460
 800fb72:	2210      	movs	r2, #16
 800fb74:	4619      	mov	r1, r3
 800fb76:	68b8      	ldr	r0, [r7, #8]
 800fb78:	f00b fa06 	bl	801af88 <memcmp>
 800fb7c:	4603      	mov	r3, r0
 800fb7e:	2b00      	cmp	r3, #0
 800fb80:	d001      	beq.n	800fb86 <se3_payload_decrypt+0x7c>
            return false;
 800fb82:	2300      	movs	r3, #0
 800fb84:	e020      	b.n	800fbc8 <se3_payload_decrypt+0xbe>
        }
    }

	switch(crypto_algo){
 800fb86:	f897 3020 	ldrb.w	r3, [r7, #32]
 800fb8a:	2b00      	cmp	r3, #0
 800fb8c:	d118      	bne.n	800fbc0 <se3_payload_decrypt+0xb6>
		case SE3_AES256:
		    if (flags & SE3_CMDFLAG_ENCRYPT) {
 800fb8e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800fb92:	2b00      	cmp	r3, #0
 800fb94:	da16      	bge.n	800fbc4 <se3_payload_decrypt+0xba>
		        B5_Aes256_SetIV(&(ctx->aesdec), iv);
 800fb96:	68fb      	ldr	r3, [r7, #12]
 800fb98:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 800fb9c:	6879      	ldr	r1, [r7, #4]
 800fb9e:	4618      	mov	r0, r3
 800fba0:	f7f3 ffea 	bl	8003b78 <B5_Aes256_SetIV>
		        B5_Aes256_Update(&(ctx->aesdec), NULL, data, data,0, nblocks);
 800fba4:	68fb      	ldr	r3, [r7, #12]
 800fba6:	f503 7096 	add.w	r0, r3, #300	; 0x12c
 800fbaa:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800fbae:	9301      	str	r3, [sp, #4]
 800fbb0:	2300      	movs	r3, #0
 800fbb2:	9300      	str	r3, [sp, #0]
 800fbb4:	683b      	ldr	r3, [r7, #0]
 800fbb6:	683a      	ldr	r2, [r7, #0]
 800fbb8:	2100      	movs	r1, #0
 800fbba:	f7f4 f825 	bl	8003c08 <B5_Aes256_Update>
		    } break;
 800fbbe:	e001      	b.n	800fbc4 <se3_payload_decrypt+0xba>
			//to be implemented

		case SE3_SHA256:
			//to be implemented

		default: return false; break;
 800fbc0:	2300      	movs	r3, #0
 800fbc2:	e001      	b.n	800fbc8 <se3_payload_decrypt+0xbe>
		    } break;
 800fbc4:	bf00      	nop
	}


    return true;
 800fbc6:	2301      	movs	r3, #1
}
 800fbc8:	4618      	mov	r0, r3
 800fbca:	3710      	adds	r7, #16
 800fbcc:	46bd      	mov	sp, r7
 800fbce:	bd80      	pop	{r7, pc}

0800fbd0 <sekey_get_implementation_info>:
/*	sekey_get_implementation_info: This function would be the core of the sekey behavior,
 * 	it has to be implemented. The provided code is just a stub
 */


bool sekey_get_implementation_info(uint8_t* algo_implementation, uint8_t* crypto_algo, uint8_t *key){
 800fbd0:	b580      	push	{r7, lr}
 800fbd2:	b084      	sub	sp, #16
 800fbd4:	af00      	add	r7, sp, #0
 800fbd6:	60f8      	str	r0, [r7, #12]
 800fbd8:	60b9      	str	r1, [r7, #8]
 800fbda:	607a      	str	r2, [r7, #4]

	if (sekey_get_auth(key)){
 800fbdc:	6878      	ldr	r0, [r7, #4]
 800fbde:	f000 f80e 	bl	800fbfe <sekey_get_auth>
 800fbe2:	4603      	mov	r3, r0
 800fbe4:	2b00      	cmp	r3, #0
 800fbe6:	d005      	beq.n	800fbf4 <sekey_get_implementation_info+0x24>
		*algo_implementation = SE3_SECURITY_CORE;
 800fbe8:	68fb      	ldr	r3, [r7, #12]
 800fbea:	2200      	movs	r2, #0
 800fbec:	701a      	strb	r2, [r3, #0]
		*crypto_algo = SE3_AES256;
 800fbee:	68bb      	ldr	r3, [r7, #8]
 800fbf0:	2200      	movs	r2, #0
 800fbf2:	701a      	strb	r2, [r3, #0]
	}
	return true;
 800fbf4:	2301      	movs	r3, #1
}
 800fbf6:	4618      	mov	r0, r3
 800fbf8:	3710      	adds	r7, #16
 800fbfa:	46bd      	mov	sp, r7
 800fbfc:	bd80      	pop	{r7, pc}

0800fbfe <sekey_get_auth>:

bool sekey_get_auth(uint8_t *key){
 800fbfe:	b480      	push	{r7}
 800fc00:	b083      	sub	sp, #12
 800fc02:	af00      	add	r7, sp, #0
 800fc04:	6078      	str	r0, [r7, #4]

	return true;
 800fc06:	2301      	movs	r3, #1
}
 800fc08:	4618      	mov	r0, r3
 800fc0a:	370c      	adds	r7, #12
 800fc0c:	46bd      	mov	sp, r7
 800fc0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc12:	4770      	bx	lr

0800fc14 <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 800fc14:	b580      	push	{r7, lr}
 800fc16:	b084      	sub	sp, #16
 800fc18:	af00      	add	r7, sp, #0
  ADC_ChannelConfTypeDef sConfig;

    /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    */
  hadc1.Instance = ADC1;
 800fc1a:	4b1a      	ldr	r3, [pc, #104]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc1c:	4a1a      	ldr	r2, [pc, #104]	; (800fc88 <MX_ADC1_Init+0x74>)
 800fc1e:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4;
 800fc20:	4b18      	ldr	r3, [pc, #96]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc22:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800fc26:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION12b;
 800fc28:	4b16      	ldr	r3, [pc, #88]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc2a:	2200      	movs	r2, #0
 800fc2c:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = DISABLE;
 800fc2e:	4b15      	ldr	r3, [pc, #84]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc30:	2200      	movs	r2, #0
 800fc32:	611a      	str	r2, [r3, #16]
  hadc1.Init.ContinuousConvMode = DISABLE;
 800fc34:	4b13      	ldr	r3, [pc, #76]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc36:	2200      	movs	r2, #0
 800fc38:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 800fc3a:	4b12      	ldr	r3, [pc, #72]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc3c:	2200      	movs	r2, #0
 800fc3e:	621a      	str	r2, [r3, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800fc40:	4b10      	ldr	r3, [pc, #64]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc42:	2200      	movs	r2, #0
 800fc44:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800fc46:	4b0f      	ldr	r3, [pc, #60]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc48:	2200      	movs	r2, #0
 800fc4a:	60da      	str	r2, [r3, #12]
  hadc1.Init.NbrOfConversion = 1;
 800fc4c:	4b0d      	ldr	r3, [pc, #52]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc4e:	2201      	movs	r2, #1
 800fc50:	61da      	str	r2, [r3, #28]
  hadc1.Init.DMAContinuousRequests = DISABLE;
 800fc52:	4b0c      	ldr	r3, [pc, #48]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc54:	2200      	movs	r2, #0
 800fc56:	631a      	str	r2, [r3, #48]	; 0x30
  hadc1.Init.EOCSelection = EOC_SINGLE_CONV;
 800fc58:	4b0a      	ldr	r3, [pc, #40]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc5a:	2201      	movs	r2, #1
 800fc5c:	615a      	str	r2, [r3, #20]
  HAL_ADC_Init(&hadc1);
 800fc5e:	4809      	ldr	r0, [pc, #36]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc60:	f001 fc84 	bl	801156c <HAL_ADC_Init>

    /**Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
    */
  sConfig.Channel = ADC_CHANNEL_12;
 800fc64:	230c      	movs	r3, #12
 800fc66:	603b      	str	r3, [r7, #0]
  sConfig.Rank = 1;
 800fc68:	2301      	movs	r3, #1
 800fc6a:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 800fc6c:	2300      	movs	r3, #0
 800fc6e:	60bb      	str	r3, [r7, #8]
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 800fc70:	463b      	mov	r3, r7
 800fc72:	4619      	mov	r1, r3
 800fc74:	4803      	ldr	r0, [pc, #12]	; (800fc84 <MX_ADC1_Init+0x70>)
 800fc76:	f001 fcbd 	bl	80115f4 <HAL_ADC_ConfigChannel>

}
 800fc7a:	bf00      	nop
 800fc7c:	3710      	adds	r7, #16
 800fc7e:	46bd      	mov	sp, r7
 800fc80:	bd80      	pop	{r7, pc}
 800fc82:	bf00      	nop
 800fc84:	2000ce98 	.word	0x2000ce98
 800fc88:	40012000 	.word	0x40012000

0800fc8c <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 800fc8c:	b580      	push	{r7, lr}
 800fc8e:	b088      	sub	sp, #32
 800fc90:	af00      	add	r7, sp, #0
 800fc92:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hadc->Instance==ADC1)
 800fc94:	687b      	ldr	r3, [r7, #4]
 800fc96:	681b      	ldr	r3, [r3, #0]
 800fc98:	4a10      	ldr	r2, [pc, #64]	; (800fcdc <HAL_ADC_MspInit+0x50>)
 800fc9a:	4293      	cmp	r3, r2
 800fc9c:	d119      	bne.n	800fcd2 <HAL_ADC_MspInit+0x46>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 800fc9e:	2300      	movs	r3, #0
 800fca0:	60bb      	str	r3, [r7, #8]
 800fca2:	4b0f      	ldr	r3, [pc, #60]	; (800fce0 <HAL_ADC_MspInit+0x54>)
 800fca4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800fca6:	4a0e      	ldr	r2, [pc, #56]	; (800fce0 <HAL_ADC_MspInit+0x54>)
 800fca8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800fcac:	6453      	str	r3, [r2, #68]	; 0x44
 800fcae:	4b0c      	ldr	r3, [pc, #48]	; (800fce0 <HAL_ADC_MspInit+0x54>)
 800fcb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800fcb2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800fcb6:	60bb      	str	r3, [r7, #8]
 800fcb8:	68bb      	ldr	r3, [r7, #8]
  
    /**ADC1 GPIO Configuration    
    PC2     ------> ADC1_IN12 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800fcba:	2304      	movs	r3, #4
 800fcbc:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800fcbe:	2303      	movs	r3, #3
 800fcc0:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fcc2:	2300      	movs	r3, #0
 800fcc4:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800fcc6:	f107 030c 	add.w	r3, r7, #12
 800fcca:	4619      	mov	r1, r3
 800fccc:	4805      	ldr	r0, [pc, #20]	; (800fce4 <HAL_ADC_MspInit+0x58>)
 800fcce:	f002 fdc9 	bl	8012864 <HAL_GPIO_Init>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 800fcd2:	bf00      	nop
 800fcd4:	3720      	adds	r7, #32
 800fcd6:	46bd      	mov	sp, r7
 800fcd8:	bd80      	pop	{r7, pc}
 800fcda:	bf00      	nop
 800fcdc:	40012000 	.word	0x40012000
 800fce0:	40023800 	.word	0x40023800
 800fce4:	40020800 	.word	0x40020800

0800fce8 <MX_CRC_Init>:

CRC_HandleTypeDef hcrc;

/* CRC init function */
void MX_CRC_Init(void)
{
 800fce8:	b580      	push	{r7, lr}
 800fcea:	af00      	add	r7, sp, #0

  hcrc.Instance = CRC;
 800fcec:	4b03      	ldr	r3, [pc, #12]	; (800fcfc <MX_CRC_Init+0x14>)
 800fcee:	4a04      	ldr	r2, [pc, #16]	; (800fd00 <MX_CRC_Init+0x18>)
 800fcf0:	601a      	str	r2, [r3, #0]
  HAL_CRC_Init(&hcrc);
 800fcf2:	4802      	ldr	r0, [pc, #8]	; (800fcfc <MX_CRC_Init+0x14>)
 800fcf4:	f001 ffdd 	bl	8011cb2 <HAL_CRC_Init>

}
 800fcf8:	bf00      	nop
 800fcfa:	bd80      	pop	{r7, pc}
 800fcfc:	2000cee0 	.word	0x2000cee0
 800fd00:	40023000 	.word	0x40023000

0800fd04 <HAL_CRC_MspInit>:

void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 800fd04:	b480      	push	{r7}
 800fd06:	b085      	sub	sp, #20
 800fd08:	af00      	add	r7, sp, #0
 800fd0a:	6078      	str	r0, [r7, #4]

  if(hcrc->Instance==CRC)
 800fd0c:	687b      	ldr	r3, [r7, #4]
 800fd0e:	681b      	ldr	r3, [r3, #0]
 800fd10:	4a0b      	ldr	r2, [pc, #44]	; (800fd40 <HAL_CRC_MspInit+0x3c>)
 800fd12:	4293      	cmp	r3, r2
 800fd14:	d10d      	bne.n	800fd32 <HAL_CRC_MspInit+0x2e>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __CRC_CLK_ENABLE();
 800fd16:	2300      	movs	r3, #0
 800fd18:	60fb      	str	r3, [r7, #12]
 800fd1a:	4b0a      	ldr	r3, [pc, #40]	; (800fd44 <HAL_CRC_MspInit+0x40>)
 800fd1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fd1e:	4a09      	ldr	r2, [pc, #36]	; (800fd44 <HAL_CRC_MspInit+0x40>)
 800fd20:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800fd24:	6313      	str	r3, [r2, #48]	; 0x30
 800fd26:	4b07      	ldr	r3, [pc, #28]	; (800fd44 <HAL_CRC_MspInit+0x40>)
 800fd28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fd2a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800fd2e:	60fb      	str	r3, [r7, #12]
 800fd30:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }
}
 800fd32:	bf00      	nop
 800fd34:	3714      	adds	r7, #20
 800fd36:	46bd      	mov	sp, r7
 800fd38:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd3c:	4770      	bx	lr
 800fd3e:	bf00      	nop
 800fd40:	40023000 	.word	0x40023000
 800fd44:	40023800 	.word	0x40023800

0800fd48 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 800fd48:	b580      	push	{r7, lr}
 800fd4a:	b082      	sub	sp, #8
 800fd4c:	af00      	add	r7, sp, #0
  /* DMA controller clock enable */
  __DMA2_CLK_ENABLE();
 800fd4e:	2300      	movs	r3, #0
 800fd50:	607b      	str	r3, [r7, #4]
 800fd52:	4b10      	ldr	r3, [pc, #64]	; (800fd94 <MX_DMA_Init+0x4c>)
 800fd54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fd56:	4a0f      	ldr	r2, [pc, #60]	; (800fd94 <MX_DMA_Init+0x4c>)
 800fd58:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800fd5c:	6313      	str	r3, [r2, #48]	; 0x30
 800fd5e:	4b0d      	ldr	r3, [pc, #52]	; (800fd94 <MX_DMA_Init+0x4c>)
 800fd60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fd62:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800fd66:	607b      	str	r3, [r7, #4]
 800fd68:	687b      	ldr	r3, [r7, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 6, 0);
 800fd6a:	2200      	movs	r2, #0
 800fd6c:	2106      	movs	r1, #6
 800fd6e:	203b      	movs	r0, #59	; 0x3b
 800fd70:	f001 ff3f 	bl	8011bf2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 800fd74:	203b      	movs	r0, #59	; 0x3b
 800fd76:	f001 ff58 	bl	8011c2a <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 6, 0);
 800fd7a:	2200      	movs	r2, #0
 800fd7c:	2106      	movs	r1, #6
 800fd7e:	2045      	movs	r0, #69	; 0x45
 800fd80:	f001 ff37 	bl	8011bf2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 800fd84:	2045      	movs	r0, #69	; 0x45
 800fd86:	f001 ff50 	bl	8011c2a <HAL_NVIC_EnableIRQ>

}
 800fd8a:	bf00      	nop
 800fd8c:	3708      	adds	r7, #8
 800fd8e:	46bd      	mov	sp, r7
 800fd90:	bd80      	pop	{r7, pc}
 800fd92:	bf00      	nop
 800fd94:	40023800 	.word	0x40023800

0800fd98 <MX_FMC_Init>:
NOR_HandleTypeDef hnor1;
NOR_HandleTypeDef hnor2;

/* FMC initialization function */
void MX_FMC_Init(void)
{
 800fd98:	b580      	push	{r7, lr}
 800fd9a:	b088      	sub	sp, #32
 800fd9c:	af00      	add	r7, sp, #0
  FMC_NORSRAM_TimingTypeDef Timing;

  /** Perform the NOR1 memory initialization sequence
  */
  hnor1.Instance = FMC_NORSRAM_DEVICE;
 800fd9e:	4b4a      	ldr	r3, [pc, #296]	; (800fec8 <MX_FMC_Init+0x130>)
 800fda0:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800fda4:	601a      	str	r2, [r3, #0]
  hnor1.Extended = FMC_NORSRAM_EXTENDED_DEVICE;
 800fda6:	4b48      	ldr	r3, [pc, #288]	; (800fec8 <MX_FMC_Init+0x130>)
 800fda8:	4a48      	ldr	r2, [pc, #288]	; (800fecc <MX_FMC_Init+0x134>)
 800fdaa:	605a      	str	r2, [r3, #4]
  /* hnor1.Init */
  hnor1.Init.NSBank = FMC_NORSRAM_BANK1;
 800fdac:	4b46      	ldr	r3, [pc, #280]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdae:	2200      	movs	r2, #0
 800fdb0:	609a      	str	r2, [r3, #8]
  hnor1.Init.DataAddressMux = FMC_DATA_ADDRESS_MUX_DISABLE;
 800fdb2:	4b45      	ldr	r3, [pc, #276]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdb4:	2200      	movs	r2, #0
 800fdb6:	60da      	str	r2, [r3, #12]
  hnor1.Init.MemoryType = FMC_MEMORY_TYPE_NOR;
 800fdb8:	4b43      	ldr	r3, [pc, #268]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdba:	2208      	movs	r2, #8
 800fdbc:	611a      	str	r2, [r3, #16]
  hnor1.Init.MemoryDataWidth = FMC_NORSRAM_MEM_BUS_WIDTH_16;
 800fdbe:	4b42      	ldr	r3, [pc, #264]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdc0:	2210      	movs	r2, #16
 800fdc2:	615a      	str	r2, [r3, #20]
  hnor1.Init.BurstAccessMode = FMC_BURST_ACCESS_MODE_DISABLE;
 800fdc4:	4b40      	ldr	r3, [pc, #256]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdc6:	2200      	movs	r2, #0
 800fdc8:	619a      	str	r2, [r3, #24]
  hnor1.Init.WaitSignalPolarity = FMC_WAIT_SIGNAL_POLARITY_LOW;
 800fdca:	4b3f      	ldr	r3, [pc, #252]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdcc:	2200      	movs	r2, #0
 800fdce:	61da      	str	r2, [r3, #28]
  hnor1.Init.WrapMode = FMC_WRAP_MODE_DISABLE;
 800fdd0:	4b3d      	ldr	r3, [pc, #244]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdd2:	2200      	movs	r2, #0
 800fdd4:	621a      	str	r2, [r3, #32]
  hnor1.Init.WaitSignalActive = FMC_WAIT_TIMING_BEFORE_WS;
 800fdd6:	4b3c      	ldr	r3, [pc, #240]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdd8:	2200      	movs	r2, #0
 800fdda:	625a      	str	r2, [r3, #36]	; 0x24
  hnor1.Init.WriteOperation = FMC_WRITE_OPERATION_DISABLE;
 800fddc:	4b3a      	ldr	r3, [pc, #232]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdde:	2200      	movs	r2, #0
 800fde0:	629a      	str	r2, [r3, #40]	; 0x28
  hnor1.Init.WaitSignal = FMC_WAIT_SIGNAL_DISABLE;
 800fde2:	4b39      	ldr	r3, [pc, #228]	; (800fec8 <MX_FMC_Init+0x130>)
 800fde4:	2200      	movs	r2, #0
 800fde6:	62da      	str	r2, [r3, #44]	; 0x2c
  hnor1.Init.ExtendedMode = FMC_EXTENDED_MODE_DISABLE;
 800fde8:	4b37      	ldr	r3, [pc, #220]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdea:	2200      	movs	r2, #0
 800fdec:	631a      	str	r2, [r3, #48]	; 0x30
  hnor1.Init.AsynchronousWait = FMC_ASYNCHRONOUS_WAIT_DISABLE;
 800fdee:	4b36      	ldr	r3, [pc, #216]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdf0:	2200      	movs	r2, #0
 800fdf2:	635a      	str	r2, [r3, #52]	; 0x34
  hnor1.Init.WriteBurst = FMC_WRITE_BURST_DISABLE;
 800fdf4:	4b34      	ldr	r3, [pc, #208]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdf6:	2200      	movs	r2, #0
 800fdf8:	639a      	str	r2, [r3, #56]	; 0x38
  hnor1.Init.ContinuousClock = FMC_CONTINUOUS_CLOCK_SYNC_ONLY;
 800fdfa:	4b33      	ldr	r3, [pc, #204]	; (800fec8 <MX_FMC_Init+0x130>)
 800fdfc:	2200      	movs	r2, #0
 800fdfe:	63da      	str	r2, [r3, #60]	; 0x3c
  hnor1.Init.PageSize = FMC_PAGE_SIZE_NONE;
 800fe00:	4b31      	ldr	r3, [pc, #196]	; (800fec8 <MX_FMC_Init+0x130>)
 800fe02:	2200      	movs	r2, #0
 800fe04:	645a      	str	r2, [r3, #68]	; 0x44
  /* Timing */
  Timing.AddressSetupTime = 15;
 800fe06:	230f      	movs	r3, #15
 800fe08:	607b      	str	r3, [r7, #4]
  Timing.AddressHoldTime = 15;
 800fe0a:	230f      	movs	r3, #15
 800fe0c:	60bb      	str	r3, [r7, #8]
  Timing.DataSetupTime = 255;
 800fe0e:	23ff      	movs	r3, #255	; 0xff
 800fe10:	60fb      	str	r3, [r7, #12]
  Timing.BusTurnAroundDuration = 15;
 800fe12:	230f      	movs	r3, #15
 800fe14:	613b      	str	r3, [r7, #16]
  Timing.CLKDivision = 16;
 800fe16:	2310      	movs	r3, #16
 800fe18:	617b      	str	r3, [r7, #20]
  Timing.DataLatency = 17;
 800fe1a:	2311      	movs	r3, #17
 800fe1c:	61bb      	str	r3, [r7, #24]
  Timing.AccessMode = FMC_ACCESS_MODE_A;
 800fe1e:	2300      	movs	r3, #0
 800fe20:	61fb      	str	r3, [r7, #28]
  /* ExtTiming */

  HAL_NOR_Init(&hnor1, &Timing, NULL);
 800fe22:	1d3b      	adds	r3, r7, #4
 800fe24:	2200      	movs	r2, #0
 800fe26:	4619      	mov	r1, r3
 800fe28:	4827      	ldr	r0, [pc, #156]	; (800fec8 <MX_FMC_Init+0x130>)
 800fe2a:	f002 ffbf 	bl	8012dac <HAL_NOR_Init>

  /** Perform the NOR2 memory initialization sequence
  */
  hnor2.Instance = FMC_NORSRAM_DEVICE;
 800fe2e:	4b28      	ldr	r3, [pc, #160]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe30:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800fe34:	601a      	str	r2, [r3, #0]
  hnor2.Extended = FMC_NORSRAM_EXTENDED_DEVICE;
 800fe36:	4b26      	ldr	r3, [pc, #152]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe38:	4a24      	ldr	r2, [pc, #144]	; (800fecc <MX_FMC_Init+0x134>)
 800fe3a:	605a      	str	r2, [r3, #4]
  /* hnor2.Init */
  hnor2.Init.NSBank = FMC_NORSRAM_BANK2;
 800fe3c:	4b24      	ldr	r3, [pc, #144]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe3e:	2202      	movs	r2, #2
 800fe40:	609a      	str	r2, [r3, #8]
  hnor2.Init.DataAddressMux = FMC_DATA_ADDRESS_MUX_DISABLE;
 800fe42:	4b23      	ldr	r3, [pc, #140]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe44:	2200      	movs	r2, #0
 800fe46:	60da      	str	r2, [r3, #12]
  hnor2.Init.MemoryType = FMC_MEMORY_TYPE_NOR;
 800fe48:	4b21      	ldr	r3, [pc, #132]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe4a:	2208      	movs	r2, #8
 800fe4c:	611a      	str	r2, [r3, #16]
  hnor2.Init.MemoryDataWidth = FMC_NORSRAM_MEM_BUS_WIDTH_16;
 800fe4e:	4b20      	ldr	r3, [pc, #128]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe50:	2210      	movs	r2, #16
 800fe52:	615a      	str	r2, [r3, #20]
  hnor2.Init.BurstAccessMode = FMC_BURST_ACCESS_MODE_DISABLE;
 800fe54:	4b1e      	ldr	r3, [pc, #120]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe56:	2200      	movs	r2, #0
 800fe58:	619a      	str	r2, [r3, #24]
  hnor2.Init.WaitSignalPolarity = FMC_WAIT_SIGNAL_POLARITY_LOW;
 800fe5a:	4b1d      	ldr	r3, [pc, #116]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe5c:	2200      	movs	r2, #0
 800fe5e:	61da      	str	r2, [r3, #28]
  hnor2.Init.WrapMode = FMC_WRAP_MODE_DISABLE;
 800fe60:	4b1b      	ldr	r3, [pc, #108]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe62:	2200      	movs	r2, #0
 800fe64:	621a      	str	r2, [r3, #32]
  hnor2.Init.WaitSignalActive = FMC_WAIT_TIMING_BEFORE_WS;
 800fe66:	4b1a      	ldr	r3, [pc, #104]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe68:	2200      	movs	r2, #0
 800fe6a:	625a      	str	r2, [r3, #36]	; 0x24
  hnor2.Init.WriteOperation = FMC_WRITE_OPERATION_DISABLE;
 800fe6c:	4b18      	ldr	r3, [pc, #96]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe6e:	2200      	movs	r2, #0
 800fe70:	629a      	str	r2, [r3, #40]	; 0x28
  hnor2.Init.WaitSignal = FMC_WAIT_SIGNAL_DISABLE;
 800fe72:	4b17      	ldr	r3, [pc, #92]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe74:	2200      	movs	r2, #0
 800fe76:	62da      	str	r2, [r3, #44]	; 0x2c
  hnor2.Init.ExtendedMode = FMC_EXTENDED_MODE_DISABLE;
 800fe78:	4b15      	ldr	r3, [pc, #84]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe7a:	2200      	movs	r2, #0
 800fe7c:	631a      	str	r2, [r3, #48]	; 0x30
  hnor2.Init.AsynchronousWait = FMC_ASYNCHRONOUS_WAIT_DISABLE;
 800fe7e:	4b14      	ldr	r3, [pc, #80]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe80:	2200      	movs	r2, #0
 800fe82:	635a      	str	r2, [r3, #52]	; 0x34
  hnor2.Init.WriteBurst = FMC_WRITE_BURST_DISABLE;
 800fe84:	4b12      	ldr	r3, [pc, #72]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe86:	2200      	movs	r2, #0
 800fe88:	639a      	str	r2, [r3, #56]	; 0x38
  hnor2.Init.ContinuousClock = FMC_CONTINUOUS_CLOCK_SYNC_ONLY;
 800fe8a:	4b11      	ldr	r3, [pc, #68]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe8c:	2200      	movs	r2, #0
 800fe8e:	63da      	str	r2, [r3, #60]	; 0x3c
  hnor2.Init.PageSize = FMC_PAGE_SIZE_NONE;
 800fe90:	4b0f      	ldr	r3, [pc, #60]	; (800fed0 <MX_FMC_Init+0x138>)
 800fe92:	2200      	movs	r2, #0
 800fe94:	645a      	str	r2, [r3, #68]	; 0x44
  /* Timing */
  Timing.AddressSetupTime = 15;
 800fe96:	230f      	movs	r3, #15
 800fe98:	607b      	str	r3, [r7, #4]
  Timing.AddressHoldTime = 15;
 800fe9a:	230f      	movs	r3, #15
 800fe9c:	60bb      	str	r3, [r7, #8]
  Timing.DataSetupTime = 255;
 800fe9e:	23ff      	movs	r3, #255	; 0xff
 800fea0:	60fb      	str	r3, [r7, #12]
  Timing.BusTurnAroundDuration = 15;
 800fea2:	230f      	movs	r3, #15
 800fea4:	613b      	str	r3, [r7, #16]
  Timing.CLKDivision = 16;
 800fea6:	2310      	movs	r3, #16
 800fea8:	617b      	str	r3, [r7, #20]
  Timing.DataLatency = 17;
 800feaa:	2311      	movs	r3, #17
 800feac:	61bb      	str	r3, [r7, #24]
  Timing.AccessMode = FMC_ACCESS_MODE_A;
 800feae:	2300      	movs	r3, #0
 800feb0:	61fb      	str	r3, [r7, #28]
  /* ExtTiming */

  HAL_NOR_Init(&hnor2, &Timing, NULL);
 800feb2:	1d3b      	adds	r3, r7, #4
 800feb4:	2200      	movs	r2, #0
 800feb6:	4619      	mov	r1, r3
 800feb8:	4805      	ldr	r0, [pc, #20]	; (800fed0 <MX_FMC_Init+0x138>)
 800feba:	f002 ff77 	bl	8012dac <HAL_NOR_Init>

}
 800febe:	bf00      	nop
 800fec0:	3720      	adds	r7, #32
 800fec2:	46bd      	mov	sp, r7
 800fec4:	bd80      	pop	{r7, pc}
 800fec6:	bf00      	nop
 800fec8:	2000cee8 	.word	0x2000cee8
 800fecc:	a0000104 	.word	0xa0000104
 800fed0:	2000cf34 	.word	0x2000cf34

0800fed4 <HAL_FMC_MspInit>:

static int FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 800fed4:	b580      	push	{r7, lr}
 800fed6:	b086      	sub	sp, #24
 800fed8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct;
  if (FMC_Initialized) {
 800feda:	4b2c      	ldr	r3, [pc, #176]	; (800ff8c <HAL_FMC_MspInit+0xb8>)
 800fedc:	681b      	ldr	r3, [r3, #0]
 800fede:	2b00      	cmp	r3, #0
 800fee0:	d150      	bne.n	800ff84 <HAL_FMC_MspInit+0xb0>
    return;
  }
  FMC_Initialized = 1;
 800fee2:	4b2a      	ldr	r3, [pc, #168]	; (800ff8c <HAL_FMC_MspInit+0xb8>)
 800fee4:	2201      	movs	r2, #1
 800fee6:	601a      	str	r2, [r3, #0]
  /* Peripheral clock enable */
  __FMC_CLK_ENABLE();
 800fee8:	2300      	movs	r3, #0
 800feea:	603b      	str	r3, [r7, #0]
 800feec:	4b28      	ldr	r3, [pc, #160]	; (800ff90 <HAL_FMC_MspInit+0xbc>)
 800feee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800fef0:	4a27      	ldr	r2, [pc, #156]	; (800ff90 <HAL_FMC_MspInit+0xbc>)
 800fef2:	f043 0301 	orr.w	r3, r3, #1
 800fef6:	6393      	str	r3, [r2, #56]	; 0x38
 800fef8:	4b25      	ldr	r3, [pc, #148]	; (800ff90 <HAL_FMC_MspInit+0xbc>)
 800fefa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800fefc:	f003 0301 	and.w	r3, r3, #1
 800ff00:	603b      	str	r3, [r7, #0]
 800ff02:	683b      	ldr	r3, [r7, #0]
  PE12   ------> FMC_D9
  PE15   ------> FMC_D12
  PE13   ------> FMC_D10
  */
  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_0|GPIO_PIN_5|GPIO_PIN_1 
 800ff04:	f24c 73b3 	movw	r3, #51123	; 0xc7b3
 800ff08:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_4|GPIO_PIN_15|GPIO_PIN_10|GPIO_PIN_14 
                          |GPIO_PIN_9|GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff0a:	2302      	movs	r3, #2
 800ff0c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff0e:	2300      	movs	r3, #0
 800ff10:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800ff12:	2303      	movs	r3, #3
 800ff14:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800ff16:	230c      	movs	r3, #12
 800ff18:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800ff1a:	1d3b      	adds	r3, r7, #4
 800ff1c:	4619      	mov	r1, r3
 800ff1e:	481d      	ldr	r0, [pc, #116]	; (800ff94 <HAL_FMC_MspInit+0xc0>)
 800ff20:	f002 fca0 	bl	8012864 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 800ff24:	233f      	movs	r3, #63	; 0x3f
 800ff26:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_4|GPIO_PIN_5;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff28:	2302      	movs	r3, #2
 800ff2a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff2c:	2300      	movs	r3, #0
 800ff2e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800ff30:	2303      	movs	r3, #3
 800ff32:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800ff34:	230c      	movs	r3, #12
 800ff36:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800ff38:	1d3b      	adds	r3, r7, #4
 800ff3a:	4619      	mov	r1, r3
 800ff3c:	4816      	ldr	r0, [pc, #88]	; (800ff98 <HAL_FMC_MspInit+0xc4>)
 800ff3e:	f002 fc91 	bl	8012864 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_9;
 800ff42:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ff46:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff48:	2302      	movs	r3, #2
 800ff4a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff4c:	2300      	movs	r3, #0
 800ff4e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800ff50:	2303      	movs	r3, #3
 800ff52:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800ff54:	230c      	movs	r3, #12
 800ff56:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800ff58:	1d3b      	adds	r3, r7, #4
 800ff5a:	4619      	mov	r1, r3
 800ff5c:	480f      	ldr	r0, [pc, #60]	; (800ff9c <HAL_FMC_MspInit+0xc8>)
 800ff5e:	f002 fc81 	bl	8012864 <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_14 
 800ff62:	f64f 7380 	movw	r3, #65408	; 0xff80
 800ff66:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_7|GPIO_PIN_10|GPIO_PIN_12|GPIO_PIN_15 
                          |GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff68:	2302      	movs	r3, #2
 800ff6a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff6c:	2300      	movs	r3, #0
 800ff6e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 800ff70:	2303      	movs	r3, #3
 800ff72:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800ff74:	230c      	movs	r3, #12
 800ff76:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800ff78:	1d3b      	adds	r3, r7, #4
 800ff7a:	4619      	mov	r1, r3
 800ff7c:	4808      	ldr	r0, [pc, #32]	; (800ffa0 <HAL_FMC_MspInit+0xcc>)
 800ff7e:	f002 fc71 	bl	8012864 <HAL_GPIO_Init>
 800ff82:	e000      	b.n	800ff86 <HAL_FMC_MspInit+0xb2>
    return;
 800ff84:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 800ff86:	3718      	adds	r7, #24
 800ff88:	46bd      	mov	sp, r7
 800ff8a:	bd80      	pop	{r7, pc}
 800ff8c:	20000488 	.word	0x20000488
 800ff90:	40023800 	.word	0x40023800
 800ff94:	40020c00 	.word	0x40020c00
 800ff98:	40021400 	.word	0x40021400
 800ff9c:	40021800 	.word	0x40021800
 800ffa0:	40021000 	.word	0x40021000

0800ffa4 <HAL_NOR_MspInit>:

void HAL_NOR_MspInit(NOR_HandleTypeDef* hnor){
 800ffa4:	b580      	push	{r7, lr}
 800ffa6:	b082      	sub	sp, #8
 800ffa8:	af00      	add	r7, sp, #0
 800ffaa:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN NOR_MspInit 0 */

  /* USER CODE END NOR_MspInit 0 */
  HAL_FMC_MspInit();
 800ffac:	f7ff ff92 	bl	800fed4 <HAL_FMC_MspInit>
  /* USER CODE BEGIN NOR_MspInit 1 */

  /* USER CODE END NOR_MspInit 1 */
}
 800ffb0:	bf00      	nop
 800ffb2:	3708      	adds	r7, #8
 800ffb4:	46bd      	mov	sp, r7
 800ffb6:	bd80      	pop	{r7, pc}

0800ffb8 <MX_GPIO_Init>:
 * EVENT_OUT
 * EXTI
 PA8   ------> RCC_MCO_1
 */
void MX_GPIO_Init(void)
{
 800ffb8:	b580      	push	{r7, lr}
 800ffba:	b08e      	sub	sp, #56	; 0x38
 800ffbc:	af00      	add	r7, sp, #0
    
    GPIO_InitTypeDef GPIO_InitStruct;
    
    /* GPIO Ports Clock Enable */
    __GPIOE_CLK_ENABLE();
 800ffbe:	2300      	movs	r3, #0
 800ffc0:	623b      	str	r3, [r7, #32]
 800ffc2:	4b75      	ldr	r3, [pc, #468]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ffc6:	4a74      	ldr	r2, [pc, #464]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffc8:	f043 0310 	orr.w	r3, r3, #16
 800ffcc:	6313      	str	r3, [r2, #48]	; 0x30
 800ffce:	4b72      	ldr	r3, [pc, #456]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ffd2:	f003 0310 	and.w	r3, r3, #16
 800ffd6:	623b      	str	r3, [r7, #32]
 800ffd8:	6a3b      	ldr	r3, [r7, #32]
    __GPIOB_CLK_ENABLE();
 800ffda:	2300      	movs	r3, #0
 800ffdc:	61fb      	str	r3, [r7, #28]
 800ffde:	4b6e      	ldr	r3, [pc, #440]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffe0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ffe2:	4a6d      	ldr	r2, [pc, #436]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffe4:	f043 0302 	orr.w	r3, r3, #2
 800ffe8:	6313      	str	r3, [r2, #48]	; 0x30
 800ffea:	4b6b      	ldr	r3, [pc, #428]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800ffec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ffee:	f003 0302 	and.w	r3, r3, #2
 800fff2:	61fb      	str	r3, [r7, #28]
 800fff4:	69fb      	ldr	r3, [r7, #28]
    __GPIOD_CLK_ENABLE();
 800fff6:	2300      	movs	r3, #0
 800fff8:	61bb      	str	r3, [r7, #24]
 800fffa:	4b67      	ldr	r3, [pc, #412]	; (8010198 <MX_GPIO_Init+0x1e0>)
 800fffc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800fffe:	4a66      	ldr	r2, [pc, #408]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010000:	f043 0308 	orr.w	r3, r3, #8
 8010004:	6313      	str	r3, [r2, #48]	; 0x30
 8010006:	4b64      	ldr	r3, [pc, #400]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010008:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801000a:	f003 0308 	and.w	r3, r3, #8
 801000e:	61bb      	str	r3, [r7, #24]
 8010010:	69bb      	ldr	r3, [r7, #24]
    __GPIOC_CLK_ENABLE();
 8010012:	2300      	movs	r3, #0
 8010014:	617b      	str	r3, [r7, #20]
 8010016:	4b60      	ldr	r3, [pc, #384]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010018:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801001a:	4a5f      	ldr	r2, [pc, #380]	; (8010198 <MX_GPIO_Init+0x1e0>)
 801001c:	f043 0304 	orr.w	r3, r3, #4
 8010020:	6313      	str	r3, [r2, #48]	; 0x30
 8010022:	4b5d      	ldr	r3, [pc, #372]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010024:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010026:	f003 0304 	and.w	r3, r3, #4
 801002a:	617b      	str	r3, [r7, #20]
 801002c:	697b      	ldr	r3, [r7, #20]
    __GPIOA_CLK_ENABLE();
 801002e:	2300      	movs	r3, #0
 8010030:	613b      	str	r3, [r7, #16]
 8010032:	4b59      	ldr	r3, [pc, #356]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010034:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010036:	4a58      	ldr	r2, [pc, #352]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010038:	f043 0301 	orr.w	r3, r3, #1
 801003c:	6313      	str	r3, [r2, #48]	; 0x30
 801003e:	4b56      	ldr	r3, [pc, #344]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010040:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010042:	f003 0301 	and.w	r3, r3, #1
 8010046:	613b      	str	r3, [r7, #16]
 8010048:	693b      	ldr	r3, [r7, #16]
    __GPIOF_CLK_ENABLE();
 801004a:	2300      	movs	r3, #0
 801004c:	60fb      	str	r3, [r7, #12]
 801004e:	4b52      	ldr	r3, [pc, #328]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010050:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010052:	4a51      	ldr	r2, [pc, #324]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010054:	f043 0320 	orr.w	r3, r3, #32
 8010058:	6313      	str	r3, [r2, #48]	; 0x30
 801005a:	4b4f      	ldr	r3, [pc, #316]	; (8010198 <MX_GPIO_Init+0x1e0>)
 801005c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801005e:	f003 0320 	and.w	r3, r3, #32
 8010062:	60fb      	str	r3, [r7, #12]
 8010064:	68fb      	ldr	r3, [r7, #12]
    __GPIOG_CLK_ENABLE();
 8010066:	2300      	movs	r3, #0
 8010068:	60bb      	str	r3, [r7, #8]
 801006a:	4b4b      	ldr	r3, [pc, #300]	; (8010198 <MX_GPIO_Init+0x1e0>)
 801006c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801006e:	4a4a      	ldr	r2, [pc, #296]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010070:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010074:	6313      	str	r3, [r2, #48]	; 0x30
 8010076:	4b48      	ldr	r3, [pc, #288]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010078:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801007a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801007e:	60bb      	str	r3, [r7, #8]
 8010080:	68bb      	ldr	r3, [r7, #8]
    __GPIOI_CLK_ENABLE();
 8010082:	2300      	movs	r3, #0
 8010084:	607b      	str	r3, [r7, #4]
 8010086:	4b44      	ldr	r3, [pc, #272]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010088:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801008a:	4a43      	ldr	r2, [pc, #268]	; (8010198 <MX_GPIO_Init+0x1e0>)
 801008c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8010090:	6313      	str	r3, [r2, #48]	; 0x30
 8010092:	4b41      	ldr	r3, [pc, #260]	; (8010198 <MX_GPIO_Init+0x1e0>)
 8010094:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010096:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801009a:	607b      	str	r3, [r7, #4]
 801009c:	687b      	ldr	r3, [r7, #4]
    __GPIOH_CLK_ENABLE();
 801009e:	2300      	movs	r3, #0
 80100a0:	603b      	str	r3, [r7, #0]
 80100a2:	4b3d      	ldr	r3, [pc, #244]	; (8010198 <MX_GPIO_Init+0x1e0>)
 80100a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80100a6:	4a3c      	ldr	r2, [pc, #240]	; (8010198 <MX_GPIO_Init+0x1e0>)
 80100a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80100ac:	6313      	str	r3, [r2, #48]	; 0x30
 80100ae:	4b3a      	ldr	r3, [pc, #232]	; (8010198 <MX_GPIO_Init+0x1e0>)
 80100b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80100b2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80100b6:	603b      	str	r3, [r7, #0]
 80100b8:	683b      	ldr	r3, [r7, #0]
    
    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(GPIOE, FPGA_TCK_Pin|FPGA_TDO_Pin|SC_ON_OFF_Pin|SC_RST_Pin
 80100ba:	2200      	movs	r2, #0
 80100bc:	2177      	movs	r1, #119	; 0x77
 80100be:	4837      	ldr	r0, [pc, #220]	; (801019c <MX_GPIO_Init+0x1e4>)
 80100c0:	f002 fd7a 	bl	8012bb8 <HAL_GPIO_WritePin>
                      |FPGA_TMS_Pin|FPGA_PROGRAMN_Pin, GPIO_PIN_RESET);
    
    /*Configure GPIO pin Output Level */
    HAL_GPIO_WritePin(GPIOG, GPIO0_RST_OUT_Pin|FPGA_RST_Pin, GPIO_PIN_RESET);
 80100c4:	2200      	movs	r2, #0
 80100c6:	210c      	movs	r1, #12
 80100c8:	4835      	ldr	r0, [pc, #212]	; (80101a0 <MX_GPIO_Init+0x1e8>)
 80100ca:	f002 fd75 	bl	8012bb8 <HAL_GPIO_WritePin>
    
    /*Configure GPIO pins : PE0 PE1 */
    GPIO_InitStruct.Pin = SC_ON_OFF_Pin|SC_RST_Pin;
 80100ce:	2303      	movs	r3, #3
 80100d0:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80100d2:	2301      	movs	r3, #1
 80100d4:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80100d6:	2300      	movs	r3, #0
 80100d8:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 80100da:	2300      	movs	r3, #0
 80100dc:	633b      	str	r3, [r7, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80100de:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80100e2:	4619      	mov	r1, r3
 80100e4:	482d      	ldr	r0, [pc, #180]	; (801019c <MX_GPIO_Init+0x1e4>)
 80100e6:	f002 fbbd 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pins : PE3 PE5 PE4 PE6 */
    GPIO_InitStruct.Pin = FPGA_TCK_Pin|FPGA_TDI_Pin|FPGA_TMS_Pin|FPGA_PROGRAMN_Pin;
 80100ea:	2378      	movs	r3, #120	; 0x78
 80100ec:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80100ee:	2301      	movs	r3, #1
 80100f0:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80100f2:	2300      	movs	r3, #0
 80100f4:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 80100f6:	2303      	movs	r3, #3
 80100f8:	633b      	str	r3, [r7, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80100fa:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80100fe:	4619      	mov	r1, r3
 8010100:	4826      	ldr	r0, [pc, #152]	; (801019c <MX_GPIO_Init+0x1e4>)
 8010102:	f002 fbaf 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pin : PE2 */
    GPIO_InitStruct.Pin = FPGA_TDO_Pin;
 8010106:	2304      	movs	r3, #4
 8010108:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 801010a:	2300      	movs	r3, #0
 801010c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801010e:	2300      	movs	r3, #0
 8010110:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(FPGA_TDI_GPIO_Port, &GPIO_InitStruct);
 8010112:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8010116:	4619      	mov	r1, r3
 8010118:	4820      	ldr	r0, [pc, #128]	; (801019c <MX_GPIO_Init+0x1e4>)
 801011a:	f002 fba3 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pin : PA9 */
    GPIO_InitStruct.Pin = FPGA_INTN_Pin;
 801011e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8010122:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8010124:	2300      	movs	r3, #0
 8010126:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010128:	2300      	movs	r3, #0
 801012a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(FPGA_INTN_GPIO_Port, &GPIO_InitStruct);
 801012c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8010130:	4619      	mov	r1, r3
 8010132:	481c      	ldr	r0, [pc, #112]	; (80101a4 <MX_GPIO_Init+0x1ec>)
 8010134:	f002 fb96 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pin : PA8 */
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 8010138:	f44f 7380 	mov.w	r3, #256	; 0x100
 801013c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801013e:	2302      	movs	r3, #2
 8010140:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010142:	2300      	movs	r3, #0
 8010144:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8010146:	2300      	movs	r3, #0
 8010148:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 801014a:	2300      	movs	r3, #0
 801014c:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801014e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8010152:	4619      	mov	r1, r3
 8010154:	4813      	ldr	r0, [pc, #76]	; (80101a4 <MX_GPIO_Init+0x1ec>)
 8010156:	f002 fb85 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pin : PF10 */
    GPIO_InitStruct.Pin = GPIO1_INT_N_OUT_Pin;
 801015a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801015e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8010160:	2300      	movs	r3, #0
 8010162:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010164:	2300      	movs	r3, #0
 8010166:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIO1_INT_N_OUT_GPIO_Port, &GPIO_InitStruct);
 8010168:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801016c:	4619      	mov	r1, r3
 801016e:	480e      	ldr	r0, [pc, #56]	; (80101a8 <MX_GPIO_Init+0x1f0>)
 8010170:	f002 fb78 	bl	8012864 <HAL_GPIO_Init>
    
    /*Configure GPIO pins : PG3 PG2 */
    GPIO_InitStruct.Pin = GPIO0_RST_OUT_Pin|FPGA_RST_Pin;
 8010174:	230c      	movs	r3, #12
 8010176:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010178:	2301      	movs	r3, #1
 801017a:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801017c:	2300      	movs	r3, #0
 801017e:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8010180:	2300      	movs	r3, #0
 8010182:	633b      	str	r3, [r7, #48]	; 0x30
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8010184:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8010188:	4619      	mov	r1, r3
 801018a:	4805      	ldr	r0, [pc, #20]	; (80101a0 <MX_GPIO_Init+0x1e8>)
 801018c:	f002 fb6a 	bl	8012864 <HAL_GPIO_Init>
    
    
    
}
 8010190:	bf00      	nop
 8010192:	3738      	adds	r7, #56	; 0x38
 8010194:	46bd      	mov	sp, r7
 8010196:	bd80      	pop	{r7, pc}
 8010198:	40023800 	.word	0x40023800
 801019c:	40021000 	.word	0x40021000
 80101a0:	40021800 	.word	0x40021800
 80101a4:	40020000 	.word	0x40020000
 80101a8:	40021400 	.word	0x40021400

080101ac <MX_I2C2_Init>:

I2C_HandleTypeDef hi2c2;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
 80101ac:	b580      	push	{r7, lr}
 80101ae:	af00      	add	r7, sp, #0

  hi2c2.Instance = I2C2;
 80101b0:	4b10      	ldr	r3, [pc, #64]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101b2:	4a11      	ldr	r2, [pc, #68]	; (80101f8 <MX_I2C2_Init+0x4c>)
 80101b4:	601a      	str	r2, [r3, #0]
  hi2c2.Init.ClockSpeed = 100000;
 80101b6:	4b0f      	ldr	r3, [pc, #60]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101b8:	4a10      	ldr	r2, [pc, #64]	; (80101fc <MX_I2C2_Init+0x50>)
 80101ba:	605a      	str	r2, [r3, #4]
  hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
 80101bc:	4b0d      	ldr	r3, [pc, #52]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101be:	2200      	movs	r2, #0
 80101c0:	609a      	str	r2, [r3, #8]
  hi2c2.Init.OwnAddress1 = 0;
 80101c2:	4b0c      	ldr	r3, [pc, #48]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101c4:	2200      	movs	r2, #0
 80101c6:	60da      	str	r2, [r3, #12]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80101c8:	4b0a      	ldr	r3, [pc, #40]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101ca:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80101ce:	611a      	str	r2, [r3, #16]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLED;
 80101d0:	4b08      	ldr	r3, [pc, #32]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101d2:	2200      	movs	r2, #0
 80101d4:	615a      	str	r2, [r3, #20]
  hi2c2.Init.OwnAddress2 = 0;
 80101d6:	4b07      	ldr	r3, [pc, #28]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101d8:	2200      	movs	r2, #0
 80101da:	619a      	str	r2, [r3, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLED;
 80101dc:	4b05      	ldr	r3, [pc, #20]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101de:	2200      	movs	r2, #0
 80101e0:	61da      	str	r2, [r3, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLED;
 80101e2:	4b04      	ldr	r3, [pc, #16]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101e4:	2200      	movs	r2, #0
 80101e6:	621a      	str	r2, [r3, #32]
  HAL_I2C_Init(&hi2c2);
 80101e8:	4802      	ldr	r0, [pc, #8]	; (80101f4 <MX_I2C2_Init+0x48>)
 80101ea:	f002 fcff 	bl	8012bec <HAL_I2C_Init>

}
 80101ee:	bf00      	nop
 80101f0:	bd80      	pop	{r7, pc}
 80101f2:	bf00      	nop
 80101f4:	2000cf80 	.word	0x2000cf80
 80101f8:	40005800 	.word	0x40005800
 80101fc:	000186a0 	.word	0x000186a0

08010200 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8010200:	b580      	push	{r7, lr}
 8010202:	b088      	sub	sp, #32
 8010204:	af00      	add	r7, sp, #0
 8010206:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hi2c->Instance==I2C2)
 8010208:	687b      	ldr	r3, [r7, #4]
 801020a:	681b      	ldr	r3, [r3, #0]
 801020c:	4a12      	ldr	r2, [pc, #72]	; (8010258 <HAL_I2C_MspInit+0x58>)
 801020e:	4293      	cmp	r3, r2
 8010210:	d11d      	bne.n	801024e <HAL_I2C_MspInit+0x4e>
  
    /**I2C2 GPIO Configuration    
    PH4     ------> I2C2_SCL
    PH5     ------> I2C2_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8010212:	2330      	movs	r3, #48	; 0x30
 8010214:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8010216:	2312      	movs	r3, #18
 8010218:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 801021a:	2301      	movs	r3, #1
 801021c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 801021e:	2303      	movs	r3, #3
 8010220:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8010222:	2304      	movs	r3, #4
 8010224:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8010226:	f107 030c 	add.w	r3, r7, #12
 801022a:	4619      	mov	r1, r3
 801022c:	480b      	ldr	r0, [pc, #44]	; (801025c <HAL_I2C_MspInit+0x5c>)
 801022e:	f002 fb19 	bl	8012864 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __I2C2_CLK_ENABLE();
 8010232:	2300      	movs	r3, #0
 8010234:	60bb      	str	r3, [r7, #8]
 8010236:	4b0a      	ldr	r3, [pc, #40]	; (8010260 <HAL_I2C_MspInit+0x60>)
 8010238:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801023a:	4a09      	ldr	r2, [pc, #36]	; (8010260 <HAL_I2C_MspInit+0x60>)
 801023c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8010240:	6413      	str	r3, [r2, #64]	; 0x40
 8010242:	4b07      	ldr	r3, [pc, #28]	; (8010260 <HAL_I2C_MspInit+0x60>)
 8010244:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010246:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 801024a:	60bb      	str	r3, [r7, #8]
 801024c:	68bb      	ldr	r3, [r7, #8]
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 801024e:	bf00      	nop
 8010250:	3720      	adds	r7, #32
 8010252:	46bd      	mov	sp, r7
 8010254:	bd80      	pop	{r7, pc}
 8010256:	bf00      	nop
 8010258:	40005800 	.word	0x40005800
 801025c:	40021c00 	.word	0x40021c00
 8010260:	40023800 	.word	0x40023800

08010264 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8010264:	b580      	push	{r7, lr}
 8010266:	af00      	add	r7, sp, #0
	/* USER CODE END 1 */

	/* MCU Configuration----------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 8010268:	f001 f912 	bl	8011490 <HAL_Init>

	/* Configure the system clock */
	SystemClock_Config();
 801026c:	f000 f822 	bl	80102b4 <SystemClock_Config>

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
 8010270:	f7ff fea2 	bl	800ffb8 <MX_GPIO_Init>
	MX_DMA_Init();
 8010274:	f7ff fd68 	bl	800fd48 <MX_DMA_Init>
	MX_ADC1_Init();
 8010278:	f7ff fccc 	bl	800fc14 <MX_ADC1_Init>
	MX_FMC_Init();
 801027c:	f7ff fd8c 	bl	800fd98 <MX_FMC_Init>
	MX_I2C2_Init();
 8010280:	f7ff ff94 	bl	80101ac <MX_I2C2_Init>
	MX_SDIO_SD_Init();
 8010284:	f000 f8b2 	bl	80103ec <MX_SDIO_SD_Init>
	MX_SPI5_Init();
 8010288:	f000 faa4 	bl	80107d4 <MX_SPI5_Init>
	MX_TIM4_Init();
 801028c:	f000 fb50 	bl	8010930 <MX_TIM4_Init>
	MX_USART1_UART_Init();
 8010290:	f000 fbca 	bl	8010a28 <MX_USART1_UART_Init>
	MX_USART6_SMARTCARD_Init();
 8010294:	f000 fbee 	bl	8010a74 <MX_USART6_SMARTCARD_Init>
	MX_USB_DEVICE_Init();
 8010298:	f000 fcba 	bl	8010c10 <MX_USB_DEVICE_Init>
	MX_CRC_Init();
 801029c:	f7ff fd24 	bl	800fce8 <MX_CRC_Init>
	MX_RNG_Init();
 80102a0:	f000 f874 	bl	801038c <MX_RNG_Init>

	/* USER CODE BEGIN */
	device_init();
 80102a4:	f7fc fe10 	bl	800cec8 <device_init>

	device_loop();
 80102a8:	f7fc fe1a 	bl	800cee0 <device_loop>
	/* USER CODE END  */


	return 0;
 80102ac:	2300      	movs	r3, #0
}
 80102ae:	4618      	mov	r0, r3
 80102b0:	bd80      	pop	{r7, pc}
	...

080102b4 <SystemClock_Config>:


/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 80102b4:	b580      	push	{r7, lr}
 80102b6:	b094      	sub	sp, #80	; 0x50
 80102b8:	af00      	add	r7, sp, #0

	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_ClkInitTypeDef RCC_ClkInitStruct;

	__PWR_CLK_ENABLE();
 80102ba:	2300      	movs	r3, #0
 80102bc:	60bb      	str	r3, [r7, #8]
 80102be:	4b30      	ldr	r3, [pc, #192]	; (8010380 <SystemClock_Config+0xcc>)
 80102c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80102c2:	4a2f      	ldr	r2, [pc, #188]	; (8010380 <SystemClock_Config+0xcc>)
 80102c4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80102c8:	6413      	str	r3, [r2, #64]	; 0x40
 80102ca:	4b2d      	ldr	r3, [pc, #180]	; (8010380 <SystemClock_Config+0xcc>)
 80102cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80102ce:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80102d2:	60bb      	str	r3, [r7, #8]
 80102d4:	68bb      	ldr	r3, [r7, #8]
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80102d6:	2300      	movs	r3, #0
 80102d8:	607b      	str	r3, [r7, #4]
 80102da:	4b2a      	ldr	r3, [pc, #168]	; (8010384 <SystemClock_Config+0xd0>)
 80102dc:	681b      	ldr	r3, [r3, #0]
 80102de:	4a29      	ldr	r2, [pc, #164]	; (8010384 <SystemClock_Config+0xd0>)
 80102e0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80102e4:	6013      	str	r3, [r2, #0]
 80102e6:	4b27      	ldr	r3, [pc, #156]	; (8010384 <SystemClock_Config+0xd0>)
 80102e8:	681b      	ldr	r3, [r3, #0]
 80102ea:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 80102ee:	607b      	str	r3, [r7, #4]
 80102f0:	687b      	ldr	r3, [r7, #4]

	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80102f2:	2301      	movs	r3, #1
 80102f4:	623b      	str	r3, [r7, #32]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80102f6:	2301      	movs	r3, #1
 80102f8:	627b      	str	r3, [r7, #36]	; 0x24
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80102fa:	2302      	movs	r3, #2
 80102fc:	63bb      	str	r3, [r7, #56]	; 0x38
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80102fe:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8010302:	63fb      	str	r3, [r7, #60]	; 0x3c
	RCC_OscInitStruct.PLL.PLLM = 16;
 8010304:	2310      	movs	r3, #16
 8010306:	643b      	str	r3, [r7, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLN = 336;
 8010308:	f44f 73a8 	mov.w	r3, #336	; 0x150
 801030c:	647b      	str	r3, [r7, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 801030e:	2302      	movs	r3, #2
 8010310:	64bb      	str	r3, [r7, #72]	; 0x48
	RCC_OscInitStruct.PLL.PLLQ = 7;
 8010312:	2307      	movs	r3, #7
 8010314:	64fb      	str	r3, [r7, #76]	; 0x4c
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8010316:	f107 0320 	add.w	r3, r7, #32
 801031a:	4618      	mov	r0, r3
 801031c:	f003 fdd6 	bl	8013ecc <HAL_RCC_OscConfig>

	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8010320:	230f      	movs	r3, #15
 8010322:	60fb      	str	r3, [r7, #12]
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8010324:	2302      	movs	r3, #2
 8010326:	613b      	str	r3, [r7, #16]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8010328:	2300      	movs	r3, #0
 801032a:	617b      	str	r3, [r7, #20]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 801032c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8010330:	61bb      	str	r3, [r7, #24]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8010332:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8010336:	61fb      	str	r3, [r7, #28]
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 8010338:	f107 030c 	add.w	r3, r7, #12
 801033c:	2105      	movs	r1, #5
 801033e:	4618      	mov	r0, r3
 8010340:	f003 ffd8 	bl	80142f4 <HAL_RCC_ClockConfig>

	HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_2);
 8010344:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8010348:	f44f 01c0 	mov.w	r1, #6291456	; 0x600000
 801034c:	2000      	movs	r0, #0
 801034e:	f004 f8c3 	bl	80144d8 <HAL_RCC_MCOConfig>

	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8010352:	f004 f9a5 	bl	80146a0 <HAL_RCC_GetHCLKFreq>
 8010356:	4602      	mov	r2, r0
 8010358:	4b0b      	ldr	r3, [pc, #44]	; (8010388 <SystemClock_Config+0xd4>)
 801035a:	fba3 2302 	umull	r2, r3, r3, r2
 801035e:	099b      	lsrs	r3, r3, #6
 8010360:	4618      	mov	r0, r3
 8010362:	f001 fc70 	bl	8011c46 <HAL_SYSTICK_Config>

	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8010366:	2004      	movs	r0, #4
 8010368:	f001 fc7a 	bl	8011c60 <HAL_SYSTICK_CLKSourceConfig>

	/* SysTick_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 801036c:	2200      	movs	r2, #0
 801036e:	2100      	movs	r1, #0
 8010370:	f04f 30ff 	mov.w	r0, #4294967295
 8010374:	f001 fc3d 	bl	8011bf2 <HAL_NVIC_SetPriority>
}
 8010378:	bf00      	nop
 801037a:	3750      	adds	r7, #80	; 0x50
 801037c:	46bd      	mov	sp, r7
 801037e:	bd80      	pop	{r7, pc}
 8010380:	40023800 	.word	0x40023800
 8010384:	40007000 	.word	0x40007000
 8010388:	10624dd3 	.word	0x10624dd3

0801038c <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 801038c:	b580      	push	{r7, lr}
 801038e:	af00      	add	r7, sp, #0

  hrng.Instance = RNG;
 8010390:	4b03      	ldr	r3, [pc, #12]	; (80103a0 <MX_RNG_Init+0x14>)
 8010392:	4a04      	ldr	r2, [pc, #16]	; (80103a4 <MX_RNG_Init+0x18>)
 8010394:	601a      	str	r2, [r3, #0]
  HAL_RNG_Init(&hrng);
 8010396:	4802      	ldr	r0, [pc, #8]	; (80103a0 <MX_RNG_Init+0x14>)
 8010398:	f004 f9ee 	bl	8014778 <HAL_RNG_Init>

}
 801039c:	bf00      	nop
 801039e:	bd80      	pop	{r7, pc}
 80103a0:	2000cfc4 	.word	0x2000cfc4
 80103a4:	50060800 	.word	0x50060800

080103a8 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 80103a8:	b480      	push	{r7}
 80103aa:	b085      	sub	sp, #20
 80103ac:	af00      	add	r7, sp, #0
 80103ae:	6078      	str	r0, [r7, #4]

  if(hrng->Instance==RNG)
 80103b0:	687b      	ldr	r3, [r7, #4]
 80103b2:	681b      	ldr	r3, [r3, #0]
 80103b4:	4a0b      	ldr	r2, [pc, #44]	; (80103e4 <HAL_RNG_MspInit+0x3c>)
 80103b6:	4293      	cmp	r3, r2
 80103b8:	d10d      	bne.n	80103d6 <HAL_RNG_MspInit+0x2e>
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __RNG_CLK_ENABLE();
 80103ba:	2300      	movs	r3, #0
 80103bc:	60fb      	str	r3, [r7, #12]
 80103be:	4b0a      	ldr	r3, [pc, #40]	; (80103e8 <HAL_RNG_MspInit+0x40>)
 80103c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80103c2:	4a09      	ldr	r2, [pc, #36]	; (80103e8 <HAL_RNG_MspInit+0x40>)
 80103c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80103c8:	6353      	str	r3, [r2, #52]	; 0x34
 80103ca:	4b07      	ldr	r3, [pc, #28]	; (80103e8 <HAL_RNG_MspInit+0x40>)
 80103cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80103ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80103d2:	60fb      	str	r3, [r7, #12]
 80103d4:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 80103d6:	bf00      	nop
 80103d8:	3714      	adds	r7, #20
 80103da:	46bd      	mov	sp, r7
 80103dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80103e0:	4770      	bx	lr
 80103e2:	bf00      	nop
 80103e4:	50060800 	.word	0x50060800
 80103e8:	40023800 	.word	0x40023800

080103ec <MX_SDIO_SD_Init>:
DMA_HandleTypeDef hdma_sdio_tx;

/* SDIO init function */

void MX_SDIO_SD_Init(void)
{
 80103ec:	b580      	push	{r7, lr}
 80103ee:	af00      	add	r7, sp, #0

  hsd.Instance = SDIO;
 80103f0:	4b0f      	ldr	r3, [pc, #60]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 80103f2:	4a10      	ldr	r2, [pc, #64]	; (8010434 <MX_SDIO_SD_Init+0x48>)
 80103f4:	601a      	str	r2, [r3, #0]
  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
 80103f6:	4b0e      	ldr	r3, [pc, #56]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 80103f8:	2200      	movs	r2, #0
 80103fa:	605a      	str	r2, [r3, #4]
  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
 80103fc:	4b0c      	ldr	r3, [pc, #48]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 80103fe:	2200      	movs	r2, #0
 8010400:	609a      	str	r2, [r3, #8]
  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8010402:	4b0b      	ldr	r3, [pc, #44]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 8010404:	2200      	movs	r2, #0
 8010406:	60da      	str	r2, [r3, #12]
  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
 8010408:	4b09      	ldr	r3, [pc, #36]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 801040a:	2200      	movs	r2, #0
 801040c:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 801040e:	4b08      	ldr	r3, [pc, #32]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 8010410:	2200      	movs	r2, #0
 8010412:	615a      	str	r2, [r3, #20]
  hsd.Init.ClockDiv = 0;
 8010414:	4b06      	ldr	r3, [pc, #24]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 8010416:	2200      	movs	r2, #0
 8010418:	619a      	str	r2, [r3, #24]
  HAL_SD_Init(&hsd, &SDCardInfo);
 801041a:	4907      	ldr	r1, [pc, #28]	; (8010438 <MX_SDIO_SD_Init+0x4c>)
 801041c:	4804      	ldr	r0, [pc, #16]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 801041e:	f004 fa29 	bl	8014874 <HAL_SD_Init>

  HAL_SD_WideBusOperation_Config(&hsd, SDIO_BUS_WIDE_4B);
 8010422:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8010426:	4802      	ldr	r0, [pc, #8]	; (8010430 <MX_SDIO_SD_Init+0x44>)
 8010428:	f005 f8b8 	bl	801559c <HAL_SD_WideBusOperation_Config>

}
 801042c:	bf00      	nop
 801042e:	bd80      	pop	{r7, pc}
 8010430:	2000d0d8 	.word	0x2000d0d8
 8010434:	40012c00 	.word	0x40012c00
 8010438:	2000d028 	.word	0x2000d028

0801043c <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 801043c:	b580      	push	{r7, lr}
 801043e:	b088      	sub	sp, #32
 8010440:	af00      	add	r7, sp, #0
 8010442:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsd->Instance==SDIO)
 8010444:	687b      	ldr	r3, [r7, #4]
 8010446:	681b      	ldr	r3, [r3, #0]
 8010448:	4a56      	ldr	r2, [pc, #344]	; (80105a4 <HAL_SD_MspInit+0x168>)
 801044a:	4293      	cmp	r3, r2
 801044c:	f040 80a5 	bne.w	801059a <HAL_SD_MspInit+0x15e>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */

  /* USER CODE END SDIO_MspInit 0 */
    /* Peripheral clock enable */
    __SDIO_CLK_ENABLE();
 8010450:	2300      	movs	r3, #0
 8010452:	60bb      	str	r3, [r7, #8]
 8010454:	4b54      	ldr	r3, [pc, #336]	; (80105a8 <HAL_SD_MspInit+0x16c>)
 8010456:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010458:	4a53      	ldr	r2, [pc, #332]	; (80105a8 <HAL_SD_MspInit+0x16c>)
 801045a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801045e:	6453      	str	r3, [r2, #68]	; 0x44
 8010460:	4b51      	ldr	r3, [pc, #324]	; (80105a8 <HAL_SD_MspInit+0x16c>)
 8010462:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010464:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8010468:	60bb      	str	r3, [r7, #8]
 801046a:	68bb      	ldr	r3, [r7, #8]
    PC10     ------> SDIO_D2
    PD2     ------> SDIO_CMD
    PC9     ------> SDIO_D1
    PC8     ------> SDIO_D0 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11|GPIO_PIN_10|GPIO_PIN_9 
 801046c:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
 8010470:	60fb      	str	r3, [r7, #12]
                          |GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010472:	2302      	movs	r3, #2
 8010474:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010476:	2300      	movs	r3, #0
 8010478:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 801047a:	2303      	movs	r3, #3
 801047c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 801047e:	230c      	movs	r3, #12
 8010480:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010482:	f107 030c 	add.w	r3, r7, #12
 8010486:	4619      	mov	r1, r3
 8010488:	4848      	ldr	r0, [pc, #288]	; (80105ac <HAL_SD_MspInit+0x170>)
 801048a:	f002 f9eb 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 801048e:	2304      	movs	r3, #4
 8010490:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010492:	2302      	movs	r3, #2
 8010494:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010496:	2300      	movs	r3, #0
 8010498:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 801049a:	2303      	movs	r3, #3
 801049c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 801049e:	230c      	movs	r3, #12
 80104a0:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80104a2:	f107 030c 	add.w	r3, r7, #12
 80104a6:	4619      	mov	r1, r3
 80104a8:	4841      	ldr	r0, [pc, #260]	; (80105b0 <HAL_SD_MspInit+0x174>)
 80104aa:	f002 f9db 	bl	8012864 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_sdio_rx.Instance = DMA2_Stream3;
 80104ae:	4b41      	ldr	r3, [pc, #260]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104b0:	4a41      	ldr	r2, [pc, #260]	; (80105b8 <HAL_SD_MspInit+0x17c>)
 80104b2:	601a      	str	r2, [r3, #0]
    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
 80104b4:	4b3f      	ldr	r3, [pc, #252]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104b6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80104ba:	605a      	str	r2, [r3, #4]
    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80104bc:	4b3d      	ldr	r3, [pc, #244]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104be:	2200      	movs	r2, #0
 80104c0:	609a      	str	r2, [r3, #8]
    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 80104c2:	4b3c      	ldr	r3, [pc, #240]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104c4:	2200      	movs	r2, #0
 80104c6:	60da      	str	r2, [r3, #12]
    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
 80104c8:	4b3a      	ldr	r3, [pc, #232]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104ca:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80104ce:	611a      	str	r2, [r3, #16]
    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80104d0:	4b38      	ldr	r3, [pc, #224]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104d2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80104d6:	615a      	str	r2, [r3, #20]
    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80104d8:	4b36      	ldr	r3, [pc, #216]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104da:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80104de:	619a      	str	r2, [r3, #24]
    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
 80104e0:	4b34      	ldr	r3, [pc, #208]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104e2:	2220      	movs	r2, #32
 80104e4:	61da      	str	r2, [r3, #28]
    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80104e6:	4b33      	ldr	r3, [pc, #204]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104e8:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 80104ec:	621a      	str	r2, [r3, #32]
    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80104ee:	4b31      	ldr	r3, [pc, #196]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104f0:	2204      	movs	r2, #4
 80104f2:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 80104f4:	4b2f      	ldr	r3, [pc, #188]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104f6:	2203      	movs	r2, #3
 80104f8:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
 80104fa:	4b2e      	ldr	r3, [pc, #184]	; (80105b4 <HAL_SD_MspInit+0x178>)
 80104fc:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8010500:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 8010502:	4b2c      	ldr	r3, [pc, #176]	; (80105b4 <HAL_SD_MspInit+0x178>)
 8010504:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8010508:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_DMA_Init(&hdma_sdio_rx);
 801050a:	482a      	ldr	r0, [pc, #168]	; (80105b4 <HAL_SD_MspInit+0x178>)
 801050c:	f001 fbf0 	bl	8011cf0 <HAL_DMA_Init>

    __HAL_LINKDMA(hsd,hdmarx,hdma_sdio_rx);
 8010510:	687b      	ldr	r3, [r7, #4]
 8010512:	4a28      	ldr	r2, [pc, #160]	; (80105b4 <HAL_SD_MspInit+0x178>)
 8010514:	659a      	str	r2, [r3, #88]	; 0x58
 8010516:	4a27      	ldr	r2, [pc, #156]	; (80105b4 <HAL_SD_MspInit+0x178>)
 8010518:	687b      	ldr	r3, [r7, #4]
 801051a:	6393      	str	r3, [r2, #56]	; 0x38

    hdma_sdio_tx.Instance = DMA2_Stream6;
 801051c:	4b27      	ldr	r3, [pc, #156]	; (80105bc <HAL_SD_MspInit+0x180>)
 801051e:	4a28      	ldr	r2, [pc, #160]	; (80105c0 <HAL_SD_MspInit+0x184>)
 8010520:	601a      	str	r2, [r3, #0]
    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
 8010522:	4b26      	ldr	r3, [pc, #152]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010524:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8010528:	605a      	str	r2, [r3, #4]
    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801052a:	4b24      	ldr	r3, [pc, #144]	; (80105bc <HAL_SD_MspInit+0x180>)
 801052c:	2240      	movs	r2, #64	; 0x40
 801052e:	609a      	str	r2, [r3, #8]
    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8010530:	4b22      	ldr	r3, [pc, #136]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010532:	2200      	movs	r2, #0
 8010534:	60da      	str	r2, [r3, #12]
    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
 8010536:	4b21      	ldr	r3, [pc, #132]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010538:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801053c:	611a      	str	r2, [r3, #16]
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 801053e:	4b1f      	ldr	r3, [pc, #124]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010540:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8010544:	615a      	str	r2, [r3, #20]
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8010546:	4b1d      	ldr	r3, [pc, #116]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010548:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 801054c:	619a      	str	r2, [r3, #24]
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
 801054e:	4b1b      	ldr	r3, [pc, #108]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010550:	2220      	movs	r2, #32
 8010552:	61da      	str	r2, [r3, #28]
    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8010554:	4b19      	ldr	r3, [pc, #100]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010556:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 801055a:	621a      	str	r2, [r3, #32]
    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 801055c:	4b17      	ldr	r3, [pc, #92]	; (80105bc <HAL_SD_MspInit+0x180>)
 801055e:	2204      	movs	r2, #4
 8010560:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8010562:	4b16      	ldr	r3, [pc, #88]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010564:	2203      	movs	r2, #3
 8010566:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
 8010568:	4b14      	ldr	r3, [pc, #80]	; (80105bc <HAL_SD_MspInit+0x180>)
 801056a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 801056e:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 8010570:	4b12      	ldr	r3, [pc, #72]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010572:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8010576:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_DMA_Init(&hdma_sdio_tx);
 8010578:	4810      	ldr	r0, [pc, #64]	; (80105bc <HAL_SD_MspInit+0x180>)
 801057a:	f001 fbb9 	bl	8011cf0 <HAL_DMA_Init>

    __HAL_LINKDMA(hsd,hdmatx,hdma_sdio_tx);
 801057e:	687b      	ldr	r3, [r7, #4]
 8010580:	4a0e      	ldr	r2, [pc, #56]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010582:	65da      	str	r2, [r3, #92]	; 0x5c
 8010584:	4a0d      	ldr	r2, [pc, #52]	; (80105bc <HAL_SD_MspInit+0x180>)
 8010586:	687b      	ldr	r3, [r7, #4]
 8010588:	6393      	str	r3, [r2, #56]	; 0x38

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
 801058a:	2200      	movs	r2, #0
 801058c:	2105      	movs	r1, #5
 801058e:	2031      	movs	r0, #49	; 0x31
 8010590:	f001 fb2f 	bl	8011bf2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDIO_IRQn);
 8010594:	2031      	movs	r0, #49	; 0x31
 8010596:	f001 fb48 	bl	8011c2a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDIO_MspInit 1 */

  /* USER CODE END SDIO_MspInit 1 */
  }
}
 801059a:	bf00      	nop
 801059c:	3720      	adds	r7, #32
 801059e:	46bd      	mov	sp, r7
 80105a0:	bd80      	pop	{r7, pc}
 80105a2:	bf00      	nop
 80105a4:	40012c00 	.word	0x40012c00
 80105a8:	40023800 	.word	0x40023800
 80105ac:	40020800 	.word	0x40020800
 80105b0:	40020c00 	.word	0x40020c00
 80105b4:	2000cfd0 	.word	0x2000cfd0
 80105b8:	40026458 	.word	0x40026458
 80105bc:	2000d080 	.word	0x2000d080
 80105c0:	400264a0 	.word	0x400264a0

080105c4 <se3_rand32>:
#include "se3_rand.h"
#include "rng.h"
#include "stm32f4xx_hal_rng.h"


bool se3_rand32(uint32_t *val){
 80105c4:	b580      	push	{r7, lr}
 80105c6:	b084      	sub	sp, #16
 80105c8:	af00      	add	r7, sp, #0
 80105ca:	6078      	str	r0, [r7, #4]
	size_t i;
	HAL_StatusTypeDef ret;
	for(i=0; i<20; i++){
 80105cc:	2300      	movs	r3, #0
 80105ce:	60fb      	str	r3, [r7, #12]
 80105d0:	e012      	b.n	80105f8 <se3_rand32+0x34>
		ret=HAL_RNG_GenerateRandomNumber(&hrng, val);
 80105d2:	6879      	ldr	r1, [r7, #4]
 80105d4:	480c      	ldr	r0, [pc, #48]	; (8010608 <se3_rand32+0x44>)
 80105d6:	f004 f902 	bl	80147de <HAL_RNG_GenerateRandomNumber>
 80105da:	4603      	mov	r3, r0
 80105dc:	72fb      	strb	r3, [r7, #11]
		if(ret==HAL_OK){
 80105de:	7afb      	ldrb	r3, [r7, #11]
 80105e0:	2b00      	cmp	r3, #0
 80105e2:	d101      	bne.n	80105e8 <se3_rand32+0x24>
			return true;
 80105e4:	2301      	movs	r3, #1
 80105e6:	e00b      	b.n	8010600 <se3_rand32+0x3c>
		}
		else if(ret==HAL_ERROR){
 80105e8:	7afb      	ldrb	r3, [r7, #11]
 80105ea:	2b01      	cmp	r3, #1
 80105ec:	d101      	bne.n	80105f2 <se3_rand32+0x2e>
			return false;
 80105ee:	2300      	movs	r3, #0
 80105f0:	e006      	b.n	8010600 <se3_rand32+0x3c>
	for(i=0; i<20; i++){
 80105f2:	68fb      	ldr	r3, [r7, #12]
 80105f4:	3301      	adds	r3, #1
 80105f6:	60fb      	str	r3, [r7, #12]
 80105f8:	68fb      	ldr	r3, [r7, #12]
 80105fa:	2b13      	cmp	r3, #19
 80105fc:	d9e9      	bls.n	80105d2 <se3_rand32+0xe>
		}
	}
	return false;
 80105fe:	2300      	movs	r3, #0
}
 8010600:	4618      	mov	r0, r3
 8010602:	3710      	adds	r7, #16
 8010604:	46bd      	mov	sp, r7
 8010606:	bd80      	pop	{r7, pc}
 8010608:	2000cfc4 	.word	0x2000cfc4

0801060c <se3_rand>:

uint16_t se3_rand(uint16_t size, uint8_t* data){
 801060c:	b580      	push	{r7, lr}
 801060e:	b086      	sub	sp, #24
 8010610:	af00      	add	r7, sp, #0
 8010612:	4603      	mov	r3, r0
 8010614:	6039      	str	r1, [r7, #0]
 8010616:	80fb      	strh	r3, [r7, #6]
	uint32_t tmp;
	size_t i,n;

	n=size/4;
 8010618:	88fb      	ldrh	r3, [r7, #6]
 801061a:	089b      	lsrs	r3, r3, #2
 801061c:	b29b      	uxth	r3, r3
 801061e:	613b      	str	r3, [r7, #16]
	for(i=0;i<n;i++){
 8010620:	2300      	movs	r3, #0
 8010622:	617b      	str	r3, [r7, #20]
 8010624:	e010      	b.n	8010648 <se3_rand+0x3c>
		if(!se3_rand32((uint32_t*)data)){
 8010626:	6838      	ldr	r0, [r7, #0]
 8010628:	f7ff ffcc 	bl	80105c4 <se3_rand32>
 801062c:	4603      	mov	r3, r0
 801062e:	f083 0301 	eor.w	r3, r3, #1
 8010632:	b2db      	uxtb	r3, r3
 8010634:	2b00      	cmp	r3, #0
 8010636:	d001      	beq.n	801063c <se3_rand+0x30>
			return 0;
 8010638:	2300      	movs	r3, #0
 801063a:	e031      	b.n	80106a0 <se3_rand+0x94>
		}
		data+=4;
 801063c:	683b      	ldr	r3, [r7, #0]
 801063e:	3304      	adds	r3, #4
 8010640:	603b      	str	r3, [r7, #0]
	for(i=0;i<n;i++){
 8010642:	697b      	ldr	r3, [r7, #20]
 8010644:	3301      	adds	r3, #1
 8010646:	617b      	str	r3, [r7, #20]
 8010648:	697a      	ldr	r2, [r7, #20]
 801064a:	693b      	ldr	r3, [r7, #16]
 801064c:	429a      	cmp	r2, r3
 801064e:	d3ea      	bcc.n	8010626 <se3_rand+0x1a>
	}
	n=size%4;
 8010650:	88fb      	ldrh	r3, [r7, #6]
 8010652:	f003 0303 	and.w	r3, r3, #3
 8010656:	613b      	str	r3, [r7, #16]
	if(n!=0){
 8010658:	693b      	ldr	r3, [r7, #16]
 801065a:	2b00      	cmp	r3, #0
 801065c:	d01f      	beq.n	801069e <se3_rand+0x92>
		if(!se3_rand32(&tmp)){
 801065e:	f107 030c 	add.w	r3, r7, #12
 8010662:	4618      	mov	r0, r3
 8010664:	f7ff ffae 	bl	80105c4 <se3_rand32>
 8010668:	4603      	mov	r3, r0
 801066a:	f083 0301 	eor.w	r3, r3, #1
 801066e:	b2db      	uxtb	r3, r3
 8010670:	2b00      	cmp	r3, #0
 8010672:	d001      	beq.n	8010678 <se3_rand+0x6c>
			return 0;
 8010674:	2300      	movs	r3, #0
 8010676:	e013      	b.n	80106a0 <se3_rand+0x94>
		}
		for(i=0;i<n;i++){
 8010678:	2300      	movs	r3, #0
 801067a:	617b      	str	r3, [r7, #20]
 801067c:	e00b      	b.n	8010696 <se3_rand+0x8a>
			data[i]=((uint8_t*)&tmp)[i];
 801067e:	f107 020c 	add.w	r2, r7, #12
 8010682:	697b      	ldr	r3, [r7, #20]
 8010684:	441a      	add	r2, r3
 8010686:	6839      	ldr	r1, [r7, #0]
 8010688:	697b      	ldr	r3, [r7, #20]
 801068a:	440b      	add	r3, r1
 801068c:	7812      	ldrb	r2, [r2, #0]
 801068e:	701a      	strb	r2, [r3, #0]
		for(i=0;i<n;i++){
 8010690:	697b      	ldr	r3, [r7, #20]
 8010692:	3301      	adds	r3, #1
 8010694:	617b      	str	r3, [r7, #20]
 8010696:	697a      	ldr	r2, [r7, #20]
 8010698:	693b      	ldr	r3, [r7, #16]
 801069a:	429a      	cmp	r2, r3
 801069c:	d3ef      	bcc.n	801067e <se3_rand+0x72>
		}
	}
	return size;
 801069e:	88fb      	ldrh	r3, [r7, #6]
}
 80106a0:	4618      	mov	r0, r3
 80106a2:	3718      	adds	r7, #24
 80106a4:	46bd      	mov	sp, r7
 80106a6:	bd80      	pop	{r7, pc}

080106a8 <secube_sdio_write>:
#include "usbd_storage_if.h"
#include "sdio.h"


bool secube_sdio_write(uint8_t lun, const uint8_t* buf, uint32_t blk_addr, uint16_t blk_len)
{
 80106a8:	b590      	push	{r4, r7, lr}
 80106aa:	b087      	sub	sp, #28
 80106ac:	af02      	add	r7, sp, #8
 80106ae:	60b9      	str	r1, [r7, #8]
 80106b0:	607a      	str	r2, [r7, #4]
 80106b2:	461a      	mov	r2, r3
 80106b4:	4603      	mov	r3, r0
 80106b6:	73fb      	strb	r3, [r7, #15]
 80106b8:	4613      	mov	r3, r2
 80106ba:	81bb      	strh	r3, [r7, #12]
	if (HAL_SD_WriteBlocks_DMA(&hsd, (uint32_t *)buf, blk_addr * STORAGE_BLK_SIZ, STORAGE_BLK_SIZ, blk_len) == SD_OK)
 80106bc:	687b      	ldr	r3, [r7, #4]
 80106be:	025b      	lsls	r3, r3, #9
 80106c0:	f04f 0400 	mov.w	r4, #0
 80106c4:	89ba      	ldrh	r2, [r7, #12]
 80106c6:	9201      	str	r2, [sp, #4]
 80106c8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80106cc:	9200      	str	r2, [sp, #0]
 80106ce:	461a      	mov	r2, r3
 80106d0:	4623      	mov	r3, r4
 80106d2:	68b9      	ldr	r1, [r7, #8]
 80106d4:	4809      	ldr	r0, [pc, #36]	; (80106fc <secube_sdio_write+0x54>)
 80106d6:	f004 fa09 	bl	8014aec <HAL_SD_WriteBlocks_DMA>
 80106da:	4603      	mov	r3, r0
 80106dc:	2b00      	cmp	r3, #0
 80106de:	d108      	bne.n	80106f2 <secube_sdio_write+0x4a>
		if (HAL_SD_CheckWriteOperation(&hsd, (uint32_t)SD_DATATIMEOUT) == SD_OK)
 80106e0:	4907      	ldr	r1, [pc, #28]	; (8010700 <secube_sdio_write+0x58>)
 80106e2:	4806      	ldr	r0, [pc, #24]	; (80106fc <secube_sdio_write+0x54>)
 80106e4:	f004 fb2c 	bl	8014d40 <HAL_SD_CheckWriteOperation>
 80106e8:	4603      	mov	r3, r0
 80106ea:	2b00      	cmp	r3, #0
 80106ec:	d101      	bne.n	80106f2 <secube_sdio_write+0x4a>
			return true;
 80106ee:	2301      	movs	r3, #1
 80106f0:	e000      	b.n	80106f4 <secube_sdio_write+0x4c>

	return false;
 80106f2:	2300      	movs	r3, #0
}
 80106f4:	4618      	mov	r0, r3
 80106f6:	3714      	adds	r7, #20
 80106f8:	46bd      	mov	sp, r7
 80106fa:	bd90      	pop	{r4, r7, pc}
 80106fc:	2000d0d8 	.word	0x2000d0d8
 8010700:	05f5e100 	.word	0x05f5e100

08010704 <secube_sdio_read>:
bool secube_sdio_read(uint8_t lun, uint8_t* buf, uint32_t blk_addr, uint16_t blk_len)
{
 8010704:	b590      	push	{r4, r7, lr}
 8010706:	b087      	sub	sp, #28
 8010708:	af02      	add	r7, sp, #8
 801070a:	60b9      	str	r1, [r7, #8]
 801070c:	607a      	str	r2, [r7, #4]
 801070e:	461a      	mov	r2, r3
 8010710:	4603      	mov	r3, r0
 8010712:	73fb      	strb	r3, [r7, #15]
 8010714:	4613      	mov	r3, r2
 8010716:	81bb      	strh	r3, [r7, #12]
	if (HAL_SD_ReadBlocks_DMA(&hsd, (uint32_t *)buf, blk_addr * STORAGE_BLK_SIZ, STORAGE_BLK_SIZ, blk_len) == SD_OK)
 8010718:	687b      	ldr	r3, [r7, #4]
 801071a:	025b      	lsls	r3, r3, #9
 801071c:	f04f 0400 	mov.w	r4, #0
 8010720:	89ba      	ldrh	r2, [r7, #12]
 8010722:	9201      	str	r2, [sp, #4]
 8010724:	f44f 7200 	mov.w	r2, #512	; 0x200
 8010728:	9200      	str	r2, [sp, #0]
 801072a:	461a      	mov	r2, r3
 801072c:	4623      	mov	r3, r4
 801072e:	68b9      	ldr	r1, [r7, #8]
 8010730:	4809      	ldr	r0, [pc, #36]	; (8010758 <secube_sdio_read+0x54>)
 8010732:	f004 f915 	bl	8014960 <HAL_SD_ReadBlocks_DMA>
 8010736:	4603      	mov	r3, r0
 8010738:	2b00      	cmp	r3, #0
 801073a:	d108      	bne.n	801074e <secube_sdio_read+0x4a>
		if (HAL_SD_CheckReadOperation(&hsd, (uint32_t)SD_DATATIMEOUT) == SD_OK)
 801073c:	4907      	ldr	r1, [pc, #28]	; (801075c <secube_sdio_read+0x58>)
 801073e:	4806      	ldr	r0, [pc, #24]	; (8010758 <secube_sdio_read+0x54>)
 8010740:	f004 faa0 	bl	8014c84 <HAL_SD_CheckReadOperation>
 8010744:	4603      	mov	r3, r0
 8010746:	2b00      	cmp	r3, #0
 8010748:	d101      	bne.n	801074e <secube_sdio_read+0x4a>
			return true;
 801074a:	2301      	movs	r3, #1
 801074c:	e000      	b.n	8010750 <secube_sdio_read+0x4c>

	return false;
 801074e:	2300      	movs	r3, #0
}
 8010750:	4618      	mov	r0, r3
 8010752:	3714      	adds	r7, #20
 8010754:	46bd      	mov	sp, r7
 8010756:	bd90      	pop	{r4, r7, pc}
 8010758:	2000d0d8 	.word	0x2000d0d8
 801075c:	05f5e100 	.word	0x05f5e100

08010760 <secube_sdio_capacity>:

bool secube_sdio_capacity(uint32_t *block_num, uint16_t *block_size)
{
 8010760:	b590      	push	{r4, r7, lr}
 8010762:	b083      	sub	sp, #12
 8010764:	af00      	add	r7, sp, #0
 8010766:	6078      	str	r0, [r7, #4]
 8010768:	6039      	str	r1, [r7, #0]

	if (HAL_SD_Get_CardInfo(&hsd,&SDCardInfo) == SD_OK){
 801076a:	4910      	ldr	r1, [pc, #64]	; (80107ac <secube_sdio_capacity+0x4c>)
 801076c:	4810      	ldr	r0, [pc, #64]	; (80107b0 <secube_sdio_capacity+0x50>)
 801076e:	f004 fc0a 	bl	8014f86 <HAL_SD_Get_CardInfo>
 8010772:	4603      	mov	r3, r0
 8010774:	2b00      	cmp	r3, #0
 8010776:	d113      	bne.n	80107a0 <secube_sdio_capacity+0x40>
			*block_num = (SDCardInfo.CardCapacity)/STORAGE_BLK_SIZ  - 1;
 8010778:	4b0c      	ldr	r3, [pc, #48]	; (80107ac <secube_sdio_capacity+0x4c>)
 801077a:	e9d3 1212 	ldrd	r1, r2, [r3, #72]	; 0x48
 801077e:	f04f 0300 	mov.w	r3, #0
 8010782:	f04f 0400 	mov.w	r4, #0
 8010786:	0a4b      	lsrs	r3, r1, #9
 8010788:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 801078c:	0a54      	lsrs	r4, r2, #9
 801078e:	1e5a      	subs	r2, r3, #1
 8010790:	687b      	ldr	r3, [r7, #4]
 8010792:	601a      	str	r2, [r3, #0]
			*block_size = STORAGE_BLK_SIZ;
 8010794:	683b      	ldr	r3, [r7, #0]
 8010796:	f44f 7200 	mov.w	r2, #512	; 0x200
 801079a:	801a      	strh	r2, [r3, #0]
			return true;
 801079c:	2301      	movs	r3, #1
 801079e:	e000      	b.n	80107a2 <secube_sdio_capacity+0x42>
		}

	return false;
 80107a0:	2300      	movs	r3, #0
}
 80107a2:	4618      	mov	r0, r3
 80107a4:	370c      	adds	r7, #12
 80107a6:	46bd      	mov	sp, r7
 80107a8:	bd90      	pop	{r4, r7, pc}
 80107aa:	bf00      	nop
 80107ac:	2000d028 	.word	0x2000d028
 80107b0:	2000d0d8 	.word	0x2000d0d8

080107b4 <secube_sdio_isready>:

bool secube_sdio_isready(void)
{
 80107b4:	b580      	push	{r7, lr}
 80107b6:	af00      	add	r7, sp, #0

	if (HAL_SD_GetStatus(&hsd) != SD_TRANSFER_OK)
 80107b8:	4805      	ldr	r0, [pc, #20]	; (80107d0 <secube_sdio_isready+0x1c>)
 80107ba:	f004 ff7b 	bl	80156b4 <HAL_SD_GetStatus>
 80107be:	4603      	mov	r3, r0
 80107c0:	2b00      	cmp	r3, #0
 80107c2:	d001      	beq.n	80107c8 <secube_sdio_isready+0x14>
		return false;
 80107c4:	2300      	movs	r3, #0
 80107c6:	e000      	b.n	80107ca <secube_sdio_isready+0x16>

	return true;
 80107c8:	2301      	movs	r3, #1
}
 80107ca:	4618      	mov	r0, r3
 80107cc:	bd80      	pop	{r7, pc}
 80107ce:	bf00      	nop
 80107d0:	2000d0d8 	.word	0x2000d0d8

080107d4 <MX_SPI5_Init>:

SPI_HandleTypeDef hspi5;

/* SPI5 init function */
void MX_SPI5_Init(void)
{
 80107d4:	b580      	push	{r7, lr}
 80107d6:	af00      	add	r7, sp, #0

  hspi5.Instance = SPI5;
 80107d8:	4b14      	ldr	r3, [pc, #80]	; (801082c <MX_SPI5_Init+0x58>)
 80107da:	4a15      	ldr	r2, [pc, #84]	; (8010830 <MX_SPI5_Init+0x5c>)
 80107dc:	601a      	str	r2, [r3, #0]
  hspi5.Init.Mode = SPI_MODE_MASTER;
 80107de:	4b13      	ldr	r3, [pc, #76]	; (801082c <MX_SPI5_Init+0x58>)
 80107e0:	f44f 7282 	mov.w	r2, #260	; 0x104
 80107e4:	605a      	str	r2, [r3, #4]
  hspi5.Init.Direction = SPI_DIRECTION_2LINES;
 80107e6:	4b11      	ldr	r3, [pc, #68]	; (801082c <MX_SPI5_Init+0x58>)
 80107e8:	2200      	movs	r2, #0
 80107ea:	609a      	str	r2, [r3, #8]
  hspi5.Init.DataSize = SPI_DATASIZE_8BIT;
 80107ec:	4b0f      	ldr	r3, [pc, #60]	; (801082c <MX_SPI5_Init+0x58>)
 80107ee:	2200      	movs	r2, #0
 80107f0:	60da      	str	r2, [r3, #12]
  hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
 80107f2:	4b0e      	ldr	r3, [pc, #56]	; (801082c <MX_SPI5_Init+0x58>)
 80107f4:	2200      	movs	r2, #0
 80107f6:	611a      	str	r2, [r3, #16]
  hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
 80107f8:	4b0c      	ldr	r3, [pc, #48]	; (801082c <MX_SPI5_Init+0x58>)
 80107fa:	2200      	movs	r2, #0
 80107fc:	615a      	str	r2, [r3, #20]
  hspi5.Init.NSS = SPI_NSS_HARD_INPUT;
 80107fe:	4b0b      	ldr	r3, [pc, #44]	; (801082c <MX_SPI5_Init+0x58>)
 8010800:	2200      	movs	r2, #0
 8010802:	619a      	str	r2, [r3, #24]
  hspi5.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8010804:	4b09      	ldr	r3, [pc, #36]	; (801082c <MX_SPI5_Init+0x58>)
 8010806:	2200      	movs	r2, #0
 8010808:	61da      	str	r2, [r3, #28]
  hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
 801080a:	4b08      	ldr	r3, [pc, #32]	; (801082c <MX_SPI5_Init+0x58>)
 801080c:	2200      	movs	r2, #0
 801080e:	621a      	str	r2, [r3, #32]
  hspi5.Init.TIMode = SPI_TIMODE_DISABLED;
 8010810:	4b06      	ldr	r3, [pc, #24]	; (801082c <MX_SPI5_Init+0x58>)
 8010812:	2200      	movs	r2, #0
 8010814:	625a      	str	r2, [r3, #36]	; 0x24
  hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 8010816:	4b05      	ldr	r3, [pc, #20]	; (801082c <MX_SPI5_Init+0x58>)
 8010818:	2200      	movs	r2, #0
 801081a:	629a      	str	r2, [r3, #40]	; 0x28
  hspi5.Init.CRCPolynomial = 10;
 801081c:	4b03      	ldr	r3, [pc, #12]	; (801082c <MX_SPI5_Init+0x58>)
 801081e:	220a      	movs	r2, #10
 8010820:	62da      	str	r2, [r3, #44]	; 0x2c
  HAL_SPI_Init(&hspi5);
 8010822:	4802      	ldr	r0, [pc, #8]	; (801082c <MX_SPI5_Init+0x58>)
 8010824:	f005 ffd6 	bl	80167d4 <HAL_SPI_Init>

}
 8010828:	bf00      	nop
 801082a:	bd80      	pop	{r7, pc}
 801082c:	2000d138 	.word	0x2000d138
 8010830:	40015000 	.word	0x40015000

08010834 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8010834:	b580      	push	{r7, lr}
 8010836:	b088      	sub	sp, #32
 8010838:	af00      	add	r7, sp, #0
 801083a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI5)
 801083c:	687b      	ldr	r3, [r7, #4]
 801083e:	681b      	ldr	r3, [r3, #0]
 8010840:	4a18      	ldr	r2, [pc, #96]	; (80108a4 <HAL_SPI_MspInit+0x70>)
 8010842:	4293      	cmp	r3, r2
 8010844:	d12a      	bne.n	801089c <HAL_SPI_MspInit+0x68>
  {
  /* USER CODE BEGIN SPI5_MspInit 0 */

  /* USER CODE END SPI5_MspInit 0 */
    /* Peripheral clock enable */
    __SPI5_CLK_ENABLE();
 8010846:	2300      	movs	r3, #0
 8010848:	60bb      	str	r3, [r7, #8]
 801084a:	4b17      	ldr	r3, [pc, #92]	; (80108a8 <HAL_SPI_MspInit+0x74>)
 801084c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801084e:	4a16      	ldr	r2, [pc, #88]	; (80108a8 <HAL_SPI_MspInit+0x74>)
 8010850:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8010854:	6453      	str	r3, [r2, #68]	; 0x44
 8010856:	4b14      	ldr	r3, [pc, #80]	; (80108a8 <HAL_SPI_MspInit+0x74>)
 8010858:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801085a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 801085e:	60bb      	str	r3, [r7, #8]
 8010860:	68bb      	ldr	r3, [r7, #8]
    PF7     ------> SPI5_SCK
    PF6     ------> SPI5_NSS
    PF9     ------> SPI5_MOSI
    PF8     ------> SPI5_MISO 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_9|GPIO_PIN_8;
 8010862:	f44f 7360 	mov.w	r3, #896	; 0x380
 8010866:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010868:	2302      	movs	r3, #2
 801086a:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801086c:	2300      	movs	r3, #0
 801086e:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010870:	2303      	movs	r3, #3
 8010872:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
 8010874:	2305      	movs	r3, #5
 8010876:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8010878:	f107 030c 	add.w	r3, r7, #12
 801087c:	4619      	mov	r1, r3
 801087e:	480b      	ldr	r0, [pc, #44]	; (80108ac <HAL_SPI_MspInit+0x78>)
 8010880:	f001 fff0 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8010884:	2340      	movs	r3, #64	; 0x40
 8010886:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8010888:	2300      	movs	r3, #0
 801088a:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801088c:	2300      	movs	r3, #0
 801088e:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8010890:	f107 030c 	add.w	r3, r7, #12
 8010894:	4619      	mov	r1, r3
 8010896:	4805      	ldr	r0, [pc, #20]	; (80108ac <HAL_SPI_MspInit+0x78>)
 8010898:	f001 ffe4 	bl	8012864 <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI5_MspInit 1 */

  /* USER CODE END SPI5_MspInit 1 */
  }
}
 801089c:	bf00      	nop
 801089e:	3720      	adds	r7, #32
 80108a0:	46bd      	mov	sp, r7
 80108a2:	bd80      	pop	{r7, pc}
 80108a4:	40015000 	.word	0x40015000
 80108a8:	40023800 	.word	0x40023800
 80108ac:	40021400 	.word	0x40021400

080108b0 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80108b0:	b580      	push	{r7, lr}
 80108b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80108b4:	2003      	movs	r0, #3
 80108b6:	f001 f991 	bl	8011bdc <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80108ba:	2200      	movs	r2, #0
 80108bc:	2100      	movs	r1, #0
 80108be:	f04f 30ff 	mov.w	r0, #4294967295
 80108c2:	f001 f996 	bl	8011bf2 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80108c6:	bf00      	nop
 80108c8:	bd80      	pop	{r7, pc}

080108ca <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80108ca:	b580      	push	{r7, lr}
 80108cc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80108ce:	f000 fe1d 	bl	801150c <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
 80108d2:	f001 f9e1 	bl	8011c98 <HAL_SYSTICK_IRQHandler>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  se3_time_inc();
 80108d6:	f7fc fd25 	bl	800d324 <se3_time_inc>
  /* USER CODE END SysTick_IRQn 1 */
}
 80108da:	bf00      	nop
 80108dc:	bd80      	pop	{r7, pc}
	...

080108e0 <SDIO_IRQHandler>:

/**
* @brief This function handles SDIO global interrupt.
*/
void SDIO_IRQHandler(void)
{
 80108e0:	b580      	push	{r7, lr}
 80108e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDIO_IRQn 0 */

  /* USER CODE END SDIO_IRQn 0 */
  HAL_SD_IRQHandler(&hsd);
 80108e4:	4802      	ldr	r0, [pc, #8]	; (80108f0 <SDIO_IRQHandler+0x10>)
 80108e6:	f004 fa90 	bl	8014e0a <HAL_SD_IRQHandler>
  /* USER CODE BEGIN SDIO_IRQn 1 */

  /* USER CODE END SDIO_IRQn 1 */
}
 80108ea:	bf00      	nop
 80108ec:	bd80      	pop	{r7, pc}
 80108ee:	bf00      	nop
 80108f0:	2000d0d8 	.word	0x2000d0d8

080108f4 <DMA2_Stream3_IRQHandler>:

/**
* @brief This function handles DMA2 stream3 global interrupt.
*/
void DMA2_Stream3_IRQHandler(void)
{
 80108f4:	b580      	push	{r7, lr}
 80108f6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_rx);
 80108f8:	4802      	ldr	r0, [pc, #8]	; (8010904 <DMA2_Stream3_IRQHandler+0x10>)
 80108fa:	f001 fae5 	bl	8011ec8 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream3_IRQn 1 */

  /* USER CODE END DMA2_Stream3_IRQn 1 */
}
 80108fe:	bf00      	nop
 8010900:	bd80      	pop	{r7, pc}
 8010902:	bf00      	nop
 8010904:	2000cfd0 	.word	0x2000cfd0

08010908 <DMA2_Stream6_IRQHandler>:

/**
* @brief This function handles DMA2 stream6 global interrupt.
*/
void DMA2_Stream6_IRQHandler(void)
{
 8010908:	b580      	push	{r7, lr}
 801090a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_tx);
 801090c:	4802      	ldr	r0, [pc, #8]	; (8010918 <DMA2_Stream6_IRQHandler+0x10>)
 801090e:	f001 fadb 	bl	8011ec8 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream6_IRQn 1 */

  /* USER CODE END DMA2_Stream6_IRQn 1 */
}
 8010912:	bf00      	nop
 8010914:	bd80      	pop	{r7, pc}
 8010916:	bf00      	nop
 8010918:	2000d080 	.word	0x2000d080

0801091c <OTG_HS_IRQHandler>:

/**
* @brief This function handles USB On The Go HS global interrupt.
*/
void OTG_HS_IRQHandler(void)
{
 801091c:	b580      	push	{r7, lr}
 801091e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

	/* USER CODE END OTG_HS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
 8010920:	4802      	ldr	r0, [pc, #8]	; (801092c <OTG_HS_IRQHandler+0x10>)
 8010922:	f002 fbb4 	bl	801308e <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_IRQn 1 */

  /* USER CODE END OTG_HS_IRQn 1 */
}
 8010926:	bf00      	nop
 8010928:	bd80      	pop	{r7, pc}
 801092a:	bf00      	nop
 801092c:	2000d480 	.word	0x2000d480

08010930 <MX_TIM4_Init>:

TIM_HandleTypeDef htim4;

/* TIM4 init function */
void MX_TIM4_Init(void)
{
 8010930:	b580      	push	{r7, lr}
 8010932:	b08a      	sub	sp, #40	; 0x28
 8010934:	af00      	add	r7, sp, #0
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim4.Instance = TIM4;
 8010936:	4b18      	ldr	r3, [pc, #96]	; (8010998 <MX_TIM4_Init+0x68>)
 8010938:	4a18      	ldr	r2, [pc, #96]	; (801099c <MX_TIM4_Init+0x6c>)
 801093a:	601a      	str	r2, [r3, #0]
  htim4.Init.Prescaler = 0;
 801093c:	4b16      	ldr	r3, [pc, #88]	; (8010998 <MX_TIM4_Init+0x68>)
 801093e:	2200      	movs	r2, #0
 8010940:	605a      	str	r2, [r3, #4]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8010942:	4b15      	ldr	r3, [pc, #84]	; (8010998 <MX_TIM4_Init+0x68>)
 8010944:	2200      	movs	r2, #0
 8010946:	609a      	str	r2, [r3, #8]
  htim4.Init.Period = 0;
 8010948:	4b13      	ldr	r3, [pc, #76]	; (8010998 <MX_TIM4_Init+0x68>)
 801094a:	2200      	movs	r2, #0
 801094c:	60da      	str	r2, [r3, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801094e:	4b12      	ldr	r3, [pc, #72]	; (8010998 <MX_TIM4_Init+0x68>)
 8010950:	2200      	movs	r2, #0
 8010952:	611a      	str	r2, [r3, #16]
  HAL_TIM_PWM_Init(&htim4);
 8010954:	4810      	ldr	r0, [pc, #64]	; (8010998 <MX_TIM4_Init+0x68>)
 8010956:	f005 ffa8 	bl	80168aa <HAL_TIM_PWM_Init>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801095a:	2300      	movs	r3, #0
 801095c:	623b      	str	r3, [r7, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801095e:	2300      	movs	r3, #0
 8010960:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);
 8010962:	f107 0320 	add.w	r3, r7, #32
 8010966:	4619      	mov	r1, r3
 8010968:	480b      	ldr	r0, [pc, #44]	; (8010998 <MX_TIM4_Init+0x68>)
 801096a:	f006 fafd 	bl	8016f68 <HAL_TIMEx_MasterConfigSynchronization>

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801096e:	2360      	movs	r3, #96	; 0x60
 8010970:	607b      	str	r3, [r7, #4]
  sConfigOC.Pulse = 0;
 8010972:	2300      	movs	r3, #0
 8010974:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8010976:	2300      	movs	r3, #0
 8010978:	60fb      	str	r3, [r7, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801097a:	2300      	movs	r3, #0
 801097c:	617b      	str	r3, [r7, #20]
  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1);
 801097e:	1d3b      	adds	r3, r7, #4
 8010980:	2200      	movs	r2, #0
 8010982:	4619      	mov	r1, r3
 8010984:	4804      	ldr	r0, [pc, #16]	; (8010998 <MX_TIM4_Init+0x68>)
 8010986:	f005 ffbb 	bl	8016900 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_MspPostInit(&htim4);
 801098a:	4803      	ldr	r0, [pc, #12]	; (8010998 <MX_TIM4_Init+0x68>)
 801098c:	f000 f82a 	bl	80109e4 <HAL_TIM_MspPostInit>

}
 8010990:	bf00      	nop
 8010992:	3728      	adds	r7, #40	; 0x28
 8010994:	46bd      	mov	sp, r7
 8010996:	bd80      	pop	{r7, pc}
 8010998:	2000d190 	.word	0x2000d190
 801099c:	40000800 	.word	0x40000800

080109a0 <HAL_TIM_PWM_MspInit>:

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 80109a0:	b480      	push	{r7}
 80109a2:	b085      	sub	sp, #20
 80109a4:	af00      	add	r7, sp, #0
 80109a6:	6078      	str	r0, [r7, #4]

  if(htim_pwm->Instance==TIM4)
 80109a8:	687b      	ldr	r3, [r7, #4]
 80109aa:	681b      	ldr	r3, [r3, #0]
 80109ac:	4a0b      	ldr	r2, [pc, #44]	; (80109dc <HAL_TIM_PWM_MspInit+0x3c>)
 80109ae:	4293      	cmp	r3, r2
 80109b0:	d10d      	bne.n	80109ce <HAL_TIM_PWM_MspInit+0x2e>
  {
  /* USER CODE BEGIN TIM4_MspInit 0 */

  /* USER CODE END TIM4_MspInit 0 */
    /* Peripheral clock enable */
    __TIM4_CLK_ENABLE();
 80109b2:	2300      	movs	r3, #0
 80109b4:	60fb      	str	r3, [r7, #12]
 80109b6:	4b0a      	ldr	r3, [pc, #40]	; (80109e0 <HAL_TIM_PWM_MspInit+0x40>)
 80109b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80109ba:	4a09      	ldr	r2, [pc, #36]	; (80109e0 <HAL_TIM_PWM_MspInit+0x40>)
 80109bc:	f043 0304 	orr.w	r3, r3, #4
 80109c0:	6413      	str	r3, [r2, #64]	; 0x40
 80109c2:	4b07      	ldr	r3, [pc, #28]	; (80109e0 <HAL_TIM_PWM_MspInit+0x40>)
 80109c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80109c6:	f003 0304 	and.w	r3, r3, #4
 80109ca:	60fb      	str	r3, [r7, #12]
 80109cc:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }
}
 80109ce:	bf00      	nop
 80109d0:	3714      	adds	r7, #20
 80109d2:	46bd      	mov	sp, r7
 80109d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80109d8:	4770      	bx	lr
 80109da:	bf00      	nop
 80109dc:	40000800 	.word	0x40000800
 80109e0:	40023800 	.word	0x40023800

080109e4 <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 80109e4:	b580      	push	{r7, lr}
 80109e6:	b088      	sub	sp, #32
 80109e8:	af00      	add	r7, sp, #0
 80109ea:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM4)
 80109ec:	687b      	ldr	r3, [r7, #4]
 80109ee:	681b      	ldr	r3, [r3, #0]
 80109f0:	4a0b      	ldr	r2, [pc, #44]	; (8010a20 <HAL_TIM_MspPostInit+0x3c>)
 80109f2:	4293      	cmp	r3, r2
 80109f4:	d110      	bne.n	8010a18 <HAL_TIM_MspPostInit+0x34>
  /* USER CODE END TIM4_MspPostInit 0 */
  
    /**TIM4 GPIO Configuration    
    PD12     ------> TIM4_CH1 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80109f6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80109fa:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80109fc:	2302      	movs	r3, #2
 80109fe:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010a00:	2300      	movs	r3, #0
 8010a02:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8010a04:	2300      	movs	r3, #0
 8010a06:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8010a08:	2302      	movs	r3, #2
 8010a0a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8010a0c:	f107 030c 	add.w	r3, r7, #12
 8010a10:	4619      	mov	r1, r3
 8010a12:	4804      	ldr	r0, [pc, #16]	; (8010a24 <HAL_TIM_MspPostInit+0x40>)
 8010a14:	f001 ff26 	bl	8012864 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }

}
 8010a18:	bf00      	nop
 8010a1a:	3720      	adds	r7, #32
 8010a1c:	46bd      	mov	sp, r7
 8010a1e:	bd80      	pop	{r7, pc}
 8010a20:	40000800 	.word	0x40000800
 8010a24:	40020c00 	.word	0x40020c00

08010a28 <MX_USART1_UART_Init>:
SMARTCARD_HandleTypeDef hsc6;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8010a28:	b580      	push	{r7, lr}
 8010a2a:	af00      	add	r7, sp, #0

  huart1.Instance = USART1;
 8010a2c:	4b0f      	ldr	r3, [pc, #60]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a2e:	4a10      	ldr	r2, [pc, #64]	; (8010a70 <MX_USART1_UART_Init+0x48>)
 8010a30:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 8010a32:	4b0e      	ldr	r3, [pc, #56]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a34:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8010a38:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8010a3a:	4b0c      	ldr	r3, [pc, #48]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a3c:	2200      	movs	r2, #0
 8010a3e:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8010a40:	4b0a      	ldr	r3, [pc, #40]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a42:	2200      	movs	r2, #0
 8010a44:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8010a46:	4b09      	ldr	r3, [pc, #36]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a48:	2200      	movs	r2, #0
 8010a4a:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8010a4c:	4b07      	ldr	r3, [pc, #28]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a4e:	220c      	movs	r2, #12
 8010a50:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8010a52:	4b06      	ldr	r3, [pc, #24]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a54:	f44f 7240 	mov.w	r2, #768	; 0x300
 8010a58:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8010a5a:	4b04      	ldr	r3, [pc, #16]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a5c:	2200      	movs	r2, #0
 8010a5e:	61da      	str	r2, [r3, #28]
  HAL_UART_Init(&huart1);
 8010a60:	4802      	ldr	r0, [pc, #8]	; (8010a6c <MX_USART1_UART_Init+0x44>)
 8010a62:	f006 fac6 	bl	8016ff2 <HAL_UART_Init>

}
 8010a66:	bf00      	nop
 8010a68:	bd80      	pop	{r7, pc}
 8010a6a:	bf00      	nop
 8010a6c:	2000d1cc 	.word	0x2000d1cc
 8010a70:	40011000 	.word	0x40011000

08010a74 <MX_USART6_SMARTCARD_Init>:
/* USART6 init function */

void MX_USART6_SMARTCARD_Init(void)
{
 8010a74:	b580      	push	{r7, lr}
 8010a76:	af00      	add	r7, sp, #0

  hsc6.Instance = USART6;
 8010a78:	4b16      	ldr	r3, [pc, #88]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010a7a:	4a17      	ldr	r2, [pc, #92]	; (8010ad8 <MX_USART6_SMARTCARD_Init+0x64>)
 8010a7c:	601a      	str	r2, [r3, #0]
  hsc6.Init.BaudRate = 115200;
 8010a7e:	4b15      	ldr	r3, [pc, #84]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010a80:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8010a84:	605a      	str	r2, [r3, #4]
  hsc6.Init.WordLength = SMARTCARD_WORDLENGTH_9B;
 8010a86:	4b13      	ldr	r3, [pc, #76]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010a88:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8010a8c:	609a      	str	r2, [r3, #8]
  hsc6.Init.StopBits = SMARTCARD_STOPBITS_1_5;
 8010a8e:	4b11      	ldr	r3, [pc, #68]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010a90:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8010a94:	60da      	str	r2, [r3, #12]
  hsc6.Init.Parity = SMARTCARD_PARITY_EVEN;
 8010a96:	4b0f      	ldr	r3, [pc, #60]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010a98:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8010a9c:	611a      	str	r2, [r3, #16]
  hsc6.Init.Mode = SMARTCARD_MODE_TX_RX;
 8010a9e:	4b0d      	ldr	r3, [pc, #52]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010aa0:	220c      	movs	r2, #12
 8010aa2:	615a      	str	r2, [r3, #20]
  hsc6.Init.CLKPolarity = SMARTCARD_POLARITY_LOW;
 8010aa4:	4b0b      	ldr	r3, [pc, #44]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010aa6:	2200      	movs	r2, #0
 8010aa8:	619a      	str	r2, [r3, #24]
  hsc6.Init.CLKPhase = SMARTCARD_PHASE_1EDGE;
 8010aaa:	4b0a      	ldr	r3, [pc, #40]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010aac:	2200      	movs	r2, #0
 8010aae:	61da      	str	r2, [r3, #28]
  hsc6.Init.CLKLastBit = SMARTCARD_LASTBIT_DISABLE;
 8010ab0:	4b08      	ldr	r3, [pc, #32]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010ab2:	2200      	movs	r2, #0
 8010ab4:	621a      	str	r2, [r3, #32]
  hsc6.Init.Prescaler = 11;
 8010ab6:	4b07      	ldr	r3, [pc, #28]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010ab8:	220b      	movs	r2, #11
 8010aba:	625a      	str	r2, [r3, #36]	; 0x24
  hsc6.Init.GuardTime = 0;
 8010abc:	4b05      	ldr	r3, [pc, #20]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010abe:	2200      	movs	r2, #0
 8010ac0:	629a      	str	r2, [r3, #40]	; 0x28
  hsc6.Init.NACKState = SMARTCARD_NACK_DISABLED;
 8010ac2:	4b04      	ldr	r3, [pc, #16]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010ac4:	2200      	movs	r2, #0
 8010ac6:	62da      	str	r2, [r3, #44]	; 0x2c
  HAL_SMARTCARD_Init(&hsc6);
 8010ac8:	4802      	ldr	r0, [pc, #8]	; (8010ad4 <MX_USART6_SMARTCARD_Init+0x60>)
 8010aca:	f005 fcbc 	bl	8016446 <HAL_SMARTCARD_Init>

}
 8010ace:	bf00      	nop
 8010ad0:	bd80      	pop	{r7, pc}
 8010ad2:	bf00      	nop
 8010ad4:	2000d20c 	.word	0x2000d20c
 8010ad8:	40011400 	.word	0x40011400

08010adc <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8010adc:	b580      	push	{r7, lr}
 8010ade:	b088      	sub	sp, #32
 8010ae0:	af00      	add	r7, sp, #0
 8010ae2:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART1)
 8010ae4:	687b      	ldr	r3, [r7, #4]
 8010ae6:	681b      	ldr	r3, [r3, #0]
 8010ae8:	4a23      	ldr	r2, [pc, #140]	; (8010b78 <HAL_UART_MspInit+0x9c>)
 8010aea:	4293      	cmp	r3, r2
 8010aec:	d13f      	bne.n	8010b6e <HAL_UART_MspInit+0x92>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __USART1_CLK_ENABLE();
 8010aee:	2300      	movs	r3, #0
 8010af0:	60bb      	str	r3, [r7, #8]
 8010af2:	4b22      	ldr	r3, [pc, #136]	; (8010b7c <HAL_UART_MspInit+0xa0>)
 8010af4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010af6:	4a21      	ldr	r2, [pc, #132]	; (8010b7c <HAL_UART_MspInit+0xa0>)
 8010af8:	f043 0310 	orr.w	r3, r3, #16
 8010afc:	6453      	str	r3, [r2, #68]	; 0x44
 8010afe:	4b1f      	ldr	r3, [pc, #124]	; (8010b7c <HAL_UART_MspInit+0xa0>)
 8010b00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010b02:	f003 0310 	and.w	r3, r3, #16
 8010b06:	60bb      	str	r3, [r7, #8]
 8010b08:	68bb      	ldr	r3, [r7, #8]
    PB6     ------> USART1_TX
    PA12     ------> USART1_RTS
    PA11     ------> USART1_CTS
    PA10     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8010b0a:	2340      	movs	r3, #64	; 0x40
 8010b0c:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010b0e:	2302      	movs	r3, #2
 8010b10:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8010b12:	2301      	movs	r3, #1
 8010b14:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010b16:	2303      	movs	r3, #3
 8010b18:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8010b1a:	2307      	movs	r3, #7
 8010b1c:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8010b1e:	f107 030c 	add.w	r3, r7, #12
 8010b22:	4619      	mov	r1, r3
 8010b24:	4816      	ldr	r0, [pc, #88]	; (8010b80 <HAL_UART_MspInit+0xa4>)
 8010b26:	f001 fe9d 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11;
 8010b2a:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8010b2e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010b30:	2302      	movs	r3, #2
 8010b32:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010b34:	2300      	movs	r3, #0
 8010b36:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010b38:	2303      	movs	r3, #3
 8010b3a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8010b3c:	2307      	movs	r3, #7
 8010b3e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8010b40:	f107 030c 	add.w	r3, r7, #12
 8010b44:	4619      	mov	r1, r3
 8010b46:	480f      	ldr	r0, [pc, #60]	; (8010b84 <HAL_UART_MspInit+0xa8>)
 8010b48:	f001 fe8c 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8010b4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8010b50:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010b52:	2302      	movs	r3, #2
 8010b54:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8010b56:	2301      	movs	r3, #1
 8010b58:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010b5a:	2303      	movs	r3, #3
 8010b5c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8010b5e:	2307      	movs	r3, #7
 8010b60:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8010b62:	f107 030c 	add.w	r3, r7, #12
 8010b66:	4619      	mov	r1, r3
 8010b68:	4806      	ldr	r0, [pc, #24]	; (8010b84 <HAL_UART_MspInit+0xa8>)
 8010b6a:	f001 fe7b 	bl	8012864 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 8010b6e:	bf00      	nop
 8010b70:	3720      	adds	r7, #32
 8010b72:	46bd      	mov	sp, r7
 8010b74:	bd80      	pop	{r7, pc}
 8010b76:	bf00      	nop
 8010b78:	40011000 	.word	0x40011000
 8010b7c:	40023800 	.word	0x40023800
 8010b80:	40020400 	.word	0x40020400
 8010b84:	40020000 	.word	0x40020000

08010b88 <HAL_SMARTCARD_MspInit>:

void HAL_SMARTCARD_MspInit(SMARTCARD_HandleTypeDef* hsmartcard)
{
 8010b88:	b580      	push	{r7, lr}
 8010b8a:	b088      	sub	sp, #32
 8010b8c:	af00      	add	r7, sp, #0
 8010b8e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hsmartcard->Instance==USART6)
 8010b90:	687b      	ldr	r3, [r7, #4]
 8010b92:	681b      	ldr	r3, [r3, #0]
 8010b94:	4a1a      	ldr	r2, [pc, #104]	; (8010c00 <HAL_SMARTCARD_MspInit+0x78>)
 8010b96:	4293      	cmp	r3, r2
 8010b98:	d12d      	bne.n	8010bf6 <HAL_SMARTCARD_MspInit+0x6e>
  {
  /* USER CODE BEGIN USART6_MspInit 0 */

  /* USER CODE END USART6_MspInit 0 */
    /* Peripheral clock enable */
    __USART6_CLK_ENABLE();
 8010b9a:	2300      	movs	r3, #0
 8010b9c:	60bb      	str	r3, [r7, #8]
 8010b9e:	4b19      	ldr	r3, [pc, #100]	; (8010c04 <HAL_SMARTCARD_MspInit+0x7c>)
 8010ba0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010ba2:	4a18      	ldr	r2, [pc, #96]	; (8010c04 <HAL_SMARTCARD_MspInit+0x7c>)
 8010ba4:	f043 0320 	orr.w	r3, r3, #32
 8010ba8:	6453      	str	r3, [r2, #68]	; 0x44
 8010baa:	4b16      	ldr	r3, [pc, #88]	; (8010c04 <HAL_SMARTCARD_MspInit+0x7c>)
 8010bac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010bae:	f003 0320 	and.w	r3, r3, #32
 8010bb2:	60bb      	str	r3, [r7, #8]
 8010bb4:	68bb      	ldr	r3, [r7, #8]
  
    /**USART6 GPIO Configuration    
    PC6     ------> USART6_TX
    PG7     ------> USART6_CK 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 8010bb6:	2340      	movs	r3, #64	; 0x40
 8010bb8:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8010bba:	2312      	movs	r3, #18
 8010bbc:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8010bbe:	2301      	movs	r3, #1
 8010bc0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010bc2:	2303      	movs	r3, #3
 8010bc4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8010bc6:	2308      	movs	r3, #8
 8010bc8:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010bca:	f107 030c 	add.w	r3, r7, #12
 8010bce:	4619      	mov	r1, r3
 8010bd0:	480d      	ldr	r0, [pc, #52]	; (8010c08 <HAL_SMARTCARD_MspInit+0x80>)
 8010bd2:	f001 fe47 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
 8010bd6:	2380      	movs	r3, #128	; 0x80
 8010bd8:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010bda:	2302      	movs	r3, #2
 8010bdc:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010bde:	2300      	movs	r3, #0
 8010be0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010be2:	2303      	movs	r3, #3
 8010be4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8010be6:	2308      	movs	r3, #8
 8010be8:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8010bea:	f107 030c 	add.w	r3, r7, #12
 8010bee:	4619      	mov	r1, r3
 8010bf0:	4806      	ldr	r0, [pc, #24]	; (8010c0c <HAL_SMARTCARD_MspInit+0x84>)
 8010bf2:	f001 fe37 	bl	8012864 <HAL_GPIO_Init>

  /* USER CODE BEGIN USART6_MspInit 1 */

  /* USER CODE END USART6_MspInit 1 */
  }
}
 8010bf6:	bf00      	nop
 8010bf8:	3720      	adds	r7, #32
 8010bfa:	46bd      	mov	sp, r7
 8010bfc:	bd80      	pop	{r7, pc}
 8010bfe:	bf00      	nop
 8010c00:	40011400 	.word	0x40011400
 8010c04:	40023800 	.word	0x40023800
 8010c08:	40020800 	.word	0x40020800
 8010c0c:	40021800 	.word	0x40021800

08010c10 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceHS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8010c10:	b580      	push	{r7, lr}
 8010c12:	af00      	add	r7, sp, #0
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceHS, &HS_Desc, DEVICE_HS);
 8010c14:	2201      	movs	r2, #1
 8010c16:	4908      	ldr	r1, [pc, #32]	; (8010c38 <MX_USB_DEVICE_Init+0x28>)
 8010c18:	4808      	ldr	r0, [pc, #32]	; (8010c3c <MX_USB_DEVICE_Init+0x2c>)
 8010c1a:	f007 ffaf 	bl	8018b7c <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceHS, &USBD_MSC);
 8010c1e:	4908      	ldr	r1, [pc, #32]	; (8010c40 <MX_USB_DEVICE_Init+0x30>)
 8010c20:	4806      	ldr	r0, [pc, #24]	; (8010c3c <MX_USB_DEVICE_Init+0x2c>)
 8010c22:	f007 ffd6 	bl	8018bd2 <USBD_RegisterClass>

  USBD_MSC_RegisterStorage(&hUsbDeviceHS, &USBD_Storage_Interface_fops_HS);
 8010c26:	4907      	ldr	r1, [pc, #28]	; (8010c44 <MX_USB_DEVICE_Init+0x34>)
 8010c28:	4804      	ldr	r0, [pc, #16]	; (8010c3c <MX_USB_DEVICE_Init+0x2c>)
 8010c2a:	f009 f869 	bl	8019d00 <USBD_MSC_RegisterStorage>

  USBD_Start(&hUsbDeviceHS);
 8010c2e:	4803      	ldr	r0, [pc, #12]	; (8010c3c <MX_USB_DEVICE_Init+0x2c>)
 8010c30:	f007 ffe9 	bl	8018c06 <USBD_Start>

}
 8010c34:	bf00      	nop
 8010c36:	bd80      	pop	{r7, pc}
 8010c38:	20000304 	.word	0x20000304
 8010c3c:	2000d25c 	.word	0x2000d25c
 8010c40:	2000035c 	.word	0x2000035c
 8010c44:	20000338 	.word	0x20000338

08010c48 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 8010c48:	b580      	push	{r7, lr}
 8010c4a:	b08a      	sub	sp, #40	; 0x28
 8010c4c:	af00      	add	r7, sp, #0
 8010c4e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  if(hpcd->Instance==USB_OTG_HS)
 8010c50:	687b      	ldr	r3, [r7, #4]
 8010c52:	681b      	ldr	r3, [r3, #0]
 8010c54:	4a36      	ldr	r2, [pc, #216]	; (8010d30 <HAL_PCD_MspInit+0xe8>)
 8010c56:	4293      	cmp	r3, r2
 8010c58:	d165      	bne.n	8010d26 <HAL_PCD_MspInit+0xde>
    PA3     ------> USB_OTG_HS_ULPI_D0
    PB1     ------> USB_OTG_HS_ULPI_D2
    PB0     ------> USB_OTG_HS_ULPI_D1
    PB11     ------> USB_OTG_HS_ULPI_D4 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_12|GPIO_PIN_10 
 8010c5a:	f643 4323 	movw	r3, #15395	; 0x3c23
 8010c5e:	617b      	str	r3, [r7, #20]
                          |GPIO_PIN_1|GPIO_PIN_0|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010c60:	2302      	movs	r3, #2
 8010c62:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010c64:	2300      	movs	r3, #0
 8010c66:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010c68:	2303      	movs	r3, #3
 8010c6a:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010c6c:	230a      	movs	r3, #10
 8010c6e:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8010c70:	f107 0314 	add.w	r3, r7, #20
 8010c74:	4619      	mov	r1, r3
 8010c76:	482f      	ldr	r0, [pc, #188]	; (8010d34 <HAL_PCD_MspInit+0xec>)
 8010c78:	f001 fdf4 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8010c7c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8010c80:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010c82:	2302      	movs	r3, #2
 8010c84:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010c86:	2300      	movs	r3, #0
 8010c88:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010c8a:	2303      	movs	r3, #3
 8010c8c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010c8e:	230a      	movs	r3, #10
 8010c90:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8010c92:	f107 0314 	add.w	r3, r7, #20
 8010c96:	4619      	mov	r1, r3
 8010c98:	4827      	ldr	r0, [pc, #156]	; (8010d38 <HAL_PCD_MspInit+0xf0>)
 8010c9a:	f001 fde3 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_0;
 8010c9e:	2309      	movs	r3, #9
 8010ca0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010ca2:	2302      	movs	r3, #2
 8010ca4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010ca6:	2300      	movs	r3, #0
 8010ca8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010caa:	2303      	movs	r3, #3
 8010cac:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010cae:	230a      	movs	r3, #10
 8010cb0:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8010cb2:	f107 0314 	add.w	r3, r7, #20
 8010cb6:	4619      	mov	r1, r3
 8010cb8:	4820      	ldr	r0, [pc, #128]	; (8010d3c <HAL_PCD_MspInit+0xf4>)
 8010cba:	f001 fdd3 	bl	8012864 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_3;
 8010cbe:	2328      	movs	r3, #40	; 0x28
 8010cc0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010cc2:	2302      	movs	r3, #2
 8010cc4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010cc6:	2300      	movs	r3, #0
 8010cc8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8010cca:	2303      	movs	r3, #3
 8010ccc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8010cce:	230a      	movs	r3, #10
 8010cd0:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8010cd2:	f107 0314 	add.w	r3, r7, #20
 8010cd6:	4619      	mov	r1, r3
 8010cd8:	4819      	ldr	r0, [pc, #100]	; (8010d40 <HAL_PCD_MspInit+0xf8>)
 8010cda:	f001 fdc3 	bl	8012864 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __USB_OTG_HS_CLK_ENABLE();
 8010cde:	2300      	movs	r3, #0
 8010ce0:	613b      	str	r3, [r7, #16]
 8010ce2:	4b18      	ldr	r3, [pc, #96]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010ce6:	4a17      	ldr	r2, [pc, #92]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010ce8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8010cec:	6313      	str	r3, [r2, #48]	; 0x30
 8010cee:	4b15      	ldr	r3, [pc, #84]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010cf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010cf2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8010cf6:	613b      	str	r3, [r7, #16]
 8010cf8:	693b      	ldr	r3, [r7, #16]
    __USB_OTG_HS_ULPI_CLK_ENABLE();
 8010cfa:	2300      	movs	r3, #0
 8010cfc:	60fb      	str	r3, [r7, #12]
 8010cfe:	4b11      	ldr	r3, [pc, #68]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010d00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010d02:	4a10      	ldr	r2, [pc, #64]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010d04:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8010d08:	6313      	str	r3, [r2, #48]	; 0x30
 8010d0a:	4b0e      	ldr	r3, [pc, #56]	; (8010d44 <HAL_PCD_MspInit+0xfc>)
 8010d0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010d0e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8010d12:	60fb      	str	r3, [r7, #12]
 8010d14:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 7, 0);
 8010d16:	2200      	movs	r2, #0
 8010d18:	2107      	movs	r1, #7
 8010d1a:	204d      	movs	r0, #77	; 0x4d
 8010d1c:	f000 ff69 	bl	8011bf2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8010d20:	204d      	movs	r0, #77	; 0x4d
 8010d22:	f000 ff82 	bl	8011c2a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */

  /* USER CODE END USB_OTG_HS_MspInit 1 */
  }
}
 8010d26:	bf00      	nop
 8010d28:	3728      	adds	r7, #40	; 0x28
 8010d2a:	46bd      	mov	sp, r7
 8010d2c:	bd80      	pop	{r7, pc}
 8010d2e:	bf00      	nop
 8010d30:	40040000 	.word	0x40040000
 8010d34:	40020400 	.word	0x40020400
 8010d38:	40022000 	.word	0x40022000
 8010d3c:	40020800 	.word	0x40020800
 8010d40:	40020000 	.word	0x40020000
 8010d44:	40023800 	.word	0x40023800

08010d48 <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 8010d48:	b580      	push	{r7, lr}
 8010d4a:	b082      	sub	sp, #8
 8010d4c:	af00      	add	r7, sp, #0
 8010d4e:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8010d50:	687b      	ldr	r3, [r7, #4]
 8010d52:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 8010d56:	687b      	ldr	r3, [r7, #4]
 8010d58:	f503 7361 	add.w	r3, r3, #900	; 0x384
 8010d5c:	4619      	mov	r1, r3
 8010d5e:	4610      	mov	r0, r2
 8010d60:	f007 ff9a 	bl	8018c98 <USBD_LL_SetupStage>
}
 8010d64:	bf00      	nop
 8010d66:	3708      	adds	r7, #8
 8010d68:	46bd      	mov	sp, r7
 8010d6a:	bd80      	pop	{r7, pc}

08010d6c <HAL_PCD_DataOutStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8010d6c:	b580      	push	{r7, lr}
 8010d6e:	b082      	sub	sp, #8
 8010d70:	af00      	add	r7, sp, #0
 8010d72:	6078      	str	r0, [r7, #4]
 8010d74:	460b      	mov	r3, r1
 8010d76:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8010d78:	687b      	ldr	r3, [r7, #4]
 8010d7a:	f8d3 03b4 	ldr.w	r0, [r3, #948]	; 0x3b4
 8010d7e:	78fa      	ldrb	r2, [r7, #3]
 8010d80:	6879      	ldr	r1, [r7, #4]
 8010d82:	4613      	mov	r3, r2
 8010d84:	00db      	lsls	r3, r3, #3
 8010d86:	1a9b      	subs	r3, r3, r2
 8010d88:	009b      	lsls	r3, r3, #2
 8010d8a:	440b      	add	r3, r1
 8010d8c:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 8010d90:	681a      	ldr	r2, [r3, #0]
 8010d92:	78fb      	ldrb	r3, [r7, #3]
 8010d94:	4619      	mov	r1, r3
 8010d96:	f007 ffc9 	bl	8018d2c <USBD_LL_DataOutStage>
}
 8010d9a:	bf00      	nop
 8010d9c:	3708      	adds	r7, #8
 8010d9e:	46bd      	mov	sp, r7
 8010da0:	bd80      	pop	{r7, pc}

08010da2 <HAL_PCD_DataInStageCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8010da2:	b580      	push	{r7, lr}
 8010da4:	b082      	sub	sp, #8
 8010da6:	af00      	add	r7, sp, #0
 8010da8:	6078      	str	r0, [r7, #4]
 8010daa:	460b      	mov	r3, r1
 8010dac:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8010dae:	687b      	ldr	r3, [r7, #4]
 8010db0:	f8d3 03b4 	ldr.w	r0, [r3, #948]	; 0x3b4
 8010db4:	78fa      	ldrb	r2, [r7, #3]
 8010db6:	6879      	ldr	r1, [r7, #4]
 8010db8:	4613      	mov	r3, r2
 8010dba:	00db      	lsls	r3, r3, #3
 8010dbc:	1a9b      	subs	r3, r3, r2
 8010dbe:	009b      	lsls	r3, r3, #2
 8010dc0:	440b      	add	r3, r1
 8010dc2:	3344      	adds	r3, #68	; 0x44
 8010dc4:	681a      	ldr	r2, [r3, #0]
 8010dc6:	78fb      	ldrb	r3, [r7, #3]
 8010dc8:	4619      	mov	r1, r3
 8010dca:	f008 f80a 	bl	8018de2 <USBD_LL_DataInStage>
}
 8010dce:	bf00      	nop
 8010dd0:	3708      	adds	r7, #8
 8010dd2:	46bd      	mov	sp, r7
 8010dd4:	bd80      	pop	{r7, pc}

08010dd6 <HAL_PCD_SOFCallback>:
  * @brief  SOF callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
 8010dd6:	b580      	push	{r7, lr}
 8010dd8:	b082      	sub	sp, #8
 8010dda:	af00      	add	r7, sp, #0
 8010ddc:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF(hpcd->pData);
 8010dde:	687b      	ldr	r3, [r7, #4]
 8010de0:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010de4:	4618      	mov	r0, r3
 8010de6:	f008 f8f0 	bl	8018fca <USBD_LL_SOF>
}
 8010dea:	bf00      	nop
 8010dec:	3708      	adds	r7, #8
 8010dee:	46bd      	mov	sp, r7
 8010df0:	bd80      	pop	{r7, pc}

08010df2 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8010df2:	b580      	push	{r7, lr}
 8010df4:	b084      	sub	sp, #16
 8010df6:	af00      	add	r7, sp, #0
 8010df8:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8010dfa:	2301      	movs	r3, #1
 8010dfc:	73fb      	strb	r3, [r7, #15]

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 8010dfe:	687b      	ldr	r3, [r7, #4]
 8010e00:	68db      	ldr	r3, [r3, #12]
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d002      	beq.n	8010e0c <HAL_PCD_ResetCallback+0x1a>
 8010e06:	2b02      	cmp	r3, #2
 8010e08:	d003      	beq.n	8010e12 <HAL_PCD_ResetCallback+0x20>
 8010e0a:	e005      	b.n	8010e18 <HAL_PCD_ResetCallback+0x26>
  {
  case PCD_SPEED_HIGH:
    speed = USBD_SPEED_HIGH;
 8010e0c:	2300      	movs	r3, #0
 8010e0e:	73fb      	strb	r3, [r7, #15]
    break;
 8010e10:	e005      	b.n	8010e1e <HAL_PCD_ResetCallback+0x2c>
  case PCD_SPEED_FULL:
    speed = USBD_SPEED_FULL;    
 8010e12:	2301      	movs	r3, #1
 8010e14:	73fb      	strb	r3, [r7, #15]
    break;
 8010e16:	e002      	b.n	8010e1e <HAL_PCD_ResetCallback+0x2c>
	
  default:
    speed = USBD_SPEED_FULL;    
 8010e18:	2301      	movs	r3, #1
 8010e1a:	73fb      	strb	r3, [r7, #15]
    break;    
 8010e1c:	bf00      	nop
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 8010e1e:	687b      	ldr	r3, [r7, #4]
 8010e20:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010e24:	7bfa      	ldrb	r2, [r7, #15]
 8010e26:	4611      	mov	r1, r2
 8010e28:	4618      	mov	r0, r3
 8010e2a:	f008 f898 	bl	8018f5e <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 8010e2e:	687b      	ldr	r3, [r7, #4]
 8010e30:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010e34:	4618      	mov	r0, r3
 8010e36:	f008 f863 	bl	8018f00 <USBD_LL_Reset>
}
 8010e3a:	bf00      	nop
 8010e3c:	3710      	adds	r7, #16
 8010e3e:	46bd      	mov	sp, r7
 8010e40:	bd80      	pop	{r7, pc}
	...

08010e44 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{  
 8010e44:	b580      	push	{r7, lr}
 8010e46:	b082      	sub	sp, #8
 8010e48:	af00      	add	r7, sp, #0
 8010e4a:	6078      	str	r0, [r7, #4]
   /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend(hpcd->pData);
 8010e4c:	687b      	ldr	r3, [r7, #4]
 8010e4e:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010e52:	4618      	mov	r0, r3
 8010e54:	f008 f893 	bl	8018f7e <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8010e58:	687b      	ldr	r3, [r7, #4]
 8010e5a:	681b      	ldr	r3, [r3, #0]
 8010e5c:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8010e60:	681b      	ldr	r3, [r3, #0]
 8010e62:	687a      	ldr	r2, [r7, #4]
 8010e64:	6812      	ldr	r2, [r2, #0]
 8010e66:	f502 6260 	add.w	r2, r2, #3584	; 0xe00
 8010e6a:	f043 0301 	orr.w	r3, r3, #1
 8010e6e:	6013      	str	r3, [r2, #0]
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8010e70:	687b      	ldr	r3, [r7, #4]
 8010e72:	6a1b      	ldr	r3, [r3, #32]
 8010e74:	2b00      	cmp	r3, #0
 8010e76:	d005      	beq.n	8010e84 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8010e78:	4b04      	ldr	r3, [pc, #16]	; (8010e8c <HAL_PCD_SuspendCallback+0x48>)
 8010e7a:	691b      	ldr	r3, [r3, #16]
 8010e7c:	4a03      	ldr	r2, [pc, #12]	; (8010e8c <HAL_PCD_SuspendCallback+0x48>)
 8010e7e:	f043 0306 	orr.w	r3, r3, #6
 8010e82:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8010e84:	bf00      	nop
 8010e86:	3708      	adds	r7, #8
 8010e88:	46bd      	mov	sp, r7
 8010e8a:	bd80      	pop	{r7, pc}
 8010e8c:	e000ed00 	.word	0xe000ed00

08010e90 <HAL_PCD_ResumeCallback>:
    When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
 8010e90:	b580      	push	{r7, lr}
 8010e92:	b082      	sub	sp, #8
 8010e94:	af00      	add	r7, sp, #0
 8010e96:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 8010e98:	687b      	ldr	r3, [r7, #4]
 8010e9a:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010e9e:	4618      	mov	r0, r3
 8010ea0:	f008 f882 	bl	8018fa8 <USBD_LL_Resume>
}
 8010ea4:	bf00      	nop
 8010ea6:	3708      	adds	r7, #8
 8010ea8:	46bd      	mov	sp, r7
 8010eaa:	bd80      	pop	{r7, pc}

08010eac <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8010eac:	b580      	push	{r7, lr}
 8010eae:	b082      	sub	sp, #8
 8010eb0:	af00      	add	r7, sp, #0
 8010eb2:	6078      	str	r0, [r7, #4]
 8010eb4:	460b      	mov	r3, r1
 8010eb6:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8010eb8:	687b      	ldr	r3, [r7, #4]
 8010eba:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010ebe:	78fa      	ldrb	r2, [r7, #3]
 8010ec0:	4611      	mov	r1, r2
 8010ec2:	4618      	mov	r0, r3
 8010ec4:	f008 f8a8 	bl	8019018 <USBD_LL_IsoOUTIncomplete>
}
 8010ec8:	bf00      	nop
 8010eca:	3708      	adds	r7, #8
 8010ecc:	46bd      	mov	sp, r7
 8010ece:	bd80      	pop	{r7, pc}

08010ed0 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  hpcd: PCD handle
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
 8010ed0:	b580      	push	{r7, lr}
 8010ed2:	b082      	sub	sp, #8
 8010ed4:	af00      	add	r7, sp, #0
 8010ed6:	6078      	str	r0, [r7, #4]
 8010ed8:	460b      	mov	r3, r1
 8010eda:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8010edc:	687b      	ldr	r3, [r7, #4]
 8010ede:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010ee2:	78fa      	ldrb	r2, [r7, #3]
 8010ee4:	4611      	mov	r1, r2
 8010ee6:	4618      	mov	r0, r3
 8010ee8:	f008 f889 	bl	8018ffe <USBD_LL_IsoINIncomplete>
}
 8010eec:	bf00      	nop
 8010eee:	3708      	adds	r7, #8
 8010ef0:	46bd      	mov	sp, r7
 8010ef2:	bd80      	pop	{r7, pc}

08010ef4 <HAL_PCD_ConnectCallback>:
  * @brief  Connect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
 8010ef4:	b580      	push	{r7, lr}
 8010ef6:	b082      	sub	sp, #8
 8010ef8:	af00      	add	r7, sp, #0
 8010efa:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected(hpcd->pData);
 8010efc:	687b      	ldr	r3, [r7, #4]
 8010efe:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010f02:	4618      	mov	r0, r3
 8010f04:	f008 f895 	bl	8019032 <USBD_LL_DevConnected>
}
 8010f08:	bf00      	nop
 8010f0a:	3708      	adds	r7, #8
 8010f0c:	46bd      	mov	sp, r7
 8010f0e:	bd80      	pop	{r7, pc}

08010f10 <HAL_PCD_DisconnectCallback>:
  * @brief  Disconnect callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
 8010f10:	b580      	push	{r7, lr}
 8010f12:	b082      	sub	sp, #8
 8010f14:	af00      	add	r7, sp, #0
 8010f16:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected(hpcd->pData);
 8010f18:	687b      	ldr	r3, [r7, #4]
 8010f1a:	f8d3 33b4 	ldr.w	r3, [r3, #948]	; 0x3b4
 8010f1e:	4618      	mov	r0, r3
 8010f20:	f008 f892 	bl	8019048 <USBD_LL_DevDisconnected>
}
 8010f24:	bf00      	nop
 8010f26:	3708      	adds	r7, #8
 8010f28:	46bd      	mov	sp, r7
 8010f2a:	bd80      	pop	{r7, pc}

08010f2c <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 8010f2c:	b580      	push	{r7, lr}
 8010f2e:	b082      	sub	sp, #8
 8010f30:	af00      	add	r7, sp, #0
 8010f32:	6078      	str	r0, [r7, #4]
  /* Init USB_IP */
  if (pdev->id == DEVICE_HS) {
 8010f34:	687b      	ldr	r3, [r7, #4]
 8010f36:	781b      	ldrb	r3, [r3, #0]
 8010f38:	2b01      	cmp	r3, #1
 8010f3a:	d13e      	bne.n	8010fba <USBD_LL_Init+0x8e>
  /* Link The driver to the stack */
  hpcd_USB_OTG_HS.pData = pdev;
 8010f3c:	4a21      	ldr	r2, [pc, #132]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f3e:	687b      	ldr	r3, [r7, #4]
 8010f40:	f8c2 33b4 	str.w	r3, [r2, #948]	; 0x3b4
  pdev->pData = &hpcd_USB_OTG_HS;
 8010f44:	687b      	ldr	r3, [r7, #4]
 8010f46:	4a1f      	ldr	r2, [pc, #124]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f48:	f8c3 2220 	str.w	r2, [r3, #544]	; 0x220

  hpcd_USB_OTG_HS.Instance = USB_OTG_HS;
 8010f4c:	4b1d      	ldr	r3, [pc, #116]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f4e:	4a1e      	ldr	r2, [pc, #120]	; (8010fc8 <USBD_LL_Init+0x9c>)
 8010f50:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_HS.Init.dev_endpoints = 11;
 8010f52:	4b1c      	ldr	r3, [pc, #112]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f54:	220b      	movs	r2, #11
 8010f56:	605a      	str	r2, [r3, #4]
  hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_HIGH;
 8010f58:	4b1a      	ldr	r3, [pc, #104]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f5a:	2200      	movs	r2, #0
 8010f5c:	60da      	str	r2, [r3, #12]
  hpcd_USB_OTG_HS.Init.dma_enable = ENABLE;
 8010f5e:	4b19      	ldr	r3, [pc, #100]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f60:	2201      	movs	r2, #1
 8010f62:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_HS.Init.ep0_mps = DEP0CTL_MPS_64;
 8010f64:	4b17      	ldr	r3, [pc, #92]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f66:	2200      	movs	r2, #0
 8010f68:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_HS.Init.phy_itface = USB_OTG_ULPI_PHY;
 8010f6a:	4b16      	ldr	r3, [pc, #88]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f6c:	2201      	movs	r2, #1
 8010f6e:	619a      	str	r2, [r3, #24]
  hpcd_USB_OTG_HS.Init.Sof_enable = DISABLE;
 8010f70:	4b14      	ldr	r3, [pc, #80]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f72:	2200      	movs	r2, #0
 8010f74:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_HS.Init.low_power_enable = DISABLE;
 8010f76:	4b13      	ldr	r3, [pc, #76]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f78:	2200      	movs	r2, #0
 8010f7a:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_HS.Init.lpm_enable = DISABLE;
 8010f7c:	4b11      	ldr	r3, [pc, #68]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f7e:	2200      	movs	r2, #0
 8010f80:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_HS.Init.vbus_sensing_enable = ENABLE;
 8010f82:	4b10      	ldr	r3, [pc, #64]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f84:	2201      	movs	r2, #1
 8010f86:	62da      	str	r2, [r3, #44]	; 0x2c
  hpcd_USB_OTG_HS.Init.use_dedicated_ep1 = DISABLE;
 8010f88:	4b0e      	ldr	r3, [pc, #56]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f8a:	2200      	movs	r2, #0
 8010f8c:	631a      	str	r2, [r3, #48]	; 0x30
  hpcd_USB_OTG_HS.Init.use_external_vbus = DISABLE;
 8010f8e:	4b0d      	ldr	r3, [pc, #52]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f90:	2200      	movs	r2, #0
 8010f92:	635a      	str	r2, [r3, #52]	; 0x34
  HAL_PCD_Init(&hpcd_USB_OTG_HS);
 8010f94:	480b      	ldr	r0, [pc, #44]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010f96:	f001 ff51 	bl	8012e3c <HAL_PCD_Init>

  HAL_PCD_SetRxFiFo(&hpcd_USB_OTG_HS, 0x200);
 8010f9a:	f44f 7100 	mov.w	r1, #512	; 0x200
 8010f9e:	4809      	ldr	r0, [pc, #36]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010fa0:	f002 ff82 	bl	8013ea8 <HAL_PCDEx_SetRxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_HS, 0, 0x80);
 8010fa4:	2280      	movs	r2, #128	; 0x80
 8010fa6:	2100      	movs	r1, #0
 8010fa8:	4806      	ldr	r0, [pc, #24]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010faa:	f002 ff32 	bl	8013e12 <HAL_PCDEx_SetTxFiFo>
  HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_HS, 1, 0x174);
 8010fae:	f44f 72ba 	mov.w	r2, #372	; 0x174
 8010fb2:	2101      	movs	r1, #1
 8010fb4:	4803      	ldr	r0, [pc, #12]	; (8010fc4 <USBD_LL_Init+0x98>)
 8010fb6:	f002 ff2c 	bl	8013e12 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 8010fba:	2300      	movs	r3, #0
}
 8010fbc:	4618      	mov	r0, r3
 8010fbe:	3708      	adds	r7, #8
 8010fc0:	46bd      	mov	sp, r7
 8010fc2:	bd80      	pop	{r7, pc}
 8010fc4:	2000d480 	.word	0x2000d480
 8010fc8:	40040000 	.word	0x40040000

08010fcc <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8010fcc:	b580      	push	{r7, lr}
 8010fce:	b082      	sub	sp, #8
 8010fd0:	af00      	add	r7, sp, #0
 8010fd2:	6078      	str	r0, [r7, #4]
  HAL_PCD_Start(pdev->pData);
 8010fd4:	687b      	ldr	r3, [r7, #4]
 8010fd6:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8010fda:	4618      	mov	r0, r3
 8010fdc:	f002 f835 	bl	801304a <HAL_PCD_Start>
  return USBD_OK; 
 8010fe0:	2300      	movs	r3, #0
}
 8010fe2:	4618      	mov	r0, r3
 8010fe4:	3708      	adds	r7, #8
 8010fe6:	46bd      	mov	sp, r7
 8010fe8:	bd80      	pop	{r7, pc}

08010fea <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 8010fea:	b580      	push	{r7, lr}
 8010fec:	b082      	sub	sp, #8
 8010fee:	af00      	add	r7, sp, #0
 8010ff0:	6078      	str	r0, [r7, #4]
 8010ff2:	4608      	mov	r0, r1
 8010ff4:	4611      	mov	r1, r2
 8010ff6:	461a      	mov	r2, r3
 8010ff8:	4603      	mov	r3, r0
 8010ffa:	70fb      	strb	r3, [r7, #3]
 8010ffc:	460b      	mov	r3, r1
 8010ffe:	70bb      	strb	r3, [r7, #2]
 8011000:	4613      	mov	r3, r2
 8011002:	803b      	strh	r3, [r7, #0]

  HAL_PCD_EP_Open(pdev->pData, 
 8011004:	687b      	ldr	r3, [r7, #4]
 8011006:	f8d3 0220 	ldr.w	r0, [r3, #544]	; 0x220
 801100a:	78bb      	ldrb	r3, [r7, #2]
 801100c:	883a      	ldrh	r2, [r7, #0]
 801100e:	78f9      	ldrb	r1, [r7, #3]
 8011010:	f002 fc2a 	bl	8013868 <HAL_PCD_EP_Open>
                  ep_addr, 
                  ep_mps, 
                  ep_type);
  
  return USBD_OK; 
 8011014:	2300      	movs	r3, #0
}
 8011016:	4618      	mov	r0, r3
 8011018:	3708      	adds	r7, #8
 801101a:	46bd      	mov	sp, r7
 801101c:	bd80      	pop	{r7, pc}

0801101e <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 801101e:	b580      	push	{r7, lr}
 8011020:	b082      	sub	sp, #8
 8011022:	af00      	add	r7, sp, #0
 8011024:	6078      	str	r0, [r7, #4]
 8011026:	460b      	mov	r3, r1
 8011028:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 801102a:	687b      	ldr	r3, [r7, #4]
 801102c:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8011030:	78fa      	ldrb	r2, [r7, #3]
 8011032:	4611      	mov	r1, r2
 8011034:	4618      	mov	r0, r3
 8011036:	f002 fc80 	bl	801393a <HAL_PCD_EP_Close>
  return USBD_OK; 
 801103a:	2300      	movs	r3, #0
}
 801103c:	4618      	mov	r0, r3
 801103e:	3708      	adds	r7, #8
 8011040:	46bd      	mov	sp, r7
 8011042:	bd80      	pop	{r7, pc}

08011044 <USBD_LL_FlushEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8011044:	b580      	push	{r7, lr}
 8011046:	b082      	sub	sp, #8
 8011048:	af00      	add	r7, sp, #0
 801104a:	6078      	str	r0, [r7, #4]
 801104c:	460b      	mov	r3, r1
 801104e:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_Flush(pdev->pData, ep_addr);
 8011050:	687b      	ldr	r3, [r7, #4]
 8011052:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8011056:	78fa      	ldrb	r2, [r7, #3]
 8011058:	4611      	mov	r1, r2
 801105a:	4618      	mov	r0, r3
 801105c:	f002 fe2b 	bl	8013cb6 <HAL_PCD_EP_Flush>
  return USBD_OK; 
 8011060:	2300      	movs	r3, #0
}
 8011062:	4618      	mov	r0, r3
 8011064:	3708      	adds	r7, #8
 8011066:	46bd      	mov	sp, r7
 8011068:	bd80      	pop	{r7, pc}

0801106a <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 801106a:	b580      	push	{r7, lr}
 801106c:	b082      	sub	sp, #8
 801106e:	af00      	add	r7, sp, #0
 8011070:	6078      	str	r0, [r7, #4]
 8011072:	460b      	mov	r3, r1
 8011074:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8011076:	687b      	ldr	r3, [r7, #4]
 8011078:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 801107c:	78fa      	ldrb	r2, [r7, #3]
 801107e:	4611      	mov	r1, r2
 8011080:	4618      	mov	r0, r3
 8011082:	f002 fd70 	bl	8013b66 <HAL_PCD_EP_SetStall>
  return USBD_OK; 
 8011086:	2300      	movs	r3, #0
}
 8011088:	4618      	mov	r0, r3
 801108a:	3708      	adds	r7, #8
 801108c:	46bd      	mov	sp, r7
 801108e:	bd80      	pop	{r7, pc}

08011090 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8011090:	b580      	push	{r7, lr}
 8011092:	b082      	sub	sp, #8
 8011094:	af00      	add	r7, sp, #0
 8011096:	6078      	str	r0, [r7, #4]
 8011098:	460b      	mov	r3, r1
 801109a:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 801109c:	687b      	ldr	r3, [r7, #4]
 801109e:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 80110a2:	78fa      	ldrb	r2, [r7, #3]
 80110a4:	4611      	mov	r1, r2
 80110a6:	4618      	mov	r0, r3
 80110a8:	f002 fdb9 	bl	8013c1e <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
 80110ac:	2300      	movs	r3, #0
}
 80110ae:	4618      	mov	r0, r3
 80110b0:	3708      	adds	r7, #8
 80110b2:	46bd      	mov	sp, r7
 80110b4:	bd80      	pop	{r7, pc}

080110b6 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 80110b6:	b480      	push	{r7}
 80110b8:	b085      	sub	sp, #20
 80110ba:	af00      	add	r7, sp, #0
 80110bc:	6078      	str	r0, [r7, #4]
 80110be:	460b      	mov	r3, r1
 80110c0:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 80110c2:	687b      	ldr	r3, [r7, #4]
 80110c4:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 80110c8:	60fb      	str	r3, [r7, #12]
  
  if((ep_addr & 0x80) == 0x80)
 80110ca:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80110ce:	2b00      	cmp	r3, #0
 80110d0:	da0b      	bge.n	80110ea <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 80110d2:	78fb      	ldrb	r3, [r7, #3]
 80110d4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80110d8:	68f9      	ldr	r1, [r7, #12]
 80110da:	4613      	mov	r3, r2
 80110dc:	00db      	lsls	r3, r3, #3
 80110de:	1a9b      	subs	r3, r3, r2
 80110e0:	009b      	lsls	r3, r3, #2
 80110e2:	440b      	add	r3, r1
 80110e4:	333a      	adds	r3, #58	; 0x3a
 80110e6:	781b      	ldrb	r3, [r3, #0]
 80110e8:	e00b      	b.n	8011102 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 80110ea:	78fb      	ldrb	r3, [r7, #3]
 80110ec:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80110f0:	68f9      	ldr	r1, [r7, #12]
 80110f2:	4613      	mov	r3, r2
 80110f4:	00db      	lsls	r3, r3, #3
 80110f6:	1a9b      	subs	r3, r3, r2
 80110f8:	009b      	lsls	r3, r3, #2
 80110fa:	440b      	add	r3, r1
 80110fc:	f503 73ef 	add.w	r3, r3, #478	; 0x1de
 8011100:	781b      	ldrb	r3, [r3, #0]
  }
}
 8011102:	4618      	mov	r0, r3
 8011104:	3714      	adds	r7, #20
 8011106:	46bd      	mov	sp, r7
 8011108:	f85d 7b04 	ldr.w	r7, [sp], #4
 801110c:	4770      	bx	lr

0801110e <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 801110e:	b580      	push	{r7, lr}
 8011110:	b082      	sub	sp, #8
 8011112:	af00      	add	r7, sp, #0
 8011114:	6078      	str	r0, [r7, #4]
 8011116:	460b      	mov	r3, r1
 8011118:	70fb      	strb	r3, [r7, #3]
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 801111a:	687b      	ldr	r3, [r7, #4]
 801111c:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 8011120:	78fa      	ldrb	r2, [r7, #3]
 8011122:	4611      	mov	r1, r2
 8011124:	4618      	mov	r0, r3
 8011126:	f002 fb7e 	bl	8013826 <HAL_PCD_SetAddress>
  return USBD_OK; 
 801112a:	2300      	movs	r3, #0
}
 801112c:	4618      	mov	r0, r3
 801112e:	3708      	adds	r7, #8
 8011130:	46bd      	mov	sp, r7
 8011132:	bd80      	pop	{r7, pc}

08011134 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8011134:	b580      	push	{r7, lr}
 8011136:	b084      	sub	sp, #16
 8011138:	af00      	add	r7, sp, #0
 801113a:	60f8      	str	r0, [r7, #12]
 801113c:	607a      	str	r2, [r7, #4]
 801113e:	461a      	mov	r2, r3
 8011140:	460b      	mov	r3, r1
 8011142:	72fb      	strb	r3, [r7, #11]
 8011144:	4613      	mov	r3, r2
 8011146:	813b      	strh	r3, [r7, #8]

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8011148:	68fb      	ldr	r3, [r7, #12]
 801114a:	f8d3 0220 	ldr.w	r0, [r3, #544]	; 0x220
 801114e:	893b      	ldrh	r3, [r7, #8]
 8011150:	7af9      	ldrb	r1, [r7, #11]
 8011152:	687a      	ldr	r2, [r7, #4]
 8011154:	f002 fcaf 	bl	8013ab6 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
 8011158:	2300      	movs	r3, #0
}
 801115a:	4618      	mov	r0, r3
 801115c:	3710      	adds	r7, #16
 801115e:	46bd      	mov	sp, r7
 8011160:	bd80      	pop	{r7, pc}

08011162 <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8011162:	b580      	push	{r7, lr}
 8011164:	b084      	sub	sp, #16
 8011166:	af00      	add	r7, sp, #0
 8011168:	60f8      	str	r0, [r7, #12]
 801116a:	607a      	str	r2, [r7, #4]
 801116c:	461a      	mov	r2, r3
 801116e:	460b      	mov	r3, r1
 8011170:	72fb      	strb	r3, [r7, #11]
 8011172:	4613      	mov	r3, r2
 8011174:	813b      	strh	r3, [r7, #8]

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8011176:	68fb      	ldr	r3, [r7, #12]
 8011178:	f8d3 0220 	ldr.w	r0, [r3, #544]	; 0x220
 801117c:	893b      	ldrh	r3, [r7, #8]
 801117e:	7af9      	ldrb	r1, [r7, #11]
 8011180:	687a      	ldr	r2, [r7, #4]
 8011182:	f002 fc25 	bl	80139d0 <HAL_PCD_EP_Receive>
  return USBD_OK;   
 8011186:	2300      	movs	r3, #0
}
 8011188:	4618      	mov	r0, r3
 801118a:	3710      	adds	r7, #16
 801118c:	46bd      	mov	sp, r7
 801118e:	bd80      	pop	{r7, pc}

08011190 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 8011190:	b580      	push	{r7, lr}
 8011192:	b082      	sub	sp, #8
 8011194:	af00      	add	r7, sp, #0
 8011196:	6078      	str	r0, [r7, #4]
 8011198:	460b      	mov	r3, r1
 801119a:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 801119c:	687b      	ldr	r3, [r7, #4]
 801119e:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 80111a2:	78fa      	ldrb	r2, [r7, #3]
 80111a4:	4611      	mov	r1, r2
 80111a6:	4618      	mov	r0, r3
 80111a8:	f002 fc6c 	bl	8013a84 <HAL_PCD_EP_GetRxCount>
 80111ac:	4603      	mov	r3, r0
}
 80111ae:	4618      	mov	r0, r3
 80111b0:	3708      	adds	r7, #8
 80111b2:	46bd      	mov	sp, r7
 80111b4:	bd80      	pop	{r7, pc}
	...

080111b8 <USBD_HS_DeviceDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80111b8:	b480      	push	{r7}
 80111ba:	b083      	sub	sp, #12
 80111bc:	af00      	add	r7, sp, #0
 80111be:	4603      	mov	r3, r0
 80111c0:	6039      	str	r1, [r7, #0]
 80111c2:	71fb      	strb	r3, [r7, #7]
  *length = sizeof(USBD_HS_DeviceDesc);
 80111c4:	683b      	ldr	r3, [r7, #0]
 80111c6:	2212      	movs	r2, #18
 80111c8:	801a      	strh	r2, [r3, #0]
  return USBD_HS_DeviceDesc;
 80111ca:	4b03      	ldr	r3, [pc, #12]	; (80111d8 <USBD_HS_DeviceDescriptor+0x20>)
}
 80111cc:	4618      	mov	r0, r3
 80111ce:	370c      	adds	r7, #12
 80111d0:	46bd      	mov	sp, r7
 80111d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111d6:	4770      	bx	lr
 80111d8:	20000320 	.word	0x20000320

080111dc <USBD_HS_LangIDStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80111dc:	b480      	push	{r7}
 80111de:	b083      	sub	sp, #12
 80111e0:	af00      	add	r7, sp, #0
 80111e2:	4603      	mov	r3, r0
 80111e4:	6039      	str	r1, [r7, #0]
 80111e6:	71fb      	strb	r3, [r7, #7]
  *length =  sizeof(USBD_LangIDDesc);  
 80111e8:	683b      	ldr	r3, [r7, #0]
 80111ea:	2204      	movs	r2, #4
 80111ec:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 80111ee:	4b03      	ldr	r3, [pc, #12]	; (80111fc <USBD_HS_LangIDStrDescriptor+0x20>)
}
 80111f0:	4618      	mov	r0, r3
 80111f2:	370c      	adds	r7, #12
 80111f4:	46bd      	mov	sp, r7
 80111f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111fa:	4770      	bx	lr
 80111fc:	20000334 	.word	0x20000334

08011200 <USBD_HS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8011200:	b580      	push	{r7, lr}
 8011202:	b082      	sub	sp, #8
 8011204:	af00      	add	r7, sp, #0
 8011206:	4603      	mov	r3, r0
 8011208:	6039      	str	r1, [r7, #0]
 801120a:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 801120c:	79fb      	ldrb	r3, [r7, #7]
 801120e:	2b00      	cmp	r3, #0
 8011210:	d105      	bne.n	801121e <USBD_HS_ProductStrDescriptor+0x1e>
  {   
    USBD_GetString ((uint8_t *)USBD_PRODUCT_STRING_HS, USBD_StrDesc, length);
 8011212:	683a      	ldr	r2, [r7, #0]
 8011214:	4907      	ldr	r1, [pc, #28]	; (8011234 <USBD_HS_ProductStrDescriptor+0x34>)
 8011216:	4808      	ldr	r0, [pc, #32]	; (8011238 <USBD_HS_ProductStrDescriptor+0x38>)
 8011218:	f008 fb31 	bl	801987e <USBD_GetString>
 801121c:	e004      	b.n	8011228 <USBD_HS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString ((uint8_t *)USBD_PRODUCT_STRING_HS, USBD_StrDesc, length);    
 801121e:	683a      	ldr	r2, [r7, #0]
 8011220:	4904      	ldr	r1, [pc, #16]	; (8011234 <USBD_HS_ProductStrDescriptor+0x34>)
 8011222:	4805      	ldr	r0, [pc, #20]	; (8011238 <USBD_HS_ProductStrDescriptor+0x38>)
 8011224:	f008 fb2b 	bl	801987e <USBD_GetString>
  }
  return USBD_StrDesc;
 8011228:	4b02      	ldr	r3, [pc, #8]	; (8011234 <USBD_HS_ProductStrDescriptor+0x34>)
}
 801122a:	4618      	mov	r0, r3
 801122c:	3708      	adds	r7, #8
 801122e:	46bd      	mov	sp, r7
 8011230:	bd80      	pop	{r7, pc}
 8011232:	bf00      	nop
 8011234:	2000d838 	.word	0x2000d838
 8011238:	0801e18c 	.word	0x0801e18c

0801123c <USBD_HS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 801123c:	b580      	push	{r7, lr}
 801123e:	b082      	sub	sp, #8
 8011240:	af00      	add	r7, sp, #0
 8011242:	4603      	mov	r3, r0
 8011244:	6039      	str	r1, [r7, #0]
 8011246:	71fb      	strb	r3, [r7, #7]
  USBD_GetString ((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8011248:	683a      	ldr	r2, [r7, #0]
 801124a:	4904      	ldr	r1, [pc, #16]	; (801125c <USBD_HS_ManufacturerStrDescriptor+0x20>)
 801124c:	4804      	ldr	r0, [pc, #16]	; (8011260 <USBD_HS_ManufacturerStrDescriptor+0x24>)
 801124e:	f008 fb16 	bl	801987e <USBD_GetString>
  return USBD_StrDesc;
 8011252:	4b02      	ldr	r3, [pc, #8]	; (801125c <USBD_HS_ManufacturerStrDescriptor+0x20>)
}
 8011254:	4618      	mov	r0, r3
 8011256:	3708      	adds	r7, #8
 8011258:	46bd      	mov	sp, r7
 801125a:	bd80      	pop	{r7, pc}
 801125c:	2000d838 	.word	0x2000d838
 8011260:	0801e18c 	.word	0x0801e18c

08011264 <USBD_HS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8011264:	b580      	push	{r7, lr}
 8011266:	b082      	sub	sp, #8
 8011268:	af00      	add	r7, sp, #0
 801126a:	4603      	mov	r3, r0
 801126c:	6039      	str	r1, [r7, #0]
 801126e:	71fb      	strb	r3, [r7, #7]
  if(speed  == USBD_SPEED_HIGH)
 8011270:	79fb      	ldrb	r3, [r7, #7]
 8011272:	2b00      	cmp	r3, #0
 8011274:	d105      	bne.n	8011282 <USBD_HS_SerialStrDescriptor+0x1e>
  {    
    USBD_GetString ((uint8_t *)USBD_SERIALNUMBER_STRING_HS, USBD_StrDesc, length);
 8011276:	683a      	ldr	r2, [r7, #0]
 8011278:	4907      	ldr	r1, [pc, #28]	; (8011298 <USBD_HS_SerialStrDescriptor+0x34>)
 801127a:	4808      	ldr	r0, [pc, #32]	; (801129c <USBD_HS_SerialStrDescriptor+0x38>)
 801127c:	f008 faff 	bl	801987e <USBD_GetString>
 8011280:	e004      	b.n	801128c <USBD_HS_SerialStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString ((uint8_t *)USBD_SERIALNUMBER_STRING_HS, USBD_StrDesc, length);    
 8011282:	683a      	ldr	r2, [r7, #0]
 8011284:	4904      	ldr	r1, [pc, #16]	; (8011298 <USBD_HS_SerialStrDescriptor+0x34>)
 8011286:	4805      	ldr	r0, [pc, #20]	; (801129c <USBD_HS_SerialStrDescriptor+0x38>)
 8011288:	f008 faf9 	bl	801987e <USBD_GetString>
  }
  return USBD_StrDesc;
 801128c:	4b02      	ldr	r3, [pc, #8]	; (8011298 <USBD_HS_SerialStrDescriptor+0x34>)
}
 801128e:	4618      	mov	r0, r3
 8011290:	3708      	adds	r7, #8
 8011292:	46bd      	mov	sp, r7
 8011294:	bd80      	pop	{r7, pc}
 8011296:	bf00      	nop
 8011298:	2000d838 	.word	0x2000d838
 801129c:	0801e194 	.word	0x0801e194

080112a0 <USBD_HS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80112a0:	b580      	push	{r7, lr}
 80112a2:	b082      	sub	sp, #8
 80112a4:	af00      	add	r7, sp, #0
 80112a6:	4603      	mov	r3, r0
 80112a8:	6039      	str	r1, [r7, #0]
 80112aa:	71fb      	strb	r3, [r7, #7]
  if(speed  == USBD_SPEED_HIGH)
 80112ac:	79fb      	ldrb	r3, [r7, #7]
 80112ae:	2b00      	cmp	r3, #0
 80112b0:	d105      	bne.n	80112be <USBD_HS_ConfigStrDescriptor+0x1e>
  {  
    USBD_GetString ((uint8_t *)USBD_CONFIGURATION_STRING_HS, USBD_StrDesc, length);
 80112b2:	683a      	ldr	r2, [r7, #0]
 80112b4:	4907      	ldr	r1, [pc, #28]	; (80112d4 <USBD_HS_ConfigStrDescriptor+0x34>)
 80112b6:	4808      	ldr	r0, [pc, #32]	; (80112d8 <USBD_HS_ConfigStrDescriptor+0x38>)
 80112b8:	f008 fae1 	bl	801987e <USBD_GetString>
 80112bc:	e004      	b.n	80112c8 <USBD_HS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString ((uint8_t *)USBD_CONFIGURATION_STRING_HS, USBD_StrDesc, length); 
 80112be:	683a      	ldr	r2, [r7, #0]
 80112c0:	4904      	ldr	r1, [pc, #16]	; (80112d4 <USBD_HS_ConfigStrDescriptor+0x34>)
 80112c2:	4805      	ldr	r0, [pc, #20]	; (80112d8 <USBD_HS_ConfigStrDescriptor+0x38>)
 80112c4:	f008 fadb 	bl	801987e <USBD_GetString>
  }
  return USBD_StrDesc;  
 80112c8:	4b02      	ldr	r3, [pc, #8]	; (80112d4 <USBD_HS_ConfigStrDescriptor+0x34>)
}
 80112ca:	4618      	mov	r0, r3
 80112cc:	3708      	adds	r7, #8
 80112ce:	46bd      	mov	sp, r7
 80112d0:	bd80      	pop	{r7, pc}
 80112d2:	bf00      	nop
 80112d4:	2000d838 	.word	0x2000d838
 80112d8:	0801e1a4 	.word	0x0801e1a4

080112dc <USBD_HS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_HS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80112dc:	b580      	push	{r7, lr}
 80112de:	b082      	sub	sp, #8
 80112e0:	af00      	add	r7, sp, #0
 80112e2:	4603      	mov	r3, r0
 80112e4:	6039      	str	r1, [r7, #0]
 80112e6:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 80112e8:	79fb      	ldrb	r3, [r7, #7]
 80112ea:	2b00      	cmp	r3, #0
 80112ec:	d105      	bne.n	80112fa <USBD_HS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString ((uint8_t *)USBD_INTERFACE_STRING_HS, USBD_StrDesc, length);
 80112ee:	683a      	ldr	r2, [r7, #0]
 80112f0:	4907      	ldr	r1, [pc, #28]	; (8011310 <USBD_HS_InterfaceStrDescriptor+0x34>)
 80112f2:	4808      	ldr	r0, [pc, #32]	; (8011314 <USBD_HS_InterfaceStrDescriptor+0x38>)
 80112f4:	f008 fac3 	bl	801987e <USBD_GetString>
 80112f8:	e004      	b.n	8011304 <USBD_HS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString ((uint8_t *)USBD_INTERFACE_STRING_HS, USBD_StrDesc, length);
 80112fa:	683a      	ldr	r2, [r7, #0]
 80112fc:	4904      	ldr	r1, [pc, #16]	; (8011310 <USBD_HS_InterfaceStrDescriptor+0x34>)
 80112fe:	4805      	ldr	r0, [pc, #20]	; (8011314 <USBD_HS_InterfaceStrDescriptor+0x38>)
 8011300:	f008 fabd 	bl	801987e <USBD_GetString>
  }
  return USBD_StrDesc;  
 8011304:	4b02      	ldr	r3, [pc, #8]	; (8011310 <USBD_HS_InterfaceStrDescriptor+0x34>)
}
 8011306:	4618      	mov	r0, r3
 8011308:	3708      	adds	r7, #8
 801130a:	46bd      	mov	sp, r7
 801130c:	bd80      	pop	{r7, pc}
 801130e:	bf00      	nop
 8011310:	2000d838 	.word	0x2000d838
 8011314:	0801e1b0 	.word	0x0801e1b0

08011318 <STORAGE_Init_HS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_Init_HS (uint8_t lun)
{
 8011318:	b480      	push	{r7}
 801131a:	b083      	sub	sp, #12
 801131c:	af00      	add	r7, sp, #0
 801131e:	4603      	mov	r3, r0
 8011320:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 9 */ 
  return (USBD_OK);
 8011322:	2300      	movs	r3, #0
  /* USER CODE END 9 */ 
}
 8011324:	4618      	mov	r0, r3
 8011326:	370c      	adds	r7, #12
 8011328:	46bd      	mov	sp, r7
 801132a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801132e:	4770      	bx	lr

08011330 <STORAGE_GetCapacity_HS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetCapacity_HS (uint8_t lun, uint32_t *block_num, uint16_t *block_size)
{
 8011330:	b580      	push	{r7, lr}
 8011332:	b084      	sub	sp, #16
 8011334:	af00      	add	r7, sp, #0
 8011336:	4603      	mov	r3, r0
 8011338:	60b9      	str	r1, [r7, #8]
 801133a:	607a      	str	r2, [r7, #4]
 801133c:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 10 */   
	if (!secube_sdio_capacity(block_num, block_size))
 801133e:	6879      	ldr	r1, [r7, #4]
 8011340:	68b8      	ldr	r0, [r7, #8]
 8011342:	f7ff fa0d 	bl	8010760 <secube_sdio_capacity>
 8011346:	4603      	mov	r3, r0
 8011348:	f083 0301 	eor.w	r3, r3, #1
 801134c:	b2db      	uxtb	r3, r3
 801134e:	2b00      	cmp	r3, #0
 8011350:	d001      	beq.n	8011356 <STORAGE_GetCapacity_HS+0x26>
		return USBD_FAIL;
 8011352:	2302      	movs	r3, #2
 8011354:	e000      	b.n	8011358 <STORAGE_GetCapacity_HS+0x28>

	return USBD_OK;
 8011356:	2300      	movs	r3, #0
  /* USER CODE END 10 */ 
}
 8011358:	4618      	mov	r0, r3
 801135a:	3710      	adds	r7, #16
 801135c:	46bd      	mov	sp, r7
 801135e:	bd80      	pop	{r7, pc}

08011360 <STORAGE_IsReady_HS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t  STORAGE_IsReady_HS (uint8_t lun)
{
 8011360:	b580      	push	{r7, lr}
 8011362:	b082      	sub	sp, #8
 8011364:	af00      	add	r7, sp, #0
 8011366:	4603      	mov	r3, r0
 8011368:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 11 */ 
	if (!secube_sdio_isready())
 801136a:	f7ff fa23 	bl	80107b4 <secube_sdio_isready>
 801136e:	4603      	mov	r3, r0
 8011370:	f083 0301 	eor.w	r3, r3, #1
 8011374:	b2db      	uxtb	r3, r3
 8011376:	2b00      	cmp	r3, #0
 8011378:	d001      	beq.n	801137e <STORAGE_IsReady_HS+0x1e>
		return USBD_FAIL;
 801137a:	2302      	movs	r3, #2
 801137c:	e000      	b.n	8011380 <STORAGE_IsReady_HS+0x20>

	return USBD_OK;
 801137e:	2300      	movs	r3, #0
  /* USER CODE END 11 */ 
}
 8011380:	4618      	mov	r0, r3
 8011382:	3708      	adds	r7, #8
 8011384:	46bd      	mov	sp, r7
 8011386:	bd80      	pop	{r7, pc}

08011388 <STORAGE_IsWriteProtected_HS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t  STORAGE_IsWriteProtected_HS (uint8_t lun)
{
 8011388:	b480      	push	{r7}
 801138a:	b083      	sub	sp, #12
 801138c:	af00      	add	r7, sp, #0
 801138e:	4603      	mov	r3, r0
 8011390:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 12 */ 
  return (USBD_OK);
 8011392:	2300      	movs	r3, #0
  /* USER CODE END 12 */ 
}
 8011394:	4618      	mov	r0, r3
 8011396:	370c      	adds	r7, #12
 8011398:	46bd      	mov	sp, r7
 801139a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801139e:	4770      	bx	lr

080113a0 <STORAGE_Read_HS>:
*******************************************************************************/
int8_t STORAGE_Read_HS (uint8_t lun, 
                        uint8_t *buf, 
                        uint32_t blk_addr,                       
                        uint16_t blk_len)
{
 80113a0:	b580      	push	{r7, lr}
 80113a2:	b086      	sub	sp, #24
 80113a4:	af00      	add	r7, sp, #0
 80113a6:	60b9      	str	r1, [r7, #8]
 80113a8:	607a      	str	r2, [r7, #4]
 80113aa:	461a      	mov	r2, r3
 80113ac:	4603      	mov	r3, r0
 80113ae:	73fb      	strb	r3, [r7, #15]
 80113b0:	4613      	mov	r3, r2
 80113b2:	81bb      	strh	r3, [r7, #12]
  /* USER CODE BEGIN 13 */ 
	int32_t r = se3_proto_send(lun, buf, blk_addr, blk_len);
 80113b4:	89bb      	ldrh	r3, [r7, #12]
 80113b6:	7bf8      	ldrb	r0, [r7, #15]
 80113b8:	687a      	ldr	r2, [r7, #4]
 80113ba:	68b9      	ldr	r1, [r7, #8]
 80113bc:	f7fb fd22 	bl	800ce04 <se3_proto_send>
 80113c0:	6178      	str	r0, [r7, #20]
	if(r==SE3_PROTO_BUSY){
 80113c2:	697b      	ldr	r3, [r7, #20]
 80113c4:	2b02      	cmp	r3, #2
 80113c6:	d101      	bne.n	80113cc <STORAGE_Read_HS+0x2c>
		return USBD_BUSY;
 80113c8:	2301      	movs	r3, #1
 80113ca:	e005      	b.n	80113d8 <STORAGE_Read_HS+0x38>
	}
	else if(r==SE3_PROTO_OK){
 80113cc:	697b      	ldr	r3, [r7, #20]
 80113ce:	2b00      	cmp	r3, #0
 80113d0:	d101      	bne.n	80113d6 <STORAGE_Read_HS+0x36>
		return USBD_OK;
 80113d2:	2300      	movs	r3, #0
 80113d4:	e000      	b.n	80113d8 <STORAGE_Read_HS+0x38>
	}
	return USBD_FAIL;
 80113d6:	2302      	movs	r3, #2
	//if (_SEcube_device_send_data(lun, buf, blk_addr, blk_len) != PROTOCOL_OK)
	//	return USBD_FAIL;

	//return USBD_OK;
  /* USER CODE END 13 */ 
}
 80113d8:	4618      	mov	r0, r3
 80113da:	3718      	adds	r7, #24
 80113dc:	46bd      	mov	sp, r7
 80113de:	bd80      	pop	{r7, pc}

080113e0 <STORAGE_Write_HS>:
*******************************************************************************/
int8_t STORAGE_Write_HS (uint8_t lun, 
                         uint8_t *buf, 
                         uint32_t blk_addr,
                         uint16_t blk_len)
{
 80113e0:	b580      	push	{r7, lr}
 80113e2:	b084      	sub	sp, #16
 80113e4:	af00      	add	r7, sp, #0
 80113e6:	60b9      	str	r1, [r7, #8]
 80113e8:	607a      	str	r2, [r7, #4]
 80113ea:	461a      	mov	r2, r3
 80113ec:	4603      	mov	r3, r0
 80113ee:	73fb      	strb	r3, [r7, #15]
 80113f0:	4613      	mov	r3, r2
 80113f2:	81bb      	strh	r3, [r7, #12]
  /* USER CODE BEGIN 14 */ 
	if(SE3_PROTO_OK != se3_proto_recv(lun, buf, blk_addr, blk_len))
 80113f4:	89bb      	ldrh	r3, [r7, #12]
 80113f6:	7bf8      	ldrb	r0, [r7, #15]
 80113f8:	687a      	ldr	r2, [r7, #4]
 80113fa:	68b9      	ldr	r1, [r7, #8]
 80113fc:	f7fb fb86 	bl	800cb0c <se3_proto_recv>
 8011400:	4603      	mov	r3, r0
 8011402:	2b00      	cmp	r3, #0
 8011404:	d001      	beq.n	801140a <STORAGE_Write_HS+0x2a>
		return USBD_FAIL;
 8011406:	2302      	movs	r3, #2
 8011408:	e000      	b.n	801140c <STORAGE_Write_HS+0x2c>
	return USBD_OK;
 801140a:	2300      	movs	r3, #0
	//if (_SEcube_device_receive_data(lun, buf, blk_addr, blk_len) != PROTOCOL_OK)
	//	return USBD_FAIL;

	//return USBD_OK;
  /* USER CODE END 14 */ 
}
 801140c:	4618      	mov	r0, r3
 801140e:	3710      	adds	r7, #16
 8011410:	46bd      	mov	sp, r7
 8011412:	bd80      	pop	{r7, pc}

08011414 <STORAGE_GetMaxLun_HS>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int8_t STORAGE_GetMaxLun_HS (void)
{
 8011414:	b480      	push	{r7}
 8011416:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 15 */ 
  return (STORAGE_LUN_NBR - 1);
 8011418:	2300      	movs	r3, #0
  /* USER CODE END 15 */   
}
 801141a:	4618      	mov	r0, r3
 801141c:	46bd      	mov	sp, r7
 801141e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011422:	4770      	bx	lr

08011424 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8011424:	b480      	push	{r7}
 8011426:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8011428:	4b16      	ldr	r3, [pc, #88]	; (8011484 <SystemInit+0x60>)
 801142a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801142e:	4a15      	ldr	r2, [pc, #84]	; (8011484 <SystemInit+0x60>)
 8011430:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8011434:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8011438:	4b13      	ldr	r3, [pc, #76]	; (8011488 <SystemInit+0x64>)
 801143a:	681b      	ldr	r3, [r3, #0]
 801143c:	4a12      	ldr	r2, [pc, #72]	; (8011488 <SystemInit+0x64>)
 801143e:	f043 0301 	orr.w	r3, r3, #1
 8011442:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8011444:	4b10      	ldr	r3, [pc, #64]	; (8011488 <SystemInit+0x64>)
 8011446:	2200      	movs	r2, #0
 8011448:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 801144a:	4b0f      	ldr	r3, [pc, #60]	; (8011488 <SystemInit+0x64>)
 801144c:	681b      	ldr	r3, [r3, #0]
 801144e:	4a0e      	ldr	r2, [pc, #56]	; (8011488 <SystemInit+0x64>)
 8011450:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8011454:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8011458:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 801145a:	4b0b      	ldr	r3, [pc, #44]	; (8011488 <SystemInit+0x64>)
 801145c:	4a0b      	ldr	r2, [pc, #44]	; (801148c <SystemInit+0x68>)
 801145e:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8011460:	4b09      	ldr	r3, [pc, #36]	; (8011488 <SystemInit+0x64>)
 8011462:	681b      	ldr	r3, [r3, #0]
 8011464:	4a08      	ldr	r2, [pc, #32]	; (8011488 <SystemInit+0x64>)
 8011466:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 801146a:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 801146c:	4b06      	ldr	r3, [pc, #24]	; (8011488 <SystemInit+0x64>)
 801146e:	2200      	movs	r2, #0
 8011470:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8011472:	4b04      	ldr	r3, [pc, #16]	; (8011484 <SystemInit+0x60>)
 8011474:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8011478:	609a      	str	r2, [r3, #8]
#endif
}
 801147a:	bf00      	nop
 801147c:	46bd      	mov	sp, r7
 801147e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011482:	4770      	bx	lr
 8011484:	e000ed00 	.word	0xe000ed00
 8011488:	40023800 	.word	0x40023800
 801148c:	24003010 	.word	0x24003010

08011490 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8011490:	b580      	push	{r7, lr}
 8011492:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8011494:	4b0e      	ldr	r3, [pc, #56]	; (80114d0 <HAL_Init+0x40>)
 8011496:	681b      	ldr	r3, [r3, #0]
 8011498:	4a0d      	ldr	r2, [pc, #52]	; (80114d0 <HAL_Init+0x40>)
 801149a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801149e:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 80114a0:	4b0b      	ldr	r3, [pc, #44]	; (80114d0 <HAL_Init+0x40>)
 80114a2:	681b      	ldr	r3, [r3, #0]
 80114a4:	4a0a      	ldr	r2, [pc, #40]	; (80114d0 <HAL_Init+0x40>)
 80114a6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80114aa:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80114ac:	4b08      	ldr	r3, [pc, #32]	; (80114d0 <HAL_Init+0x40>)
 80114ae:	681b      	ldr	r3, [r3, #0]
 80114b0:	4a07      	ldr	r2, [pc, #28]	; (80114d0 <HAL_Init+0x40>)
 80114b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80114b6:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80114b8:	2003      	movs	r0, #3
 80114ba:	f000 fb8f 	bl	8011bdc <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80114be:	2000      	movs	r0, #0
 80114c0:	f000 f808 	bl	80114d4 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80114c4:	f7ff f9f4 	bl	80108b0 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 80114c8:	2300      	movs	r3, #0
}
 80114ca:	4618      	mov	r0, r3
 80114cc:	bd80      	pop	{r7, pc}
 80114ce:	bf00      	nop
 80114d0:	40023c00 	.word	0x40023c00

080114d4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80114d4:	b580      	push	{r7, lr}
 80114d6:	b082      	sub	sp, #8
 80114d8:	af00      	add	r7, sp, #0
 80114da:	6078      	str	r0, [r7, #4]
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 80114dc:	f003 f8e0 	bl	80146a0 <HAL_RCC_GetHCLKFreq>
 80114e0:	4602      	mov	r2, r0
 80114e2:	4b09      	ldr	r3, [pc, #36]	; (8011508 <HAL_InitTick+0x34>)
 80114e4:	fba3 2302 	umull	r2, r3, r3, r2
 80114e8:	099b      	lsrs	r3, r3, #6
 80114ea:	4618      	mov	r0, r3
 80114ec:	f000 fbab 	bl	8011c46 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 80114f0:	2200      	movs	r2, #0
 80114f2:	6879      	ldr	r1, [r7, #4]
 80114f4:	f04f 30ff 	mov.w	r0, #4294967295
 80114f8:	f000 fb7b 	bl	8011bf2 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
 80114fc:	2300      	movs	r3, #0
}
 80114fe:	4618      	mov	r0, r3
 8011500:	3708      	adds	r7, #8
 8011502:	46bd      	mov	sp, r7
 8011504:	bd80      	pop	{r7, pc}
 8011506:	bf00      	nop
 8011508:	10624dd3 	.word	0x10624dd3

0801150c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 801150c:	b480      	push	{r7}
 801150e:	af00      	add	r7, sp, #0
  uwTick++;
 8011510:	4b04      	ldr	r3, [pc, #16]	; (8011524 <HAL_IncTick+0x18>)
 8011512:	681b      	ldr	r3, [r3, #0]
 8011514:	3301      	adds	r3, #1
 8011516:	4a03      	ldr	r2, [pc, #12]	; (8011524 <HAL_IncTick+0x18>)
 8011518:	6013      	str	r3, [r2, #0]
}
 801151a:	bf00      	nop
 801151c:	46bd      	mov	sp, r7
 801151e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011522:	4770      	bx	lr
 8011524:	2000da38 	.word	0x2000da38

08011528 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8011528:	b480      	push	{r7}
 801152a:	af00      	add	r7, sp, #0
  return uwTick;
 801152c:	4b03      	ldr	r3, [pc, #12]	; (801153c <HAL_GetTick+0x14>)
 801152e:	681b      	ldr	r3, [r3, #0]
}
 8011530:	4618      	mov	r0, r3
 8011532:	46bd      	mov	sp, r7
 8011534:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011538:	4770      	bx	lr
 801153a:	bf00      	nop
 801153c:	2000da38 	.word	0x2000da38

08011540 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8011540:	b580      	push	{r7, lr}
 8011542:	b084      	sub	sp, #16
 8011544:	af00      	add	r7, sp, #0
 8011546:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8011548:	2300      	movs	r3, #0
 801154a:	60fb      	str	r3, [r7, #12]
  tickstart = HAL_GetTick();
 801154c:	f7ff ffec 	bl	8011528 <HAL_GetTick>
 8011550:	60f8      	str	r0, [r7, #12]
  while((HAL_GetTick() - tickstart) < Delay)
 8011552:	bf00      	nop
 8011554:	f7ff ffe8 	bl	8011528 <HAL_GetTick>
 8011558:	4602      	mov	r2, r0
 801155a:	68fb      	ldr	r3, [r7, #12]
 801155c:	1ad2      	subs	r2, r2, r3
 801155e:	687b      	ldr	r3, [r7, #4]
 8011560:	429a      	cmp	r2, r3
 8011562:	d3f7      	bcc.n	8011554 <HAL_Delay+0x14>
  {
  }
}
 8011564:	bf00      	nop
 8011566:	3710      	adds	r7, #16
 8011568:	46bd      	mov	sp, r7
 801156a:	bd80      	pop	{r7, pc}

0801156c <HAL_ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 801156c:	b580      	push	{r7, lr}
 801156e:	b084      	sub	sp, #16
 8011570:	af00      	add	r7, sp, #0
 8011572:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8011574:	2300      	movs	r3, #0
 8011576:	73fb      	strb	r3, [r7, #15]
  
  /* Check ADC handle */
  if(hadc == NULL)
 8011578:	687b      	ldr	r3, [r7, #4]
 801157a:	2b00      	cmp	r3, #0
 801157c:	d101      	bne.n	8011582 <HAL_ADC_Init+0x16>
  {
    return HAL_ERROR;
 801157e:	2301      	movs	r3, #1
 8011580:	e033      	b.n	80115ea <HAL_ADC_Init+0x7e>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }
  
  if(hadc->State == HAL_ADC_STATE_RESET)
 8011582:	687b      	ldr	r3, [r7, #4]
 8011584:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011586:	2b00      	cmp	r3, #0
 8011588:	d109      	bne.n	801159e <HAL_ADC_Init+0x32>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 801158a:	687b      	ldr	r3, [r7, #4]
 801158c:	2200      	movs	r2, #0
 801158e:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8011590:	687b      	ldr	r3, [r7, #4]
 8011592:	2200      	movs	r2, #0
 8011594:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8011598:	6878      	ldr	r0, [r7, #4]
 801159a:	f7fe fb77 	bl	800fc8c <HAL_ADC_MspInit>
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 801159e:	687b      	ldr	r3, [r7, #4]
 80115a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80115a2:	f003 0310 	and.w	r3, r3, #16
 80115a6:	2b00      	cmp	r3, #0
 80115a8:	d118      	bne.n	80115dc <HAL_ADC_Init+0x70>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80115aa:	687b      	ldr	r3, [r7, #4]
 80115ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80115ae:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80115b2:	f023 0302 	bic.w	r3, r3, #2
 80115b6:	f043 0202 	orr.w	r2, r3, #2
 80115ba:	687b      	ldr	r3, [r7, #4]
 80115bc:	641a      	str	r2, [r3, #64]	; 0x40
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);
    
    /* Set ADC parameters */
    ADC_Init(hadc);
 80115be:	6878      	ldr	r0, [r7, #4]
 80115c0:	f000 f93c 	bl	801183c <ADC_Init>
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 80115c4:	687b      	ldr	r3, [r7, #4]
 80115c6:	2200      	movs	r2, #0
 80115c8:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Set the ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80115ca:	687b      	ldr	r3, [r7, #4]
 80115cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80115ce:	f023 0303 	bic.w	r3, r3, #3
 80115d2:	f043 0201 	orr.w	r2, r3, #1
 80115d6:	687b      	ldr	r3, [r7, #4]
 80115d8:	641a      	str	r2, [r3, #64]	; 0x40
 80115da:	e001      	b.n	80115e0 <HAL_ADC_Init+0x74>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    tmp_hal_status = HAL_ERROR;
 80115dc:	2301      	movs	r3, #1
 80115de:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80115e0:	687b      	ldr	r3, [r7, #4]
 80115e2:	2200      	movs	r2, #0
 80115e4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return tmp_hal_status;
 80115e8:	7bfb      	ldrb	r3, [r7, #15]
}
 80115ea:	4618      	mov	r0, r3
 80115ec:	3710      	adds	r7, #16
 80115ee:	46bd      	mov	sp, r7
 80115f0:	bd80      	pop	{r7, pc}
	...

080115f4 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig: ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 80115f4:	b480      	push	{r7}
 80115f6:	b085      	sub	sp, #20
 80115f8:	af00      	add	r7, sp, #0
 80115fa:	6078      	str	r0, [r7, #4]
 80115fc:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0U;
 80115fe:	2300      	movs	r3, #0
 8011600:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8011602:	687b      	ldr	r3, [r7, #4]
 8011604:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8011608:	2b01      	cmp	r3, #1
 801160a:	d101      	bne.n	8011610 <HAL_ADC_ConfigChannel+0x1c>
 801160c:	2302      	movs	r3, #2
 801160e:	e105      	b.n	801181c <HAL_ADC_ConfigChannel+0x228>
 8011610:	687b      	ldr	r3, [r7, #4]
 8011612:	2201      	movs	r2, #1
 8011614:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (sConfig->Channel > ADC_CHANNEL_9)
 8011618:	683b      	ldr	r3, [r7, #0]
 801161a:	681b      	ldr	r3, [r3, #0]
 801161c:	2b09      	cmp	r3, #9
 801161e:	d925      	bls.n	801166c <HAL_ADC_ConfigChannel+0x78>
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8011620:	687b      	ldr	r3, [r7, #4]
 8011622:	681b      	ldr	r3, [r3, #0]
 8011624:	68d9      	ldr	r1, [r3, #12]
 8011626:	683b      	ldr	r3, [r7, #0]
 8011628:	681b      	ldr	r3, [r3, #0]
 801162a:	b29b      	uxth	r3, r3
 801162c:	461a      	mov	r2, r3
 801162e:	4613      	mov	r3, r2
 8011630:	005b      	lsls	r3, r3, #1
 8011632:	4413      	add	r3, r2
 8011634:	3b1e      	subs	r3, #30
 8011636:	2207      	movs	r2, #7
 8011638:	fa02 f303 	lsl.w	r3, r2, r3
 801163c:	43da      	mvns	r2, r3
 801163e:	687b      	ldr	r3, [r7, #4]
 8011640:	681b      	ldr	r3, [r3, #0]
 8011642:	400a      	ands	r2, r1
 8011644:	60da      	str	r2, [r3, #12]
    
    /* Set the new sample time */
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8011646:	687b      	ldr	r3, [r7, #4]
 8011648:	681b      	ldr	r3, [r3, #0]
 801164a:	68d9      	ldr	r1, [r3, #12]
 801164c:	683b      	ldr	r3, [r7, #0]
 801164e:	689a      	ldr	r2, [r3, #8]
 8011650:	683b      	ldr	r3, [r7, #0]
 8011652:	681b      	ldr	r3, [r3, #0]
 8011654:	b29b      	uxth	r3, r3
 8011656:	4618      	mov	r0, r3
 8011658:	4603      	mov	r3, r0
 801165a:	005b      	lsls	r3, r3, #1
 801165c:	4403      	add	r3, r0
 801165e:	3b1e      	subs	r3, #30
 8011660:	409a      	lsls	r2, r3
 8011662:	687b      	ldr	r3, [r7, #4]
 8011664:	681b      	ldr	r3, [r3, #0]
 8011666:	430a      	orrs	r2, r1
 8011668:	60da      	str	r2, [r3, #12]
 801166a:	e022      	b.n	80116b2 <HAL_ADC_ConfigChannel+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 801166c:	687b      	ldr	r3, [r7, #4]
 801166e:	681b      	ldr	r3, [r3, #0]
 8011670:	6919      	ldr	r1, [r3, #16]
 8011672:	683b      	ldr	r3, [r7, #0]
 8011674:	681b      	ldr	r3, [r3, #0]
 8011676:	b29b      	uxth	r3, r3
 8011678:	461a      	mov	r2, r3
 801167a:	4613      	mov	r3, r2
 801167c:	005b      	lsls	r3, r3, #1
 801167e:	4413      	add	r3, r2
 8011680:	2207      	movs	r2, #7
 8011682:	fa02 f303 	lsl.w	r3, r2, r3
 8011686:	43da      	mvns	r2, r3
 8011688:	687b      	ldr	r3, [r7, #4]
 801168a:	681b      	ldr	r3, [r3, #0]
 801168c:	400a      	ands	r2, r1
 801168e:	611a      	str	r2, [r3, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8011690:	687b      	ldr	r3, [r7, #4]
 8011692:	681b      	ldr	r3, [r3, #0]
 8011694:	6919      	ldr	r1, [r3, #16]
 8011696:	683b      	ldr	r3, [r7, #0]
 8011698:	689a      	ldr	r2, [r3, #8]
 801169a:	683b      	ldr	r3, [r7, #0]
 801169c:	681b      	ldr	r3, [r3, #0]
 801169e:	b29b      	uxth	r3, r3
 80116a0:	4618      	mov	r0, r3
 80116a2:	4603      	mov	r3, r0
 80116a4:	005b      	lsls	r3, r3, #1
 80116a6:	4403      	add	r3, r0
 80116a8:	409a      	lsls	r2, r3
 80116aa:	687b      	ldr	r3, [r7, #4]
 80116ac:	681b      	ldr	r3, [r3, #0]
 80116ae:	430a      	orrs	r2, r1
 80116b0:	611a      	str	r2, [r3, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7U)
 80116b2:	683b      	ldr	r3, [r7, #0]
 80116b4:	685b      	ldr	r3, [r3, #4]
 80116b6:	2b06      	cmp	r3, #6
 80116b8:	d824      	bhi.n	8011704 <HAL_ADC_ConfigChannel+0x110>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80116ba:	687b      	ldr	r3, [r7, #4]
 80116bc:	681b      	ldr	r3, [r3, #0]
 80116be:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80116c0:	683b      	ldr	r3, [r7, #0]
 80116c2:	685a      	ldr	r2, [r3, #4]
 80116c4:	4613      	mov	r3, r2
 80116c6:	009b      	lsls	r3, r3, #2
 80116c8:	4413      	add	r3, r2
 80116ca:	3b05      	subs	r3, #5
 80116cc:	221f      	movs	r2, #31
 80116ce:	fa02 f303 	lsl.w	r3, r2, r3
 80116d2:	43da      	mvns	r2, r3
 80116d4:	687b      	ldr	r3, [r7, #4]
 80116d6:	681b      	ldr	r3, [r3, #0]
 80116d8:	400a      	ands	r2, r1
 80116da:	635a      	str	r2, [r3, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	681b      	ldr	r3, [r3, #0]
 80116e0:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80116e2:	683b      	ldr	r3, [r7, #0]
 80116e4:	681b      	ldr	r3, [r3, #0]
 80116e6:	b29b      	uxth	r3, r3
 80116e8:	4618      	mov	r0, r3
 80116ea:	683b      	ldr	r3, [r7, #0]
 80116ec:	685a      	ldr	r2, [r3, #4]
 80116ee:	4613      	mov	r3, r2
 80116f0:	009b      	lsls	r3, r3, #2
 80116f2:	4413      	add	r3, r2
 80116f4:	3b05      	subs	r3, #5
 80116f6:	fa00 f203 	lsl.w	r2, r0, r3
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	681b      	ldr	r3, [r3, #0]
 80116fe:	430a      	orrs	r2, r1
 8011700:	635a      	str	r2, [r3, #52]	; 0x34
 8011702:	e04c      	b.n	801179e <HAL_ADC_ConfigChannel+0x1aa>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13U)
 8011704:	683b      	ldr	r3, [r7, #0]
 8011706:	685b      	ldr	r3, [r3, #4]
 8011708:	2b0c      	cmp	r3, #12
 801170a:	d824      	bhi.n	8011756 <HAL_ADC_ConfigChannel+0x162>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 801170c:	687b      	ldr	r3, [r7, #4]
 801170e:	681b      	ldr	r3, [r3, #0]
 8011710:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8011712:	683b      	ldr	r3, [r7, #0]
 8011714:	685a      	ldr	r2, [r3, #4]
 8011716:	4613      	mov	r3, r2
 8011718:	009b      	lsls	r3, r3, #2
 801171a:	4413      	add	r3, r2
 801171c:	3b23      	subs	r3, #35	; 0x23
 801171e:	221f      	movs	r2, #31
 8011720:	fa02 f303 	lsl.w	r3, r2, r3
 8011724:	43da      	mvns	r2, r3
 8011726:	687b      	ldr	r3, [r7, #4]
 8011728:	681b      	ldr	r3, [r3, #0]
 801172a:	400a      	ands	r2, r1
 801172c:	631a      	str	r2, [r3, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 801172e:	687b      	ldr	r3, [r7, #4]
 8011730:	681b      	ldr	r3, [r3, #0]
 8011732:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8011734:	683b      	ldr	r3, [r7, #0]
 8011736:	681b      	ldr	r3, [r3, #0]
 8011738:	b29b      	uxth	r3, r3
 801173a:	4618      	mov	r0, r3
 801173c:	683b      	ldr	r3, [r7, #0]
 801173e:	685a      	ldr	r2, [r3, #4]
 8011740:	4613      	mov	r3, r2
 8011742:	009b      	lsls	r3, r3, #2
 8011744:	4413      	add	r3, r2
 8011746:	3b23      	subs	r3, #35	; 0x23
 8011748:	fa00 f203 	lsl.w	r2, r0, r3
 801174c:	687b      	ldr	r3, [r7, #4]
 801174e:	681b      	ldr	r3, [r3, #0]
 8011750:	430a      	orrs	r2, r1
 8011752:	631a      	str	r2, [r3, #48]	; 0x30
 8011754:	e023      	b.n	801179e <HAL_ADC_ConfigChannel+0x1aa>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8011756:	687b      	ldr	r3, [r7, #4]
 8011758:	681b      	ldr	r3, [r3, #0]
 801175a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801175c:	683b      	ldr	r3, [r7, #0]
 801175e:	685a      	ldr	r2, [r3, #4]
 8011760:	4613      	mov	r3, r2
 8011762:	009b      	lsls	r3, r3, #2
 8011764:	4413      	add	r3, r2
 8011766:	3b41      	subs	r3, #65	; 0x41
 8011768:	221f      	movs	r2, #31
 801176a:	fa02 f303 	lsl.w	r3, r2, r3
 801176e:	43da      	mvns	r2, r3
 8011770:	687b      	ldr	r3, [r7, #4]
 8011772:	681b      	ldr	r3, [r3, #0]
 8011774:	400a      	ands	r2, r1
 8011776:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8011778:	687b      	ldr	r3, [r7, #4]
 801177a:	681b      	ldr	r3, [r3, #0]
 801177c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801177e:	683b      	ldr	r3, [r7, #0]
 8011780:	681b      	ldr	r3, [r3, #0]
 8011782:	b29b      	uxth	r3, r3
 8011784:	4618      	mov	r0, r3
 8011786:	683b      	ldr	r3, [r7, #0]
 8011788:	685a      	ldr	r2, [r3, #4]
 801178a:	4613      	mov	r3, r2
 801178c:	009b      	lsls	r3, r3, #2
 801178e:	4413      	add	r3, r2
 8011790:	3b41      	subs	r3, #65	; 0x41
 8011792:	fa00 f203 	lsl.w	r2, r0, r3
 8011796:	687b      	ldr	r3, [r7, #4]
 8011798:	681b      	ldr	r3, [r3, #0]
 801179a:	430a      	orrs	r2, r1
 801179c:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 801179e:	687b      	ldr	r3, [r7, #4]
 80117a0:	681b      	ldr	r3, [r3, #0]
 80117a2:	4a21      	ldr	r2, [pc, #132]	; (8011828 <HAL_ADC_ConfigChannel+0x234>)
 80117a4:	4293      	cmp	r3, r2
 80117a6:	d109      	bne.n	80117bc <HAL_ADC_ConfigChannel+0x1c8>
 80117a8:	683b      	ldr	r3, [r7, #0]
 80117aa:	681b      	ldr	r3, [r3, #0]
 80117ac:	2b12      	cmp	r3, #18
 80117ae:	d105      	bne.n	80117bc <HAL_ADC_ConfigChannel+0x1c8>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 80117b0:	4b1e      	ldr	r3, [pc, #120]	; (801182c <HAL_ADC_ConfigChannel+0x238>)
 80117b2:	685b      	ldr	r3, [r3, #4]
 80117b4:	4a1d      	ldr	r2, [pc, #116]	; (801182c <HAL_ADC_ConfigChannel+0x238>)
 80117b6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80117ba:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80117bc:	687b      	ldr	r3, [r7, #4]
 80117be:	681b      	ldr	r3, [r3, #0]
 80117c0:	4a19      	ldr	r2, [pc, #100]	; (8011828 <HAL_ADC_ConfigChannel+0x234>)
 80117c2:	4293      	cmp	r3, r2
 80117c4:	d125      	bne.n	8011812 <HAL_ADC_ConfigChannel+0x21e>
 80117c6:	683b      	ldr	r3, [r7, #0]
 80117c8:	681b      	ldr	r3, [r3, #0]
 80117ca:	4a19      	ldr	r2, [pc, #100]	; (8011830 <HAL_ADC_ConfigChannel+0x23c>)
 80117cc:	4293      	cmp	r3, r2
 80117ce:	d003      	beq.n	80117d8 <HAL_ADC_ConfigChannel+0x1e4>
 80117d0:	683b      	ldr	r3, [r7, #0]
 80117d2:	681b      	ldr	r3, [r3, #0]
 80117d4:	2b11      	cmp	r3, #17
 80117d6:	d11c      	bne.n	8011812 <HAL_ADC_ConfigChannel+0x21e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 80117d8:	4b14      	ldr	r3, [pc, #80]	; (801182c <HAL_ADC_ConfigChannel+0x238>)
 80117da:	685b      	ldr	r3, [r3, #4]
 80117dc:	4a13      	ldr	r2, [pc, #76]	; (801182c <HAL_ADC_ConfigChannel+0x238>)
 80117de:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80117e2:	6053      	str	r3, [r2, #4]
    
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 80117e4:	683b      	ldr	r3, [r7, #0]
 80117e6:	681b      	ldr	r3, [r3, #0]
 80117e8:	4a11      	ldr	r2, [pc, #68]	; (8011830 <HAL_ADC_ConfigChannel+0x23c>)
 80117ea:	4293      	cmp	r3, r2
 80117ec:	d111      	bne.n	8011812 <HAL_ADC_ConfigChannel+0x21e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80117ee:	4b11      	ldr	r3, [pc, #68]	; (8011834 <HAL_ADC_ConfigChannel+0x240>)
 80117f0:	681b      	ldr	r3, [r3, #0]
 80117f2:	4a11      	ldr	r2, [pc, #68]	; (8011838 <HAL_ADC_ConfigChannel+0x244>)
 80117f4:	fba2 2303 	umull	r2, r3, r2, r3
 80117f8:	0c9a      	lsrs	r2, r3, #18
 80117fa:	4613      	mov	r3, r2
 80117fc:	009b      	lsls	r3, r3, #2
 80117fe:	4413      	add	r3, r2
 8011800:	005b      	lsls	r3, r3, #1
 8011802:	60fb      	str	r3, [r7, #12]
      while(counter != 0U)
 8011804:	e002      	b.n	801180c <HAL_ADC_ConfigChannel+0x218>
      {
        counter--;
 8011806:	68fb      	ldr	r3, [r7, #12]
 8011808:	3b01      	subs	r3, #1
 801180a:	60fb      	str	r3, [r7, #12]
      while(counter != 0U)
 801180c:	68fb      	ldr	r3, [r7, #12]
 801180e:	2b00      	cmp	r3, #0
 8011810:	d1f9      	bne.n	8011806 <HAL_ADC_ConfigChannel+0x212>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8011812:	687b      	ldr	r3, [r7, #4]
 8011814:	2200      	movs	r2, #0
 8011816:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 801181a:	2300      	movs	r3, #0
}
 801181c:	4618      	mov	r0, r3
 801181e:	3714      	adds	r7, #20
 8011820:	46bd      	mov	sp, r7
 8011822:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011826:	4770      	bx	lr
 8011828:	40012000 	.word	0x40012000
 801182c:	40012300 	.word	0x40012300
 8011830:	10000012 	.word	0x10000012
 8011834:	20000358 	.word	0x20000358
 8011838:	431bde83 	.word	0x431bde83

0801183c <ADC_Init>:
  * @param  hadc: pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 801183c:	b480      	push	{r7}
 801183e:	b085      	sub	sp, #20
 8011840:	af00      	add	r7, sp, #0
 8011842:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8011844:	4b7d      	ldr	r3, [pc, #500]	; (8011a3c <ADC_Init+0x200>)
 8011846:	685b      	ldr	r3, [r3, #4]
 8011848:	4a7c      	ldr	r2, [pc, #496]	; (8011a3c <ADC_Init+0x200>)
 801184a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 801184e:	6053      	str	r3, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8011850:	4b7a      	ldr	r3, [pc, #488]	; (8011a3c <ADC_Init+0x200>)
 8011852:	685a      	ldr	r2, [r3, #4]
 8011854:	687b      	ldr	r3, [r7, #4]
 8011856:	685b      	ldr	r3, [r3, #4]
 8011858:	4978      	ldr	r1, [pc, #480]	; (8011a3c <ADC_Init+0x200>)
 801185a:	4313      	orrs	r3, r2
 801185c:	604b      	str	r3, [r1, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 801185e:	687b      	ldr	r3, [r7, #4]
 8011860:	681b      	ldr	r3, [r3, #0]
 8011862:	685a      	ldr	r2, [r3, #4]
 8011864:	687b      	ldr	r3, [r7, #4]
 8011866:	681b      	ldr	r3, [r3, #0]
 8011868:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 801186c:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 801186e:	687b      	ldr	r3, [r7, #4]
 8011870:	681b      	ldr	r3, [r3, #0]
 8011872:	6859      	ldr	r1, [r3, #4]
 8011874:	687b      	ldr	r3, [r7, #4]
 8011876:	691b      	ldr	r3, [r3, #16]
 8011878:	021a      	lsls	r2, r3, #8
 801187a:	687b      	ldr	r3, [r7, #4]
 801187c:	681b      	ldr	r3, [r3, #0]
 801187e:	430a      	orrs	r2, r1
 8011880:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8011882:	687b      	ldr	r3, [r7, #4]
 8011884:	681b      	ldr	r3, [r3, #0]
 8011886:	685a      	ldr	r2, [r3, #4]
 8011888:	687b      	ldr	r3, [r7, #4]
 801188a:	681b      	ldr	r3, [r3, #0]
 801188c:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8011890:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8011892:	687b      	ldr	r3, [r7, #4]
 8011894:	681b      	ldr	r3, [r3, #0]
 8011896:	6859      	ldr	r1, [r3, #4]
 8011898:	687b      	ldr	r3, [r7, #4]
 801189a:	689a      	ldr	r2, [r3, #8]
 801189c:	687b      	ldr	r3, [r7, #4]
 801189e:	681b      	ldr	r3, [r3, #0]
 80118a0:	430a      	orrs	r2, r1
 80118a2:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 80118a4:	687b      	ldr	r3, [r7, #4]
 80118a6:	681b      	ldr	r3, [r3, #0]
 80118a8:	689a      	ldr	r2, [r3, #8]
 80118aa:	687b      	ldr	r3, [r7, #4]
 80118ac:	681b      	ldr	r3, [r3, #0]
 80118ae:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80118b2:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80118b4:	687b      	ldr	r3, [r7, #4]
 80118b6:	681b      	ldr	r3, [r3, #0]
 80118b8:	6899      	ldr	r1, [r3, #8]
 80118ba:	687b      	ldr	r3, [r7, #4]
 80118bc:	68da      	ldr	r2, [r3, #12]
 80118be:	687b      	ldr	r3, [r7, #4]
 80118c0:	681b      	ldr	r3, [r3, #0]
 80118c2:	430a      	orrs	r2, r1
 80118c4:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80118c6:	687b      	ldr	r3, [r7, #4]
 80118c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80118ca:	4a5d      	ldr	r2, [pc, #372]	; (8011a40 <ADC_Init+0x204>)
 80118cc:	4293      	cmp	r3, r2
 80118ce:	d022      	beq.n	8011916 <ADC_Init+0xda>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80118d0:	687b      	ldr	r3, [r7, #4]
 80118d2:	681b      	ldr	r3, [r3, #0]
 80118d4:	689a      	ldr	r2, [r3, #8]
 80118d6:	687b      	ldr	r3, [r7, #4]
 80118d8:	681b      	ldr	r3, [r3, #0]
 80118da:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80118de:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 80118e0:	687b      	ldr	r3, [r7, #4]
 80118e2:	681b      	ldr	r3, [r3, #0]
 80118e4:	6899      	ldr	r1, [r3, #8]
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80118ea:	687b      	ldr	r3, [r7, #4]
 80118ec:	681b      	ldr	r3, [r3, #0]
 80118ee:	430a      	orrs	r2, r1
 80118f0:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80118f2:	687b      	ldr	r3, [r7, #4]
 80118f4:	681b      	ldr	r3, [r3, #0]
 80118f6:	689a      	ldr	r2, [r3, #8]
 80118f8:	687b      	ldr	r3, [r7, #4]
 80118fa:	681b      	ldr	r3, [r3, #0]
 80118fc:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8011900:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8011902:	687b      	ldr	r3, [r7, #4]
 8011904:	681b      	ldr	r3, [r3, #0]
 8011906:	6899      	ldr	r1, [r3, #8]
 8011908:	687b      	ldr	r3, [r7, #4]
 801190a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801190c:	687b      	ldr	r3, [r7, #4]
 801190e:	681b      	ldr	r3, [r3, #0]
 8011910:	430a      	orrs	r2, r1
 8011912:	609a      	str	r2, [r3, #8]
 8011914:	e00f      	b.n	8011936 <ADC_Init+0xfa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8011916:	687b      	ldr	r3, [r7, #4]
 8011918:	681b      	ldr	r3, [r3, #0]
 801191a:	689a      	ldr	r2, [r3, #8]
 801191c:	687b      	ldr	r3, [r7, #4]
 801191e:	681b      	ldr	r3, [r3, #0]
 8011920:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8011924:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8011926:	687b      	ldr	r3, [r7, #4]
 8011928:	681b      	ldr	r3, [r3, #0]
 801192a:	689a      	ldr	r2, [r3, #8]
 801192c:	687b      	ldr	r3, [r7, #4]
 801192e:	681b      	ldr	r3, [r3, #0]
 8011930:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8011934:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8011936:	687b      	ldr	r3, [r7, #4]
 8011938:	681b      	ldr	r3, [r3, #0]
 801193a:	689a      	ldr	r2, [r3, #8]
 801193c:	687b      	ldr	r3, [r7, #4]
 801193e:	681b      	ldr	r3, [r3, #0]
 8011940:	f022 0202 	bic.w	r2, r2, #2
 8011944:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
 8011946:	687b      	ldr	r3, [r7, #4]
 8011948:	681b      	ldr	r3, [r3, #0]
 801194a:	6899      	ldr	r1, [r3, #8]
 801194c:	687b      	ldr	r3, [r7, #4]
 801194e:	699b      	ldr	r3, [r3, #24]
 8011950:	005a      	lsls	r2, r3, #1
 8011952:	687b      	ldr	r3, [r7, #4]
 8011954:	681b      	ldr	r3, [r3, #0]
 8011956:	430a      	orrs	r2, r1
 8011958:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 801195a:	687b      	ldr	r3, [r7, #4]
 801195c:	6a1b      	ldr	r3, [r3, #32]
 801195e:	2b00      	cmp	r3, #0
 8011960:	d026      	beq.n	80119b0 <ADC_Init+0x174>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8011962:	687b      	ldr	r3, [r7, #4]
 8011964:	681b      	ldr	r3, [r3, #0]
 8011966:	685a      	ldr	r2, [r3, #4]
 8011968:	687b      	ldr	r3, [r7, #4]
 801196a:	681b      	ldr	r3, [r3, #0]
 801196c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8011970:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8011972:	687b      	ldr	r3, [r7, #4]
 8011974:	681b      	ldr	r3, [r3, #0]
 8011976:	685a      	ldr	r2, [r3, #4]
 8011978:	687b      	ldr	r3, [r7, #4]
 801197a:	681b      	ldr	r3, [r3, #0]
 801197c:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8011980:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8011982:	687b      	ldr	r3, [r7, #4]
 8011984:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011986:	1e5a      	subs	r2, r3, #1
 8011988:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 801198c:	60fb      	str	r3, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801198e:	68fb      	ldr	r3, [r7, #12]
 8011990:	fa93 f3a3 	rbit	r3, r3
 8011994:	60bb      	str	r3, [r7, #8]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8011996:	68bb      	ldr	r3, [r7, #8]
 8011998:	fab3 f383 	clz	r3, r3
 801199c:	fa02 f103 	lsl.w	r1, r2, r3
 80119a0:	687b      	ldr	r3, [r7, #4]
 80119a2:	681b      	ldr	r3, [r3, #0]
 80119a4:	685a      	ldr	r2, [r3, #4]
 80119a6:	687b      	ldr	r3, [r7, #4]
 80119a8:	681b      	ldr	r3, [r3, #0]
 80119aa:	430a      	orrs	r2, r1
 80119ac:	605a      	str	r2, [r3, #4]
 80119ae:	e007      	b.n	80119c0 <ADC_Init+0x184>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 80119b0:	687b      	ldr	r3, [r7, #4]
 80119b2:	681b      	ldr	r3, [r3, #0]
 80119b4:	685a      	ldr	r2, [r3, #4]
 80119b6:	687b      	ldr	r3, [r7, #4]
 80119b8:	681b      	ldr	r3, [r3, #0]
 80119ba:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80119be:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 80119c0:	687b      	ldr	r3, [r7, #4]
 80119c2:	681b      	ldr	r3, [r3, #0]
 80119c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80119c6:	687b      	ldr	r3, [r7, #4]
 80119c8:	681b      	ldr	r3, [r3, #0]
 80119ca:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 80119ce:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 80119d0:	687b      	ldr	r3, [r7, #4]
 80119d2:	681b      	ldr	r3, [r3, #0]
 80119d4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80119d6:	687b      	ldr	r3, [r7, #4]
 80119d8:	69db      	ldr	r3, [r3, #28]
 80119da:	3b01      	subs	r3, #1
 80119dc:	051a      	lsls	r2, r3, #20
 80119de:	687b      	ldr	r3, [r7, #4]
 80119e0:	681b      	ldr	r3, [r3, #0]
 80119e2:	430a      	orrs	r2, r1
 80119e4:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80119e6:	687b      	ldr	r3, [r7, #4]
 80119e8:	681b      	ldr	r3, [r3, #0]
 80119ea:	689a      	ldr	r2, [r3, #8]
 80119ec:	687b      	ldr	r3, [r7, #4]
 80119ee:	681b      	ldr	r3, [r3, #0]
 80119f0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80119f4:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
 80119f6:	687b      	ldr	r3, [r7, #4]
 80119f8:	681b      	ldr	r3, [r3, #0]
 80119fa:	6899      	ldr	r1, [r3, #8]
 80119fc:	687b      	ldr	r3, [r7, #4]
 80119fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011a00:	025a      	lsls	r2, r3, #9
 8011a02:	687b      	ldr	r3, [r7, #4]
 8011a04:	681b      	ldr	r3, [r3, #0]
 8011a06:	430a      	orrs	r2, r1
 8011a08:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8011a0a:	687b      	ldr	r3, [r7, #4]
 8011a0c:	681b      	ldr	r3, [r3, #0]
 8011a0e:	689a      	ldr	r2, [r3, #8]
 8011a10:	687b      	ldr	r3, [r7, #4]
 8011a12:	681b      	ldr	r3, [r3, #0]
 8011a14:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8011a18:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8011a1a:	687b      	ldr	r3, [r7, #4]
 8011a1c:	681b      	ldr	r3, [r3, #0]
 8011a1e:	6899      	ldr	r1, [r3, #8]
 8011a20:	687b      	ldr	r3, [r7, #4]
 8011a22:	695b      	ldr	r3, [r3, #20]
 8011a24:	029a      	lsls	r2, r3, #10
 8011a26:	687b      	ldr	r3, [r7, #4]
 8011a28:	681b      	ldr	r3, [r3, #0]
 8011a2a:	430a      	orrs	r2, r1
 8011a2c:	609a      	str	r2, [r3, #8]
}
 8011a2e:	bf00      	nop
 8011a30:	3714      	adds	r7, #20
 8011a32:	46bd      	mov	sp, r7
 8011a34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a38:	4770      	bx	lr
 8011a3a:	bf00      	nop
 8011a3c:	40012300 	.word	0x40012300
 8011a40:	0f000001 	.word	0x0f000001

08011a44 <NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8011a44:	b480      	push	{r7}
 8011a46:	b085      	sub	sp, #20
 8011a48:	af00      	add	r7, sp, #0
 8011a4a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8011a4c:	687b      	ldr	r3, [r7, #4]
 8011a4e:	f003 0307 	and.w	r3, r3, #7
 8011a52:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8011a54:	4b0c      	ldr	r3, [pc, #48]	; (8011a88 <NVIC_SetPriorityGrouping+0x44>)
 8011a56:	68db      	ldr	r3, [r3, #12]
 8011a58:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8011a5a:	68ba      	ldr	r2, [r7, #8]
 8011a5c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8011a60:	4013      	ands	r3, r2
 8011a62:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8011a64:	68fb      	ldr	r3, [r7, #12]
 8011a66:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8011a68:	68bb      	ldr	r3, [r7, #8]
 8011a6a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8011a6c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8011a70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8011a74:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8011a76:	4a04      	ldr	r2, [pc, #16]	; (8011a88 <NVIC_SetPriorityGrouping+0x44>)
 8011a78:	68bb      	ldr	r3, [r7, #8]
 8011a7a:	60d3      	str	r3, [r2, #12]
}
 8011a7c:	bf00      	nop
 8011a7e:	3714      	adds	r7, #20
 8011a80:	46bd      	mov	sp, r7
 8011a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a86:	4770      	bx	lr
 8011a88:	e000ed00 	.word	0xe000ed00

08011a8c <NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8011a8c:	b480      	push	{r7}
 8011a8e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8011a90:	4b04      	ldr	r3, [pc, #16]	; (8011aa4 <NVIC_GetPriorityGrouping+0x18>)
 8011a92:	68db      	ldr	r3, [r3, #12]
 8011a94:	0a1b      	lsrs	r3, r3, #8
 8011a96:	f003 0307 	and.w	r3, r3, #7
}
 8011a9a:	4618      	mov	r0, r3
 8011a9c:	46bd      	mov	sp, r7
 8011a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011aa2:	4770      	bx	lr
 8011aa4:	e000ed00 	.word	0xe000ed00

08011aa8 <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8011aa8:	b480      	push	{r7}
 8011aaa:	b083      	sub	sp, #12
 8011aac:	af00      	add	r7, sp, #0
 8011aae:	4603      	mov	r3, r0
 8011ab0:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8011ab2:	79fb      	ldrb	r3, [r7, #7]
 8011ab4:	f003 021f 	and.w	r2, r3, #31
 8011ab8:	4907      	ldr	r1, [pc, #28]	; (8011ad8 <NVIC_EnableIRQ+0x30>)
 8011aba:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011abe:	095b      	lsrs	r3, r3, #5
 8011ac0:	2001      	movs	r0, #1
 8011ac2:	fa00 f202 	lsl.w	r2, r0, r2
 8011ac6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8011aca:	bf00      	nop
 8011acc:	370c      	adds	r7, #12
 8011ace:	46bd      	mov	sp, r7
 8011ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011ad4:	4770      	bx	lr
 8011ad6:	bf00      	nop
 8011ad8:	e000e100 	.word	0xe000e100

08011adc <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8011adc:	b480      	push	{r7}
 8011ade:	b083      	sub	sp, #12
 8011ae0:	af00      	add	r7, sp, #0
 8011ae2:	4603      	mov	r3, r0
 8011ae4:	6039      	str	r1, [r7, #0]
 8011ae6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 8011ae8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011aec:	2b00      	cmp	r3, #0
 8011aee:	da0b      	bge.n	8011b08 <NVIC_SetPriority+0x2c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011af0:	683b      	ldr	r3, [r7, #0]
 8011af2:	b2da      	uxtb	r2, r3
 8011af4:	490c      	ldr	r1, [pc, #48]	; (8011b28 <NVIC_SetPriority+0x4c>)
 8011af6:	79fb      	ldrb	r3, [r7, #7]
 8011af8:	f003 030f 	and.w	r3, r3, #15
 8011afc:	3b04      	subs	r3, #4
 8011afe:	0112      	lsls	r2, r2, #4
 8011b00:	b2d2      	uxtb	r2, r2
 8011b02:	440b      	add	r3, r1
 8011b04:	761a      	strb	r2, [r3, #24]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8011b06:	e009      	b.n	8011b1c <NVIC_SetPriority+0x40>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8011b08:	683b      	ldr	r3, [r7, #0]
 8011b0a:	b2da      	uxtb	r2, r3
 8011b0c:	4907      	ldr	r1, [pc, #28]	; (8011b2c <NVIC_SetPriority+0x50>)
 8011b0e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011b12:	0112      	lsls	r2, r2, #4
 8011b14:	b2d2      	uxtb	r2, r2
 8011b16:	440b      	add	r3, r1
 8011b18:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8011b1c:	bf00      	nop
 8011b1e:	370c      	adds	r7, #12
 8011b20:	46bd      	mov	sp, r7
 8011b22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b26:	4770      	bx	lr
 8011b28:	e000ed00 	.word	0xe000ed00
 8011b2c:	e000e100 	.word	0xe000e100

08011b30 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8011b30:	b480      	push	{r7}
 8011b32:	b089      	sub	sp, #36	; 0x24
 8011b34:	af00      	add	r7, sp, #0
 8011b36:	60f8      	str	r0, [r7, #12]
 8011b38:	60b9      	str	r1, [r7, #8]
 8011b3a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8011b3c:	68fb      	ldr	r3, [r7, #12]
 8011b3e:	f003 0307 	and.w	r3, r3, #7
 8011b42:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8011b44:	69fb      	ldr	r3, [r7, #28]
 8011b46:	f1c3 0307 	rsb	r3, r3, #7
 8011b4a:	2b04      	cmp	r3, #4
 8011b4c:	bf28      	it	cs
 8011b4e:	2304      	movcs	r3, #4
 8011b50:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8011b52:	69fb      	ldr	r3, [r7, #28]
 8011b54:	3304      	adds	r3, #4
 8011b56:	2b06      	cmp	r3, #6
 8011b58:	d902      	bls.n	8011b60 <NVIC_EncodePriority+0x30>
 8011b5a:	69fb      	ldr	r3, [r7, #28]
 8011b5c:	3b03      	subs	r3, #3
 8011b5e:	e000      	b.n	8011b62 <NVIC_EncodePriority+0x32>
 8011b60:	2300      	movs	r3, #0
 8011b62:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8011b64:	f04f 32ff 	mov.w	r2, #4294967295
 8011b68:	69bb      	ldr	r3, [r7, #24]
 8011b6a:	fa02 f303 	lsl.w	r3, r2, r3
 8011b6e:	43da      	mvns	r2, r3
 8011b70:	68bb      	ldr	r3, [r7, #8]
 8011b72:	401a      	ands	r2, r3
 8011b74:	697b      	ldr	r3, [r7, #20]
 8011b76:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8011b78:	f04f 31ff 	mov.w	r1, #4294967295
 8011b7c:	697b      	ldr	r3, [r7, #20]
 8011b7e:	fa01 f303 	lsl.w	r3, r1, r3
 8011b82:	43d9      	mvns	r1, r3
 8011b84:	687b      	ldr	r3, [r7, #4]
 8011b86:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8011b88:	4313      	orrs	r3, r2
         );
}
 8011b8a:	4618      	mov	r0, r3
 8011b8c:	3724      	adds	r7, #36	; 0x24
 8011b8e:	46bd      	mov	sp, r7
 8011b90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011b94:	4770      	bx	lr
	...

08011b98 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8011b98:	b580      	push	{r7, lr}
 8011b9a:	b082      	sub	sp, #8
 8011b9c:	af00      	add	r7, sp, #0
 8011b9e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8011ba0:	687b      	ldr	r3, [r7, #4]
 8011ba2:	3b01      	subs	r3, #1
 8011ba4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8011ba8:	d301      	bcc.n	8011bae <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8011baa:	2301      	movs	r3, #1
 8011bac:	e00f      	b.n	8011bce <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8011bae:	4a0a      	ldr	r2, [pc, #40]	; (8011bd8 <SysTick_Config+0x40>)
 8011bb0:	687b      	ldr	r3, [r7, #4]
 8011bb2:	3b01      	subs	r3, #1
 8011bb4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8011bb6:	210f      	movs	r1, #15
 8011bb8:	f04f 30ff 	mov.w	r0, #4294967295
 8011bbc:	f7ff ff8e 	bl	8011adc <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8011bc0:	4b05      	ldr	r3, [pc, #20]	; (8011bd8 <SysTick_Config+0x40>)
 8011bc2:	2200      	movs	r2, #0
 8011bc4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8011bc6:	4b04      	ldr	r3, [pc, #16]	; (8011bd8 <SysTick_Config+0x40>)
 8011bc8:	2207      	movs	r2, #7
 8011bca:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8011bcc:	2300      	movs	r3, #0
}
 8011bce:	4618      	mov	r0, r3
 8011bd0:	3708      	adds	r7, #8
 8011bd2:	46bd      	mov	sp, r7
 8011bd4:	bd80      	pop	{r7, pc}
 8011bd6:	bf00      	nop
 8011bd8:	e000e010 	.word	0xe000e010

08011bdc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8011bdc:	b580      	push	{r7, lr}
 8011bde:	b082      	sub	sp, #8
 8011be0:	af00      	add	r7, sp, #0
 8011be2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8011be4:	6878      	ldr	r0, [r7, #4]
 8011be6:	f7ff ff2d 	bl	8011a44 <NVIC_SetPriorityGrouping>
}
 8011bea:	bf00      	nop
 8011bec:	3708      	adds	r7, #8
 8011bee:	46bd      	mov	sp, r7
 8011bf0:	bd80      	pop	{r7, pc}

08011bf2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8011bf2:	b580      	push	{r7, lr}
 8011bf4:	b086      	sub	sp, #24
 8011bf6:	af00      	add	r7, sp, #0
 8011bf8:	4603      	mov	r3, r0
 8011bfa:	60b9      	str	r1, [r7, #8]
 8011bfc:	607a      	str	r2, [r7, #4]
 8011bfe:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8011c00:	2300      	movs	r3, #0
 8011c02:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8011c04:	f7ff ff42 	bl	8011a8c <NVIC_GetPriorityGrouping>
 8011c08:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8011c0a:	687a      	ldr	r2, [r7, #4]
 8011c0c:	68b9      	ldr	r1, [r7, #8]
 8011c0e:	6978      	ldr	r0, [r7, #20]
 8011c10:	f7ff ff8e 	bl	8011b30 <NVIC_EncodePriority>
 8011c14:	4602      	mov	r2, r0
 8011c16:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8011c1a:	4611      	mov	r1, r2
 8011c1c:	4618      	mov	r0, r3
 8011c1e:	f7ff ff5d 	bl	8011adc <NVIC_SetPriority>
}
 8011c22:	bf00      	nop
 8011c24:	3718      	adds	r7, #24
 8011c26:	46bd      	mov	sp, r7
 8011c28:	bd80      	pop	{r7, pc}

08011c2a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8011c2a:	b580      	push	{r7, lr}
 8011c2c:	b082      	sub	sp, #8
 8011c2e:	af00      	add	r7, sp, #0
 8011c30:	4603      	mov	r3, r0
 8011c32:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8011c34:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8011c38:	4618      	mov	r0, r3
 8011c3a:	f7ff ff35 	bl	8011aa8 <NVIC_EnableIRQ>
}
 8011c3e:	bf00      	nop
 8011c40:	3708      	adds	r7, #8
 8011c42:	46bd      	mov	sp, r7
 8011c44:	bd80      	pop	{r7, pc}

08011c46 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8011c46:	b580      	push	{r7, lr}
 8011c48:	b082      	sub	sp, #8
 8011c4a:	af00      	add	r7, sp, #0
 8011c4c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8011c4e:	6878      	ldr	r0, [r7, #4]
 8011c50:	f7ff ffa2 	bl	8011b98 <SysTick_Config>
 8011c54:	4603      	mov	r3, r0
}
 8011c56:	4618      	mov	r0, r3
 8011c58:	3708      	adds	r7, #8
 8011c5a:	46bd      	mov	sp, r7
 8011c5c:	bd80      	pop	{r7, pc}
	...

08011c60 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8011c60:	b480      	push	{r7}
 8011c62:	b083      	sub	sp, #12
 8011c64:	af00      	add	r7, sp, #0
 8011c66:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8011c68:	687b      	ldr	r3, [r7, #4]
 8011c6a:	2b04      	cmp	r3, #4
 8011c6c:	d106      	bne.n	8011c7c <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8011c6e:	4b09      	ldr	r3, [pc, #36]	; (8011c94 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8011c70:	681b      	ldr	r3, [r3, #0]
 8011c72:	4a08      	ldr	r2, [pc, #32]	; (8011c94 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8011c74:	f043 0304 	orr.w	r3, r3, #4
 8011c78:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
 8011c7a:	e005      	b.n	8011c88 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8011c7c:	4b05      	ldr	r3, [pc, #20]	; (8011c94 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8011c7e:	681b      	ldr	r3, [r3, #0]
 8011c80:	4a04      	ldr	r2, [pc, #16]	; (8011c94 <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8011c82:	f023 0304 	bic.w	r3, r3, #4
 8011c86:	6013      	str	r3, [r2, #0]
}
 8011c88:	bf00      	nop
 8011c8a:	370c      	adds	r7, #12
 8011c8c:	46bd      	mov	sp, r7
 8011c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011c92:	4770      	bx	lr
 8011c94:	e000e010 	.word	0xe000e010

08011c98 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8011c98:	b580      	push	{r7, lr}
 8011c9a:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
 8011c9c:	f000 f802 	bl	8011ca4 <HAL_SYSTICK_Callback>
}
 8011ca0:	bf00      	nop
 8011ca2:	bd80      	pop	{r7, pc}

08011ca4 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8011ca4:	b480      	push	{r7}
 8011ca6:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
 8011ca8:	bf00      	nop
 8011caa:	46bd      	mov	sp, r7
 8011cac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011cb0:	4770      	bx	lr

08011cb2 <HAL_CRC_Init>:
  * @param  hcrc: pointer to a CRC_HandleTypeDef structure that contains
  *         the configuration information for CRC
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8011cb2:	b580      	push	{r7, lr}
 8011cb4:	b082      	sub	sp, #8
 8011cb6:	af00      	add	r7, sp, #0
 8011cb8:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if(hcrc == NULL)
 8011cba:	687b      	ldr	r3, [r7, #4]
 8011cbc:	2b00      	cmp	r3, #0
 8011cbe:	d101      	bne.n	8011cc4 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8011cc0:	2301      	movs	r3, #1
 8011cc2:	e011      	b.n	8011ce8 <HAL_CRC_Init+0x36>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if(hcrc->State == HAL_CRC_STATE_RESET)
 8011cc4:	687b      	ldr	r3, [r7, #4]
 8011cc6:	795b      	ldrb	r3, [r3, #5]
 8011cc8:	b2db      	uxtb	r3, r3
 8011cca:	2b00      	cmp	r3, #0
 8011ccc:	d105      	bne.n	8011cda <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8011cce:	687b      	ldr	r3, [r7, #4]
 8011cd0:	2200      	movs	r2, #0
 8011cd2:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8011cd4:	6878      	ldr	r0, [r7, #4]
 8011cd6:	f7fe f815 	bl	800fd04 <HAL_CRC_MspInit>
  }
  
  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_BUSY;
 8011cda:	687b      	ldr	r3, [r7, #4]
 8011cdc:	2202      	movs	r2, #2
 8011cde:	715a      	strb	r2, [r3, #5]
   
  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	2201      	movs	r2, #1
 8011ce4:	715a      	strb	r2, [r3, #5]
  
  /* Return function status */
  return HAL_OK;
 8011ce6:	2300      	movs	r3, #0
}
 8011ce8:	4618      	mov	r0, r3
 8011cea:	3708      	adds	r7, #8
 8011cec:	46bd      	mov	sp, r7
 8011cee:	bd80      	pop	{r7, pc}

08011cf0 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8011cf0:	b580      	push	{r7, lr}
 8011cf2:	b084      	sub	sp, #16
 8011cf4:	af00      	add	r7, sp, #0
 8011cf6:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 8011cf8:	2300      	movs	r3, #0
 8011cfa:	60fb      	str	r3, [r7, #12]

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8011cfc:	687b      	ldr	r3, [r7, #4]
 8011cfe:	2b00      	cmp	r3, #0
 8011d00:	d101      	bne.n	8011d06 <HAL_DMA_Init+0x16>
  {
    return HAL_ERROR;
 8011d02:	2301      	movs	r3, #1
 8011d04:	e05a      	b.n	8011dbc <HAL_DMA_Init+0xcc>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8011d06:	687b      	ldr	r3, [r7, #4]
 8011d08:	2202      	movs	r2, #2
 8011d0a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8011d0e:	687b      	ldr	r3, [r7, #4]
 8011d10:	681b      	ldr	r3, [r3, #0]
 8011d12:	681b      	ldr	r3, [r3, #0]
 8011d14:	60fb      	str	r3, [r7, #12]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8011d16:	68fa      	ldr	r2, [r7, #12]
 8011d18:	4b2a      	ldr	r3, [pc, #168]	; (8011dc4 <HAL_DMA_Init+0xd4>)
 8011d1a:	4013      	ands	r3, r2
 8011d1c:	60fb      	str	r3, [r7, #12]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8011d1e:	687b      	ldr	r3, [r7, #4]
 8011d20:	685a      	ldr	r2, [r3, #4]
 8011d22:	687b      	ldr	r3, [r7, #4]
 8011d24:	689b      	ldr	r3, [r3, #8]
 8011d26:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8011d28:	687b      	ldr	r3, [r7, #4]
 8011d2a:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8011d2c:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8011d2e:	687b      	ldr	r3, [r7, #4]
 8011d30:	691b      	ldr	r3, [r3, #16]
 8011d32:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8011d34:	687b      	ldr	r3, [r7, #4]
 8011d36:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8011d38:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8011d3a:	687b      	ldr	r3, [r7, #4]
 8011d3c:	699b      	ldr	r3, [r3, #24]
 8011d3e:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8011d40:	687b      	ldr	r3, [r7, #4]
 8011d42:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8011d44:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8011d46:	687b      	ldr	r3, [r7, #4]
 8011d48:	6a1b      	ldr	r3, [r3, #32]
 8011d4a:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8011d4c:	68fa      	ldr	r2, [r7, #12]
 8011d4e:	4313      	orrs	r3, r2
 8011d50:	60fb      	str	r3, [r7, #12]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8011d52:	687b      	ldr	r3, [r7, #4]
 8011d54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011d56:	2b04      	cmp	r3, #4
 8011d58:	d107      	bne.n	8011d6a <HAL_DMA_Init+0x7a>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8011d5a:	687b      	ldr	r3, [r7, #4]
 8011d5c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8011d5e:	687b      	ldr	r3, [r7, #4]
 8011d60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8011d62:	4313      	orrs	r3, r2
 8011d64:	68fa      	ldr	r2, [r7, #12]
 8011d66:	4313      	orrs	r3, r2
 8011d68:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8011d6a:	687b      	ldr	r3, [r7, #4]
 8011d6c:	681b      	ldr	r3, [r3, #0]
 8011d6e:	68fa      	ldr	r2, [r7, #12]
 8011d70:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8011d72:	687b      	ldr	r3, [r7, #4]
 8011d74:	681b      	ldr	r3, [r3, #0]
 8011d76:	695b      	ldr	r3, [r3, #20]
 8011d78:	60fb      	str	r3, [r7, #12]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8011d7a:	68fb      	ldr	r3, [r7, #12]
 8011d7c:	f023 0307 	bic.w	r3, r3, #7
 8011d80:	60fb      	str	r3, [r7, #12]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8011d82:	687b      	ldr	r3, [r7, #4]
 8011d84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011d86:	68fa      	ldr	r2, [r7, #12]
 8011d88:	4313      	orrs	r3, r2
 8011d8a:	60fb      	str	r3, [r7, #12]

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8011d8c:	687b      	ldr	r3, [r7, #4]
 8011d8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011d90:	2b04      	cmp	r3, #4
 8011d92:	d104      	bne.n	8011d9e <HAL_DMA_Init+0xae>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8011d94:	687b      	ldr	r3, [r7, #4]
 8011d96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011d98:	68fa      	ldr	r2, [r7, #12]
 8011d9a:	4313      	orrs	r3, r2
 8011d9c:	60fb      	str	r3, [r7, #12]
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8011d9e:	687b      	ldr	r3, [r7, #4]
 8011da0:	681b      	ldr	r3, [r3, #0]
 8011da2:	68fa      	ldr	r2, [r7, #12]
 8011da4:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  DMA_CalcBaseAndBitshift(hdma);
 8011da6:	6878      	ldr	r0, [r7, #4]
 8011da8:	f000 fa28 	bl	80121fc <DMA_CalcBaseAndBitshift>

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8011dac:	687b      	ldr	r3, [r7, #4]
 8011dae:	2200      	movs	r2, #0
 8011db0:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8011db2:	687b      	ldr	r3, [r7, #4]
 8011db4:	2201      	movs	r2, #1
 8011db6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8011dba:	2300      	movs	r3, #0
}
 8011dbc:	4618      	mov	r0, r3
 8011dbe:	3710      	adds	r7, #16
 8011dc0:	46bd      	mov	sp, r7
 8011dc2:	bd80      	pop	{r7, pc}
 8011dc4:	f010803f 	.word	0xf010803f

08011dc8 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8011dc8:	b580      	push	{r7, lr}
 8011dca:	b084      	sub	sp, #16
 8011dcc:	af00      	add	r7, sp, #0
 8011dce:	60f8      	str	r0, [r7, #12]
 8011dd0:	60b9      	str	r1, [r7, #8]
 8011dd2:	607a      	str	r2, [r7, #4]
 8011dd4:	603b      	str	r3, [r7, #0]
  /* Process locked */
  __HAL_LOCK(hdma);
 8011dd6:	68fb      	ldr	r3, [r7, #12]
 8011dd8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8011ddc:	2b01      	cmp	r3, #1
 8011dde:	d101      	bne.n	8011de4 <HAL_DMA_Start_IT+0x1c>
 8011de0:	2302      	movs	r3, #2
 8011de2:	e02e      	b.n	8011e42 <HAL_DMA_Start_IT+0x7a>
 8011de4:	68fb      	ldr	r3, [r7, #12]
 8011de6:	2201      	movs	r2, #1
 8011de8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8011dec:	68fb      	ldr	r3, [r7, #12]
 8011dee:	2202      	movs	r2, #2
 8011df0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

   /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8011df4:	68fb      	ldr	r3, [r7, #12]
 8011df6:	681b      	ldr	r3, [r3, #0]
 8011df8:	681a      	ldr	r2, [r3, #0]
 8011dfa:	68fb      	ldr	r3, [r7, #12]
 8011dfc:	681b      	ldr	r3, [r3, #0]
 8011dfe:	f022 0201 	bic.w	r2, r2, #1
 8011e02:	601a      	str	r2, [r3, #0]

  /* Configure the source, destination address and the data length */
  DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8011e04:	683b      	ldr	r3, [r7, #0]
 8011e06:	687a      	ldr	r2, [r7, #4]
 8011e08:	68b9      	ldr	r1, [r7, #8]
 8011e0a:	68f8      	ldr	r0, [r7, #12]
 8011e0c:	f000 f9c8 	bl	80121a0 <DMA_SetConfig>

  /* Enable all interrupts */
  hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME;
 8011e10:	68fb      	ldr	r3, [r7, #12]
 8011e12:	681b      	ldr	r3, [r3, #0]
 8011e14:	681a      	ldr	r2, [r3, #0]
 8011e16:	68fb      	ldr	r3, [r7, #12]
 8011e18:	681b      	ldr	r3, [r3, #0]
 8011e1a:	f042 021e 	orr.w	r2, r2, #30
 8011e1e:	601a      	str	r2, [r3, #0]
  hdma->Instance->FCR |= DMA_IT_FE;
 8011e20:	68fb      	ldr	r3, [r7, #12]
 8011e22:	681b      	ldr	r3, [r3, #0]
 8011e24:	695a      	ldr	r2, [r3, #20]
 8011e26:	68fb      	ldr	r3, [r7, #12]
 8011e28:	681b      	ldr	r3, [r3, #0]
 8011e2a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8011e2e:	615a      	str	r2, [r3, #20]

   /* Enable the Peripheral */
  __HAL_DMA_ENABLE(hdma);
 8011e30:	68fb      	ldr	r3, [r7, #12]
 8011e32:	681b      	ldr	r3, [r3, #0]
 8011e34:	681a      	ldr	r2, [r3, #0]
 8011e36:	68fb      	ldr	r3, [r7, #12]
 8011e38:	681b      	ldr	r3, [r3, #0]
 8011e3a:	f042 0201 	orr.w	r2, r2, #1
 8011e3e:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8011e40:	2300      	movs	r3, #0
} 
 8011e42:	4618      	mov	r0, r3
 8011e44:	3710      	adds	r7, #16
 8011e46:	46bd      	mov	sp, r7
 8011e48:	bd80      	pop	{r7, pc}

08011e4a <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8011e4a:	b580      	push	{r7, lr}
 8011e4c:	b084      	sub	sp, #16
 8011e4e:	af00      	add	r7, sp, #0
 8011e50:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8011e52:	2300      	movs	r3, #0
 8011e54:	60fb      	str	r3, [r7, #12]

  /* Disable the stream */
  __HAL_DMA_DISABLE(hdma);
 8011e56:	687b      	ldr	r3, [r7, #4]
 8011e58:	681b      	ldr	r3, [r3, #0]
 8011e5a:	681a      	ldr	r2, [r3, #0]
 8011e5c:	687b      	ldr	r3, [r7, #4]
 8011e5e:	681b      	ldr	r3, [r3, #0]
 8011e60:	f022 0201 	bic.w	r2, r2, #1
 8011e64:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8011e66:	f7ff fb5f 	bl	8011528 <HAL_GetTick>
 8011e6a:	60f8      	str	r0, [r7, #12]

  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != 0U)
 8011e6c:	e017      	b.n	8011e9e <HAL_DMA_Abort+0x54>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8011e6e:	f7ff fb5b 	bl	8011528 <HAL_GetTick>
 8011e72:	4602      	mov	r2, r0
 8011e74:	68fb      	ldr	r3, [r7, #12]
 8011e76:	1ad3      	subs	r3, r2, r3
 8011e78:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8011e7c:	d90f      	bls.n	8011e9e <HAL_DMA_Abort+0x54>
    {
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
 8011e7e:	687b      	ldr	r3, [r7, #4]
 8011e80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011e82:	f043 0220 	orr.w	r2, r3, #32
 8011e86:	687b      	ldr	r3, [r7, #4]
 8011e88:	64da      	str	r2, [r3, #76]	; 0x4c
      
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8011e8a:	687b      	ldr	r3, [r7, #4]
 8011e8c:	2200      	movs	r2, #0
 8011e8e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8011e92:	687b      	ldr	r3, [r7, #4]
 8011e94:	2203      	movs	r2, #3
 8011e96:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 8011e9a:	2303      	movs	r3, #3
 8011e9c:	e00f      	b.n	8011ebe <HAL_DMA_Abort+0x74>
  while((hdma->Instance->CR & DMA_SxCR_EN) != 0U)
 8011e9e:	687b      	ldr	r3, [r7, #4]
 8011ea0:	681b      	ldr	r3, [r3, #0]
 8011ea2:	681b      	ldr	r3, [r3, #0]
 8011ea4:	f003 0301 	and.w	r3, r3, #1
 8011ea8:	2b00      	cmp	r3, #0
 8011eaa:	d1e0      	bne.n	8011e6e <HAL_DMA_Abort+0x24>
    }
  }
  /* Process Unlocked */
  __HAL_UNLOCK(hdma);
 8011eac:	687b      	ldr	r3, [r7, #4]
 8011eae:	2200      	movs	r2, #0
 8011eb0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8011eb4:	687b      	ldr	r3, [r7, #4]
 8011eb6:	2201      	movs	r2, #1
 8011eb8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8011ebc:	2300      	movs	r3, #0
}
 8011ebe:	4618      	mov	r0, r3
 8011ec0:	3710      	adds	r7, #16
 8011ec2:	46bd      	mov	sp, r7
 8011ec4:	bd80      	pop	{r7, pc}
	...

08011ec8 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8011ec8:	b580      	push	{r7, lr}
 8011eca:	b084      	sub	sp, #16
 8011ecc:	af00      	add	r7, sp, #0
 8011ece:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs;

  regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8011ed0:	687b      	ldr	r3, [r7, #4]
 8011ed2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011ed4:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((regs->ISR & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8011ed6:	68fb      	ldr	r3, [r7, #12]
 8011ed8:	681a      	ldr	r2, [r3, #0]
 8011eda:	687b      	ldr	r3, [r7, #4]
 8011edc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011ede:	2108      	movs	r1, #8
 8011ee0:	fa01 f303 	lsl.w	r3, r1, r3
 8011ee4:	4013      	ands	r3, r2
 8011ee6:	2b00      	cmp	r3, #0
 8011ee8:	d02a      	beq.n	8011f40 <HAL_DMA_IRQHandler+0x78>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8011eea:	687b      	ldr	r3, [r7, #4]
 8011eec:	681b      	ldr	r3, [r3, #0]
 8011eee:	681b      	ldr	r3, [r3, #0]
 8011ef0:	f003 0304 	and.w	r3, r3, #4
 8011ef4:	2b00      	cmp	r3, #0
 8011ef6:	d023      	beq.n	8011f40 <HAL_DMA_IRQHandler+0x78>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 8011ef8:	687b      	ldr	r3, [r7, #4]
 8011efa:	681b      	ldr	r3, [r3, #0]
 8011efc:	681a      	ldr	r2, [r3, #0]
 8011efe:	687b      	ldr	r3, [r7, #4]
 8011f00:	681b      	ldr	r3, [r3, #0]
 8011f02:	f022 0204 	bic.w	r2, r2, #4
 8011f06:	601a      	str	r2, [r3, #0]

      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8011f08:	687b      	ldr	r3, [r7, #4]
 8011f0a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011f0c:	2208      	movs	r2, #8
 8011f0e:	409a      	lsls	r2, r3
 8011f10:	68fb      	ldr	r3, [r7, #12]
 8011f12:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8011f14:	687b      	ldr	r3, [r7, #4]
 8011f16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011f18:	f043 0201 	orr.w	r2, r3, #1
 8011f1c:	687b      	ldr	r3, [r7, #4]
 8011f1e:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8011f20:	687b      	ldr	r3, [r7, #4]
 8011f22:	2204      	movs	r2, #4
 8011f24:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8011f28:	687b      	ldr	r3, [r7, #4]
 8011f2a:	2200      	movs	r2, #0
 8011f2c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8011f30:	687b      	ldr	r3, [r7, #4]
 8011f32:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011f34:	2b00      	cmp	r3, #0
 8011f36:	d003      	beq.n	8011f40 <HAL_DMA_IRQHandler+0x78>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8011f38:	687b      	ldr	r3, [r7, #4]
 8011f3a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011f3c:	6878      	ldr	r0, [r7, #4]
 8011f3e:	4798      	blx	r3
      }
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((regs->ISR & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8011f40:	68fb      	ldr	r3, [r7, #12]
 8011f42:	681a      	ldr	r2, [r3, #0]
 8011f44:	687b      	ldr	r3, [r7, #4]
 8011f46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011f48:	4993      	ldr	r1, [pc, #588]	; (8012198 <HAL_DMA_IRQHandler+0x2d0>)
 8011f4a:	fa01 f303 	lsl.w	r3, r1, r3
 8011f4e:	4013      	ands	r3, r2
 8011f50:	2b00      	cmp	r3, #0
 8011f52:	d02a      	beq.n	8011faa <HAL_DMA_IRQHandler+0xe2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8011f54:	687b      	ldr	r3, [r7, #4]
 8011f56:	681b      	ldr	r3, [r3, #0]
 8011f58:	695b      	ldr	r3, [r3, #20]
 8011f5a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8011f5e:	2b00      	cmp	r3, #0
 8011f60:	d023      	beq.n	8011faa <HAL_DMA_IRQHandler+0xe2>
    {
      /* Disable the FIFO Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_FE);
 8011f62:	687b      	ldr	r3, [r7, #4]
 8011f64:	681b      	ldr	r3, [r3, #0]
 8011f66:	695a      	ldr	r2, [r3, #20]
 8011f68:	687b      	ldr	r3, [r7, #4]
 8011f6a:	681b      	ldr	r3, [r3, #0]
 8011f6c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8011f70:	615a      	str	r2, [r3, #20]

      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8011f72:	687b      	ldr	r3, [r7, #4]
 8011f74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011f76:	4a88      	ldr	r2, [pc, #544]	; (8012198 <HAL_DMA_IRQHandler+0x2d0>)
 8011f78:	409a      	lsls	r2, r3
 8011f7a:	68fb      	ldr	r3, [r7, #12]
 8011f7c:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8011f7e:	687b      	ldr	r3, [r7, #4]
 8011f80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011f82:	f043 0202 	orr.w	r2, r3, #2
 8011f86:	687b      	ldr	r3, [r7, #4]
 8011f88:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8011f8a:	687b      	ldr	r3, [r7, #4]
 8011f8c:	2204      	movs	r2, #4
 8011f8e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8011f92:	687b      	ldr	r3, [r7, #4]
 8011f94:	2200      	movs	r2, #0
 8011f96:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8011f9a:	687b      	ldr	r3, [r7, #4]
 8011f9c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011f9e:	2b00      	cmp	r3, #0
 8011fa0:	d003      	beq.n	8011faa <HAL_DMA_IRQHandler+0xe2>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8011fa2:	687b      	ldr	r3, [r7, #4]
 8011fa4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011fa6:	6878      	ldr	r0, [r7, #4]
 8011fa8:	4798      	blx	r3
      }
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((regs->ISR & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8011faa:	68fb      	ldr	r3, [r7, #12]
 8011fac:	681a      	ldr	r2, [r3, #0]
 8011fae:	687b      	ldr	r3, [r7, #4]
 8011fb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011fb2:	497a      	ldr	r1, [pc, #488]	; (801219c <HAL_DMA_IRQHandler+0x2d4>)
 8011fb4:	fa01 f303 	lsl.w	r3, r1, r3
 8011fb8:	4013      	ands	r3, r2
 8011fba:	2b00      	cmp	r3, #0
 8011fbc:	d02a      	beq.n	8012014 <HAL_DMA_IRQHandler+0x14c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8011fbe:	687b      	ldr	r3, [r7, #4]
 8011fc0:	681b      	ldr	r3, [r3, #0]
 8011fc2:	681b      	ldr	r3, [r3, #0]
 8011fc4:	f003 0302 	and.w	r3, r3, #2
 8011fc8:	2b00      	cmp	r3, #0
 8011fca:	d023      	beq.n	8012014 <HAL_DMA_IRQHandler+0x14c>
    {
      /* Disable the direct mode Error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_DME);
 8011fcc:	687b      	ldr	r3, [r7, #4]
 8011fce:	681b      	ldr	r3, [r3, #0]
 8011fd0:	681a      	ldr	r2, [r3, #0]
 8011fd2:	687b      	ldr	r3, [r7, #4]
 8011fd4:	681b      	ldr	r3, [r3, #0]
 8011fd6:	f022 0202 	bic.w	r2, r2, #2
 8011fda:	601a      	str	r2, [r3, #0]

      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8011fdc:	687b      	ldr	r3, [r7, #4]
 8011fde:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011fe0:	4a6e      	ldr	r2, [pc, #440]	; (801219c <HAL_DMA_IRQHandler+0x2d4>)
 8011fe2:	409a      	lsls	r2, r3
 8011fe4:	68fb      	ldr	r3, [r7, #12]
 8011fe6:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8011fe8:	687b      	ldr	r3, [r7, #4]
 8011fea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011fec:	f043 0204 	orr.w	r2, r3, #4
 8011ff0:	687b      	ldr	r3, [r7, #4]
 8011ff2:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8011ff4:	687b      	ldr	r3, [r7, #4]
 8011ff6:	2204      	movs	r2, #4
 8011ff8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8011ffc:	687b      	ldr	r3, [r7, #4]
 8011ffe:	2200      	movs	r2, #0
 8012000:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if(hdma->XferErrorCallback != NULL)
 8012004:	687b      	ldr	r3, [r7, #4]
 8012006:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8012008:	2b00      	cmp	r3, #0
 801200a:	d003      	beq.n	8012014 <HAL_DMA_IRQHandler+0x14c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 801200c:	687b      	ldr	r3, [r7, #4]
 801200e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8012010:	6878      	ldr	r0, [r7, #4]
 8012012:	4798      	blx	r3
      }
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((regs->ISR & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8012014:	68fb      	ldr	r3, [r7, #12]
 8012016:	681a      	ldr	r2, [r3, #0]
 8012018:	687b      	ldr	r3, [r7, #4]
 801201a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801201c:	2110      	movs	r1, #16
 801201e:	fa01 f303 	lsl.w	r3, r1, r3
 8012022:	4013      	ands	r3, r2
 8012024:	2b00      	cmp	r3, #0
 8012026:	d04c      	beq.n	80120c2 <HAL_DMA_IRQHandler+0x1fa>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8012028:	687b      	ldr	r3, [r7, #4]
 801202a:	681b      	ldr	r3, [r3, #0]
 801202c:	681b      	ldr	r3, [r3, #0]
 801202e:	f003 0308 	and.w	r3, r3, #8
 8012032:	2b00      	cmp	r3, #0
 8012034:	d045      	beq.n	80120c2 <HAL_DMA_IRQHandler+0x1fa>
    {
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8012036:	687b      	ldr	r3, [r7, #4]
 8012038:	681b      	ldr	r3, [r3, #0]
 801203a:	681b      	ldr	r3, [r3, #0]
 801203c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8012040:	2b00      	cmp	r3, #0
 8012042:	d01d      	beq.n	8012080 <HAL_DMA_IRQHandler+0x1b8>
      {
        /* Clear the half transfer complete flag */
        regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8012044:	687b      	ldr	r3, [r7, #4]
 8012046:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8012048:	2210      	movs	r2, #16
 801204a:	409a      	lsls	r2, r3
 801204c:	68fb      	ldr	r3, [r7, #12]
 801204e:	609a      	str	r2, [r3, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0U)
 8012050:	687b      	ldr	r3, [r7, #4]
 8012052:	681b      	ldr	r3, [r3, #0]
 8012054:	681b      	ldr	r3, [r3, #0]
 8012056:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 801205a:	2b00      	cmp	r3, #0
 801205c:	d104      	bne.n	8012068 <HAL_DMA_IRQHandler+0x1a0>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 801205e:	687b      	ldr	r3, [r7, #4]
 8012060:	2231      	movs	r2, #49	; 0x31
 8012062:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8012066:	e024      	b.n	80120b2 <HAL_DMA_IRQHandler+0x1ea>
        }
        /* Current memory buffer used is Memory 1 */
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0U)
 8012068:	687b      	ldr	r3, [r7, #4]
 801206a:	681b      	ldr	r3, [r3, #0]
 801206c:	681b      	ldr	r3, [r3, #0]
 801206e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8012072:	2b00      	cmp	r3, #0
 8012074:	d01d      	beq.n	80120b2 <HAL_DMA_IRQHandler+0x1ea>
        {
          /* Change DMA peripheral state */
          hdma->State = HAL_DMA_STATE_READY_HALF_MEM1;
 8012076:	687b      	ldr	r3, [r7, #4]
 8012078:	2241      	movs	r2, #65	; 0x41
 801207a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 801207e:	e018      	b.n	80120b2 <HAL_DMA_IRQHandler+0x1ea>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 8012080:	687b      	ldr	r3, [r7, #4]
 8012082:	681b      	ldr	r3, [r3, #0]
 8012084:	681b      	ldr	r3, [r3, #0]
 8012086:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801208a:	2b00      	cmp	r3, #0
 801208c:	d107      	bne.n	801209e <HAL_DMA_IRQHandler+0x1d6>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 801208e:	687b      	ldr	r3, [r7, #4]
 8012090:	681b      	ldr	r3, [r3, #0]
 8012092:	681a      	ldr	r2, [r3, #0]
 8012094:	687b      	ldr	r3, [r7, #4]
 8012096:	681b      	ldr	r3, [r3, #0]
 8012098:	f022 0208 	bic.w	r2, r2, #8
 801209c:	601a      	str	r2, [r3, #0]
        }
        /* Clear the half transfer complete flag */
        regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80120a2:	2210      	movs	r2, #16
 80120a4:	409a      	lsls	r2, r3
 80120a6:	68fb      	ldr	r3, [r7, #12]
 80120a8:	609a      	str	r2, [r3, #8]

        /* Change DMA peripheral state */
        hdma->State = HAL_DMA_STATE_READY_HALF_MEM0;
 80120aa:	687b      	ldr	r3, [r7, #4]
 80120ac:	2231      	movs	r2, #49	; 0x31
 80120ae:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      }

      if(hdma->XferHalfCpltCallback != NULL)
 80120b2:	687b      	ldr	r3, [r7, #4]
 80120b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80120b6:	2b00      	cmp	r3, #0
 80120b8:	d003      	beq.n	80120c2 <HAL_DMA_IRQHandler+0x1fa>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 80120ba:	687b      	ldr	r3, [r7, #4]
 80120bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80120be:	6878      	ldr	r0, [r7, #4]
 80120c0:	4798      	blx	r3
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((regs->ISR & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80120c2:	68fb      	ldr	r3, [r7, #12]
 80120c4:	681a      	ldr	r2, [r3, #0]
 80120c6:	687b      	ldr	r3, [r7, #4]
 80120c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80120ca:	2120      	movs	r1, #32
 80120cc:	fa01 f303 	lsl.w	r3, r1, r3
 80120d0:	4013      	ands	r3, r2
 80120d2:	2b00      	cmp	r3, #0
 80120d4:	d05c      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80120d6:	687b      	ldr	r3, [r7, #4]
 80120d8:	681b      	ldr	r3, [r3, #0]
 80120da:	681b      	ldr	r3, [r3, #0]
 80120dc:	f003 0310 	and.w	r3, r3, #16
 80120e0:	2b00      	cmp	r3, #0
 80120e2:	d055      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
    {
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 80120e4:	687b      	ldr	r3, [r7, #4]
 80120e6:	681b      	ldr	r3, [r3, #0]
 80120e8:	681b      	ldr	r3, [r3, #0]
 80120ea:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80120ee:	2b00      	cmp	r3, #0
 80120f0:	d025      	beq.n	801213e <HAL_DMA_IRQHandler+0x276>
      {
        /* Clear the transfer complete flag */
        regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80120f2:	687b      	ldr	r3, [r7, #4]
 80120f4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80120f6:	2220      	movs	r2, #32
 80120f8:	409a      	lsls	r2, r3
 80120fa:	68fb      	ldr	r3, [r7, #12]
 80120fc:	609a      	str	r2, [r3, #8]

        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == 0U)
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	681b      	ldr	r3, [r3, #0]
 8012102:	681b      	ldr	r3, [r3, #0]
 8012104:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8012108:	2b00      	cmp	r3, #0
 801210a:	d108      	bne.n	801211e <HAL_DMA_IRQHandler+0x256>
        {
          if(hdma->XferM1CpltCallback != NULL)
 801210c:	687b      	ldr	r3, [r7, #4]
 801210e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012110:	2b00      	cmp	r3, #0
 8012112:	d03d      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8012114:	687b      	ldr	r3, [r7, #4]
 8012116:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8012118:	6878      	ldr	r0, [r7, #4]
 801211a:	4798      	blx	r3
          hdma->XferCpltCallback(hdma);
        }
      }
    }
  }
}
 801211c:	e038      	b.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
        else if((hdma->Instance->CR & DMA_SxCR_CT) != 0U)
 801211e:	687b      	ldr	r3, [r7, #4]
 8012120:	681b      	ldr	r3, [r3, #0]
 8012122:	681b      	ldr	r3, [r3, #0]
 8012124:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8012128:	2b00      	cmp	r3, #0
 801212a:	d031      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
          if(hdma->XferCpltCallback != NULL)
 801212c:	687b      	ldr	r3, [r7, #4]
 801212e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012130:	2b00      	cmp	r3, #0
 8012132:	d02d      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
            hdma->XferCpltCallback(hdma);
 8012134:	687b      	ldr	r3, [r7, #4]
 8012136:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012138:	6878      	ldr	r0, [r7, #4]
 801213a:	4798      	blx	r3
}
 801213c:	e028      	b.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 801213e:	687b      	ldr	r3, [r7, #4]
 8012140:	681b      	ldr	r3, [r3, #0]
 8012142:	681b      	ldr	r3, [r3, #0]
 8012144:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8012148:	2b00      	cmp	r3, #0
 801214a:	d107      	bne.n	801215c <HAL_DMA_IRQHandler+0x294>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 801214c:	687b      	ldr	r3, [r7, #4]
 801214e:	681b      	ldr	r3, [r3, #0]
 8012150:	681a      	ldr	r2, [r3, #0]
 8012152:	687b      	ldr	r3, [r7, #4]
 8012154:	681b      	ldr	r3, [r3, #0]
 8012156:	f022 0210 	bic.w	r2, r2, #16
 801215a:	601a      	str	r2, [r3, #0]
        regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 801215c:	687b      	ldr	r3, [r7, #4]
 801215e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8012160:	2220      	movs	r2, #32
 8012162:	409a      	lsls	r2, r3
 8012164:	68fb      	ldr	r3, [r7, #12]
 8012166:	609a      	str	r2, [r3, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
 8012168:	687b      	ldr	r3, [r7, #4]
 801216a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 801216c:	687b      	ldr	r3, [r7, #4]
 801216e:	64da      	str	r2, [r3, #76]	; 0x4c
        hdma->State = HAL_DMA_STATE_READY_MEM0;
 8012170:	687b      	ldr	r3, [r7, #4]
 8012172:	2211      	movs	r2, #17
 8012174:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 8012178:	687b      	ldr	r3, [r7, #4]
 801217a:	2200      	movs	r2, #0
 801217c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        if(hdma->XferCpltCallback != NULL)
 8012180:	687b      	ldr	r3, [r7, #4]
 8012182:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8012184:	2b00      	cmp	r3, #0
 8012186:	d003      	beq.n	8012190 <HAL_DMA_IRQHandler+0x2c8>
          hdma->XferCpltCallback(hdma);
 8012188:	687b      	ldr	r3, [r7, #4]
 801218a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801218c:	6878      	ldr	r0, [r7, #4]
 801218e:	4798      	blx	r3
}
 8012190:	bf00      	nop
 8012192:	3710      	adds	r7, #16
 8012194:	46bd      	mov	sp, r7
 8012196:	bd80      	pop	{r7, pc}
 8012198:	00800001 	.word	0x00800001
 801219c:	00800004 	.word	0x00800004

080121a0 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80121a0:	b480      	push	{r7}
 80121a2:	b085      	sub	sp, #20
 80121a4:	af00      	add	r7, sp, #0
 80121a6:	60f8      	str	r0, [r7, #12]
 80121a8:	60b9      	str	r1, [r7, #8]
 80121aa:	607a      	str	r2, [r7, #4]
 80121ac:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80121ae:	68fb      	ldr	r3, [r7, #12]
 80121b0:	681b      	ldr	r3, [r3, #0]
 80121b2:	681a      	ldr	r2, [r3, #0]
 80121b4:	68fb      	ldr	r3, [r7, #12]
 80121b6:	681b      	ldr	r3, [r3, #0]
 80121b8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80121bc:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 80121be:	68fb      	ldr	r3, [r7, #12]
 80121c0:	681b      	ldr	r3, [r3, #0]
 80121c2:	683a      	ldr	r2, [r7, #0]
 80121c4:	605a      	str	r2, [r3, #4]

  /* Peripheral to Memory */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80121c6:	68fb      	ldr	r3, [r7, #12]
 80121c8:	689b      	ldr	r3, [r3, #8]
 80121ca:	2b40      	cmp	r3, #64	; 0x40
 80121cc:	d108      	bne.n	80121e0 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 80121ce:	68fb      	ldr	r3, [r7, #12]
 80121d0:	681b      	ldr	r3, [r3, #0]
 80121d2:	687a      	ldr	r2, [r7, #4]
 80121d4:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 80121d6:	68fb      	ldr	r3, [r7, #12]
 80121d8:	681b      	ldr	r3, [r3, #0]
 80121da:	68ba      	ldr	r2, [r7, #8]
 80121dc:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;
    
    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 80121de:	e007      	b.n	80121f0 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 80121e0:	68fb      	ldr	r3, [r7, #12]
 80121e2:	681b      	ldr	r3, [r3, #0]
 80121e4:	68ba      	ldr	r2, [r7, #8]
 80121e6:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 80121e8:	68fb      	ldr	r3, [r7, #12]
 80121ea:	681b      	ldr	r3, [r3, #0]
 80121ec:	687a      	ldr	r2, [r7, #4]
 80121ee:	60da      	str	r2, [r3, #12]
}
 80121f0:	bf00      	nop
 80121f2:	3714      	adds	r7, #20
 80121f4:	46bd      	mov	sp, r7
 80121f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80121fa:	4770      	bx	lr

080121fc <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80121fc:	b480      	push	{r7}
 80121fe:	b085      	sub	sp, #20
 8012200:	af00      	add	r7, sp, #0
 8012202:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8012204:	687b      	ldr	r3, [r7, #4]
 8012206:	681b      	ldr	r3, [r3, #0]
 8012208:	b2db      	uxtb	r3, r3
 801220a:	3b10      	subs	r3, #16
 801220c:	4a14      	ldr	r2, [pc, #80]	; (8012260 <DMA_CalcBaseAndBitshift+0x64>)
 801220e:	fba2 2303 	umull	r2, r3, r2, r3
 8012212:	091b      	lsrs	r3, r3, #4
 8012214:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8012216:	4a13      	ldr	r2, [pc, #76]	; (8012264 <DMA_CalcBaseAndBitshift+0x68>)
 8012218:	68fb      	ldr	r3, [r7, #12]
 801221a:	4413      	add	r3, r2
 801221c:	781b      	ldrb	r3, [r3, #0]
 801221e:	461a      	mov	r2, r3
 8012220:	687b      	ldr	r3, [r7, #4]
 8012222:	655a      	str	r2, [r3, #84]	; 0x54
  
  if (stream_number > 3U)
 8012224:	68fb      	ldr	r3, [r7, #12]
 8012226:	2b03      	cmp	r3, #3
 8012228:	d909      	bls.n	801223e <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 801222a:	687b      	ldr	r3, [r7, #4]
 801222c:	681b      	ldr	r3, [r3, #0]
 801222e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8012232:	f023 0303 	bic.w	r3, r3, #3
 8012236:	1d1a      	adds	r2, r3, #4
 8012238:	687b      	ldr	r3, [r7, #4]
 801223a:	651a      	str	r2, [r3, #80]	; 0x50
 801223c:	e007      	b.n	801224e <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 801223e:	687b      	ldr	r3, [r7, #4]
 8012240:	681b      	ldr	r3, [r3, #0]
 8012242:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8012246:	f023 0303 	bic.w	r3, r3, #3
 801224a:	687a      	ldr	r2, [r7, #4]
 801224c:	6513      	str	r3, [r2, #80]	; 0x50
  }
  
  return hdma->StreamBaseAddress;
 801224e:	687b      	ldr	r3, [r7, #4]
 8012250:	6d1b      	ldr	r3, [r3, #80]	; 0x50
}
 8012252:	4618      	mov	r0, r3
 8012254:	3714      	adds	r7, #20
 8012256:	46bd      	mov	sp, r7
 8012258:	f85d 7b04 	ldr.w	r7, [sp], #4
 801225c:	4770      	bx	lr
 801225e:	bf00      	nop
 8012260:	aaaaaaab 	.word	0xaaaaaaab
 8012264:	0801e1e4 	.word	0x0801e1e4

08012268 <HAL_FLASH_Program>:
  * @param  Data: specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8012268:	b580      	push	{r7, lr}
 801226a:	b086      	sub	sp, #24
 801226c:	af00      	add	r7, sp, #0
 801226e:	60f8      	str	r0, [r7, #12]
 8012270:	60b9      	str	r1, [r7, #8]
 8012272:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_ERROR;
 8012276:	2301      	movs	r3, #1
 8012278:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 801227a:	4b23      	ldr	r3, [pc, #140]	; (8012308 <HAL_FLASH_Program+0xa0>)
 801227c:	7e1b      	ldrb	r3, [r3, #24]
 801227e:	2b01      	cmp	r3, #1
 8012280:	d101      	bne.n	8012286 <HAL_FLASH_Program+0x1e>
 8012282:	2302      	movs	r3, #2
 8012284:	e03b      	b.n	80122fe <HAL_FLASH_Program+0x96>
 8012286:	4b20      	ldr	r3, [pc, #128]	; (8012308 <HAL_FLASH_Program+0xa0>)
 8012288:	2201      	movs	r2, #1
 801228a:	761a      	strb	r2, [r3, #24]
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801228c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8012290:	f000 f868 	bl	8012364 <FLASH_WaitForLastOperation>
 8012294:	4603      	mov	r3, r0
 8012296:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
 8012298:	7dfb      	ldrb	r3, [r7, #23]
 801229a:	2b00      	cmp	r3, #0
 801229c:	d12b      	bne.n	80122f6 <HAL_FLASH_Program+0x8e>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 801229e:	68fb      	ldr	r3, [r7, #12]
 80122a0:	2b00      	cmp	r3, #0
 80122a2:	d105      	bne.n	80122b0 <HAL_FLASH_Program+0x48>
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
 80122a4:	783b      	ldrb	r3, [r7, #0]
 80122a6:	4619      	mov	r1, r3
 80122a8:	68b8      	ldr	r0, [r7, #8]
 80122aa:	f000 f907 	bl	80124bc <FLASH_Program_Byte>
 80122ae:	e016      	b.n	80122de <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 80122b0:	68fb      	ldr	r3, [r7, #12]
 80122b2:	2b01      	cmp	r3, #1
 80122b4:	d105      	bne.n	80122c2 <HAL_FLASH_Program+0x5a>
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 80122b6:	883b      	ldrh	r3, [r7, #0]
 80122b8:	4619      	mov	r1, r3
 80122ba:	68b8      	ldr	r0, [r7, #8]
 80122bc:	f000 f8da 	bl	8012474 <FLASH_Program_HalfWord>
 80122c0:	e00d      	b.n	80122de <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 80122c2:	68fb      	ldr	r3, [r7, #12]
 80122c4:	2b02      	cmp	r3, #2
 80122c6:	d105      	bne.n	80122d4 <HAL_FLASH_Program+0x6c>
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
 80122c8:	683b      	ldr	r3, [r7, #0]
 80122ca:	4619      	mov	r1, r3
 80122cc:	68b8      	ldr	r0, [r7, #8]
 80122ce:	f000 f8af 	bl	8012430 <FLASH_Program_Word>
 80122d2:	e004      	b.n	80122de <HAL_FLASH_Program+0x76>
    }
    else
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
 80122d4:	e9d7 2300 	ldrd	r2, r3, [r7]
 80122d8:	68b8      	ldr	r0, [r7, #8]
 80122da:	f000 f885 	bl	80123e8 <FLASH_Program_DoubleWord>
    }
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80122de:	f24c 3050 	movw	r0, #50000	; 0xc350
 80122e2:	f000 f83f 	bl	8012364 <FLASH_WaitForLastOperation>
 80122e6:	4603      	mov	r3, r0
 80122e8:	75fb      	strb	r3, [r7, #23]
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);  
 80122ea:	4b08      	ldr	r3, [pc, #32]	; (801230c <HAL_FLASH_Program+0xa4>)
 80122ec:	691b      	ldr	r3, [r3, #16]
 80122ee:	4a07      	ldr	r2, [pc, #28]	; (801230c <HAL_FLASH_Program+0xa4>)
 80122f0:	f023 0301 	bic.w	r3, r3, #1
 80122f4:	6113      	str	r3, [r2, #16]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 80122f6:	4b04      	ldr	r3, [pc, #16]	; (8012308 <HAL_FLASH_Program+0xa0>)
 80122f8:	2200      	movs	r2, #0
 80122fa:	761a      	strb	r2, [r3, #24]
  
  return status;
 80122fc:	7dfb      	ldrb	r3, [r7, #23]
}
 80122fe:	4618      	mov	r0, r3
 8012300:	3718      	adds	r7, #24
 8012302:	46bd      	mov	sp, r7
 8012304:	bd80      	pop	{r7, pc}
 8012306:	bf00      	nop
 8012308:	2000da3c 	.word	0x2000da3c
 801230c:	40023c00 	.word	0x40023c00

08012310 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 8012310:	b480      	push	{r7}
 8012312:	af00      	add	r7, sp, #0
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8012314:	4b08      	ldr	r3, [pc, #32]	; (8012338 <HAL_FLASH_Unlock+0x28>)
 8012316:	691b      	ldr	r3, [r3, #16]
 8012318:	2b00      	cmp	r3, #0
 801231a:	da07      	bge.n	801232c <HAL_FLASH_Unlock+0x1c>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 801231c:	4b06      	ldr	r3, [pc, #24]	; (8012338 <HAL_FLASH_Unlock+0x28>)
 801231e:	4a07      	ldr	r2, [pc, #28]	; (801233c <HAL_FLASH_Unlock+0x2c>)
 8012320:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8012322:	4b05      	ldr	r3, [pc, #20]	; (8012338 <HAL_FLASH_Unlock+0x28>)
 8012324:	4a06      	ldr	r2, [pc, #24]	; (8012340 <HAL_FLASH_Unlock+0x30>)
 8012326:	605a      	str	r2, [r3, #4]
  else
  {
    return HAL_ERROR;
  }
  
  return HAL_OK; 
 8012328:	2300      	movs	r3, #0
 801232a:	e000      	b.n	801232e <HAL_FLASH_Unlock+0x1e>
    return HAL_ERROR;
 801232c:	2301      	movs	r3, #1
}
 801232e:	4618      	mov	r0, r3
 8012330:	46bd      	mov	sp, r7
 8012332:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012336:	4770      	bx	lr
 8012338:	40023c00 	.word	0x40023c00
 801233c:	45670123 	.word	0x45670123
 8012340:	cdef89ab 	.word	0xcdef89ab

08012344 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 8012344:	b480      	push	{r7}
 8012346:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8012348:	4b05      	ldr	r3, [pc, #20]	; (8012360 <HAL_FLASH_Lock+0x1c>)
 801234a:	691b      	ldr	r3, [r3, #16]
 801234c:	4a04      	ldr	r2, [pc, #16]	; (8012360 <HAL_FLASH_Lock+0x1c>)
 801234e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8012352:	6113      	str	r3, [r2, #16]
  
  return HAL_OK;  
 8012354:	2300      	movs	r3, #0
}
 8012356:	4618      	mov	r0, r3
 8012358:	46bd      	mov	sp, r7
 801235a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801235e:	4770      	bx	lr
 8012360:	40023c00 	.word	0x40023c00

08012364 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout: maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 8012364:	b580      	push	{r7, lr}
 8012366:	b084      	sub	sp, #16
 8012368:	af00      	add	r7, sp, #0
 801236a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 801236c:	2300      	movs	r3, #0
 801236e:	60fb      	str	r3, [r7, #12]
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8012370:	4b1b      	ldr	r3, [pc, #108]	; (80123e0 <FLASH_WaitForLastOperation+0x7c>)
 8012372:	2200      	movs	r2, #0
 8012374:	61da      	str	r2, [r3, #28]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 8012376:	f7ff f8d7 	bl	8011528 <HAL_GetTick>
 801237a:	60f8      	str	r0, [r7, #12]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 801237c:	e010      	b.n	80123a0 <FLASH_WaitForLastOperation+0x3c>
  { 
    if(Timeout != HAL_MAX_DELAY)
 801237e:	687b      	ldr	r3, [r7, #4]
 8012380:	f1b3 3fff 	cmp.w	r3, #4294967295
 8012384:	d00c      	beq.n	80123a0 <FLASH_WaitForLastOperation+0x3c>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8012386:	687b      	ldr	r3, [r7, #4]
 8012388:	2b00      	cmp	r3, #0
 801238a:	d007      	beq.n	801239c <FLASH_WaitForLastOperation+0x38>
 801238c:	f7ff f8cc 	bl	8011528 <HAL_GetTick>
 8012390:	4602      	mov	r2, r0
 8012392:	68fb      	ldr	r3, [r7, #12]
 8012394:	1ad3      	subs	r3, r2, r3
 8012396:	687a      	ldr	r2, [r7, #4]
 8012398:	429a      	cmp	r2, r3
 801239a:	d201      	bcs.n	80123a0 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
 801239c:	2303      	movs	r3, #3
 801239e:	e01b      	b.n	80123d8 <FLASH_WaitForLastOperation+0x74>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 80123a0:	4b10      	ldr	r3, [pc, #64]	; (80123e4 <FLASH_WaitForLastOperation+0x80>)
 80123a2:	68db      	ldr	r3, [r3, #12]
 80123a4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80123a8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80123ac:	d0e7      	beq.n	801237e <FLASH_WaitForLastOperation+0x1a>
      }
    } 
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 80123ae:	4b0d      	ldr	r3, [pc, #52]	; (80123e4 <FLASH_WaitForLastOperation+0x80>)
 80123b0:	68db      	ldr	r3, [r3, #12]
 80123b2:	f003 0301 	and.w	r3, r3, #1
 80123b6:	2b01      	cmp	r3, #1
 80123b8:	d102      	bne.n	80123c0 <FLASH_WaitForLastOperation+0x5c>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80123ba:	4b0a      	ldr	r3, [pc, #40]	; (80123e4 <FLASH_WaitForLastOperation+0x80>)
 80123bc:	2201      	movs	r2, #1
 80123be:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 80123c0:	4b08      	ldr	r3, [pc, #32]	; (80123e4 <FLASH_WaitForLastOperation+0x80>)
 80123c2:	68db      	ldr	r3, [r3, #12]
 80123c4:	f403 73f9 	and.w	r3, r3, #498	; 0x1f2
 80123c8:	f5b3 7ff9 	cmp.w	r3, #498	; 0x1f2
 80123cc:	d103      	bne.n	80123d6 <FLASH_WaitForLastOperation+0x72>
                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 80123ce:	f000 f897 	bl	8012500 <FLASH_SetErrorCode>
    return HAL_ERROR;
 80123d2:	2301      	movs	r3, #1
 80123d4:	e000      	b.n	80123d8 <FLASH_WaitForLastOperation+0x74>
  }

  /* If there is no error flag set */
  return HAL_OK;
 80123d6:	2300      	movs	r3, #0
  
}  
 80123d8:	4618      	mov	r0, r3
 80123da:	3710      	adds	r7, #16
 80123dc:	46bd      	mov	sp, r7
 80123de:	bd80      	pop	{r7, pc}
 80123e0:	2000da3c 	.word	0x2000da3c
 80123e4:	40023c00 	.word	0x40023c00

080123e8 <FLASH_Program_DoubleWord>:
  * @param  Address: specifies the address to be programmed.
  * @param  Data: specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 80123e8:	b490      	push	{r4, r7}
 80123ea:	b084      	sub	sp, #16
 80123ec:	af00      	add	r7, sp, #0
 80123ee:	60f8      	str	r0, [r7, #12]
 80123f0:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80123f4:	4b0d      	ldr	r3, [pc, #52]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 80123f6:	691b      	ldr	r3, [r3, #16]
 80123f8:	4a0c      	ldr	r2, [pc, #48]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 80123fa:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80123fe:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8012400:	4b0a      	ldr	r3, [pc, #40]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 8012402:	691b      	ldr	r3, [r3, #16]
 8012404:	4a09      	ldr	r2, [pc, #36]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 8012406:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 801240a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 801240c:	4b07      	ldr	r3, [pc, #28]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 801240e:	691b      	ldr	r3, [r3, #16]
 8012410:	4a06      	ldr	r2, [pc, #24]	; (801242c <FLASH_Program_DoubleWord+0x44>)
 8012412:	f043 0301 	orr.w	r3, r3, #1
 8012416:	6113      	str	r3, [r2, #16]

  *(__IO uint64_t*)Address = Data;
 8012418:	68fa      	ldr	r2, [r7, #12]
 801241a:	e9d7 3400 	ldrd	r3, r4, [r7]
 801241e:	e9c2 3400 	strd	r3, r4, [r2]
}
 8012422:	bf00      	nop
 8012424:	3710      	adds	r7, #16
 8012426:	46bd      	mov	sp, r7
 8012428:	bc90      	pop	{r4, r7}
 801242a:	4770      	bx	lr
 801242c:	40023c00 	.word	0x40023c00

08012430 <FLASH_Program_Word>:
  * @param  Address: specifies the address to be programmed.
  * @param  Data: specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
{
 8012430:	b480      	push	{r7}
 8012432:	b083      	sub	sp, #12
 8012434:	af00      	add	r7, sp, #0
 8012436:	6078      	str	r0, [r7, #4]
 8012438:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 801243a:	4b0d      	ldr	r3, [pc, #52]	; (8012470 <FLASH_Program_Word+0x40>)
 801243c:	691b      	ldr	r3, [r3, #16]
 801243e:	4a0c      	ldr	r2, [pc, #48]	; (8012470 <FLASH_Program_Word+0x40>)
 8012440:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8012444:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8012446:	4b0a      	ldr	r3, [pc, #40]	; (8012470 <FLASH_Program_Word+0x40>)
 8012448:	691b      	ldr	r3, [r3, #16]
 801244a:	4a09      	ldr	r2, [pc, #36]	; (8012470 <FLASH_Program_Word+0x40>)
 801244c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012450:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8012452:	4b07      	ldr	r3, [pc, #28]	; (8012470 <FLASH_Program_Word+0x40>)
 8012454:	691b      	ldr	r3, [r3, #16]
 8012456:	4a06      	ldr	r2, [pc, #24]	; (8012470 <FLASH_Program_Word+0x40>)
 8012458:	f043 0301 	orr.w	r3, r3, #1
 801245c:	6113      	str	r3, [r2, #16]

  *(__IO uint32_t*)Address = Data;
 801245e:	687b      	ldr	r3, [r7, #4]
 8012460:	683a      	ldr	r2, [r7, #0]
 8012462:	601a      	str	r2, [r3, #0]
}
 8012464:	bf00      	nop
 8012466:	370c      	adds	r7, #12
 8012468:	46bd      	mov	sp, r7
 801246a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801246e:	4770      	bx	lr
 8012470:	40023c00 	.word	0x40023c00

08012474 <FLASH_Program_HalfWord>:
  * @param  Address: specifies the address to be programmed.
  * @param  Data: specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
 8012474:	b480      	push	{r7}
 8012476:	b083      	sub	sp, #12
 8012478:	af00      	add	r7, sp, #0
 801247a:	6078      	str	r0, [r7, #4]
 801247c:	460b      	mov	r3, r1
 801247e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8012480:	4b0d      	ldr	r3, [pc, #52]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 8012482:	691b      	ldr	r3, [r3, #16]
 8012484:	4a0c      	ldr	r2, [pc, #48]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 8012486:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 801248a:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 801248c:	4b0a      	ldr	r3, [pc, #40]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 801248e:	691b      	ldr	r3, [r3, #16]
 8012490:	4a09      	ldr	r2, [pc, #36]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 8012492:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8012496:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8012498:	4b07      	ldr	r3, [pc, #28]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 801249a:	691b      	ldr	r3, [r3, #16]
 801249c:	4a06      	ldr	r2, [pc, #24]	; (80124b8 <FLASH_Program_HalfWord+0x44>)
 801249e:	f043 0301 	orr.w	r3, r3, #1
 80124a2:	6113      	str	r3, [r2, #16]

  *(__IO uint16_t*)Address = Data;
 80124a4:	687b      	ldr	r3, [r7, #4]
 80124a6:	887a      	ldrh	r2, [r7, #2]
 80124a8:	801a      	strh	r2, [r3, #0]
}
 80124aa:	bf00      	nop
 80124ac:	370c      	adds	r7, #12
 80124ae:	46bd      	mov	sp, r7
 80124b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80124b4:	4770      	bx	lr
 80124b6:	bf00      	nop
 80124b8:	40023c00 	.word	0x40023c00

080124bc <FLASH_Program_Byte>:
  * @param  Address: specifies the address to be programmed.
  * @param  Data: specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
{
 80124bc:	b480      	push	{r7}
 80124be:	b083      	sub	sp, #12
 80124c0:	af00      	add	r7, sp, #0
 80124c2:	6078      	str	r0, [r7, #4]
 80124c4:	460b      	mov	r3, r1
 80124c6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80124c8:	4b0c      	ldr	r3, [pc, #48]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124ca:	691b      	ldr	r3, [r3, #16]
 80124cc:	4a0b      	ldr	r2, [pc, #44]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124ce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80124d2:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 80124d4:	4b09      	ldr	r3, [pc, #36]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124d6:	4a09      	ldr	r2, [pc, #36]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124d8:	691b      	ldr	r3, [r3, #16]
 80124da:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 80124dc:	4b07      	ldr	r3, [pc, #28]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124de:	691b      	ldr	r3, [r3, #16]
 80124e0:	4a06      	ldr	r2, [pc, #24]	; (80124fc <FLASH_Program_Byte+0x40>)
 80124e2:	f043 0301 	orr.w	r3, r3, #1
 80124e6:	6113      	str	r3, [r2, #16]

  *(__IO uint8_t*)Address = Data;
 80124e8:	687b      	ldr	r3, [r7, #4]
 80124ea:	78fa      	ldrb	r2, [r7, #3]
 80124ec:	701a      	strb	r2, [r3, #0]
}
 80124ee:	bf00      	nop
 80124f0:	370c      	adds	r7, #12
 80124f2:	46bd      	mov	sp, r7
 80124f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80124f8:	4770      	bx	lr
 80124fa:	bf00      	nop
 80124fc:	40023c00 	.word	0x40023c00

08012500 <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
 8012500:	b480      	push	{r7}
 8012502:	af00      	add	r7, sp, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8012504:	4b30      	ldr	r3, [pc, #192]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012506:	68db      	ldr	r3, [r3, #12]
 8012508:	f003 0310 	and.w	r3, r3, #16
 801250c:	2b10      	cmp	r3, #16
 801250e:	d108      	bne.n	8012522 <FLASH_SetErrorCode+0x22>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8012510:	4b2e      	ldr	r3, [pc, #184]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012512:	69db      	ldr	r3, [r3, #28]
 8012514:	f043 0310 	orr.w	r3, r3, #16
 8012518:	4a2c      	ldr	r2, [pc, #176]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 801251a:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 801251c:	4b2a      	ldr	r3, [pc, #168]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 801251e:	2210      	movs	r2, #16
 8012520:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8012522:	4b29      	ldr	r3, [pc, #164]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012524:	68db      	ldr	r3, [r3, #12]
 8012526:	f003 0320 	and.w	r3, r3, #32
 801252a:	2b20      	cmp	r3, #32
 801252c:	d108      	bne.n	8012540 <FLASH_SetErrorCode+0x40>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 801252e:	4b27      	ldr	r3, [pc, #156]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012530:	69db      	ldr	r3, [r3, #28]
 8012532:	f043 0308 	orr.w	r3, r3, #8
 8012536:	4a25      	ldr	r2, [pc, #148]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012538:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 801253a:	4b23      	ldr	r3, [pc, #140]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 801253c:	2220      	movs	r2, #32
 801253e:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8012540:	4b21      	ldr	r3, [pc, #132]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012542:	68db      	ldr	r3, [r3, #12]
 8012544:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012548:	2b40      	cmp	r3, #64	; 0x40
 801254a:	d108      	bne.n	801255e <FLASH_SetErrorCode+0x5e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 801254c:	4b1f      	ldr	r3, [pc, #124]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 801254e:	69db      	ldr	r3, [r3, #28]
 8012550:	f043 0304 	orr.w	r3, r3, #4
 8012554:	4a1d      	ldr	r2, [pc, #116]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012556:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8012558:	4b1b      	ldr	r3, [pc, #108]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 801255a:	2240      	movs	r2, #64	; 0x40
 801255c:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 801255e:	4b1a      	ldr	r3, [pc, #104]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012560:	68db      	ldr	r3, [r3, #12]
 8012562:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8012566:	2b80      	cmp	r3, #128	; 0x80
 8012568:	d108      	bne.n	801257c <FLASH_SetErrorCode+0x7c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 801256a:	4b18      	ldr	r3, [pc, #96]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 801256c:	69db      	ldr	r3, [r3, #28]
 801256e:	f043 0302 	orr.w	r3, r3, #2
 8012572:	4a16      	ldr	r2, [pc, #88]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012574:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 8012576:	4b14      	ldr	r3, [pc, #80]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012578:	2280      	movs	r2, #128	; 0x80
 801257a:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 801257c:	4b12      	ldr	r3, [pc, #72]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 801257e:	68db      	ldr	r3, [r3, #12]
 8012580:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8012584:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012588:	d109      	bne.n	801259e <FLASH_SetErrorCode+0x9e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 801258a:	4b10      	ldr	r3, [pc, #64]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 801258c:	69db      	ldr	r3, [r3, #28]
 801258e:	f043 0301 	orr.w	r3, r3, #1
 8012592:	4a0e      	ldr	r2, [pc, #56]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 8012594:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8012596:	4b0c      	ldr	r3, [pc, #48]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 8012598:	f44f 7280 	mov.w	r2, #256	; 0x100
 801259c:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 801259e:	4b0a      	ldr	r3, [pc, #40]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 80125a0:	68db      	ldr	r3, [r3, #12]
 80125a2:	f003 0302 	and.w	r3, r3, #2
 80125a6:	2b02      	cmp	r3, #2
 80125a8:	d108      	bne.n	80125bc <FLASH_SetErrorCode+0xbc>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 80125aa:	4b08      	ldr	r3, [pc, #32]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 80125ac:	69db      	ldr	r3, [r3, #28]
 80125ae:	f043 0320 	orr.w	r3, r3, #32
 80125b2:	4a06      	ldr	r2, [pc, #24]	; (80125cc <FLASH_SetErrorCode+0xcc>)
 80125b4:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 80125b6:	4b04      	ldr	r3, [pc, #16]	; (80125c8 <FLASH_SetErrorCode+0xc8>)
 80125b8:	2202      	movs	r2, #2
 80125ba:	60da      	str	r2, [r3, #12]
  }
}
 80125bc:	bf00      	nop
 80125be:	46bd      	mov	sp, r7
 80125c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125c4:	4770      	bx	lr
 80125c6:	bf00      	nop
 80125c8:	40023c00 	.word	0x40023c00
 80125cc:	2000da3c 	.word	0x2000da3c

080125d0 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  * 
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 80125d0:	b580      	push	{r7, lr}
 80125d2:	b084      	sub	sp, #16
 80125d4:	af00      	add	r7, sp, #0
 80125d6:	6078      	str	r0, [r7, #4]
 80125d8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
 80125da:	2301      	movs	r3, #1
 80125dc:	73fb      	strb	r3, [r7, #15]
  uint32_t index = 0U;
 80125de:	2300      	movs	r3, #0
 80125e0:	60bb      	str	r3, [r7, #8]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 80125e2:	4b32      	ldr	r3, [pc, #200]	; (80126ac <HAL_FLASHEx_Erase+0xdc>)
 80125e4:	7e1b      	ldrb	r3, [r3, #24]
 80125e6:	2b01      	cmp	r3, #1
 80125e8:	d101      	bne.n	80125ee <HAL_FLASHEx_Erase+0x1e>
 80125ea:	2302      	movs	r3, #2
 80125ec:	e05a      	b.n	80126a4 <HAL_FLASHEx_Erase+0xd4>
 80125ee:	4b2f      	ldr	r3, [pc, #188]	; (80126ac <HAL_FLASHEx_Erase+0xdc>)
 80125f0:	2201      	movs	r2, #1
 80125f2:	761a      	strb	r2, [r3, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80125f4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80125f8:	f7ff feb4 	bl	8012364 <FLASH_WaitForLastOperation>
 80125fc:	4603      	mov	r3, r0
 80125fe:	73fb      	strb	r3, [r7, #15]

  if(status == HAL_OK)
 8012600:	7bfb      	ldrb	r3, [r7, #15]
 8012602:	2b00      	cmp	r3, #0
 8012604:	d14a      	bne.n	801269c <HAL_FLASHEx_Erase+0xcc>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 8012606:	683b      	ldr	r3, [r7, #0]
 8012608:	f04f 32ff 	mov.w	r2, #4294967295
 801260c:	601a      	str	r2, [r3, #0]
    
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 801260e:	687b      	ldr	r3, [r7, #4]
 8012610:	681b      	ldr	r3, [r3, #0]
 8012612:	2b01      	cmp	r3, #1
 8012614:	d117      	bne.n	8012646 <HAL_FLASHEx_Erase+0x76>
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8012616:	687b      	ldr	r3, [r7, #4]
 8012618:	691b      	ldr	r3, [r3, #16]
 801261a:	b2da      	uxtb	r2, r3
 801261c:	687b      	ldr	r3, [r7, #4]
 801261e:	685b      	ldr	r3, [r3, #4]
 8012620:	4619      	mov	r1, r3
 8012622:	4610      	mov	r0, r2
 8012624:	f000 f846 	bl	80126b4 <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8012628:	f24c 3050 	movw	r0, #50000	; 0xc350
 801262c:	f7ff fe9a 	bl	8012364 <FLASH_WaitForLastOperation>
 8012630:	4603      	mov	r3, r0
 8012632:	73fb      	strb	r3, [r7, #15]
      
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 8012634:	4b1e      	ldr	r3, [pc, #120]	; (80126b0 <HAL_FLASHEx_Erase+0xe0>)
 8012636:	691b      	ldr	r3, [r3, #16]
 8012638:	4a1d      	ldr	r2, [pc, #116]	; (80126b0 <HAL_FLASHEx_Erase+0xe0>)
 801263a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 801263e:	f023 0304 	bic.w	r3, r3, #4
 8012642:	6113      	str	r3, [r2, #16]
 8012644:	e028      	b.n	8012698 <HAL_FLASHEx_Erase+0xc8>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8012646:	687b      	ldr	r3, [r7, #4]
 8012648:	689b      	ldr	r3, [r3, #8]
 801264a:	60bb      	str	r3, [r7, #8]
 801264c:	e01c      	b.n	8012688 <HAL_FLASHEx_Erase+0xb8>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 801264e:	687b      	ldr	r3, [r7, #4]
 8012650:	691b      	ldr	r3, [r3, #16]
 8012652:	b2db      	uxtb	r3, r3
 8012654:	4619      	mov	r1, r3
 8012656:	68b8      	ldr	r0, [r7, #8]
 8012658:	f000 f866 	bl	8012728 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 801265c:	f24c 3050 	movw	r0, #50000	; 0xc350
 8012660:	f7ff fe80 	bl	8012364 <FLASH_WaitForLastOperation>
 8012664:	4603      	mov	r3, r0
 8012666:	73fb      	strb	r3, [r7, #15]
        
        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8012668:	4b11      	ldr	r3, [pc, #68]	; (80126b0 <HAL_FLASHEx_Erase+0xe0>)
 801266a:	691b      	ldr	r3, [r3, #16]
 801266c:	4a10      	ldr	r2, [pc, #64]	; (80126b0 <HAL_FLASHEx_Erase+0xe0>)
 801266e:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8012672:	6113      	str	r3, [r2, #16]

        if(status != HAL_OK) 
 8012674:	7bfb      	ldrb	r3, [r7, #15]
 8012676:	2b00      	cmp	r3, #0
 8012678:	d003      	beq.n	8012682 <HAL_FLASHEx_Erase+0xb2>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
 801267a:	683b      	ldr	r3, [r7, #0]
 801267c:	68ba      	ldr	r2, [r7, #8]
 801267e:	601a      	str	r2, [r3, #0]
          break;
 8012680:	e00a      	b.n	8012698 <HAL_FLASHEx_Erase+0xc8>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8012682:	68bb      	ldr	r3, [r7, #8]
 8012684:	3301      	adds	r3, #1
 8012686:	60bb      	str	r3, [r7, #8]
 8012688:	687b      	ldr	r3, [r7, #4]
 801268a:	68da      	ldr	r2, [r3, #12]
 801268c:	687b      	ldr	r3, [r7, #4]
 801268e:	689b      	ldr	r3, [r3, #8]
 8012690:	4413      	add	r3, r2
 8012692:	68ba      	ldr	r2, [r7, #8]
 8012694:	429a      	cmp	r2, r3
 8012696:	d3da      	bcc.n	801264e <HAL_FLASHEx_Erase+0x7e>
        }
      }
    }
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();    
 8012698:	f000 f89e 	bl	80127d8 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 801269c:	4b03      	ldr	r3, [pc, #12]	; (80126ac <HAL_FLASHEx_Erase+0xdc>)
 801269e:	2200      	movs	r2, #0
 80126a0:	761a      	strb	r2, [r3, #24]

  return status;
 80126a2:	7bfb      	ldrb	r3, [r7, #15]
}
 80126a4:	4618      	mov	r0, r3
 80126a6:	3710      	adds	r7, #16
 80126a8:	46bd      	mov	sp, r7
 80126aa:	bd80      	pop	{r7, pc}
 80126ac:	2000da3c 	.word	0x2000da3c
 80126b0:	40023c00 	.word	0x40023c00

080126b4 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
{
 80126b4:	b480      	push	{r7}
 80126b6:	b083      	sub	sp, #12
 80126b8:	af00      	add	r7, sp, #0
 80126ba:	4603      	mov	r3, r0
 80126bc:	6039      	str	r1, [r7, #0]
 80126be:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* if the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80126c0:	4b18      	ldr	r3, [pc, #96]	; (8012724 <FLASH_MassErase+0x70>)
 80126c2:	691b      	ldr	r3, [r3, #16]
 80126c4:	4a17      	ldr	r2, [pc, #92]	; (8012724 <FLASH_MassErase+0x70>)
 80126c6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80126ca:	6113      	str	r3, [r2, #16]

  if(Banks == FLASH_BANK_BOTH)
 80126cc:	683b      	ldr	r3, [r7, #0]
 80126ce:	2b03      	cmp	r3, #3
 80126d0:	d108      	bne.n	80126e4 <FLASH_MassErase+0x30>
  {
    /* bank1 & bank2 will be erased*/
    FLASH->CR |= FLASH_MER_BIT;
 80126d2:	4b14      	ldr	r3, [pc, #80]	; (8012724 <FLASH_MassErase+0x70>)
 80126d4:	691b      	ldr	r3, [r3, #16]
 80126d6:	4a13      	ldr	r2, [pc, #76]	; (8012724 <FLASH_MassErase+0x70>)
 80126d8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80126dc:	f043 0304 	orr.w	r3, r3, #4
 80126e0:	6113      	str	r3, [r2, #16]
 80126e2:	e00f      	b.n	8012704 <FLASH_MassErase+0x50>
  }
  else if(Banks == FLASH_BANK_1)
 80126e4:	683b      	ldr	r3, [r7, #0]
 80126e6:	2b01      	cmp	r3, #1
 80126e8:	d106      	bne.n	80126f8 <FLASH_MassErase+0x44>
  {
    /*Only bank1 will be erased*/
    FLASH->CR |= FLASH_CR_MER1;
 80126ea:	4b0e      	ldr	r3, [pc, #56]	; (8012724 <FLASH_MassErase+0x70>)
 80126ec:	691b      	ldr	r3, [r3, #16]
 80126ee:	4a0d      	ldr	r2, [pc, #52]	; (8012724 <FLASH_MassErase+0x70>)
 80126f0:	f043 0304 	orr.w	r3, r3, #4
 80126f4:	6113      	str	r3, [r2, #16]
 80126f6:	e005      	b.n	8012704 <FLASH_MassErase+0x50>
  }
  else
  {
    /*Only bank2 will be erased*/
    FLASH->CR |= FLASH_CR_MER2;
 80126f8:	4b0a      	ldr	r3, [pc, #40]	; (8012724 <FLASH_MassErase+0x70>)
 80126fa:	691b      	ldr	r3, [r3, #16]
 80126fc:	4a09      	ldr	r2, [pc, #36]	; (8012724 <FLASH_MassErase+0x70>)
 80126fe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8012702:	6113      	str	r3, [r2, #16]
  }
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 8012704:	4b07      	ldr	r3, [pc, #28]	; (8012724 <FLASH_MassErase+0x70>)
 8012706:	691a      	ldr	r2, [r3, #16]
 8012708:	79fb      	ldrb	r3, [r7, #7]
 801270a:	021b      	lsls	r3, r3, #8
 801270c:	4313      	orrs	r3, r2
 801270e:	4a05      	ldr	r2, [pc, #20]	; (8012724 <FLASH_MassErase+0x70>)
 8012710:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8012714:	6113      	str	r3, [r2, #16]
}
 8012716:	bf00      	nop
 8012718:	370c      	adds	r7, #12
 801271a:	46bd      	mov	sp, r7
 801271c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012720:	4770      	bx	lr
 8012722:	bf00      	nop
 8012724:	40023c00 	.word	0x40023c00

08012728 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 8012728:	b480      	push	{r7}
 801272a:	b087      	sub	sp, #28
 801272c:	af00      	add	r7, sp, #0
 801272e:	6078      	str	r0, [r7, #4]
 8012730:	460b      	mov	r3, r1
 8012732:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0U;
 8012734:	2300      	movs	r3, #0
 8012736:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8012738:	78fb      	ldrb	r3, [r7, #3]
 801273a:	2b00      	cmp	r3, #0
 801273c:	d102      	bne.n	8012744 <FLASH_Erase_Sector+0x1c>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 801273e:	2300      	movs	r3, #0
 8012740:	617b      	str	r3, [r7, #20]
 8012742:	e010      	b.n	8012766 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 8012744:	78fb      	ldrb	r3, [r7, #3]
 8012746:	2b01      	cmp	r3, #1
 8012748:	d103      	bne.n	8012752 <FLASH_Erase_Sector+0x2a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 801274a:	f44f 7380 	mov.w	r3, #256	; 0x100
 801274e:	617b      	str	r3, [r7, #20]
 8012750:	e009      	b.n	8012766 <FLASH_Erase_Sector+0x3e>
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
 8012752:	78fb      	ldrb	r3, [r7, #3]
 8012754:	2b02      	cmp	r3, #2
 8012756:	d103      	bne.n	8012760 <FLASH_Erase_Sector+0x38>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8012758:	f44f 7300 	mov.w	r3, #512	; 0x200
 801275c:	617b      	str	r3, [r7, #20]
 801275e:	e002      	b.n	8012766 <FLASH_Erase_Sector+0x3e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8012760:	f44f 7340 	mov.w	r3, #768	; 0x300
 8012764:	617b      	str	r3, [r7, #20]
  }

  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
  if(Sector > FLASH_SECTOR_11) 
 8012766:	687b      	ldr	r3, [r7, #4]
 8012768:	2b0b      	cmp	r3, #11
 801276a:	d902      	bls.n	8012772 <FLASH_Erase_Sector+0x4a>
  {
    Sector += 4U;
 801276c:	687b      	ldr	r3, [r7, #4]
 801276e:	3304      	adds	r3, #4
 8012770:	607b      	str	r3, [r7, #4]
  }
  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8012772:	4b18      	ldr	r3, [pc, #96]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 8012774:	691b      	ldr	r3, [r3, #16]
 8012776:	4a17      	ldr	r2, [pc, #92]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 8012778:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 801277c:	6113      	str	r3, [r2, #16]
  FLASH->CR |= tmp_psize;
 801277e:	4b15      	ldr	r3, [pc, #84]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 8012780:	691a      	ldr	r2, [r3, #16]
 8012782:	4914      	ldr	r1, [pc, #80]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 8012784:	697b      	ldr	r3, [r7, #20]
 8012786:	4313      	orrs	r3, r2
 8012788:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 801278a:	4b12      	ldr	r3, [pc, #72]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 801278c:	691b      	ldr	r3, [r3, #16]
 801278e:	4a11      	ldr	r2, [pc, #68]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 8012790:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8012794:	6113      	str	r3, [r2, #16]
 8012796:	23f8      	movs	r3, #248	; 0xf8
 8012798:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801279a:	693b      	ldr	r3, [r7, #16]
 801279c:	fa93 f3a3 	rbit	r3, r3
 80127a0:	60fb      	str	r3, [r7, #12]
  return(result);
 80127a2:	68fb      	ldr	r3, [r7, #12]
  FLASH->CR |= FLASH_CR_SER | (Sector << POSITION_VAL(FLASH_CR_SNB));
 80127a4:	fab3 f383 	clz	r3, r3
 80127a8:	687a      	ldr	r2, [r7, #4]
 80127aa:	fa02 f303 	lsl.w	r3, r2, r3
 80127ae:	f043 0202 	orr.w	r2, r3, #2
 80127b2:	4b08      	ldr	r3, [pc, #32]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 80127b4:	691b      	ldr	r3, [r3, #16]
 80127b6:	4907      	ldr	r1, [pc, #28]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 80127b8:	4313      	orrs	r3, r2
 80127ba:	610b      	str	r3, [r1, #16]
  FLASH->CR |= FLASH_CR_STRT;
 80127bc:	4b05      	ldr	r3, [pc, #20]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 80127be:	691b      	ldr	r3, [r3, #16]
 80127c0:	4a04      	ldr	r2, [pc, #16]	; (80127d4 <FLASH_Erase_Sector+0xac>)
 80127c2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80127c6:	6113      	str	r3, [r2, #16]
}
 80127c8:	bf00      	nop
 80127ca:	371c      	adds	r7, #28
 80127cc:	46bd      	mov	sp, r7
 80127ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127d2:	4770      	bx	lr
 80127d4:	40023c00 	.word	0x40023c00

080127d8 <FLASH_FlushCaches>:
/**
  * @brief  Flush the instruction and data caches
  * @retval None
  */
void FLASH_FlushCaches(void)
{
 80127d8:	b480      	push	{r7}
 80127da:	af00      	add	r7, sp, #0
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 80127dc:	4b20      	ldr	r3, [pc, #128]	; (8012860 <FLASH_FlushCaches+0x88>)
 80127de:	681b      	ldr	r3, [r3, #0]
 80127e0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80127e4:	2b00      	cmp	r3, #0
 80127e6:	d017      	beq.n	8012818 <FLASH_FlushCaches+0x40>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 80127e8:	4b1d      	ldr	r3, [pc, #116]	; (8012860 <FLASH_FlushCaches+0x88>)
 80127ea:	681b      	ldr	r3, [r3, #0]
 80127ec:	4a1c      	ldr	r2, [pc, #112]	; (8012860 <FLASH_FlushCaches+0x88>)
 80127ee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80127f2:	6013      	str	r3, [r2, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 80127f4:	4b1a      	ldr	r3, [pc, #104]	; (8012860 <FLASH_FlushCaches+0x88>)
 80127f6:	681b      	ldr	r3, [r3, #0]
 80127f8:	4a19      	ldr	r2, [pc, #100]	; (8012860 <FLASH_FlushCaches+0x88>)
 80127fa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80127fe:	6013      	str	r3, [r2, #0]
 8012800:	4b17      	ldr	r3, [pc, #92]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012802:	681b      	ldr	r3, [r3, #0]
 8012804:	4a16      	ldr	r2, [pc, #88]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012806:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 801280a:	6013      	str	r3, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 801280c:	4b14      	ldr	r3, [pc, #80]	; (8012860 <FLASH_FlushCaches+0x88>)
 801280e:	681b      	ldr	r3, [r3, #0]
 8012810:	4a13      	ldr	r2, [pc, #76]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012812:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012816:	6013      	str	r3, [r2, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8012818:	4b11      	ldr	r3, [pc, #68]	; (8012860 <FLASH_FlushCaches+0x88>)
 801281a:	681b      	ldr	r3, [r3, #0]
 801281c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8012820:	2b00      	cmp	r3, #0
 8012822:	d017      	beq.n	8012854 <FLASH_FlushCaches+0x7c>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8012824:	4b0e      	ldr	r3, [pc, #56]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012826:	681b      	ldr	r3, [r3, #0]
 8012828:	4a0d      	ldr	r2, [pc, #52]	; (8012860 <FLASH_FlushCaches+0x88>)
 801282a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 801282e:	6013      	str	r3, [r2, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8012830:	4b0b      	ldr	r3, [pc, #44]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012832:	681b      	ldr	r3, [r3, #0]
 8012834:	4a0a      	ldr	r2, [pc, #40]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012836:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 801283a:	6013      	str	r3, [r2, #0]
 801283c:	4b08      	ldr	r3, [pc, #32]	; (8012860 <FLASH_FlushCaches+0x88>)
 801283e:	681b      	ldr	r3, [r3, #0]
 8012840:	4a07      	ldr	r2, [pc, #28]	; (8012860 <FLASH_FlushCaches+0x88>)
 8012842:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8012846:	6013      	str	r3, [r2, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8012848:	4b05      	ldr	r3, [pc, #20]	; (8012860 <FLASH_FlushCaches+0x88>)
 801284a:	681b      	ldr	r3, [r3, #0]
 801284c:	4a04      	ldr	r2, [pc, #16]	; (8012860 <FLASH_FlushCaches+0x88>)
 801284e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8012852:	6013      	str	r3, [r2, #0]
  }
}
 8012854:	bf00      	nop
 8012856:	46bd      	mov	sp, r7
 8012858:	f85d 7b04 	ldr.w	r7, [sp], #4
 801285c:	4770      	bx	lr
 801285e:	bf00      	nop
 8012860:	40023c00 	.word	0x40023c00

08012864 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8012864:	b480      	push	{r7}
 8012866:	b089      	sub	sp, #36	; 0x24
 8012868:	af00      	add	r7, sp, #0
 801286a:	6078      	str	r0, [r7, #4]
 801286c:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 801286e:	2300      	movs	r3, #0
 8012870:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8012872:	2300      	movs	r3, #0
 8012874:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8012876:	2300      	movs	r3, #0
 8012878:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 801287a:	2300      	movs	r3, #0
 801287c:	61fb      	str	r3, [r7, #28]
 801287e:	e177      	b.n	8012b70 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8012880:	2201      	movs	r2, #1
 8012882:	69fb      	ldr	r3, [r7, #28]
 8012884:	fa02 f303 	lsl.w	r3, r2, r3
 8012888:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 801288a:	683b      	ldr	r3, [r7, #0]
 801288c:	681b      	ldr	r3, [r3, #0]
 801288e:	697a      	ldr	r2, [r7, #20]
 8012890:	4013      	ands	r3, r2
 8012892:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8012894:	693a      	ldr	r2, [r7, #16]
 8012896:	697b      	ldr	r3, [r7, #20]
 8012898:	429a      	cmp	r2, r3
 801289a:	f040 8166 	bne.w	8012b6a <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 801289e:	683b      	ldr	r3, [r7, #0]
 80128a0:	685b      	ldr	r3, [r3, #4]
 80128a2:	2b02      	cmp	r3, #2
 80128a4:	d003      	beq.n	80128ae <HAL_GPIO_Init+0x4a>
 80128a6:	683b      	ldr	r3, [r7, #0]
 80128a8:	685b      	ldr	r3, [r3, #4]
 80128aa:	2b12      	cmp	r3, #18
 80128ac:	d123      	bne.n	80128f6 <HAL_GPIO_Init+0x92>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80128ae:	69fb      	ldr	r3, [r7, #28]
 80128b0:	08da      	lsrs	r2, r3, #3
 80128b2:	687b      	ldr	r3, [r7, #4]
 80128b4:	3208      	adds	r2, #8
 80128b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80128ba:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 80128bc:	69fb      	ldr	r3, [r7, #28]
 80128be:	f003 0307 	and.w	r3, r3, #7
 80128c2:	009b      	lsls	r3, r3, #2
 80128c4:	220f      	movs	r2, #15
 80128c6:	fa02 f303 	lsl.w	r3, r2, r3
 80128ca:	43db      	mvns	r3, r3
 80128cc:	69ba      	ldr	r2, [r7, #24]
 80128ce:	4013      	ands	r3, r2
 80128d0:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 80128d2:	683b      	ldr	r3, [r7, #0]
 80128d4:	691a      	ldr	r2, [r3, #16]
 80128d6:	69fb      	ldr	r3, [r7, #28]
 80128d8:	f003 0307 	and.w	r3, r3, #7
 80128dc:	009b      	lsls	r3, r3, #2
 80128de:	fa02 f303 	lsl.w	r3, r2, r3
 80128e2:	69ba      	ldr	r2, [r7, #24]
 80128e4:	4313      	orrs	r3, r2
 80128e6:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 80128e8:	69fb      	ldr	r3, [r7, #28]
 80128ea:	08da      	lsrs	r2, r3, #3
 80128ec:	687b      	ldr	r3, [r7, #4]
 80128ee:	3208      	adds	r2, #8
 80128f0:	69b9      	ldr	r1, [r7, #24]
 80128f2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80128f6:	687b      	ldr	r3, [r7, #4]
 80128f8:	681b      	ldr	r3, [r3, #0]
 80128fa:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80128fc:	69fb      	ldr	r3, [r7, #28]
 80128fe:	005b      	lsls	r3, r3, #1
 8012900:	2203      	movs	r2, #3
 8012902:	fa02 f303 	lsl.w	r3, r2, r3
 8012906:	43db      	mvns	r3, r3
 8012908:	69ba      	ldr	r2, [r7, #24]
 801290a:	4013      	ands	r3, r2
 801290c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 801290e:	683b      	ldr	r3, [r7, #0]
 8012910:	685b      	ldr	r3, [r3, #4]
 8012912:	f003 0203 	and.w	r2, r3, #3
 8012916:	69fb      	ldr	r3, [r7, #28]
 8012918:	005b      	lsls	r3, r3, #1
 801291a:	fa02 f303 	lsl.w	r3, r2, r3
 801291e:	69ba      	ldr	r2, [r7, #24]
 8012920:	4313      	orrs	r3, r2
 8012922:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8012924:	687b      	ldr	r3, [r7, #4]
 8012926:	69ba      	ldr	r2, [r7, #24]
 8012928:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 801292a:	683b      	ldr	r3, [r7, #0]
 801292c:	685b      	ldr	r3, [r3, #4]
 801292e:	2b01      	cmp	r3, #1
 8012930:	d00b      	beq.n	801294a <HAL_GPIO_Init+0xe6>
 8012932:	683b      	ldr	r3, [r7, #0]
 8012934:	685b      	ldr	r3, [r3, #4]
 8012936:	2b02      	cmp	r3, #2
 8012938:	d007      	beq.n	801294a <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 801293a:	683b      	ldr	r3, [r7, #0]
 801293c:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 801293e:	2b11      	cmp	r3, #17
 8012940:	d003      	beq.n	801294a <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8012942:	683b      	ldr	r3, [r7, #0]
 8012944:	685b      	ldr	r3, [r3, #4]
 8012946:	2b12      	cmp	r3, #18
 8012948:	d130      	bne.n	80129ac <HAL_GPIO_Init+0x148>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 801294a:	687b      	ldr	r3, [r7, #4]
 801294c:	689b      	ldr	r3, [r3, #8]
 801294e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8012950:	69fb      	ldr	r3, [r7, #28]
 8012952:	005b      	lsls	r3, r3, #1
 8012954:	2203      	movs	r2, #3
 8012956:	fa02 f303 	lsl.w	r3, r2, r3
 801295a:	43db      	mvns	r3, r3
 801295c:	69ba      	ldr	r2, [r7, #24]
 801295e:	4013      	ands	r3, r2
 8012960:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8012962:	683b      	ldr	r3, [r7, #0]
 8012964:	68da      	ldr	r2, [r3, #12]
 8012966:	69fb      	ldr	r3, [r7, #28]
 8012968:	005b      	lsls	r3, r3, #1
 801296a:	fa02 f303 	lsl.w	r3, r2, r3
 801296e:	69ba      	ldr	r2, [r7, #24]
 8012970:	4313      	orrs	r3, r2
 8012972:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8012974:	687b      	ldr	r3, [r7, #4]
 8012976:	69ba      	ldr	r2, [r7, #24]
 8012978:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 801297a:	687b      	ldr	r3, [r7, #4]
 801297c:	685b      	ldr	r3, [r3, #4]
 801297e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8012980:	2201      	movs	r2, #1
 8012982:	69fb      	ldr	r3, [r7, #28]
 8012984:	fa02 f303 	lsl.w	r3, r2, r3
 8012988:	43db      	mvns	r3, r3
 801298a:	69ba      	ldr	r2, [r7, #24]
 801298c:	4013      	ands	r3, r2
 801298e:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8012990:	683b      	ldr	r3, [r7, #0]
 8012992:	685b      	ldr	r3, [r3, #4]
 8012994:	091b      	lsrs	r3, r3, #4
 8012996:	f003 0201 	and.w	r2, r3, #1
 801299a:	69fb      	ldr	r3, [r7, #28]
 801299c:	fa02 f303 	lsl.w	r3, r2, r3
 80129a0:	69ba      	ldr	r2, [r7, #24]
 80129a2:	4313      	orrs	r3, r2
 80129a4:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 80129a6:	687b      	ldr	r3, [r7, #4]
 80129a8:	69ba      	ldr	r2, [r7, #24]
 80129aa:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80129ac:	687b      	ldr	r3, [r7, #4]
 80129ae:	68db      	ldr	r3, [r3, #12]
 80129b0:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 80129b2:	69fb      	ldr	r3, [r7, #28]
 80129b4:	005b      	lsls	r3, r3, #1
 80129b6:	2203      	movs	r2, #3
 80129b8:	fa02 f303 	lsl.w	r3, r2, r3
 80129bc:	43db      	mvns	r3, r3
 80129be:	69ba      	ldr	r2, [r7, #24]
 80129c0:	4013      	ands	r3, r2
 80129c2:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80129c4:	683b      	ldr	r3, [r7, #0]
 80129c6:	689a      	ldr	r2, [r3, #8]
 80129c8:	69fb      	ldr	r3, [r7, #28]
 80129ca:	005b      	lsls	r3, r3, #1
 80129cc:	fa02 f303 	lsl.w	r3, r2, r3
 80129d0:	69ba      	ldr	r2, [r7, #24]
 80129d2:	4313      	orrs	r3, r2
 80129d4:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 80129d6:	687b      	ldr	r3, [r7, #4]
 80129d8:	69ba      	ldr	r2, [r7, #24]
 80129da:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80129dc:	683b      	ldr	r3, [r7, #0]
 80129de:	685b      	ldr	r3, [r3, #4]
 80129e0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80129e4:	2b00      	cmp	r3, #0
 80129e6:	f000 80c0 	beq.w	8012b6a <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80129ea:	2300      	movs	r3, #0
 80129ec:	60fb      	str	r3, [r7, #12]
 80129ee:	4b65      	ldr	r3, [pc, #404]	; (8012b84 <HAL_GPIO_Init+0x320>)
 80129f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80129f2:	4a64      	ldr	r2, [pc, #400]	; (8012b84 <HAL_GPIO_Init+0x320>)
 80129f4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80129f8:	6453      	str	r3, [r2, #68]	; 0x44
 80129fa:	4b62      	ldr	r3, [pc, #392]	; (8012b84 <HAL_GPIO_Init+0x320>)
 80129fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80129fe:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8012a02:	60fb      	str	r3, [r7, #12]
 8012a04:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8012a06:	4a60      	ldr	r2, [pc, #384]	; (8012b88 <HAL_GPIO_Init+0x324>)
 8012a08:	69fb      	ldr	r3, [r7, #28]
 8012a0a:	089b      	lsrs	r3, r3, #2
 8012a0c:	3302      	adds	r3, #2
 8012a0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8012a12:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8012a14:	69fb      	ldr	r3, [r7, #28]
 8012a16:	f003 0303 	and.w	r3, r3, #3
 8012a1a:	009b      	lsls	r3, r3, #2
 8012a1c:	220f      	movs	r2, #15
 8012a1e:	fa02 f303 	lsl.w	r3, r2, r3
 8012a22:	43db      	mvns	r3, r3
 8012a24:	69ba      	ldr	r2, [r7, #24]
 8012a26:	4013      	ands	r3, r2
 8012a28:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8012a2a:	687b      	ldr	r3, [r7, #4]
 8012a2c:	4a57      	ldr	r2, [pc, #348]	; (8012b8c <HAL_GPIO_Init+0x328>)
 8012a2e:	4293      	cmp	r3, r2
 8012a30:	d037      	beq.n	8012aa2 <HAL_GPIO_Init+0x23e>
 8012a32:	687b      	ldr	r3, [r7, #4]
 8012a34:	4a56      	ldr	r2, [pc, #344]	; (8012b90 <HAL_GPIO_Init+0x32c>)
 8012a36:	4293      	cmp	r3, r2
 8012a38:	d031      	beq.n	8012a9e <HAL_GPIO_Init+0x23a>
 8012a3a:	687b      	ldr	r3, [r7, #4]
 8012a3c:	4a55      	ldr	r2, [pc, #340]	; (8012b94 <HAL_GPIO_Init+0x330>)
 8012a3e:	4293      	cmp	r3, r2
 8012a40:	d02b      	beq.n	8012a9a <HAL_GPIO_Init+0x236>
 8012a42:	687b      	ldr	r3, [r7, #4]
 8012a44:	4a54      	ldr	r2, [pc, #336]	; (8012b98 <HAL_GPIO_Init+0x334>)
 8012a46:	4293      	cmp	r3, r2
 8012a48:	d025      	beq.n	8012a96 <HAL_GPIO_Init+0x232>
 8012a4a:	687b      	ldr	r3, [r7, #4]
 8012a4c:	4a53      	ldr	r2, [pc, #332]	; (8012b9c <HAL_GPIO_Init+0x338>)
 8012a4e:	4293      	cmp	r3, r2
 8012a50:	d01f      	beq.n	8012a92 <HAL_GPIO_Init+0x22e>
 8012a52:	687b      	ldr	r3, [r7, #4]
 8012a54:	4a52      	ldr	r2, [pc, #328]	; (8012ba0 <HAL_GPIO_Init+0x33c>)
 8012a56:	4293      	cmp	r3, r2
 8012a58:	d019      	beq.n	8012a8e <HAL_GPIO_Init+0x22a>
 8012a5a:	687b      	ldr	r3, [r7, #4]
 8012a5c:	4a51      	ldr	r2, [pc, #324]	; (8012ba4 <HAL_GPIO_Init+0x340>)
 8012a5e:	4293      	cmp	r3, r2
 8012a60:	d013      	beq.n	8012a8a <HAL_GPIO_Init+0x226>
 8012a62:	687b      	ldr	r3, [r7, #4]
 8012a64:	4a50      	ldr	r2, [pc, #320]	; (8012ba8 <HAL_GPIO_Init+0x344>)
 8012a66:	4293      	cmp	r3, r2
 8012a68:	d00d      	beq.n	8012a86 <HAL_GPIO_Init+0x222>
 8012a6a:	687b      	ldr	r3, [r7, #4]
 8012a6c:	4a4f      	ldr	r2, [pc, #316]	; (8012bac <HAL_GPIO_Init+0x348>)
 8012a6e:	4293      	cmp	r3, r2
 8012a70:	d007      	beq.n	8012a82 <HAL_GPIO_Init+0x21e>
 8012a72:	687b      	ldr	r3, [r7, #4]
 8012a74:	4a4e      	ldr	r2, [pc, #312]	; (8012bb0 <HAL_GPIO_Init+0x34c>)
 8012a76:	4293      	cmp	r3, r2
 8012a78:	d101      	bne.n	8012a7e <HAL_GPIO_Init+0x21a>
 8012a7a:	2309      	movs	r3, #9
 8012a7c:	e012      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a7e:	230a      	movs	r3, #10
 8012a80:	e010      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a82:	2308      	movs	r3, #8
 8012a84:	e00e      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a86:	2307      	movs	r3, #7
 8012a88:	e00c      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a8a:	2306      	movs	r3, #6
 8012a8c:	e00a      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a8e:	2305      	movs	r3, #5
 8012a90:	e008      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a92:	2304      	movs	r3, #4
 8012a94:	e006      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a96:	2303      	movs	r3, #3
 8012a98:	e004      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a9a:	2302      	movs	r3, #2
 8012a9c:	e002      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012a9e:	2301      	movs	r3, #1
 8012aa0:	e000      	b.n	8012aa4 <HAL_GPIO_Init+0x240>
 8012aa2:	2300      	movs	r3, #0
 8012aa4:	69fa      	ldr	r2, [r7, #28]
 8012aa6:	f002 0203 	and.w	r2, r2, #3
 8012aaa:	0092      	lsls	r2, r2, #2
 8012aac:	4093      	lsls	r3, r2
 8012aae:	69ba      	ldr	r2, [r7, #24]
 8012ab0:	4313      	orrs	r3, r2
 8012ab2:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8012ab4:	4934      	ldr	r1, [pc, #208]	; (8012b88 <HAL_GPIO_Init+0x324>)
 8012ab6:	69fb      	ldr	r3, [r7, #28]
 8012ab8:	089b      	lsrs	r3, r3, #2
 8012aba:	3302      	adds	r3, #2
 8012abc:	69ba      	ldr	r2, [r7, #24]
 8012abe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8012ac2:	4b3c      	ldr	r3, [pc, #240]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012ac4:	681b      	ldr	r3, [r3, #0]
 8012ac6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8012ac8:	693b      	ldr	r3, [r7, #16]
 8012aca:	43db      	mvns	r3, r3
 8012acc:	69ba      	ldr	r2, [r7, #24]
 8012ace:	4013      	ands	r3, r2
 8012ad0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8012ad2:	683b      	ldr	r3, [r7, #0]
 8012ad4:	685b      	ldr	r3, [r3, #4]
 8012ad6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8012ada:	2b00      	cmp	r3, #0
 8012adc:	d003      	beq.n	8012ae6 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
 8012ade:	69ba      	ldr	r2, [r7, #24]
 8012ae0:	693b      	ldr	r3, [r7, #16]
 8012ae2:	4313      	orrs	r3, r2
 8012ae4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8012ae6:	4a33      	ldr	r2, [pc, #204]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012ae8:	69bb      	ldr	r3, [r7, #24]
 8012aea:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8012aec:	4b31      	ldr	r3, [pc, #196]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012aee:	685b      	ldr	r3, [r3, #4]
 8012af0:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8012af2:	693b      	ldr	r3, [r7, #16]
 8012af4:	43db      	mvns	r3, r3
 8012af6:	69ba      	ldr	r2, [r7, #24]
 8012af8:	4013      	ands	r3, r2
 8012afa:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8012afc:	683b      	ldr	r3, [r7, #0]
 8012afe:	685b      	ldr	r3, [r3, #4]
 8012b00:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8012b04:	2b00      	cmp	r3, #0
 8012b06:	d003      	beq.n	8012b10 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
 8012b08:	69ba      	ldr	r2, [r7, #24]
 8012b0a:	693b      	ldr	r3, [r7, #16]
 8012b0c:	4313      	orrs	r3, r2
 8012b0e:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8012b10:	4a28      	ldr	r2, [pc, #160]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012b12:	69bb      	ldr	r3, [r7, #24]
 8012b14:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8012b16:	4b27      	ldr	r3, [pc, #156]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012b18:	689b      	ldr	r3, [r3, #8]
 8012b1a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8012b1c:	693b      	ldr	r3, [r7, #16]
 8012b1e:	43db      	mvns	r3, r3
 8012b20:	69ba      	ldr	r2, [r7, #24]
 8012b22:	4013      	ands	r3, r2
 8012b24:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8012b26:	683b      	ldr	r3, [r7, #0]
 8012b28:	685b      	ldr	r3, [r3, #4]
 8012b2a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8012b2e:	2b00      	cmp	r3, #0
 8012b30:	d003      	beq.n	8012b3a <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
 8012b32:	69ba      	ldr	r2, [r7, #24]
 8012b34:	693b      	ldr	r3, [r7, #16]
 8012b36:	4313      	orrs	r3, r2
 8012b38:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8012b3a:	4a1e      	ldr	r2, [pc, #120]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012b3c:	69bb      	ldr	r3, [r7, #24]
 8012b3e:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8012b40:	4b1c      	ldr	r3, [pc, #112]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012b42:	68db      	ldr	r3, [r3, #12]
 8012b44:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8012b46:	693b      	ldr	r3, [r7, #16]
 8012b48:	43db      	mvns	r3, r3
 8012b4a:	69ba      	ldr	r2, [r7, #24]
 8012b4c:	4013      	ands	r3, r2
 8012b4e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8012b50:	683b      	ldr	r3, [r7, #0]
 8012b52:	685b      	ldr	r3, [r3, #4]
 8012b54:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8012b58:	2b00      	cmp	r3, #0
 8012b5a:	d003      	beq.n	8012b64 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 8012b5c:	69ba      	ldr	r2, [r7, #24]
 8012b5e:	693b      	ldr	r3, [r7, #16]
 8012b60:	4313      	orrs	r3, r2
 8012b62:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8012b64:	4a13      	ldr	r2, [pc, #76]	; (8012bb4 <HAL_GPIO_Init+0x350>)
 8012b66:	69bb      	ldr	r3, [r7, #24]
 8012b68:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8012b6a:	69fb      	ldr	r3, [r7, #28]
 8012b6c:	3301      	adds	r3, #1
 8012b6e:	61fb      	str	r3, [r7, #28]
 8012b70:	69fb      	ldr	r3, [r7, #28]
 8012b72:	2b0f      	cmp	r3, #15
 8012b74:	f67f ae84 	bls.w	8012880 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 8012b78:	bf00      	nop
 8012b7a:	3724      	adds	r7, #36	; 0x24
 8012b7c:	46bd      	mov	sp, r7
 8012b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b82:	4770      	bx	lr
 8012b84:	40023800 	.word	0x40023800
 8012b88:	40013800 	.word	0x40013800
 8012b8c:	40020000 	.word	0x40020000
 8012b90:	40020400 	.word	0x40020400
 8012b94:	40020800 	.word	0x40020800
 8012b98:	40020c00 	.word	0x40020c00
 8012b9c:	40021000 	.word	0x40021000
 8012ba0:	40021400 	.word	0x40021400
 8012ba4:	40021800 	.word	0x40021800
 8012ba8:	40021c00 	.word	0x40021c00
 8012bac:	40022000 	.word	0x40022000
 8012bb0:	40022400 	.word	0x40022400
 8012bb4:	40013c00 	.word	0x40013c00

08012bb8 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8012bb8:	b480      	push	{r7}
 8012bba:	b083      	sub	sp, #12
 8012bbc:	af00      	add	r7, sp, #0
 8012bbe:	6078      	str	r0, [r7, #4]
 8012bc0:	460b      	mov	r3, r1
 8012bc2:	807b      	strh	r3, [r7, #2]
 8012bc4:	4613      	mov	r3, r2
 8012bc6:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8012bc8:	787b      	ldrb	r3, [r7, #1]
 8012bca:	2b00      	cmp	r3, #0
 8012bcc:	d003      	beq.n	8012bd6 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8012bce:	887a      	ldrh	r2, [r7, #2]
 8012bd0:	687b      	ldr	r3, [r7, #4]
 8012bd2:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 8012bd4:	e003      	b.n	8012bde <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8012bd6:	887b      	ldrh	r3, [r7, #2]
 8012bd8:	041a      	lsls	r2, r3, #16
 8012bda:	687b      	ldr	r3, [r7, #4]
 8012bdc:	619a      	str	r2, [r3, #24]
}
 8012bde:	bf00      	nop
 8012be0:	370c      	adds	r7, #12
 8012be2:	46bd      	mov	sp, r7
 8012be4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012be8:	4770      	bx	lr
	...

08012bec <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8012bec:	b580      	push	{r7, lr}
 8012bee:	b084      	sub	sp, #16
 8012bf0:	af00      	add	r7, sp, #0
 8012bf2:	6078      	str	r0, [r7, #4]
  uint32_t freqrange = 0U;
 8012bf4:	2300      	movs	r3, #0
 8012bf6:	60fb      	str	r3, [r7, #12]
  uint32_t pclk1 = 0U;
 8012bf8:	2300      	movs	r3, #0
 8012bfa:	60bb      	str	r3, [r7, #8]

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 8012bfc:	687b      	ldr	r3, [r7, #4]
 8012bfe:	2b00      	cmp	r3, #0
 8012c00:	d101      	bne.n	8012c06 <HAL_I2C_Init+0x1a>
  {
    return HAL_ERROR;
 8012c02:	2301      	movs	r3, #1
 8012c04:	e0c8      	b.n	8012d98 <HAL_I2C_Init+0x1ac>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 8012c06:	687b      	ldr	r3, [r7, #4]
 8012c08:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8012c0c:	b2db      	uxtb	r3, r3
 8012c0e:	2b00      	cmp	r3, #0
 8012c10:	d106      	bne.n	8012c20 <HAL_I2C_Init+0x34>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8012c12:	687b      	ldr	r3, [r7, #4]
 8012c14:	2200      	movs	r2, #0
 8012c16:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 8012c1a:	6878      	ldr	r0, [r7, #4]
 8012c1c:	f7fd faf0 	bl	8010200 <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8012c20:	687b      	ldr	r3, [r7, #4]
 8012c22:	2224      	movs	r2, #36	; 0x24
 8012c24:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8012c28:	687b      	ldr	r3, [r7, #4]
 8012c2a:	681b      	ldr	r3, [r3, #0]
 8012c2c:	681a      	ldr	r2, [r3, #0]
 8012c2e:	687b      	ldr	r3, [r7, #4]
 8012c30:	681b      	ldr	r3, [r3, #0]
 8012c32:	f022 0201 	bic.w	r2, r2, #1
 8012c36:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8012c38:	f001 fd5a 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8012c3c:	60b8      	str	r0, [r7, #8]

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 8012c3e:	68bb      	ldr	r3, [r7, #8]
 8012c40:	4a57      	ldr	r2, [pc, #348]	; (8012da0 <HAL_I2C_Init+0x1b4>)
 8012c42:	fba2 2303 	umull	r2, r3, r2, r3
 8012c46:	0c9b      	lsrs	r3, r3, #18
 8012c48:	60fb      	str	r3, [r7, #12]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;
 8012c4a:	687b      	ldr	r3, [r7, #4]
 8012c4c:	681b      	ldr	r3, [r3, #0]
 8012c4e:	68fa      	ldr	r2, [r7, #12]
 8012c50:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 8012c52:	687b      	ldr	r3, [r7, #4]
 8012c54:	685b      	ldr	r3, [r3, #4]
 8012c56:	4a53      	ldr	r2, [pc, #332]	; (8012da4 <HAL_I2C_Init+0x1b8>)
 8012c58:	4293      	cmp	r3, r2
 8012c5a:	d802      	bhi.n	8012c62 <HAL_I2C_Init+0x76>
 8012c5c:	68fb      	ldr	r3, [r7, #12]
 8012c5e:	3301      	adds	r3, #1
 8012c60:	e009      	b.n	8012c76 <HAL_I2C_Init+0x8a>
 8012c62:	68fb      	ldr	r3, [r7, #12]
 8012c64:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8012c68:	fb02 f303 	mul.w	r3, r2, r3
 8012c6c:	4a4e      	ldr	r2, [pc, #312]	; (8012da8 <HAL_I2C_Init+0x1bc>)
 8012c6e:	fba2 2303 	umull	r2, r3, r2, r3
 8012c72:	099b      	lsrs	r3, r3, #6
 8012c74:	3301      	adds	r3, #1
 8012c76:	687a      	ldr	r2, [r7, #4]
 8012c78:	6812      	ldr	r2, [r2, #0]
 8012c7a:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 8012c7c:	687b      	ldr	r3, [r7, #4]
 8012c7e:	685b      	ldr	r3, [r3, #4]
 8012c80:	4a48      	ldr	r2, [pc, #288]	; (8012da4 <HAL_I2C_Init+0x1b8>)
 8012c82:	4293      	cmp	r3, r2
 8012c84:	d812      	bhi.n	8012cac <HAL_I2C_Init+0xc0>
 8012c86:	687b      	ldr	r3, [r7, #4]
 8012c88:	685b      	ldr	r3, [r3, #4]
 8012c8a:	005b      	lsls	r3, r3, #1
 8012c8c:	68ba      	ldr	r2, [r7, #8]
 8012c8e:	fbb2 f3f3 	udiv	r3, r2, r3
 8012c92:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8012c96:	2b03      	cmp	r3, #3
 8012c98:	d906      	bls.n	8012ca8 <HAL_I2C_Init+0xbc>
 8012c9a:	687b      	ldr	r3, [r7, #4]
 8012c9c:	685b      	ldr	r3, [r3, #4]
 8012c9e:	005b      	lsls	r3, r3, #1
 8012ca0:	68ba      	ldr	r2, [r7, #8]
 8012ca2:	fbb2 f3f3 	udiv	r3, r2, r3
 8012ca6:	e045      	b.n	8012d34 <HAL_I2C_Init+0x148>
 8012ca8:	2304      	movs	r3, #4
 8012caa:	e043      	b.n	8012d34 <HAL_I2C_Init+0x148>
 8012cac:	687b      	ldr	r3, [r7, #4]
 8012cae:	689b      	ldr	r3, [r3, #8]
 8012cb0:	2b00      	cmp	r3, #0
 8012cb2:	d10f      	bne.n	8012cd4 <HAL_I2C_Init+0xe8>
 8012cb4:	687b      	ldr	r3, [r7, #4]
 8012cb6:	685a      	ldr	r2, [r3, #4]
 8012cb8:	4613      	mov	r3, r2
 8012cba:	005b      	lsls	r3, r3, #1
 8012cbc:	4413      	add	r3, r2
 8012cbe:	68ba      	ldr	r2, [r7, #8]
 8012cc0:	fbb2 f3f3 	udiv	r3, r2, r3
 8012cc4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8012cc8:	2b00      	cmp	r3, #0
 8012cca:	bf0c      	ite	eq
 8012ccc:	2301      	moveq	r3, #1
 8012cce:	2300      	movne	r3, #0
 8012cd0:	b2db      	uxtb	r3, r3
 8012cd2:	e010      	b.n	8012cf6 <HAL_I2C_Init+0x10a>
 8012cd4:	687b      	ldr	r3, [r7, #4]
 8012cd6:	685a      	ldr	r2, [r3, #4]
 8012cd8:	4613      	mov	r3, r2
 8012cda:	009b      	lsls	r3, r3, #2
 8012cdc:	4413      	add	r3, r2
 8012cde:	009a      	lsls	r2, r3, #2
 8012ce0:	4413      	add	r3, r2
 8012ce2:	68ba      	ldr	r2, [r7, #8]
 8012ce4:	fbb2 f3f3 	udiv	r3, r2, r3
 8012ce8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8012cec:	2b00      	cmp	r3, #0
 8012cee:	bf0c      	ite	eq
 8012cf0:	2301      	moveq	r3, #1
 8012cf2:	2300      	movne	r3, #0
 8012cf4:	b2db      	uxtb	r3, r3
 8012cf6:	2b00      	cmp	r3, #0
 8012cf8:	d001      	beq.n	8012cfe <HAL_I2C_Init+0x112>
 8012cfa:	2301      	movs	r3, #1
 8012cfc:	e01a      	b.n	8012d34 <HAL_I2C_Init+0x148>
 8012cfe:	687b      	ldr	r3, [r7, #4]
 8012d00:	689b      	ldr	r3, [r3, #8]
 8012d02:	2b00      	cmp	r3, #0
 8012d04:	d10a      	bne.n	8012d1c <HAL_I2C_Init+0x130>
 8012d06:	687b      	ldr	r3, [r7, #4]
 8012d08:	685a      	ldr	r2, [r3, #4]
 8012d0a:	4613      	mov	r3, r2
 8012d0c:	005b      	lsls	r3, r3, #1
 8012d0e:	4413      	add	r3, r2
 8012d10:	68ba      	ldr	r2, [r7, #8]
 8012d12:	fbb2 f3f3 	udiv	r3, r2, r3
 8012d16:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8012d1a:	e00b      	b.n	8012d34 <HAL_I2C_Init+0x148>
 8012d1c:	687b      	ldr	r3, [r7, #4]
 8012d1e:	685a      	ldr	r2, [r3, #4]
 8012d20:	4613      	mov	r3, r2
 8012d22:	009b      	lsls	r3, r3, #2
 8012d24:	4413      	add	r3, r2
 8012d26:	009a      	lsls	r2, r3, #2
 8012d28:	4413      	add	r3, r2
 8012d2a:	68ba      	ldr	r2, [r7, #8]
 8012d2c:	fbb2 f3f3 	udiv	r3, r2, r3
 8012d30:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8012d34:	687a      	ldr	r2, [r7, #4]
 8012d36:	6812      	ldr	r2, [r2, #0]
 8012d38:	61d3      	str	r3, [r2, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8012d3a:	687b      	ldr	r3, [r7, #4]
 8012d3c:	69d9      	ldr	r1, [r3, #28]
 8012d3e:	687b      	ldr	r3, [r7, #4]
 8012d40:	6a1a      	ldr	r2, [r3, #32]
 8012d42:	687b      	ldr	r3, [r7, #4]
 8012d44:	681b      	ldr	r3, [r3, #0]
 8012d46:	430a      	orrs	r2, r1
 8012d48:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8012d4a:	687b      	ldr	r3, [r7, #4]
 8012d4c:	6919      	ldr	r1, [r3, #16]
 8012d4e:	687b      	ldr	r3, [r7, #4]
 8012d50:	68da      	ldr	r2, [r3, #12]
 8012d52:	687b      	ldr	r3, [r7, #4]
 8012d54:	681b      	ldr	r3, [r3, #0]
 8012d56:	430a      	orrs	r2, r1
 8012d58:	609a      	str	r2, [r3, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 8012d5a:	687b      	ldr	r3, [r7, #4]
 8012d5c:	6959      	ldr	r1, [r3, #20]
 8012d5e:	687b      	ldr	r3, [r7, #4]
 8012d60:	699a      	ldr	r2, [r3, #24]
 8012d62:	687b      	ldr	r3, [r7, #4]
 8012d64:	681b      	ldr	r3, [r3, #0]
 8012d66:	430a      	orrs	r2, r1
 8012d68:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8012d6a:	687b      	ldr	r3, [r7, #4]
 8012d6c:	681b      	ldr	r3, [r3, #0]
 8012d6e:	681a      	ldr	r2, [r3, #0]
 8012d70:	687b      	ldr	r3, [r7, #4]
 8012d72:	681b      	ldr	r3, [r3, #0]
 8012d74:	f042 0201 	orr.w	r2, r2, #1
 8012d78:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8012d7a:	687b      	ldr	r3, [r7, #4]
 8012d7c:	2200      	movs	r2, #0
 8012d7e:	641a      	str	r2, [r3, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 8012d80:	687b      	ldr	r3, [r7, #4]
 8012d82:	2220      	movs	r2, #32
 8012d84:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8012d88:	687b      	ldr	r3, [r7, #4]
 8012d8a:	2200      	movs	r2, #0
 8012d8c:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8012d8e:	687b      	ldr	r3, [r7, #4]
 8012d90:	2200      	movs	r2, #0
 8012d92:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e

  return HAL_OK;
 8012d96:	2300      	movs	r3, #0
}
 8012d98:	4618      	mov	r0, r3
 8012d9a:	3710      	adds	r7, #16
 8012d9c:	46bd      	mov	sp, r7
 8012d9e:	bd80      	pop	{r7, pc}
 8012da0:	431bde83 	.word	0x431bde83
 8012da4:	000186a0 	.word	0x000186a0
 8012da8:	10624dd3 	.word	0x10624dd3

08012dac <HAL_NOR_Init>:
  * @param  Timing: pointer to NOR control timing structure 
  * @param  ExtTiming: pointer to NOR extended mode timing structure    
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_NOR_Init(NOR_HandleTypeDef *hnor, FMC_NORSRAM_TimingTypeDef *Timing, FMC_NORSRAM_TimingTypeDef *ExtTiming)
{
 8012dac:	b580      	push	{r7, lr}
 8012dae:	b084      	sub	sp, #16
 8012db0:	af00      	add	r7, sp, #0
 8012db2:	60f8      	str	r0, [r7, #12]
 8012db4:	60b9      	str	r1, [r7, #8]
 8012db6:	607a      	str	r2, [r7, #4]
  /* Check the NOR handle parameter */
  if(hnor == NULL)
 8012db8:	68fb      	ldr	r3, [r7, #12]
 8012dba:	2b00      	cmp	r3, #0
 8012dbc:	d101      	bne.n	8012dc2 <HAL_NOR_Init+0x16>
  {
     return HAL_ERROR;
 8012dbe:	2301      	movs	r3, #1
 8012dc0:	e038      	b.n	8012e34 <HAL_NOR_Init+0x88>
  }
  
  if(hnor->State == HAL_NOR_STATE_RESET)
 8012dc2:	68fb      	ldr	r3, [r7, #12]
 8012dc4:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 8012dc8:	b2db      	uxtb	r3, r3
 8012dca:	2b00      	cmp	r3, #0
 8012dcc:	d106      	bne.n	8012ddc <HAL_NOR_Init+0x30>
  {
    /* Allocate lock resource and initialize it */
    hnor->Lock = HAL_UNLOCKED;
 8012dce:	68fb      	ldr	r3, [r7, #12]
 8012dd0:	2200      	movs	r2, #0
 8012dd2:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Initialize the low level hardware (MSP) */
    HAL_NOR_MspInit(hnor);
 8012dd6:	68f8      	ldr	r0, [r7, #12]
 8012dd8:	f7fd f8e4 	bl	800ffa4 <HAL_NOR_MspInit>
  }
  
  /* Initialize NOR control Interface */
  FMC_NORSRAM_Init(hnor->Instance, &(hnor->Init));
 8012ddc:	68fb      	ldr	r3, [r7, #12]
 8012dde:	681a      	ldr	r2, [r3, #0]
 8012de0:	68fb      	ldr	r3, [r7, #12]
 8012de2:	3308      	adds	r3, #8
 8012de4:	4619      	mov	r1, r3
 8012de6:	4610      	mov	r0, r2
 8012de8:	f004 fb6c 	bl	80174c4 <FMC_NORSRAM_Init>

  /* Initialize NOR timing Interface */
  FMC_NORSRAM_Timing_Init(hnor->Instance, Timing, hnor->Init.NSBank); 
 8012dec:	68fb      	ldr	r3, [r7, #12]
 8012dee:	6818      	ldr	r0, [r3, #0]
 8012df0:	68fb      	ldr	r3, [r7, #12]
 8012df2:	689b      	ldr	r3, [r3, #8]
 8012df4:	461a      	mov	r2, r3
 8012df6:	68b9      	ldr	r1, [r7, #8]
 8012df8:	f004 fbc8 	bl	801758c <FMC_NORSRAM_Timing_Init>

  /* Initialize NOR extended mode timing Interface */
  FMC_NORSRAM_Extended_Timing_Init(hnor->Extended, ExtTiming, hnor->Init.NSBank, hnor->Init.ExtendedMode);
 8012dfc:	68fb      	ldr	r3, [r7, #12]
 8012dfe:	6858      	ldr	r0, [r3, #4]
 8012e00:	68fb      	ldr	r3, [r7, #12]
 8012e02:	689a      	ldr	r2, [r3, #8]
 8012e04:	68fb      	ldr	r3, [r7, #12]
 8012e06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012e08:	6879      	ldr	r1, [r7, #4]
 8012e0a:	f004 fc11 	bl	8017630 <FMC_NORSRAM_Extended_Timing_Init>

  /* Enable the NORSRAM device */
  __FMC_NORSRAM_ENABLE(hnor->Instance, hnor->Init.NSBank);
 8012e0e:	68fb      	ldr	r3, [r7, #12]
 8012e10:	681b      	ldr	r3, [r3, #0]
 8012e12:	68fa      	ldr	r2, [r7, #12]
 8012e14:	6892      	ldr	r2, [r2, #8]
 8012e16:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8012e1a:	68fb      	ldr	r3, [r7, #12]
 8012e1c:	681b      	ldr	r3, [r3, #0]
 8012e1e:	68fa      	ldr	r2, [r7, #12]
 8012e20:	6892      	ldr	r2, [r2, #8]
 8012e22:	f041 0101 	orr.w	r1, r1, #1
 8012e26:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* Check the NOR controller state */
  hnor->State = HAL_NOR_STATE_READY; 
 8012e2a:	68fb      	ldr	r3, [r7, #12]
 8012e2c:	2201      	movs	r2, #1
 8012e2e:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
  
  return HAL_OK;
 8012e32:	2300      	movs	r3, #0
}
 8012e34:	4618      	mov	r0, r3
 8012e36:	3710      	adds	r7, #16
 8012e38:	46bd      	mov	sp, r7
 8012e3a:	bd80      	pop	{r7, pc}

08012e3c <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8012e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012e3e:	b08f      	sub	sp, #60	; 0x3c
 8012e40:	af0a      	add	r7, sp, #40	; 0x28
 8012e42:	6078      	str	r0, [r7, #4]
  uint32_t i = 0U;
 8012e44:	2300      	movs	r3, #0
 8012e46:	60fb      	str	r3, [r7, #12]
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8012e48:	687b      	ldr	r3, [r7, #4]
 8012e4a:	2b00      	cmp	r3, #0
 8012e4c:	d101      	bne.n	8012e52 <HAL_PCD_Init+0x16>
  {
    return HAL_ERROR;
 8012e4e:	2301      	movs	r3, #1
 8012e50:	e0f7      	b.n	8013042 <HAL_PCD_Init+0x206>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8012e52:	687b      	ldr	r3, [r7, #4]
 8012e54:	2203      	movs	r2, #3
 8012e56:	f883 2381 	strb.w	r2, [r3, #897]	; 0x381
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8012e5a:	6878      	ldr	r0, [r7, #4]
 8012e5c:	f7fd fef4 	bl	8010c48 <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8012e60:	687b      	ldr	r3, [r7, #4]
 8012e62:	681b      	ldr	r3, [r3, #0]
 8012e64:	4618      	mov	r0, r3
 8012e66:	f004 fd51 	bl	801790c <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8012e6a:	687b      	ldr	r3, [r7, #4]
 8012e6c:	681b      	ldr	r3, [r3, #0]
 8012e6e:	603b      	str	r3, [r7, #0]
 8012e70:	687e      	ldr	r6, [r7, #4]
 8012e72:	466d      	mov	r5, sp
 8012e74:	f106 0410 	add.w	r4, r6, #16
 8012e78:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8012e7a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8012e7c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8012e7e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8012e80:	e894 0003 	ldmia.w	r4, {r0, r1}
 8012e84:	e885 0003 	stmia.w	r5, {r0, r1}
 8012e88:	1d33      	adds	r3, r6, #4
 8012e8a:	cb0e      	ldmia	r3, {r1, r2, r3}
 8012e8c:	6838      	ldr	r0, [r7, #0]
 8012e8e:	f004 fcdb 	bl	8017848 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8012e92:	687b      	ldr	r3, [r7, #4]
 8012e94:	681b      	ldr	r3, [r3, #0]
 8012e96:	2100      	movs	r1, #0
 8012e98:	4618      	mov	r0, r3
 8012e9a:	f004 fd48 	bl	801792e <USB_SetCurrentMode>
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8012e9e:	2300      	movs	r3, #0
 8012ea0:	60fb      	str	r3, [r7, #12]
 8012ea2:	e04c      	b.n	8012f3e <HAL_PCD_Init+0x102>
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8012ea4:	6879      	ldr	r1, [r7, #4]
 8012ea6:	68fa      	ldr	r2, [r7, #12]
 8012ea8:	4613      	mov	r3, r2
 8012eaa:	00db      	lsls	r3, r3, #3
 8012eac:	1a9b      	subs	r3, r3, r2
 8012eae:	009b      	lsls	r3, r3, #2
 8012eb0:	440b      	add	r3, r1
 8012eb2:	3339      	adds	r3, #57	; 0x39
 8012eb4:	2201      	movs	r2, #1
 8012eb6:	701a      	strb	r2, [r3, #0]
   hpcd->IN_ep[i].num = i;
 8012eb8:	68fb      	ldr	r3, [r7, #12]
 8012eba:	b2d8      	uxtb	r0, r3
 8012ebc:	6879      	ldr	r1, [r7, #4]
 8012ebe:	68fa      	ldr	r2, [r7, #12]
 8012ec0:	4613      	mov	r3, r2
 8012ec2:	00db      	lsls	r3, r3, #3
 8012ec4:	1a9b      	subs	r3, r3, r2
 8012ec6:	009b      	lsls	r3, r3, #2
 8012ec8:	440b      	add	r3, r1
 8012eca:	3338      	adds	r3, #56	; 0x38
 8012ecc:	4602      	mov	r2, r0
 8012ece:	701a      	strb	r2, [r3, #0]
   hpcd->IN_ep[i].tx_fifo_num = i;
 8012ed0:	68fb      	ldr	r3, [r7, #12]
 8012ed2:	b298      	uxth	r0, r3
 8012ed4:	6879      	ldr	r1, [r7, #4]
 8012ed6:	68fa      	ldr	r2, [r7, #12]
 8012ed8:	4613      	mov	r3, r2
 8012eda:	00db      	lsls	r3, r3, #3
 8012edc:	1a9b      	subs	r3, r3, r2
 8012ede:	009b      	lsls	r3, r3, #2
 8012ee0:	440b      	add	r3, r1
 8012ee2:	333e      	adds	r3, #62	; 0x3e
 8012ee4:	4602      	mov	r2, r0
 8012ee6:	801a      	strh	r2, [r3, #0]
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8012ee8:	6879      	ldr	r1, [r7, #4]
 8012eea:	68fa      	ldr	r2, [r7, #12]
 8012eec:	4613      	mov	r3, r2
 8012eee:	00db      	lsls	r3, r3, #3
 8012ef0:	1a9b      	subs	r3, r3, r2
 8012ef2:	009b      	lsls	r3, r3, #2
 8012ef4:	440b      	add	r3, r1
 8012ef6:	333b      	adds	r3, #59	; 0x3b
 8012ef8:	2200      	movs	r2, #0
 8012efa:	701a      	strb	r2, [r3, #0]
   hpcd->IN_ep[i].maxpacket = 0U;
 8012efc:	6879      	ldr	r1, [r7, #4]
 8012efe:	68fa      	ldr	r2, [r7, #12]
 8012f00:	4613      	mov	r3, r2
 8012f02:	00db      	lsls	r3, r3, #3
 8012f04:	1a9b      	subs	r3, r3, r2
 8012f06:	009b      	lsls	r3, r3, #2
 8012f08:	440b      	add	r3, r1
 8012f0a:	3340      	adds	r3, #64	; 0x40
 8012f0c:	2200      	movs	r2, #0
 8012f0e:	601a      	str	r2, [r3, #0]
   hpcd->IN_ep[i].xfer_buff = 0U;
 8012f10:	6879      	ldr	r1, [r7, #4]
 8012f12:	68fa      	ldr	r2, [r7, #12]
 8012f14:	4613      	mov	r3, r2
 8012f16:	00db      	lsls	r3, r3, #3
 8012f18:	1a9b      	subs	r3, r3, r2
 8012f1a:	009b      	lsls	r3, r3, #2
 8012f1c:	440b      	add	r3, r1
 8012f1e:	3344      	adds	r3, #68	; 0x44
 8012f20:	2200      	movs	r2, #0
 8012f22:	601a      	str	r2, [r3, #0]
   hpcd->IN_ep[i].xfer_len = 0U;
 8012f24:	6879      	ldr	r1, [r7, #4]
 8012f26:	68fa      	ldr	r2, [r7, #12]
 8012f28:	4613      	mov	r3, r2
 8012f2a:	00db      	lsls	r3, r3, #3
 8012f2c:	1a9b      	subs	r3, r3, r2
 8012f2e:	009b      	lsls	r3, r3, #2
 8012f30:	440b      	add	r3, r1
 8012f32:	334c      	adds	r3, #76	; 0x4c
 8012f34:	2200      	movs	r2, #0
 8012f36:	601a      	str	r2, [r3, #0]
 for (i = 0U; i < 15U; i++)
 8012f38:	68fb      	ldr	r3, [r7, #12]
 8012f3a:	3301      	adds	r3, #1
 8012f3c:	60fb      	str	r3, [r7, #12]
 8012f3e:	68fb      	ldr	r3, [r7, #12]
 8012f40:	2b0e      	cmp	r3, #14
 8012f42:	d9af      	bls.n	8012ea4 <HAL_PCD_Init+0x68>
 }
 
 for (i = 0U; i < 15U; i++)
 8012f44:	2300      	movs	r3, #0
 8012f46:	60fb      	str	r3, [r7, #12]
 8012f48:	e05a      	b.n	8013000 <HAL_PCD_Init+0x1c4>
 {
   hpcd->OUT_ep[i].is_in = 0U;
 8012f4a:	6879      	ldr	r1, [r7, #4]
 8012f4c:	68fa      	ldr	r2, [r7, #12]
 8012f4e:	4613      	mov	r3, r2
 8012f50:	00db      	lsls	r3, r3, #3
 8012f52:	1a9b      	subs	r3, r3, r2
 8012f54:	009b      	lsls	r3, r3, #2
 8012f56:	440b      	add	r3, r1
 8012f58:	f203 13dd 	addw	r3, r3, #477	; 0x1dd
 8012f5c:	2200      	movs	r2, #0
 8012f5e:	701a      	strb	r2, [r3, #0]
   hpcd->OUT_ep[i].num = i;
 8012f60:	68fb      	ldr	r3, [r7, #12]
 8012f62:	b2d8      	uxtb	r0, r3
 8012f64:	6879      	ldr	r1, [r7, #4]
 8012f66:	68fa      	ldr	r2, [r7, #12]
 8012f68:	4613      	mov	r3, r2
 8012f6a:	00db      	lsls	r3, r3, #3
 8012f6c:	1a9b      	subs	r3, r3, r2
 8012f6e:	009b      	lsls	r3, r3, #2
 8012f70:	440b      	add	r3, r1
 8012f72:	f503 73ee 	add.w	r3, r3, #476	; 0x1dc
 8012f76:	4602      	mov	r2, r0
 8012f78:	701a      	strb	r2, [r3, #0]
   hpcd->IN_ep[i].tx_fifo_num = i;
 8012f7a:	68fb      	ldr	r3, [r7, #12]
 8012f7c:	b298      	uxth	r0, r3
 8012f7e:	6879      	ldr	r1, [r7, #4]
 8012f80:	68fa      	ldr	r2, [r7, #12]
 8012f82:	4613      	mov	r3, r2
 8012f84:	00db      	lsls	r3, r3, #3
 8012f86:	1a9b      	subs	r3, r3, r2
 8012f88:	009b      	lsls	r3, r3, #2
 8012f8a:	440b      	add	r3, r1
 8012f8c:	333e      	adds	r3, #62	; 0x3e
 8012f8e:	4602      	mov	r2, r0
 8012f90:	801a      	strh	r2, [r3, #0]
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8012f92:	6879      	ldr	r1, [r7, #4]
 8012f94:	68fa      	ldr	r2, [r7, #12]
 8012f96:	4613      	mov	r3, r2
 8012f98:	00db      	lsls	r3, r3, #3
 8012f9a:	1a9b      	subs	r3, r3, r2
 8012f9c:	009b      	lsls	r3, r3, #2
 8012f9e:	440b      	add	r3, r1
 8012fa0:	f203 13df 	addw	r3, r3, #479	; 0x1df
 8012fa4:	2200      	movs	r2, #0
 8012fa6:	701a      	strb	r2, [r3, #0]
   hpcd->OUT_ep[i].maxpacket = 0U;
 8012fa8:	6879      	ldr	r1, [r7, #4]
 8012faa:	68fa      	ldr	r2, [r7, #12]
 8012fac:	4613      	mov	r3, r2
 8012fae:	00db      	lsls	r3, r3, #3
 8012fb0:	1a9b      	subs	r3, r3, r2
 8012fb2:	009b      	lsls	r3, r3, #2
 8012fb4:	440b      	add	r3, r1
 8012fb6:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8012fba:	2200      	movs	r2, #0
 8012fbc:	601a      	str	r2, [r3, #0]
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8012fbe:	6879      	ldr	r1, [r7, #4]
 8012fc0:	68fa      	ldr	r2, [r7, #12]
 8012fc2:	4613      	mov	r3, r2
 8012fc4:	00db      	lsls	r3, r3, #3
 8012fc6:	1a9b      	subs	r3, r3, r2
 8012fc8:	009b      	lsls	r3, r3, #2
 8012fca:	440b      	add	r3, r1
 8012fcc:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 8012fd0:	2200      	movs	r2, #0
 8012fd2:	601a      	str	r2, [r3, #0]
   hpcd->OUT_ep[i].xfer_len = 0U;
 8012fd4:	6879      	ldr	r1, [r7, #4]
 8012fd6:	68fa      	ldr	r2, [r7, #12]
 8012fd8:	4613      	mov	r3, r2
 8012fda:	00db      	lsls	r3, r3, #3
 8012fdc:	1a9b      	subs	r3, r3, r2
 8012fde:	009b      	lsls	r3, r3, #2
 8012fe0:	440b      	add	r3, r1
 8012fe2:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 8012fe6:	2200      	movs	r2, #0
 8012fe8:	601a      	str	r2, [r3, #0]
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 8012fea:	687b      	ldr	r3, [r7, #4]
 8012fec:	681a      	ldr	r2, [r3, #0]
 8012fee:	68fb      	ldr	r3, [r7, #12]
 8012ff0:	3340      	adds	r3, #64	; 0x40
 8012ff2:	009b      	lsls	r3, r3, #2
 8012ff4:	4413      	add	r3, r2
 8012ff6:	2200      	movs	r2, #0
 8012ff8:	605a      	str	r2, [r3, #4]
 for (i = 0U; i < 15U; i++)
 8012ffa:	68fb      	ldr	r3, [r7, #12]
 8012ffc:	3301      	adds	r3, #1
 8012ffe:	60fb      	str	r3, [r7, #12]
 8013000:	68fb      	ldr	r3, [r7, #12]
 8013002:	2b0e      	cmp	r3, #14
 8013004:	d9a1      	bls.n	8012f4a <HAL_PCD_Init+0x10e>
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 8013006:	687b      	ldr	r3, [r7, #4]
 8013008:	681b      	ldr	r3, [r3, #0]
 801300a:	603b      	str	r3, [r7, #0]
 801300c:	687e      	ldr	r6, [r7, #4]
 801300e:	466d      	mov	r5, sp
 8013010:	f106 0410 	add.w	r4, r6, #16
 8013014:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8013016:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8013018:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801301a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801301c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8013020:	e885 0003 	stmia.w	r5, {r0, r1}
 8013024:	1d33      	adds	r3, r6, #4
 8013026:	cb0e      	ldmia	r3, {r1, r2, r3}
 8013028:	6838      	ldr	r0, [r7, #0]
 801302a:	f004 fca7 	bl	801797c <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 801302e:	687b      	ldr	r3, [r7, #4]
 8013030:	2201      	movs	r2, #1
 8013032:	f883 2381 	strb.w	r2, [r3, #897]	; 0x381
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 8013036:	687b      	ldr	r3, [r7, #4]
 8013038:	681b      	ldr	r3, [r3, #0]
 801303a:	4618      	mov	r0, r3
 801303c:	f005 fc46 	bl	80188cc <USB_DevDisconnect>
 return HAL_OK;
 8013040:	2300      	movs	r3, #0
}
 8013042:	4618      	mov	r0, r3
 8013044:	3714      	adds	r7, #20
 8013046:	46bd      	mov	sp, r7
 8013048:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801304a <HAL_PCD_Start>:
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 801304a:	b580      	push	{r7, lr}
 801304c:	b082      	sub	sp, #8
 801304e:	af00      	add	r7, sp, #0
 8013050:	6078      	str	r0, [r7, #4]
  __HAL_LOCK(hpcd); 
 8013052:	687b      	ldr	r3, [r7, #4]
 8013054:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013058:	2b01      	cmp	r3, #1
 801305a:	d101      	bne.n	8013060 <HAL_PCD_Start+0x16>
 801305c:	2302      	movs	r3, #2
 801305e:	e012      	b.n	8013086 <HAL_PCD_Start+0x3c>
 8013060:	687b      	ldr	r3, [r7, #4]
 8013062:	2201      	movs	r2, #1
 8013064:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_DevConnect (hpcd->Instance);  
 8013068:	687b      	ldr	r3, [r7, #4]
 801306a:	681b      	ldr	r3, [r3, #0]
 801306c:	4618      	mov	r0, r3
 801306e:	f005 fc17 	bl	80188a0 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8013072:	687b      	ldr	r3, [r7, #4]
 8013074:	681b      	ldr	r3, [r3, #0]
 8013076:	4618      	mov	r0, r3
 8013078:	f004 fc37 	bl	80178ea <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 801307c:	687b      	ldr	r3, [r7, #4]
 801307e:	2200      	movs	r2, #0
 8013080:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  return HAL_OK;
 8013084:	2300      	movs	r3, #0
}
 8013086:	4618      	mov	r0, r3
 8013088:	3708      	adds	r7, #8
 801308a:	46bd      	mov	sp, r7
 801308c:	bd80      	pop	{r7, pc}

0801308e <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 801308e:	b580      	push	{r7, lr}
 8013090:	b08a      	sub	sp, #40	; 0x28
 8013092:	af00      	add	r7, sp, #0
 8013094:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8013096:	687b      	ldr	r3, [r7, #4]
 8013098:	681b      	ldr	r3, [r3, #0]
 801309a:	61bb      	str	r3, [r7, #24]
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 801309c:	2300      	movs	r3, #0
 801309e:	627b      	str	r3, [r7, #36]	; 0x24
 80130a0:	2300      	movs	r3, #0
 80130a2:	623b      	str	r3, [r7, #32]
 80130a4:	2300      	movs	r3, #0
 80130a6:	617b      	str	r3, [r7, #20]
 80130a8:	2300      	movs	r3, #0
 80130aa:	61fb      	str	r3, [r7, #28]
  uint32_t fifoemptymsk = 0U, temp = 0U;
 80130ac:	2300      	movs	r3, #0
 80130ae:	613b      	str	r3, [r7, #16]
 80130b0:	2300      	movs	r3, #0
 80130b2:	60fb      	str	r3, [r7, #12]
  USB_OTG_EPTypeDef *ep;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 80130b4:	687b      	ldr	r3, [r7, #4]
 80130b6:	681b      	ldr	r3, [r3, #0]
 80130b8:	4618      	mov	r0, r3
 80130ba:	f005 fca8 	bl	8018a0e <USB_GetMode>
 80130be:	4603      	mov	r3, r0
 80130c0:	2b00      	cmp	r3, #0
 80130c2:	f040 83ad 	bne.w	8013820 <HAL_PCD_IRQHandler+0x792>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 80130c6:	687b      	ldr	r3, [r7, #4]
 80130c8:	681b      	ldr	r3, [r3, #0]
 80130ca:	4618      	mov	r0, r3
 80130cc:	f005 fc14 	bl	80188f8 <USB_ReadInterrupts>
 80130d0:	4603      	mov	r3, r0
 80130d2:	2b00      	cmp	r3, #0
 80130d4:	f000 83a3 	beq.w	801381e <HAL_PCD_IRQHandler+0x790>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 80130d8:	687b      	ldr	r3, [r7, #4]
 80130da:	681b      	ldr	r3, [r3, #0]
 80130dc:	4618      	mov	r0, r3
 80130de:	f005 fc0b 	bl	80188f8 <USB_ReadInterrupts>
 80130e2:	4603      	mov	r3, r0
 80130e4:	f003 0302 	and.w	r3, r3, #2
 80130e8:	2b02      	cmp	r3, #2
 80130ea:	d107      	bne.n	80130fc <HAL_PCD_IRQHandler+0x6e>
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80130ec:	687b      	ldr	r3, [r7, #4]
 80130ee:	681b      	ldr	r3, [r3, #0]
 80130f0:	695a      	ldr	r2, [r3, #20]
 80130f2:	687b      	ldr	r3, [r7, #4]
 80130f4:	681b      	ldr	r3, [r3, #0]
 80130f6:	f002 0202 	and.w	r2, r2, #2
 80130fa:	615a      	str	r2, [r3, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 80130fc:	687b      	ldr	r3, [r7, #4]
 80130fe:	681b      	ldr	r3, [r3, #0]
 8013100:	4618      	mov	r0, r3
 8013102:	f005 fbf9 	bl	80188f8 <USB_ReadInterrupts>
 8013106:	4603      	mov	r3, r0
 8013108:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 801310c:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8013110:	f040 80b2 	bne.w	8013278 <HAL_PCD_IRQHandler+0x1ea>
    {
      epnum = 0U;
 8013114:	2300      	movs	r3, #0
 8013116:	61fb      	str	r3, [r7, #28]
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8013118:	687b      	ldr	r3, [r7, #4]
 801311a:	681b      	ldr	r3, [r3, #0]
 801311c:	4618      	mov	r0, r3
 801311e:	f005 fc00 	bl	8018922 <USB_ReadDevAllOutEpInterrupt>
 8013122:	6238      	str	r0, [r7, #32]
      
      while ( ep_intr )
 8013124:	e0a4      	b.n	8013270 <HAL_PCD_IRQHandler+0x1e2>
      {
        if (ep_intr & 0x1U)
 8013126:	6a3b      	ldr	r3, [r7, #32]
 8013128:	f003 0301 	and.w	r3, r3, #1
 801312c:	2b00      	cmp	r3, #0
 801312e:	f000 8099 	beq.w	8013264 <HAL_PCD_IRQHandler+0x1d6>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 8013132:	687b      	ldr	r3, [r7, #4]
 8013134:	681b      	ldr	r3, [r3, #0]
 8013136:	69fa      	ldr	r2, [r7, #28]
 8013138:	b2d2      	uxtb	r2, r2
 801313a:	4611      	mov	r1, r2
 801313c:	4618      	mov	r0, r3
 801313e:	f005 fc20 	bl	8018982 <USB_ReadDevOutEPInterrupt>
 8013142:	6178      	str	r0, [r7, #20]
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8013144:	697b      	ldr	r3, [r7, #20]
 8013146:	f003 0301 	and.w	r3, r3, #1
 801314a:	2b00      	cmp	r3, #0
 801314c:	d06b      	beq.n	8013226 <HAL_PCD_IRQHandler+0x198>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 801314e:	69fb      	ldr	r3, [r7, #28]
 8013150:	015a      	lsls	r2, r3, #5
 8013152:	69bb      	ldr	r3, [r7, #24]
 8013154:	4413      	add	r3, r2
 8013156:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801315a:	461a      	mov	r2, r3
 801315c:	2301      	movs	r3, #1
 801315e:	6093      	str	r3, [r2, #8]
            
            if(hpcd->Init.dma_enable == 1U)
 8013160:	687b      	ldr	r3, [r7, #4]
 8013162:	691b      	ldr	r3, [r3, #16]
 8013164:	2b01      	cmp	r3, #1
 8013166:	d13c      	bne.n	80131e2 <HAL_PCD_IRQHandler+0x154>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 8013168:	6879      	ldr	r1, [r7, #4]
 801316a:	69fa      	ldr	r2, [r7, #28]
 801316c:	4613      	mov	r3, r2
 801316e:	00db      	lsls	r3, r3, #3
 8013170:	1a9b      	subs	r3, r3, r2
 8013172:	009b      	lsls	r3, r3, #2
 8013174:	440b      	add	r3, r1
 8013176:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 801317a:	681a      	ldr	r2, [r3, #0]
 801317c:	69fb      	ldr	r3, [r7, #28]
 801317e:	0159      	lsls	r1, r3, #5
 8013180:	69bb      	ldr	r3, [r7, #24]
 8013182:	440b      	add	r3, r1
 8013184:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8013188:	691b      	ldr	r3, [r3, #16]
 801318a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 801318e:	1ad1      	subs	r1, r2, r3
 8013190:	6878      	ldr	r0, [r7, #4]
 8013192:	69fa      	ldr	r2, [r7, #28]
 8013194:	4613      	mov	r3, r2
 8013196:	00db      	lsls	r3, r3, #3
 8013198:	1a9b      	subs	r3, r3, r2
 801319a:	009b      	lsls	r3, r3, #2
 801319c:	4403      	add	r3, r0
 801319e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 80131a2:	6019      	str	r1, [r3, #0]
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 80131a4:	6879      	ldr	r1, [r7, #4]
 80131a6:	69fa      	ldr	r2, [r7, #28]
 80131a8:	4613      	mov	r3, r2
 80131aa:	00db      	lsls	r3, r3, #3
 80131ac:	1a9b      	subs	r3, r3, r2
 80131ae:	009b      	lsls	r3, r3, #2
 80131b0:	440b      	add	r3, r1
 80131b2:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 80131b6:	6819      	ldr	r1, [r3, #0]
 80131b8:	6878      	ldr	r0, [r7, #4]
 80131ba:	69fa      	ldr	r2, [r7, #28]
 80131bc:	4613      	mov	r3, r2
 80131be:	00db      	lsls	r3, r3, #3
 80131c0:	1a9b      	subs	r3, r3, r2
 80131c2:	009b      	lsls	r3, r3, #2
 80131c4:	4403      	add	r3, r0
 80131c6:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 80131ca:	681b      	ldr	r3, [r3, #0]
 80131cc:	4419      	add	r1, r3
 80131ce:	6878      	ldr	r0, [r7, #4]
 80131d0:	69fa      	ldr	r2, [r7, #28]
 80131d2:	4613      	mov	r3, r2
 80131d4:	00db      	lsls	r3, r3, #3
 80131d6:	1a9b      	subs	r3, r3, r2
 80131d8:	009b      	lsls	r3, r3, #2
 80131da:	4403      	add	r3, r0
 80131dc:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 80131e0:	6019      	str	r1, [r3, #0]
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 80131e2:	69fb      	ldr	r3, [r7, #28]
 80131e4:	b2db      	uxtb	r3, r3
 80131e6:	4619      	mov	r1, r3
 80131e8:	6878      	ldr	r0, [r7, #4]
 80131ea:	f7fd fdbf 	bl	8010d6c <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 80131ee:	687b      	ldr	r3, [r7, #4]
 80131f0:	691b      	ldr	r3, [r3, #16]
 80131f2:	2b01      	cmp	r3, #1
 80131f4:	d117      	bne.n	8013226 <HAL_PCD_IRQHandler+0x198>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80131f6:	69fb      	ldr	r3, [r7, #28]
 80131f8:	2b00      	cmp	r3, #0
 80131fa:	d114      	bne.n	8013226 <HAL_PCD_IRQHandler+0x198>
 80131fc:	6879      	ldr	r1, [r7, #4]
 80131fe:	69fa      	ldr	r2, [r7, #28]
 8013200:	4613      	mov	r3, r2
 8013202:	00db      	lsls	r3, r3, #3
 8013204:	1a9b      	subs	r3, r3, r2
 8013206:	009b      	lsls	r3, r3, #2
 8013208:	440b      	add	r3, r1
 801320a:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 801320e:	681b      	ldr	r3, [r3, #0]
 8013210:	2b00      	cmp	r3, #0
 8013212:	d108      	bne.n	8013226 <HAL_PCD_IRQHandler+0x198>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8013214:	687b      	ldr	r3, [r7, #4]
 8013216:	6818      	ldr	r0, [r3, #0]
 8013218:	687b      	ldr	r3, [r7, #4]
 801321a:	f503 7361 	add.w	r3, r3, #900	; 0x384
 801321e:	461a      	mov	r2, r3
 8013220:	2101      	movs	r1, #1
 8013222:	f005 fc35 	bl	8018a90 <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8013226:	697b      	ldr	r3, [r7, #20]
 8013228:	f003 0308 	and.w	r3, r3, #8
 801322c:	2b00      	cmp	r3, #0
 801322e:	d00b      	beq.n	8013248 <HAL_PCD_IRQHandler+0x1ba>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 8013230:	6878      	ldr	r0, [r7, #4]
 8013232:	f7fd fd89 	bl	8010d48 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 8013236:	69fb      	ldr	r3, [r7, #28]
 8013238:	015a      	lsls	r2, r3, #5
 801323a:	69bb      	ldr	r3, [r7, #24]
 801323c:	4413      	add	r3, r2
 801323e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8013242:	461a      	mov	r2, r3
 8013244:	2308      	movs	r3, #8
 8013246:	6093      	str	r3, [r2, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8013248:	697b      	ldr	r3, [r7, #20]
 801324a:	f003 0310 	and.w	r3, r3, #16
 801324e:	2b00      	cmp	r3, #0
 8013250:	d008      	beq.n	8013264 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8013252:	69fb      	ldr	r3, [r7, #28]
 8013254:	015a      	lsls	r2, r3, #5
 8013256:	69bb      	ldr	r3, [r7, #24]
 8013258:	4413      	add	r3, r2
 801325a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801325e:	461a      	mov	r2, r3
 8013260:	2310      	movs	r3, #16
 8013262:	6093      	str	r3, [r2, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
 8013264:	69fb      	ldr	r3, [r7, #28]
 8013266:	3301      	adds	r3, #1
 8013268:	61fb      	str	r3, [r7, #28]
        ep_intr >>= 1U;
 801326a:	6a3b      	ldr	r3, [r7, #32]
 801326c:	085b      	lsrs	r3, r3, #1
 801326e:	623b      	str	r3, [r7, #32]
      while ( ep_intr )
 8013270:	6a3b      	ldr	r3, [r7, #32]
 8013272:	2b00      	cmp	r3, #0
 8013274:	f47f af57 	bne.w	8013126 <HAL_PCD_IRQHandler+0x98>
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8013278:	687b      	ldr	r3, [r7, #4]
 801327a:	681b      	ldr	r3, [r3, #0]
 801327c:	4618      	mov	r0, r3
 801327e:	f005 fb3b 	bl	80188f8 <USB_ReadInterrupts>
 8013282:	4603      	mov	r3, r0
 8013284:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8013288:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 801328c:	f040 80c2 	bne.w	8013414 <HAL_PCD_IRQHandler+0x386>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8013290:	687b      	ldr	r3, [r7, #4]
 8013292:	681b      	ldr	r3, [r3, #0]
 8013294:	4618      	mov	r0, r3
 8013296:	f005 fb5c 	bl	8018952 <USB_ReadDevAllInEpInterrupt>
 801329a:	6238      	str	r0, [r7, #32]
      
      epnum = 0U;
 801329c:	2300      	movs	r3, #0
 801329e:	61fb      	str	r3, [r7, #28]
      
      while ( ep_intr )
 80132a0:	e0b4      	b.n	801340c <HAL_PCD_IRQHandler+0x37e>
      {
        if (ep_intr & 0x1U) /* In ITR */
 80132a2:	6a3b      	ldr	r3, [r7, #32]
 80132a4:	f003 0301 	and.w	r3, r3, #1
 80132a8:	2b00      	cmp	r3, #0
 80132aa:	f000 80a9 	beq.w	8013400 <HAL_PCD_IRQHandler+0x372>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 80132ae:	687b      	ldr	r3, [r7, #4]
 80132b0:	681b      	ldr	r3, [r3, #0]
 80132b2:	69fa      	ldr	r2, [r7, #28]
 80132b4:	b2d2      	uxtb	r2, r2
 80132b6:	4611      	mov	r1, r2
 80132b8:	4618      	mov	r0, r3
 80132ba:	f005 fb7e 	bl	80189ba <USB_ReadDevInEPInterrupt>
 80132be:	6178      	str	r0, [r7, #20]

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 80132c0:	697b      	ldr	r3, [r7, #20]
 80132c2:	f003 0301 	and.w	r3, r3, #1
 80132c6:	2b00      	cmp	r3, #0
 80132c8:	d059      	beq.n	801337e <HAL_PCD_IRQHandler+0x2f0>
          {
            fifoemptymsk = 0x1U << epnum;
 80132ca:	2201      	movs	r2, #1
 80132cc:	69fb      	ldr	r3, [r7, #28]
 80132ce:	fa02 f303 	lsl.w	r3, r2, r3
 80132d2:	613b      	str	r3, [r7, #16]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80132d4:	69bb      	ldr	r3, [r7, #24]
 80132d6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80132da:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80132dc:	693b      	ldr	r3, [r7, #16]
 80132de:	43db      	mvns	r3, r3
 80132e0:	69b9      	ldr	r1, [r7, #24]
 80132e2:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80132e6:	4013      	ands	r3, r2
 80132e8:	634b      	str	r3, [r1, #52]	; 0x34
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 80132ea:	69fb      	ldr	r3, [r7, #28]
 80132ec:	015a      	lsls	r2, r3, #5
 80132ee:	69bb      	ldr	r3, [r7, #24]
 80132f0:	4413      	add	r3, r2
 80132f2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80132f6:	461a      	mov	r2, r3
 80132f8:	2301      	movs	r3, #1
 80132fa:	6093      	str	r3, [r2, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 80132fc:	687b      	ldr	r3, [r7, #4]
 80132fe:	691b      	ldr	r3, [r3, #16]
 8013300:	2b01      	cmp	r3, #1
 8013302:	d11b      	bne.n	801333c <HAL_PCD_IRQHandler+0x2ae>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8013304:	6879      	ldr	r1, [r7, #4]
 8013306:	69fa      	ldr	r2, [r7, #28]
 8013308:	4613      	mov	r3, r2
 801330a:	00db      	lsls	r3, r3, #3
 801330c:	1a9b      	subs	r3, r3, r2
 801330e:	009b      	lsls	r3, r3, #2
 8013310:	440b      	add	r3, r1
 8013312:	3344      	adds	r3, #68	; 0x44
 8013314:	6819      	ldr	r1, [r3, #0]
 8013316:	6878      	ldr	r0, [r7, #4]
 8013318:	69fa      	ldr	r2, [r7, #28]
 801331a:	4613      	mov	r3, r2
 801331c:	00db      	lsls	r3, r3, #3
 801331e:	1a9b      	subs	r3, r3, r2
 8013320:	009b      	lsls	r3, r3, #2
 8013322:	4403      	add	r3, r0
 8013324:	3340      	adds	r3, #64	; 0x40
 8013326:	681b      	ldr	r3, [r3, #0]
 8013328:	4419      	add	r1, r3
 801332a:	6878      	ldr	r0, [r7, #4]
 801332c:	69fa      	ldr	r2, [r7, #28]
 801332e:	4613      	mov	r3, r2
 8013330:	00db      	lsls	r3, r3, #3
 8013332:	1a9b      	subs	r3, r3, r2
 8013334:	009b      	lsls	r3, r3, #2
 8013336:	4403      	add	r3, r0
 8013338:	3344      	adds	r3, #68	; 0x44
 801333a:	6019      	str	r1, [r3, #0]
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 801333c:	69fb      	ldr	r3, [r7, #28]
 801333e:	b2db      	uxtb	r3, r3
 8013340:	4619      	mov	r1, r3
 8013342:	6878      	ldr	r0, [r7, #4]
 8013344:	f7fd fd2d 	bl	8010da2 <HAL_PCD_DataInStageCallback>

            if (hpcd->Init.dma_enable == 1U)
 8013348:	687b      	ldr	r3, [r7, #4]
 801334a:	691b      	ldr	r3, [r3, #16]
 801334c:	2b01      	cmp	r3, #1
 801334e:	d116      	bne.n	801337e <HAL_PCD_IRQHandler+0x2f0>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8013350:	69fb      	ldr	r3, [r7, #28]
 8013352:	2b00      	cmp	r3, #0
 8013354:	d113      	bne.n	801337e <HAL_PCD_IRQHandler+0x2f0>
 8013356:	6879      	ldr	r1, [r7, #4]
 8013358:	69fa      	ldr	r2, [r7, #28]
 801335a:	4613      	mov	r3, r2
 801335c:	00db      	lsls	r3, r3, #3
 801335e:	1a9b      	subs	r3, r3, r2
 8013360:	009b      	lsls	r3, r3, #2
 8013362:	440b      	add	r3, r1
 8013364:	334c      	adds	r3, #76	; 0x4c
 8013366:	681b      	ldr	r3, [r3, #0]
 8013368:	2b00      	cmp	r3, #0
 801336a:	d108      	bne.n	801337e <HAL_PCD_IRQHandler+0x2f0>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 801336c:	687b      	ldr	r3, [r7, #4]
 801336e:	6818      	ldr	r0, [r3, #0]
 8013370:	687b      	ldr	r3, [r7, #4]
 8013372:	f503 7361 	add.w	r3, r3, #900	; 0x384
 8013376:	461a      	mov	r2, r3
 8013378:	2101      	movs	r1, #1
 801337a:	f005 fb89 	bl	8018a90 <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 801337e:	697b      	ldr	r3, [r7, #20]
 8013380:	f003 0308 	and.w	r3, r3, #8
 8013384:	2b00      	cmp	r3, #0
 8013386:	d008      	beq.n	801339a <HAL_PCD_IRQHandler+0x30c>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8013388:	69fb      	ldr	r3, [r7, #28]
 801338a:	015a      	lsls	r2, r3, #5
 801338c:	69bb      	ldr	r3, [r7, #24]
 801338e:	4413      	add	r3, r2
 8013390:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8013394:	461a      	mov	r2, r3
 8013396:	2308      	movs	r3, #8
 8013398:	6093      	str	r3, [r2, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 801339a:	697b      	ldr	r3, [r7, #20]
 801339c:	f003 0310 	and.w	r3, r3, #16
 80133a0:	2b00      	cmp	r3, #0
 80133a2:	d008      	beq.n	80133b6 <HAL_PCD_IRQHandler+0x328>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 80133a4:	69fb      	ldr	r3, [r7, #28]
 80133a6:	015a      	lsls	r2, r3, #5
 80133a8:	69bb      	ldr	r3, [r7, #24]
 80133aa:	4413      	add	r3, r2
 80133ac:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80133b0:	461a      	mov	r2, r3
 80133b2:	2310      	movs	r3, #16
 80133b4:	6093      	str	r3, [r2, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80133b6:	697b      	ldr	r3, [r7, #20]
 80133b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80133bc:	2b00      	cmp	r3, #0
 80133be:	d008      	beq.n	80133d2 <HAL_PCD_IRQHandler+0x344>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80133c0:	69fb      	ldr	r3, [r7, #28]
 80133c2:	015a      	lsls	r2, r3, #5
 80133c4:	69bb      	ldr	r3, [r7, #24]
 80133c6:	4413      	add	r3, r2
 80133c8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80133cc:	461a      	mov	r2, r3
 80133ce:	2340      	movs	r3, #64	; 0x40
 80133d0:	6093      	str	r3, [r2, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80133d2:	697b      	ldr	r3, [r7, #20]
 80133d4:	f003 0302 	and.w	r3, r3, #2
 80133d8:	2b00      	cmp	r3, #0
 80133da:	d008      	beq.n	80133ee <HAL_PCD_IRQHandler+0x360>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80133dc:	69fb      	ldr	r3, [r7, #28]
 80133de:	015a      	lsls	r2, r3, #5
 80133e0:	69bb      	ldr	r3, [r7, #24]
 80133e2:	4413      	add	r3, r2
 80133e4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80133e8:	461a      	mov	r2, r3
 80133ea:	2302      	movs	r3, #2
 80133ec:	6093      	str	r3, [r2, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80133ee:	697b      	ldr	r3, [r7, #20]
 80133f0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80133f4:	2b00      	cmp	r3, #0
 80133f6:	d003      	beq.n	8013400 <HAL_PCD_IRQHandler+0x372>
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
 80133f8:	69f9      	ldr	r1, [r7, #28]
 80133fa:	6878      	ldr	r0, [r7, #4]
 80133fc:	f000 fc88 	bl	8013d10 <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 8013400:	69fb      	ldr	r3, [r7, #28]
 8013402:	3301      	adds	r3, #1
 8013404:	61fb      	str	r3, [r7, #28]
        ep_intr >>= 1U;
 8013406:	6a3b      	ldr	r3, [r7, #32]
 8013408:	085b      	lsrs	r3, r3, #1
 801340a:	623b      	str	r3, [r7, #32]
      while ( ep_intr )
 801340c:	6a3b      	ldr	r3, [r7, #32]
 801340e:	2b00      	cmp	r3, #0
 8013410:	f47f af47 	bne.w	80132a2 <HAL_PCD_IRQHandler+0x214>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8013414:	687b      	ldr	r3, [r7, #4]
 8013416:	681b      	ldr	r3, [r3, #0]
 8013418:	4618      	mov	r0, r3
 801341a:	f005 fa6d 	bl	80188f8 <USB_ReadInterrupts>
 801341e:	4603      	mov	r3, r0
 8013420:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8013424:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8013428:	d114      	bne.n	8013454 <HAL_PCD_IRQHandler+0x3c6>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 801342a:	69bb      	ldr	r3, [r7, #24]
 801342c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013430:	685b      	ldr	r3, [r3, #4]
 8013432:	69ba      	ldr	r2, [r7, #24]
 8013434:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8013438:	f023 0301 	bic.w	r3, r3, #1
 801343c:	6053      	str	r3, [r2, #4]
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 801343e:	6878      	ldr	r0, [r7, #4]
 8013440:	f7fd fd26 	bl	8010e90 <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8013444:	687b      	ldr	r3, [r7, #4]
 8013446:	681b      	ldr	r3, [r3, #0]
 8013448:	695a      	ldr	r2, [r3, #20]
 801344a:	687b      	ldr	r3, [r7, #4]
 801344c:	681b      	ldr	r3, [r3, #0]
 801344e:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8013452:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8013454:	687b      	ldr	r3, [r7, #4]
 8013456:	681b      	ldr	r3, [r3, #0]
 8013458:	4618      	mov	r0, r3
 801345a:	f005 fa4d 	bl	80188f8 <USB_ReadInterrupts>
 801345e:	4603      	mov	r3, r0
 8013460:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8013464:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8013468:	d112      	bne.n	8013490 <HAL_PCD_IRQHandler+0x402>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 801346a:	69bb      	ldr	r3, [r7, #24]
 801346c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013470:	689b      	ldr	r3, [r3, #8]
 8013472:	f003 0301 	and.w	r3, r3, #1
 8013476:	2b01      	cmp	r3, #1
 8013478:	d102      	bne.n	8013480 <HAL_PCD_IRQHandler+0x3f2>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 801347a:	6878      	ldr	r0, [r7, #4]
 801347c:	f7fd fce2 	bl	8010e44 <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8013480:	687b      	ldr	r3, [r7, #4]
 8013482:	681b      	ldr	r3, [r3, #0]
 8013484:	695a      	ldr	r2, [r3, #20]
 8013486:	687b      	ldr	r3, [r7, #4]
 8013488:	681b      	ldr	r3, [r3, #0]
 801348a:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 801348e:	615a      	str	r2, [r3, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8013490:	687b      	ldr	r3, [r7, #4]
 8013492:	681b      	ldr	r3, [r3, #0]
 8013494:	4618      	mov	r0, r3
 8013496:	f005 fa2f 	bl	80188f8 <USB_ReadInterrupts>
 801349a:	4603      	mov	r3, r0
 801349c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80134a0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80134a4:	f040 808a 	bne.w	80135bc <HAL_PCD_IRQHandler+0x52e>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 80134a8:	69bb      	ldr	r3, [r7, #24]
 80134aa:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80134ae:	685b      	ldr	r3, [r3, #4]
 80134b0:	69ba      	ldr	r2, [r7, #24]
 80134b2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80134b6:	f023 0301 	bic.w	r3, r3, #1
 80134ba:	6053      	str	r3, [r2, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 80134bc:	687b      	ldr	r3, [r7, #4]
 80134be:	681b      	ldr	r3, [r3, #0]
 80134c0:	2100      	movs	r1, #0
 80134c2:	4618      	mov	r0, r3
 80134c4:	f004 fb8a 	bl	8017bdc <USB_FlushTxFifo>
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80134c8:	2300      	movs	r3, #0
 80134ca:	627b      	str	r3, [r7, #36]	; 0x24
 80134cc:	e014      	b.n	80134f8 <HAL_PCD_IRQHandler+0x46a>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 80134ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80134d0:	015a      	lsls	r2, r3, #5
 80134d2:	69bb      	ldr	r3, [r7, #24]
 80134d4:	4413      	add	r3, r2
 80134d6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80134da:	461a      	mov	r2, r3
 80134dc:	23ff      	movs	r3, #255	; 0xff
 80134de:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 80134e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80134e2:	015a      	lsls	r2, r3, #5
 80134e4:	69bb      	ldr	r3, [r7, #24]
 80134e6:	4413      	add	r3, r2
 80134e8:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80134ec:	461a      	mov	r2, r3
 80134ee:	23ff      	movs	r3, #255	; 0xff
 80134f0:	6093      	str	r3, [r2, #8]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80134f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80134f4:	3301      	adds	r3, #1
 80134f6:	627b      	str	r3, [r7, #36]	; 0x24
 80134f8:	687b      	ldr	r3, [r7, #4]
 80134fa:	685b      	ldr	r3, [r3, #4]
 80134fc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80134fe:	429a      	cmp	r2, r3
 8013500:	d3e5      	bcc.n	80134ce <HAL_PCD_IRQHandler+0x440>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8013502:	69bb      	ldr	r3, [r7, #24]
 8013504:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013508:	461a      	mov	r2, r3
 801350a:	f04f 33ff 	mov.w	r3, #4294967295
 801350e:	6193      	str	r3, [r2, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8013510:	69bb      	ldr	r3, [r7, #24]
 8013512:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013516:	69db      	ldr	r3, [r3, #28]
 8013518:	69ba      	ldr	r2, [r7, #24]
 801351a:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 801351e:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8013522:	61d3      	str	r3, [r2, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 8013524:	687b      	ldr	r3, [r7, #4]
 8013526:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8013528:	2b00      	cmp	r3, #0
 801352a:	d016      	beq.n	801355a <HAL_PCD_IRQHandler+0x4cc>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 801352c:	69bb      	ldr	r3, [r7, #24]
 801352e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013532:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8013536:	69ba      	ldr	r2, [r7, #24]
 8013538:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 801353c:	f043 030b 	orr.w	r3, r3, #11
 8013540:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8013544:	69bb      	ldr	r3, [r7, #24]
 8013546:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 801354a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801354c:	69ba      	ldr	r2, [r7, #24]
 801354e:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8013552:	f043 030b 	orr.w	r3, r3, #11
 8013556:	6453      	str	r3, [r2, #68]	; 0x44
 8013558:	e013      	b.n	8013582 <HAL_PCD_IRQHandler+0x4f4>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 801355a:	69bb      	ldr	r3, [r7, #24]
 801355c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013560:	695b      	ldr	r3, [r3, #20]
 8013562:	69ba      	ldr	r2, [r7, #24]
 8013564:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8013568:	f043 030b 	orr.w	r3, r3, #11
 801356c:	6153      	str	r3, [r2, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 801356e:	69bb      	ldr	r3, [r7, #24]
 8013570:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013574:	691b      	ldr	r3, [r3, #16]
 8013576:	69ba      	ldr	r2, [r7, #24]
 8013578:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 801357c:	f043 030b 	orr.w	r3, r3, #11
 8013580:	6113      	str	r3, [r2, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8013582:	69bb      	ldr	r3, [r7, #24]
 8013584:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013588:	681b      	ldr	r3, [r3, #0]
 801358a:	69ba      	ldr	r2, [r7, #24]
 801358c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8013590:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8013594:	6013      	str	r3, [r2, #0]
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8013596:	687b      	ldr	r3, [r7, #4]
 8013598:	6818      	ldr	r0, [r3, #0]
 801359a:	687b      	ldr	r3, [r7, #4]
 801359c:	691b      	ldr	r3, [r3, #16]
 801359e:	b2d9      	uxtb	r1, r3
 80135a0:	687b      	ldr	r3, [r7, #4]
 80135a2:	f503 7361 	add.w	r3, r3, #900	; 0x384
 80135a6:	461a      	mov	r2, r3
 80135a8:	f005 fa72 	bl	8018a90 <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80135ac:	687b      	ldr	r3, [r7, #4]
 80135ae:	681b      	ldr	r3, [r3, #0]
 80135b0:	695a      	ldr	r2, [r3, #20]
 80135b2:	687b      	ldr	r3, [r7, #4]
 80135b4:	681b      	ldr	r3, [r3, #0]
 80135b6:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 80135ba:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80135bc:	687b      	ldr	r3, [r7, #4]
 80135be:	681b      	ldr	r3, [r3, #0]
 80135c0:	4618      	mov	r0, r3
 80135c2:	f005 f999 	bl	80188f8 <USB_ReadInterrupts>
 80135c6:	4603      	mov	r3, r0
 80135c8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80135cc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80135d0:	d13d      	bne.n	801364e <HAL_PCD_IRQHandler+0x5c0>
    {
      USB_ActivateSetup(hpcd->Instance);
 80135d2:	687b      	ldr	r3, [r7, #4]
 80135d4:	681b      	ldr	r3, [r3, #0]
 80135d6:	4618      	mov	r0, r3
 80135d8:	f005 fa27 	bl	8018a2a <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80135dc:	687b      	ldr	r3, [r7, #4]
 80135de:	681b      	ldr	r3, [r3, #0]
 80135e0:	68da      	ldr	r2, [r3, #12]
 80135e2:	687b      	ldr	r3, [r7, #4]
 80135e4:	681b      	ldr	r3, [r3, #0]
 80135e6:	f422 5270 	bic.w	r2, r2, #15360	; 0x3c00
 80135ea:	60da      	str	r2, [r3, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 80135ec:	687b      	ldr	r3, [r7, #4]
 80135ee:	681b      	ldr	r3, [r3, #0]
 80135f0:	4618      	mov	r0, r3
 80135f2:	f004 fb52 	bl	8017c9a <USB_GetDevSpeed>
 80135f6:	4603      	mov	r3, r0
 80135f8:	2b00      	cmp	r3, #0
 80135fa:	d10f      	bne.n	801361c <HAL_PCD_IRQHandler+0x58e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 80135fc:	687b      	ldr	r3, [r7, #4]
 80135fe:	2200      	movs	r2, #0
 8013600:	60da      	str	r2, [r3, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 8013602:	687b      	ldr	r3, [r7, #4]
 8013604:	f44f 7200 	mov.w	r2, #512	; 0x200
 8013608:	615a      	str	r2, [r3, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 801360a:	687b      	ldr	r3, [r7, #4]
 801360c:	681b      	ldr	r3, [r3, #0]
 801360e:	68da      	ldr	r2, [r3, #12]
 8013610:	687b      	ldr	r3, [r7, #4]
 8013612:	681b      	ldr	r3, [r3, #0]
 8013614:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8013618:	60da      	str	r2, [r3, #12]
 801361a:	e00d      	b.n	8013638 <HAL_PCD_IRQHandler+0x5aa>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 801361c:	687b      	ldr	r3, [r7, #4]
 801361e:	2203      	movs	r2, #3
 8013620:	60da      	str	r2, [r3, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 8013622:	687b      	ldr	r3, [r7, #4]
 8013624:	2240      	movs	r2, #64	; 0x40
 8013626:	615a      	str	r2, [r3, #20]
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_FS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8013628:	687b      	ldr	r3, [r7, #4]
 801362a:	681b      	ldr	r3, [r3, #0]
 801362c:	68da      	ldr	r2, [r3, #12]
 801362e:	687b      	ldr	r3, [r7, #4]
 8013630:	681b      	ldr	r3, [r3, #0]
 8013632:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8013636:	60da      	str	r2, [r3, #12]
      }
      
      HAL_PCD_ResetCallback(hpcd);
 8013638:	6878      	ldr	r0, [r7, #4]
 801363a:	f7fd fbda 	bl	8010df2 <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 801363e:	687b      	ldr	r3, [r7, #4]
 8013640:	681b      	ldr	r3, [r3, #0]
 8013642:	695a      	ldr	r2, [r3, #20]
 8013644:	687b      	ldr	r3, [r7, #4]
 8013646:	681b      	ldr	r3, [r3, #0]
 8013648:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 801364c:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 801364e:	687b      	ldr	r3, [r7, #4]
 8013650:	681b      	ldr	r3, [r3, #0]
 8013652:	4618      	mov	r0, r3
 8013654:	f005 f950 	bl	80188f8 <USB_ReadInterrupts>
 8013658:	4603      	mov	r3, r0
 801365a:	f003 0310 	and.w	r3, r3, #16
 801365e:	2b10      	cmp	r3, #16
 8013660:	d161      	bne.n	8013726 <HAL_PCD_IRQHandler+0x698>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8013662:	687b      	ldr	r3, [r7, #4]
 8013664:	681b      	ldr	r3, [r3, #0]
 8013666:	699a      	ldr	r2, [r3, #24]
 8013668:	687b      	ldr	r3, [r7, #4]
 801366a:	681b      	ldr	r3, [r3, #0]
 801366c:	f022 0210 	bic.w	r2, r2, #16
 8013670:	619a      	str	r2, [r3, #24]
      
      temp = USBx->GRXSTSP;
 8013672:	69bb      	ldr	r3, [r7, #24]
 8013674:	6a1b      	ldr	r3, [r3, #32]
 8013676:	60fb      	str	r3, [r7, #12]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8013678:	68fb      	ldr	r3, [r7, #12]
 801367a:	f003 020f 	and.w	r2, r3, #15
 801367e:	4613      	mov	r3, r2
 8013680:	00db      	lsls	r3, r3, #3
 8013682:	1a9b      	subs	r3, r3, r2
 8013684:	009b      	lsls	r3, r3, #2
 8013686:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 801368a:	687a      	ldr	r2, [r7, #4]
 801368c:	4413      	add	r3, r2
 801368e:	3304      	adds	r3, #4
 8013690:	60bb      	str	r3, [r7, #8]
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8013692:	68fb      	ldr	r3, [r7, #12]
 8013694:	0c5b      	lsrs	r3, r3, #17
 8013696:	f003 030f 	and.w	r3, r3, #15
 801369a:	2b02      	cmp	r3, #2
 801369c:	d124      	bne.n	80136e8 <HAL_PCD_IRQHandler+0x65a>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 801369e:	68fa      	ldr	r2, [r7, #12]
 80136a0:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80136a4:	4013      	ands	r3, r2
 80136a6:	2b00      	cmp	r3, #0
 80136a8:	d035      	beq.n	8013716 <HAL_PCD_IRQHandler+0x688>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 80136aa:	68bb      	ldr	r3, [r7, #8]
 80136ac:	68d9      	ldr	r1, [r3, #12]
 80136ae:	68fb      	ldr	r3, [r7, #12]
 80136b0:	091b      	lsrs	r3, r3, #4
 80136b2:	b29b      	uxth	r3, r3
 80136b4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80136b8:	b29b      	uxth	r3, r3
 80136ba:	461a      	mov	r2, r3
 80136bc:	69b8      	ldr	r0, [r7, #24]
 80136be:	f004 ffce 	bl	801865e <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 80136c2:	68bb      	ldr	r3, [r7, #8]
 80136c4:	68da      	ldr	r2, [r3, #12]
 80136c6:	68fb      	ldr	r3, [r7, #12]
 80136c8:	091b      	lsrs	r3, r3, #4
 80136ca:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80136ce:	441a      	add	r2, r3
 80136d0:	68bb      	ldr	r3, [r7, #8]
 80136d2:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 80136d4:	68bb      	ldr	r3, [r7, #8]
 80136d6:	699a      	ldr	r2, [r3, #24]
 80136d8:	68fb      	ldr	r3, [r7, #12]
 80136da:	091b      	lsrs	r3, r3, #4
 80136dc:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80136e0:	441a      	add	r2, r3
 80136e2:	68bb      	ldr	r3, [r7, #8]
 80136e4:	619a      	str	r2, [r3, #24]
 80136e6:	e016      	b.n	8013716 <HAL_PCD_IRQHandler+0x688>
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 80136e8:	68fb      	ldr	r3, [r7, #12]
 80136ea:	0c5b      	lsrs	r3, r3, #17
 80136ec:	f003 030f 	and.w	r3, r3, #15
 80136f0:	2b06      	cmp	r3, #6
 80136f2:	d110      	bne.n	8013716 <HAL_PCD_IRQHandler+0x688>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80136f4:	687b      	ldr	r3, [r7, #4]
 80136f6:	f503 7361 	add.w	r3, r3, #900	; 0x384
 80136fa:	2208      	movs	r2, #8
 80136fc:	4619      	mov	r1, r3
 80136fe:	69b8      	ldr	r0, [r7, #24]
 8013700:	f004 ffad 	bl	801865e <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8013704:	68bb      	ldr	r3, [r7, #8]
 8013706:	699a      	ldr	r2, [r3, #24]
 8013708:	68fb      	ldr	r3, [r7, #12]
 801370a:	091b      	lsrs	r3, r3, #4
 801370c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8013710:	441a      	add	r2, r3
 8013712:	68bb      	ldr	r3, [r7, #8]
 8013714:	619a      	str	r2, [r3, #24]
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8013716:	687b      	ldr	r3, [r7, #4]
 8013718:	681b      	ldr	r3, [r3, #0]
 801371a:	699a      	ldr	r2, [r3, #24]
 801371c:	687b      	ldr	r3, [r7, #4]
 801371e:	681b      	ldr	r3, [r3, #0]
 8013720:	f042 0210 	orr.w	r2, r2, #16
 8013724:	619a      	str	r2, [r3, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8013726:	687b      	ldr	r3, [r7, #4]
 8013728:	681b      	ldr	r3, [r3, #0]
 801372a:	4618      	mov	r0, r3
 801372c:	f005 f8e4 	bl	80188f8 <USB_ReadInterrupts>
 8013730:	4603      	mov	r3, r0
 8013732:	f003 0308 	and.w	r3, r3, #8
 8013736:	2b08      	cmp	r3, #8
 8013738:	d10a      	bne.n	8013750 <HAL_PCD_IRQHandler+0x6c2>
    {
      HAL_PCD_SOFCallback(hpcd);
 801373a:	6878      	ldr	r0, [r7, #4]
 801373c:	f7fd fb4b 	bl	8010dd6 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8013740:	687b      	ldr	r3, [r7, #4]
 8013742:	681b      	ldr	r3, [r3, #0]
 8013744:	695a      	ldr	r2, [r3, #20]
 8013746:	687b      	ldr	r3, [r7, #4]
 8013748:	681b      	ldr	r3, [r3, #0]
 801374a:	f002 0208 	and.w	r2, r2, #8
 801374e:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8013750:	687b      	ldr	r3, [r7, #4]
 8013752:	681b      	ldr	r3, [r3, #0]
 8013754:	4618      	mov	r0, r3
 8013756:	f005 f8cf 	bl	80188f8 <USB_ReadInterrupts>
 801375a:	4603      	mov	r3, r0
 801375c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8013760:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8013764:	d10d      	bne.n	8013782 <HAL_PCD_IRQHandler+0x6f4>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8013766:	69fb      	ldr	r3, [r7, #28]
 8013768:	b2db      	uxtb	r3, r3
 801376a:	4619      	mov	r1, r3
 801376c:	6878      	ldr	r0, [r7, #4]
 801376e:	f7fd fbaf 	bl	8010ed0 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8013772:	687b      	ldr	r3, [r7, #4]
 8013774:	681b      	ldr	r3, [r3, #0]
 8013776:	695a      	ldr	r2, [r3, #20]
 8013778:	687b      	ldr	r3, [r7, #4]
 801377a:	681b      	ldr	r3, [r3, #0]
 801377c:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 8013780:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8013782:	687b      	ldr	r3, [r7, #4]
 8013784:	681b      	ldr	r3, [r3, #0]
 8013786:	4618      	mov	r0, r3
 8013788:	f005 f8b6 	bl	80188f8 <USB_ReadInterrupts>
 801378c:	4603      	mov	r3, r0
 801378e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8013792:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8013796:	d10d      	bne.n	80137b4 <HAL_PCD_IRQHandler+0x726>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8013798:	69fb      	ldr	r3, [r7, #28]
 801379a:	b2db      	uxtb	r3, r3
 801379c:	4619      	mov	r1, r3
 801379e:	6878      	ldr	r0, [r7, #4]
 80137a0:	f7fd fb84 	bl	8010eac <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80137a4:	687b      	ldr	r3, [r7, #4]
 80137a6:	681b      	ldr	r3, [r3, #0]
 80137a8:	695a      	ldr	r2, [r3, #20]
 80137aa:	687b      	ldr	r3, [r7, #4]
 80137ac:	681b      	ldr	r3, [r3, #0]
 80137ae:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 80137b2:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 80137b4:	687b      	ldr	r3, [r7, #4]
 80137b6:	681b      	ldr	r3, [r3, #0]
 80137b8:	4618      	mov	r0, r3
 80137ba:	f005 f89d 	bl	80188f8 <USB_ReadInterrupts>
 80137be:	4603      	mov	r3, r0
 80137c0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80137c4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80137c8:	d10a      	bne.n	80137e0 <HAL_PCD_IRQHandler+0x752>
    {
      HAL_PCD_ConnectCallback(hpcd);
 80137ca:	6878      	ldr	r0, [r7, #4]
 80137cc:	f7fd fb92 	bl	8010ef4 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 80137d0:	687b      	ldr	r3, [r7, #4]
 80137d2:	681b      	ldr	r3, [r3, #0]
 80137d4:	695a      	ldr	r2, [r3, #20]
 80137d6:	687b      	ldr	r3, [r7, #4]
 80137d8:	681b      	ldr	r3, [r3, #0]
 80137da:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 80137de:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 80137e0:	687b      	ldr	r3, [r7, #4]
 80137e2:	681b      	ldr	r3, [r3, #0]
 80137e4:	4618      	mov	r0, r3
 80137e6:	f005 f887 	bl	80188f8 <USB_ReadInterrupts>
 80137ea:	4603      	mov	r3, r0
 80137ec:	f003 0304 	and.w	r3, r3, #4
 80137f0:	2b04      	cmp	r3, #4
 80137f2:	d115      	bne.n	8013820 <HAL_PCD_IRQHandler+0x792>
    {
      temp = hpcd->Instance->GOTGINT;
 80137f4:	687b      	ldr	r3, [r7, #4]
 80137f6:	681b      	ldr	r3, [r3, #0]
 80137f8:	685b      	ldr	r3, [r3, #4]
 80137fa:	60fb      	str	r3, [r7, #12]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 80137fc:	68fb      	ldr	r3, [r7, #12]
 80137fe:	f003 0304 	and.w	r3, r3, #4
 8013802:	2b00      	cmp	r3, #0
 8013804:	d002      	beq.n	801380c <HAL_PCD_IRQHandler+0x77e>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8013806:	6878      	ldr	r0, [r7, #4]
 8013808:	f7fd fb82 	bl	8010f10 <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 801380c:	687b      	ldr	r3, [r7, #4]
 801380e:	681b      	ldr	r3, [r3, #0]
 8013810:	6859      	ldr	r1, [r3, #4]
 8013812:	687b      	ldr	r3, [r7, #4]
 8013814:	681b      	ldr	r3, [r3, #0]
 8013816:	68fa      	ldr	r2, [r7, #12]
 8013818:	430a      	orrs	r2, r1
 801381a:	605a      	str	r2, [r3, #4]
 801381c:	e000      	b.n	8013820 <HAL_PCD_IRQHandler+0x792>
      return;
 801381e:	bf00      	nop
    }
  }
}
 8013820:	3728      	adds	r7, #40	; 0x28
 8013822:	46bd      	mov	sp, r7
 8013824:	bd80      	pop	{r7, pc}

08013826 <HAL_PCD_SetAddress>:
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8013826:	b580      	push	{r7, lr}
 8013828:	b082      	sub	sp, #8
 801382a:	af00      	add	r7, sp, #0
 801382c:	6078      	str	r0, [r7, #4]
 801382e:	460b      	mov	r3, r1
 8013830:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd); 
 8013832:	687b      	ldr	r3, [r7, #4]
 8013834:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013838:	2b01      	cmp	r3, #1
 801383a:	d101      	bne.n	8013840 <HAL_PCD_SetAddress+0x1a>
 801383c:	2302      	movs	r3, #2
 801383e:	e00f      	b.n	8013860 <HAL_PCD_SetAddress+0x3a>
 8013840:	687b      	ldr	r3, [r7, #4]
 8013842:	2201      	movs	r2, #1
 8013844:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_SetDevAddress(hpcd->Instance, address);
 8013848:	687b      	ldr	r3, [r7, #4]
 801384a:	681b      	ldr	r3, [r3, #0]
 801384c:	78fa      	ldrb	r2, [r7, #3]
 801384e:	4611      	mov	r1, r2
 8013850:	4618      	mov	r0, r3
 8013852:	f005 f801 	bl	8018858 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8013856:	687b      	ldr	r3, [r7, #4]
 8013858:	2200      	movs	r2, #0
 801385a:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  return HAL_OK;
 801385e:	2300      	movs	r3, #0
}
 8013860:	4618      	mov	r0, r3
 8013862:	3708      	adds	r7, #8
 8013864:	46bd      	mov	sp, r7
 8013866:	bd80      	pop	{r7, pc}

08013868 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8013868:	b580      	push	{r7, lr}
 801386a:	b084      	sub	sp, #16
 801386c:	af00      	add	r7, sp, #0
 801386e:	6078      	str	r0, [r7, #4]
 8013870:	4608      	mov	r0, r1
 8013872:	4611      	mov	r1, r2
 8013874:	461a      	mov	r2, r3
 8013876:	4603      	mov	r3, r0
 8013878:	70fb      	strb	r3, [r7, #3]
 801387a:	460b      	mov	r3, r1
 801387c:	803b      	strh	r3, [r7, #0]
 801387e:	4613      	mov	r3, r2
 8013880:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 8013882:	2300      	movs	r3, #0
 8013884:	72fb      	strb	r3, [r7, #11]
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8013886:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801388a:	2b00      	cmp	r3, #0
 801388c:	da0b      	bge.n	80138a6 <HAL_PCD_EP_Open+0x3e>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 801388e:	78fb      	ldrb	r3, [r7, #3]
 8013890:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013894:	4613      	mov	r3, r2
 8013896:	00db      	lsls	r3, r3, #3
 8013898:	1a9b      	subs	r3, r3, r2
 801389a:	009b      	lsls	r3, r3, #2
 801389c:	3338      	adds	r3, #56	; 0x38
 801389e:	687a      	ldr	r2, [r7, #4]
 80138a0:	4413      	add	r3, r2
 80138a2:	60fb      	str	r3, [r7, #12]
 80138a4:	e00c      	b.n	80138c0 <HAL_PCD_EP_Open+0x58>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80138a6:	78fb      	ldrb	r3, [r7, #3]
 80138a8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80138ac:	4613      	mov	r3, r2
 80138ae:	00db      	lsls	r3, r3, #3
 80138b0:	1a9b      	subs	r3, r3, r2
 80138b2:	009b      	lsls	r3, r3, #2
 80138b4:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 80138b8:	687a      	ldr	r2, [r7, #4]
 80138ba:	4413      	add	r3, r2
 80138bc:	3304      	adds	r3, #4
 80138be:	60fb      	str	r3, [r7, #12]
  }
  ep->num   = ep_addr & 0x7FU;
 80138c0:	78fb      	ldrb	r3, [r7, #3]
 80138c2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80138c6:	b2da      	uxtb	r2, r3
 80138c8:	68fb      	ldr	r3, [r7, #12]
 80138ca:	701a      	strb	r2, [r3, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 80138cc:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80138d0:	b2db      	uxtb	r3, r3
 80138d2:	09db      	lsrs	r3, r3, #7
 80138d4:	b2db      	uxtb	r3, r3
 80138d6:	461a      	mov	r2, r3
 80138d8:	68fb      	ldr	r3, [r7, #12]
 80138da:	705a      	strb	r2, [r3, #1]
  ep->maxpacket = ep_mps;
 80138dc:	883a      	ldrh	r2, [r7, #0]
 80138de:	68fb      	ldr	r3, [r7, #12]
 80138e0:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 80138e2:	68fb      	ldr	r3, [r7, #12]
 80138e4:	78ba      	ldrb	r2, [r7, #2]
 80138e6:	70da      	strb	r2, [r3, #3]
  if (ep->is_in)
 80138e8:	68fb      	ldr	r3, [r7, #12]
 80138ea:	785b      	ldrb	r3, [r3, #1]
 80138ec:	2b00      	cmp	r3, #0
 80138ee:	d004      	beq.n	80138fa <HAL_PCD_EP_Open+0x92>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 80138f0:	68fb      	ldr	r3, [r7, #12]
 80138f2:	781b      	ldrb	r3, [r3, #0]
 80138f4:	b29a      	uxth	r2, r3
 80138f6:	68fb      	ldr	r3, [r7, #12]
 80138f8:	80da      	strh	r2, [r3, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 80138fa:	78bb      	ldrb	r3, [r7, #2]
 80138fc:	2b02      	cmp	r3, #2
 80138fe:	d102      	bne.n	8013906 <HAL_PCD_EP_Open+0x9e>
  {
    ep->data_pid_start = 0U;
 8013900:	68fb      	ldr	r3, [r7, #12]
 8013902:	2200      	movs	r2, #0
 8013904:	711a      	strb	r2, [r3, #4]
  }
  
  __HAL_LOCK(hpcd); 
 8013906:	687b      	ldr	r3, [r7, #4]
 8013908:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 801390c:	2b01      	cmp	r3, #1
 801390e:	d101      	bne.n	8013914 <HAL_PCD_EP_Open+0xac>
 8013910:	2302      	movs	r3, #2
 8013912:	e00e      	b.n	8013932 <HAL_PCD_EP_Open+0xca>
 8013914:	687b      	ldr	r3, [r7, #4]
 8013916:	2201      	movs	r2, #1
 8013918:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_ActivateEndpoint(hpcd->Instance , ep);
 801391c:	687b      	ldr	r3, [r7, #4]
 801391e:	681b      	ldr	r3, [r3, #0]
 8013920:	68f9      	ldr	r1, [r7, #12]
 8013922:	4618      	mov	r0, r3
 8013924:	f004 f9ee 	bl	8017d04 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8013928:	687b      	ldr	r3, [r7, #4]
 801392a:	2200      	movs	r2, #0
 801392c:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  return ret;
 8013930:	7afb      	ldrb	r3, [r7, #11]
}
 8013932:	4618      	mov	r0, r3
 8013934:	3710      	adds	r7, #16
 8013936:	46bd      	mov	sp, r7
 8013938:	bd80      	pop	{r7, pc}

0801393a <HAL_PCD_EP_Close>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 801393a:	b580      	push	{r7, lr}
 801393c:	b084      	sub	sp, #16
 801393e:	af00      	add	r7, sp, #0
 8013940:	6078      	str	r0, [r7, #4]
 8013942:	460b      	mov	r3, r1
 8013944:	70fb      	strb	r3, [r7, #3]
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8013946:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801394a:	2b00      	cmp	r3, #0
 801394c:	da0b      	bge.n	8013966 <HAL_PCD_EP_Close+0x2c>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 801394e:	78fb      	ldrb	r3, [r7, #3]
 8013950:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013954:	4613      	mov	r3, r2
 8013956:	00db      	lsls	r3, r3, #3
 8013958:	1a9b      	subs	r3, r3, r2
 801395a:	009b      	lsls	r3, r3, #2
 801395c:	3338      	adds	r3, #56	; 0x38
 801395e:	687a      	ldr	r2, [r7, #4]
 8013960:	4413      	add	r3, r2
 8013962:	60fb      	str	r3, [r7, #12]
 8013964:	e00c      	b.n	8013980 <HAL_PCD_EP_Close+0x46>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8013966:	78fb      	ldrb	r3, [r7, #3]
 8013968:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 801396c:	4613      	mov	r3, r2
 801396e:	00db      	lsls	r3, r3, #3
 8013970:	1a9b      	subs	r3, r3, r2
 8013972:	009b      	lsls	r3, r3, #2
 8013974:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 8013978:	687a      	ldr	r2, [r7, #4]
 801397a:	4413      	add	r3, r2
 801397c:	3304      	adds	r3, #4
 801397e:	60fb      	str	r3, [r7, #12]
  }
  ep->num   = ep_addr & 0x7FU;
 8013980:	78fb      	ldrb	r3, [r7, #3]
 8013982:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013986:	b2da      	uxtb	r2, r3
 8013988:	68fb      	ldr	r3, [r7, #12]
 801398a:	701a      	strb	r2, [r3, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 801398c:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013990:	b2db      	uxtb	r3, r3
 8013992:	09db      	lsrs	r3, r3, #7
 8013994:	b2db      	uxtb	r3, r3
 8013996:	461a      	mov	r2, r3
 8013998:	68fb      	ldr	r3, [r7, #12]
 801399a:	705a      	strb	r2, [r3, #1]
  
  __HAL_LOCK(hpcd); 
 801399c:	687b      	ldr	r3, [r7, #4]
 801399e:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 80139a2:	2b01      	cmp	r3, #1
 80139a4:	d101      	bne.n	80139aa <HAL_PCD_EP_Close+0x70>
 80139a6:	2302      	movs	r3, #2
 80139a8:	e00e      	b.n	80139c8 <HAL_PCD_EP_Close+0x8e>
 80139aa:	687b      	ldr	r3, [r7, #4]
 80139ac:	2201      	movs	r2, #1
 80139ae:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 80139b2:	687b      	ldr	r3, [r7, #4]
 80139b4:	681b      	ldr	r3, [r3, #0]
 80139b6:	68f9      	ldr	r1, [r7, #12]
 80139b8:	4618      	mov	r0, r3
 80139ba:	f004 fa28 	bl	8017e0e <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 80139be:	687b      	ldr	r3, [r7, #4]
 80139c0:	2200      	movs	r2, #0
 80139c2:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  return HAL_OK;
 80139c6:	2300      	movs	r3, #0
}
 80139c8:	4618      	mov	r0, r3
 80139ca:	3710      	adds	r7, #16
 80139cc:	46bd      	mov	sp, r7
 80139ce:	bd80      	pop	{r7, pc}

080139d0 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80139d0:	b580      	push	{r7, lr}
 80139d2:	b086      	sub	sp, #24
 80139d4:	af00      	add	r7, sp, #0
 80139d6:	60f8      	str	r0, [r7, #12]
 80139d8:	607a      	str	r2, [r7, #4]
 80139da:	603b      	str	r3, [r7, #0]
 80139dc:	460b      	mov	r3, r1
 80139de:	72fb      	strb	r3, [r7, #11]
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80139e0:	7afb      	ldrb	r3, [r7, #11]
 80139e2:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80139e6:	4613      	mov	r3, r2
 80139e8:	00db      	lsls	r3, r3, #3
 80139ea:	1a9b      	subs	r3, r3, r2
 80139ec:	009b      	lsls	r3, r3, #2
 80139ee:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 80139f2:	68fa      	ldr	r2, [r7, #12]
 80139f4:	4413      	add	r3, r2
 80139f6:	3304      	adds	r3, #4
 80139f8:	617b      	str	r3, [r7, #20]
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 80139fa:	697b      	ldr	r3, [r7, #20]
 80139fc:	687a      	ldr	r2, [r7, #4]
 80139fe:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8013a00:	697b      	ldr	r3, [r7, #20]
 8013a02:	683a      	ldr	r2, [r7, #0]
 8013a04:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0U;
 8013a06:	697b      	ldr	r3, [r7, #20]
 8013a08:	2200      	movs	r2, #0
 8013a0a:	619a      	str	r2, [r3, #24]
  ep->is_in = 0U;
 8013a0c:	697b      	ldr	r3, [r7, #20]
 8013a0e:	2200      	movs	r2, #0
 8013a10:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & 0x7FU;
 8013a12:	7afb      	ldrb	r3, [r7, #11]
 8013a14:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013a18:	b2da      	uxtb	r2, r3
 8013a1a:	697b      	ldr	r3, [r7, #20]
 8013a1c:	701a      	strb	r2, [r3, #0]
  
  if (hpcd->Init.dma_enable == 1U)
 8013a1e:	68fb      	ldr	r3, [r7, #12]
 8013a20:	691b      	ldr	r3, [r3, #16]
 8013a22:	2b01      	cmp	r3, #1
 8013a24:	d102      	bne.n	8013a2c <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8013a26:	687a      	ldr	r2, [r7, #4]
 8013a28:	697b      	ldr	r3, [r7, #20]
 8013a2a:	611a      	str	r2, [r3, #16]
  }
  
  __HAL_LOCK(hpcd); 
 8013a2c:	68fb      	ldr	r3, [r7, #12]
 8013a2e:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013a32:	2b01      	cmp	r3, #1
 8013a34:	d101      	bne.n	8013a3a <HAL_PCD_EP_Receive+0x6a>
 8013a36:	2302      	movs	r3, #2
 8013a38:	e020      	b.n	8013a7c <HAL_PCD_EP_Receive+0xac>
 8013a3a:	68fb      	ldr	r3, [r7, #12]
 8013a3c:	2201      	movs	r2, #1
 8013a3e:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  
  if ((ep_addr & 0x7FU) == 0U)
 8013a42:	7afb      	ldrb	r3, [r7, #11]
 8013a44:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013a48:	2b00      	cmp	r3, #0
 8013a4a:	d109      	bne.n	8013a60 <HAL_PCD_EP_Receive+0x90>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8013a4c:	68fb      	ldr	r3, [r7, #12]
 8013a4e:	6818      	ldr	r0, [r3, #0]
 8013a50:	68fb      	ldr	r3, [r7, #12]
 8013a52:	691b      	ldr	r3, [r3, #16]
 8013a54:	b2db      	uxtb	r3, r3
 8013a56:	461a      	mov	r2, r3
 8013a58:	6979      	ldr	r1, [r7, #20]
 8013a5a:	f004 fc7b 	bl	8018354 <USB_EP0StartXfer>
 8013a5e:	e008      	b.n	8013a72 <HAL_PCD_EP_Receive+0xa2>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8013a60:	68fb      	ldr	r3, [r7, #12]
 8013a62:	6818      	ldr	r0, [r3, #0]
 8013a64:	68fb      	ldr	r3, [r7, #12]
 8013a66:	691b      	ldr	r3, [r3, #16]
 8013a68:	b2db      	uxtb	r3, r3
 8013a6a:	461a      	mov	r2, r3
 8013a6c:	6979      	ldr	r1, [r7, #20]
 8013a6e:	f004 fa43 	bl	8017ef8 <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd); 
 8013a72:	68fb      	ldr	r3, [r7, #12]
 8013a74:	2200      	movs	r2, #0
 8013a76:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  
  return HAL_OK;
 8013a7a:	2300      	movs	r3, #0
}
 8013a7c:	4618      	mov	r0, r3
 8013a7e:	3718      	adds	r7, #24
 8013a80:	46bd      	mov	sp, r7
 8013a82:	bd80      	pop	{r7, pc}

08013a84 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8013a84:	b480      	push	{r7}
 8013a86:	b083      	sub	sp, #12
 8013a88:	af00      	add	r7, sp, #0
 8013a8a:	6078      	str	r0, [r7, #4]
 8013a8c:	460b      	mov	r3, r1
 8013a8e:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & 0x7FU].xfer_count;
 8013a90:	78fb      	ldrb	r3, [r7, #3]
 8013a92:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013a96:	6879      	ldr	r1, [r7, #4]
 8013a98:	4613      	mov	r3, r2
 8013a9a:	00db      	lsls	r3, r3, #3
 8013a9c:	1a9b      	subs	r3, r3, r2
 8013a9e:	009b      	lsls	r3, r3, #2
 8013aa0:	440b      	add	r3, r1
 8013aa2:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8013aa6:	681b      	ldr	r3, [r3, #0]
 8013aa8:	b29b      	uxth	r3, r3
}
 8013aaa:	4618      	mov	r0, r3
 8013aac:	370c      	adds	r7, #12
 8013aae:	46bd      	mov	sp, r7
 8013ab0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ab4:	4770      	bx	lr

08013ab6 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8013ab6:	b580      	push	{r7, lr}
 8013ab8:	b086      	sub	sp, #24
 8013aba:	af00      	add	r7, sp, #0
 8013abc:	60f8      	str	r0, [r7, #12]
 8013abe:	607a      	str	r2, [r7, #4]
 8013ac0:	603b      	str	r3, [r7, #0]
 8013ac2:	460b      	mov	r3, r1
 8013ac4:	72fb      	strb	r3, [r7, #11]
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8013ac6:	7afb      	ldrb	r3, [r7, #11]
 8013ac8:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013acc:	4613      	mov	r3, r2
 8013ace:	00db      	lsls	r3, r3, #3
 8013ad0:	1a9b      	subs	r3, r3, r2
 8013ad2:	009b      	lsls	r3, r3, #2
 8013ad4:	3338      	adds	r3, #56	; 0x38
 8013ad6:	68fa      	ldr	r2, [r7, #12]
 8013ad8:	4413      	add	r3, r2
 8013ada:	617b      	str	r3, [r7, #20]
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8013adc:	697b      	ldr	r3, [r7, #20]
 8013ade:	687a      	ldr	r2, [r7, #4]
 8013ae0:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8013ae2:	697b      	ldr	r3, [r7, #20]
 8013ae4:	683a      	ldr	r2, [r7, #0]
 8013ae6:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0U;
 8013ae8:	697b      	ldr	r3, [r7, #20]
 8013aea:	2200      	movs	r2, #0
 8013aec:	619a      	str	r2, [r3, #24]
  ep->is_in = 1U;
 8013aee:	697b      	ldr	r3, [r7, #20]
 8013af0:	2201      	movs	r2, #1
 8013af2:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & 0x7FU;
 8013af4:	7afb      	ldrb	r3, [r7, #11]
 8013af6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013afa:	b2da      	uxtb	r2, r3
 8013afc:	697b      	ldr	r3, [r7, #20]
 8013afe:	701a      	strb	r2, [r3, #0]
  
  if (hpcd->Init.dma_enable == 1U)
 8013b00:	68fb      	ldr	r3, [r7, #12]
 8013b02:	691b      	ldr	r3, [r3, #16]
 8013b04:	2b01      	cmp	r3, #1
 8013b06:	d102      	bne.n	8013b0e <HAL_PCD_EP_Transmit+0x58>
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8013b08:	687a      	ldr	r2, [r7, #4]
 8013b0a:	697b      	ldr	r3, [r7, #20]
 8013b0c:	611a      	str	r2, [r3, #16]
  }
  
  __HAL_LOCK(hpcd); 
 8013b0e:	68fb      	ldr	r3, [r7, #12]
 8013b10:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013b14:	2b01      	cmp	r3, #1
 8013b16:	d101      	bne.n	8013b1c <HAL_PCD_EP_Transmit+0x66>
 8013b18:	2302      	movs	r3, #2
 8013b1a:	e020      	b.n	8013b5e <HAL_PCD_EP_Transmit+0xa8>
 8013b1c:	68fb      	ldr	r3, [r7, #12]
 8013b1e:	2201      	movs	r2, #1
 8013b20:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  
  if ((ep_addr & 0x7FU) == 0U)
 8013b24:	7afb      	ldrb	r3, [r7, #11]
 8013b26:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013b2a:	2b00      	cmp	r3, #0
 8013b2c:	d109      	bne.n	8013b42 <HAL_PCD_EP_Transmit+0x8c>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8013b2e:	68fb      	ldr	r3, [r7, #12]
 8013b30:	6818      	ldr	r0, [r3, #0]
 8013b32:	68fb      	ldr	r3, [r7, #12]
 8013b34:	691b      	ldr	r3, [r3, #16]
 8013b36:	b2db      	uxtb	r3, r3
 8013b38:	461a      	mov	r2, r3
 8013b3a:	6979      	ldr	r1, [r7, #20]
 8013b3c:	f004 fc0a 	bl	8018354 <USB_EP0StartXfer>
 8013b40:	e008      	b.n	8013b54 <HAL_PCD_EP_Transmit+0x9e>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8013b42:	68fb      	ldr	r3, [r7, #12]
 8013b44:	6818      	ldr	r0, [r3, #0]
 8013b46:	68fb      	ldr	r3, [r7, #12]
 8013b48:	691b      	ldr	r3, [r3, #16]
 8013b4a:	b2db      	uxtb	r3, r3
 8013b4c:	461a      	mov	r2, r3
 8013b4e:	6979      	ldr	r1, [r7, #20]
 8013b50:	f004 f9d2 	bl	8017ef8 <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 8013b54:	68fb      	ldr	r3, [r7, #12]
 8013b56:	2200      	movs	r2, #0
 8013b58:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
     
  return HAL_OK;
 8013b5c:	2300      	movs	r3, #0
}
 8013b5e:	4618      	mov	r0, r3
 8013b60:	3718      	adds	r7, #24
 8013b62:	46bd      	mov	sp, r7
 8013b64:	bd80      	pop	{r7, pc}

08013b66 <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8013b66:	b580      	push	{r7, lr}
 8013b68:	b084      	sub	sp, #16
 8013b6a:	af00      	add	r7, sp, #0
 8013b6c:	6078      	str	r0, [r7, #4]
 8013b6e:	460b      	mov	r3, r1
 8013b70:	70fb      	strb	r3, [r7, #3]
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8013b72:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013b76:	2b00      	cmp	r3, #0
 8013b78:	da0b      	bge.n	8013b92 <HAL_PCD_EP_SetStall+0x2c>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8013b7a:	78fb      	ldrb	r3, [r7, #3]
 8013b7c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013b80:	4613      	mov	r3, r2
 8013b82:	00db      	lsls	r3, r3, #3
 8013b84:	1a9b      	subs	r3, r3, r2
 8013b86:	009b      	lsls	r3, r3, #2
 8013b88:	3338      	adds	r3, #56	; 0x38
 8013b8a:	687a      	ldr	r2, [r7, #4]
 8013b8c:	4413      	add	r3, r2
 8013b8e:	60fb      	str	r3, [r7, #12]
 8013b90:	e00a      	b.n	8013ba8 <HAL_PCD_EP_SetStall+0x42>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8013b92:	78fa      	ldrb	r2, [r7, #3]
 8013b94:	4613      	mov	r3, r2
 8013b96:	00db      	lsls	r3, r3, #3
 8013b98:	1a9b      	subs	r3, r3, r2
 8013b9a:	009b      	lsls	r3, r3, #2
 8013b9c:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 8013ba0:	687a      	ldr	r2, [r7, #4]
 8013ba2:	4413      	add	r3, r2
 8013ba4:	3304      	adds	r3, #4
 8013ba6:	60fb      	str	r3, [r7, #12]
  }
  
  ep->is_stall = 1U;
 8013ba8:	68fb      	ldr	r3, [r7, #12]
 8013baa:	2201      	movs	r2, #1
 8013bac:	709a      	strb	r2, [r3, #2]
  ep->num   = ep_addr & 0x7FU;
 8013bae:	78fb      	ldrb	r3, [r7, #3]
 8013bb0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013bb4:	b2da      	uxtb	r2, r3
 8013bb6:	68fb      	ldr	r3, [r7, #12]
 8013bb8:	701a      	strb	r2, [r3, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8013bba:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013bbe:	b2db      	uxtb	r3, r3
 8013bc0:	09db      	lsrs	r3, r3, #7
 8013bc2:	b2db      	uxtb	r3, r3
 8013bc4:	461a      	mov	r2, r3
 8013bc6:	68fb      	ldr	r3, [r7, #12]
 8013bc8:	705a      	strb	r2, [r3, #1]
  
  
  __HAL_LOCK(hpcd); 
 8013bca:	687b      	ldr	r3, [r7, #4]
 8013bcc:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013bd0:	2b01      	cmp	r3, #1
 8013bd2:	d101      	bne.n	8013bd8 <HAL_PCD_EP_SetStall+0x72>
 8013bd4:	2302      	movs	r3, #2
 8013bd6:	e01e      	b.n	8013c16 <HAL_PCD_EP_SetStall+0xb0>
 8013bd8:	687b      	ldr	r3, [r7, #4]
 8013bda:	2201      	movs	r2, #1
 8013bdc:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_EPSetStall(hpcd->Instance , ep);
 8013be0:	687b      	ldr	r3, [r7, #4]
 8013be2:	681b      	ldr	r3, [r3, #0]
 8013be4:	68f9      	ldr	r1, [r7, #12]
 8013be6:	4618      	mov	r0, r3
 8013be8:	f004 fd60 	bl	80186ac <USB_EPSetStall>
  if((ep_addr & 0x7FU) == 0U)
 8013bec:	78fb      	ldrb	r3, [r7, #3]
 8013bee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013bf2:	2b00      	cmp	r3, #0
 8013bf4:	d10a      	bne.n	8013c0c <HAL_PCD_EP_SetStall+0xa6>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8013bf6:	687b      	ldr	r3, [r7, #4]
 8013bf8:	6818      	ldr	r0, [r3, #0]
 8013bfa:	687b      	ldr	r3, [r7, #4]
 8013bfc:	691b      	ldr	r3, [r3, #16]
 8013bfe:	b2d9      	uxtb	r1, r3
 8013c00:	687b      	ldr	r3, [r7, #4]
 8013c02:	f503 7361 	add.w	r3, r3, #900	; 0x384
 8013c06:	461a      	mov	r2, r3
 8013c08:	f004 ff42 	bl	8018a90 <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd); 
 8013c0c:	687b      	ldr	r3, [r7, #4]
 8013c0e:	2200      	movs	r2, #0
 8013c10:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  
  return HAL_OK;
 8013c14:	2300      	movs	r3, #0
}
 8013c16:	4618      	mov	r0, r3
 8013c18:	3710      	adds	r7, #16
 8013c1a:	46bd      	mov	sp, r7
 8013c1c:	bd80      	pop	{r7, pc}

08013c1e <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8013c1e:	b580      	push	{r7, lr}
 8013c20:	b084      	sub	sp, #16
 8013c22:	af00      	add	r7, sp, #0
 8013c24:	6078      	str	r0, [r7, #4]
 8013c26:	460b      	mov	r3, r1
 8013c28:	70fb      	strb	r3, [r7, #3]
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8013c2a:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013c2e:	2b00      	cmp	r3, #0
 8013c30:	da0b      	bge.n	8013c4a <HAL_PCD_EP_ClrStall+0x2c>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8013c32:	78fb      	ldrb	r3, [r7, #3]
 8013c34:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8013c38:	4613      	mov	r3, r2
 8013c3a:	00db      	lsls	r3, r3, #3
 8013c3c:	1a9b      	subs	r3, r3, r2
 8013c3e:	009b      	lsls	r3, r3, #2
 8013c40:	3338      	adds	r3, #56	; 0x38
 8013c42:	687a      	ldr	r2, [r7, #4]
 8013c44:	4413      	add	r3, r2
 8013c46:	60fb      	str	r3, [r7, #12]
 8013c48:	e00a      	b.n	8013c60 <HAL_PCD_EP_ClrStall+0x42>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8013c4a:	78fa      	ldrb	r2, [r7, #3]
 8013c4c:	4613      	mov	r3, r2
 8013c4e:	00db      	lsls	r3, r3, #3
 8013c50:	1a9b      	subs	r3, r3, r2
 8013c52:	009b      	lsls	r3, r3, #2
 8013c54:	f503 73ec 	add.w	r3, r3, #472	; 0x1d8
 8013c58:	687a      	ldr	r2, [r7, #4]
 8013c5a:	4413      	add	r3, r2
 8013c5c:	3304      	adds	r3, #4
 8013c5e:	60fb      	str	r3, [r7, #12]
  }
  
  ep->is_stall = 0U;
 8013c60:	68fb      	ldr	r3, [r7, #12]
 8013c62:	2200      	movs	r2, #0
 8013c64:	709a      	strb	r2, [r3, #2]
  ep->num   = ep_addr & 0x7FU;
 8013c66:	78fb      	ldrb	r3, [r7, #3]
 8013c68:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013c6c:	b2da      	uxtb	r2, r3
 8013c6e:	68fb      	ldr	r3, [r7, #12]
 8013c70:	701a      	strb	r2, [r3, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8013c72:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013c76:	b2db      	uxtb	r3, r3
 8013c78:	09db      	lsrs	r3, r3, #7
 8013c7a:	b2db      	uxtb	r3, r3
 8013c7c:	461a      	mov	r2, r3
 8013c7e:	68fb      	ldr	r3, [r7, #12]
 8013c80:	705a      	strb	r2, [r3, #1]
  
  __HAL_LOCK(hpcd); 
 8013c82:	687b      	ldr	r3, [r7, #4]
 8013c84:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013c88:	2b01      	cmp	r3, #1
 8013c8a:	d101      	bne.n	8013c90 <HAL_PCD_EP_ClrStall+0x72>
 8013c8c:	2302      	movs	r3, #2
 8013c8e:	e00e      	b.n	8013cae <HAL_PCD_EP_ClrStall+0x90>
 8013c90:	687b      	ldr	r3, [r7, #4]
 8013c92:	2201      	movs	r2, #1
 8013c94:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  USB_EPClearStall(hpcd->Instance , ep);
 8013c98:	687b      	ldr	r3, [r7, #4]
 8013c9a:	681b      	ldr	r3, [r3, #0]
 8013c9c:	68f9      	ldr	r1, [r7, #12]
 8013c9e:	4618      	mov	r0, r3
 8013ca0:	f004 fd71 	bl	8018786 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8013ca4:	687b      	ldr	r3, [r7, #4]
 8013ca6:	2200      	movs	r2, #0
 8013ca8:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
    
  return HAL_OK;
 8013cac:	2300      	movs	r3, #0
}
 8013cae:	4618      	mov	r0, r3
 8013cb0:	3710      	adds	r7, #16
 8013cb2:	46bd      	mov	sp, r7
 8013cb4:	bd80      	pop	{r7, pc}

08013cb6 <HAL_PCD_EP_Flush>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8013cb6:	b580      	push	{r7, lr}
 8013cb8:	b082      	sub	sp, #8
 8013cba:	af00      	add	r7, sp, #0
 8013cbc:	6078      	str	r0, [r7, #4]
 8013cbe:	460b      	mov	r3, r1
 8013cc0:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd); 
 8013cc2:	687b      	ldr	r3, [r7, #4]
 8013cc4:	f893 3380 	ldrb.w	r3, [r3, #896]	; 0x380
 8013cc8:	2b01      	cmp	r3, #1
 8013cca:	d101      	bne.n	8013cd0 <HAL_PCD_EP_Flush+0x1a>
 8013ccc:	2302      	movs	r3, #2
 8013cce:	e01b      	b.n	8013d08 <HAL_PCD_EP_Flush+0x52>
 8013cd0:	687b      	ldr	r3, [r7, #4]
 8013cd2:	2201      	movs	r2, #1
 8013cd4:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
  
  if ((ep_addr & 0x80U) == 0x80U)
 8013cd8:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8013cdc:	2b00      	cmp	r3, #0
 8013cde:	da09      	bge.n	8013cf4 <HAL_PCD_EP_Flush+0x3e>
  {
    USB_FlushTxFifo(hpcd->Instance, ep_addr & 0x7FU);
 8013ce0:	687b      	ldr	r3, [r7, #4]
 8013ce2:	681a      	ldr	r2, [r3, #0]
 8013ce4:	78fb      	ldrb	r3, [r7, #3]
 8013ce6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013cea:	4619      	mov	r1, r3
 8013cec:	4610      	mov	r0, r2
 8013cee:	f003 ff75 	bl	8017bdc <USB_FlushTxFifo>
 8013cf2:	e004      	b.n	8013cfe <HAL_PCD_EP_Flush+0x48>
  }
  else
  {
    USB_FlushRxFifo(hpcd->Instance);
 8013cf4:	687b      	ldr	r3, [r7, #4]
 8013cf6:	681b      	ldr	r3, [r3, #0]
 8013cf8:	4618      	mov	r0, r3
 8013cfa:	f003 ff95 	bl	8017c28 <USB_FlushRxFifo>
  }
  
  __HAL_UNLOCK(hpcd); 
 8013cfe:	687b      	ldr	r3, [r7, #4]
 8013d00:	2200      	movs	r2, #0
 8013d02:	f883 2380 	strb.w	r2, [r3, #896]	; 0x380
    
  return HAL_OK;
 8013d06:	2300      	movs	r3, #0
}
 8013d08:	4618      	mov	r0, r3
 8013d0a:	3708      	adds	r7, #8
 8013d0c:	46bd      	mov	sp, r7
 8013d0e:	bd80      	pop	{r7, pc}

08013d10 <PCD_WriteEmptyTxFifo>:
  * @param  hpcd: PCD handle
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8013d10:	b580      	push	{r7, lr}
 8013d12:	b08a      	sub	sp, #40	; 0x28
 8013d14:	af02      	add	r7, sp, #8
 8013d16:	6078      	str	r0, [r7, #4]
 8013d18:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 8013d1a:	687b      	ldr	r3, [r7, #4]
 8013d1c:	681b      	ldr	r3, [r3, #0]
 8013d1e:	617b      	str	r3, [r7, #20]
  USB_OTG_EPTypeDef *ep;
  int32_t len = 0U;
 8013d20:	2300      	movs	r3, #0
 8013d22:	61fb      	str	r3, [r7, #28]
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;
 8013d24:	2300      	movs	r3, #0
 8013d26:	613b      	str	r3, [r7, #16]

  ep = &hpcd->IN_ep[epnum];
 8013d28:	683a      	ldr	r2, [r7, #0]
 8013d2a:	4613      	mov	r3, r2
 8013d2c:	00db      	lsls	r3, r3, #3
 8013d2e:	1a9b      	subs	r3, r3, r2
 8013d30:	009b      	lsls	r3, r3, #2
 8013d32:	3338      	adds	r3, #56	; 0x38
 8013d34:	687a      	ldr	r2, [r7, #4]
 8013d36:	4413      	add	r3, r2
 8013d38:	60fb      	str	r3, [r7, #12]
  len = ep->xfer_len - ep->xfer_count;
 8013d3a:	68fb      	ldr	r3, [r7, #12]
 8013d3c:	695a      	ldr	r2, [r3, #20]
 8013d3e:	68fb      	ldr	r3, [r7, #12]
 8013d40:	699b      	ldr	r3, [r3, #24]
 8013d42:	1ad3      	subs	r3, r2, r3
 8013d44:	61fb      	str	r3, [r7, #28]
  
  if (len > ep->maxpacket)
 8013d46:	68fb      	ldr	r3, [r7, #12]
 8013d48:	689a      	ldr	r2, [r3, #8]
 8013d4a:	69fb      	ldr	r3, [r7, #28]
 8013d4c:	429a      	cmp	r2, r3
 8013d4e:	d202      	bcs.n	8013d56 <PCD_WriteEmptyTxFifo+0x46>
  {
    len = ep->maxpacket;
 8013d50:	68fb      	ldr	r3, [r7, #12]
 8013d52:	689b      	ldr	r3, [r3, #8]
 8013d54:	61fb      	str	r3, [r7, #28]
  }
  
  
  len32b = (len + 3U) / 4U;
 8013d56:	69fb      	ldr	r3, [r7, #28]
 8013d58:	3303      	adds	r3, #3
 8013d5a:	089b      	lsrs	r3, r3, #2
 8013d5c:	61bb      	str	r3, [r7, #24]
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8013d5e:	e02b      	b.n	8013db8 <PCD_WriteEmptyTxFifo+0xa8>
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 8013d60:	68fb      	ldr	r3, [r7, #12]
 8013d62:	695a      	ldr	r2, [r3, #20]
 8013d64:	68fb      	ldr	r3, [r7, #12]
 8013d66:	699b      	ldr	r3, [r3, #24]
 8013d68:	1ad3      	subs	r3, r2, r3
 8013d6a:	61fb      	str	r3, [r7, #28]
    
    if (len > ep->maxpacket)
 8013d6c:	68fb      	ldr	r3, [r7, #12]
 8013d6e:	689a      	ldr	r2, [r3, #8]
 8013d70:	69fb      	ldr	r3, [r7, #28]
 8013d72:	429a      	cmp	r2, r3
 8013d74:	d202      	bcs.n	8013d7c <PCD_WriteEmptyTxFifo+0x6c>
    {
      len = ep->maxpacket;
 8013d76:	68fb      	ldr	r3, [r7, #12]
 8013d78:	689b      	ldr	r3, [r3, #8]
 8013d7a:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 8013d7c:	69fb      	ldr	r3, [r7, #28]
 8013d7e:	3303      	adds	r3, #3
 8013d80:	089b      	lsrs	r3, r3, #2
 8013d82:	61bb      	str	r3, [r7, #24]
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 8013d84:	68fb      	ldr	r3, [r7, #12]
 8013d86:	68d9      	ldr	r1, [r3, #12]
 8013d88:	683b      	ldr	r3, [r7, #0]
 8013d8a:	b2da      	uxtb	r2, r3
 8013d8c:	69fb      	ldr	r3, [r7, #28]
 8013d8e:	b298      	uxth	r0, r3
 8013d90:	687b      	ldr	r3, [r7, #4]
 8013d92:	691b      	ldr	r3, [r3, #16]
 8013d94:	b2db      	uxtb	r3, r3
 8013d96:	9300      	str	r3, [sp, #0]
 8013d98:	4603      	mov	r3, r0
 8013d9a:	6978      	ldr	r0, [r7, #20]
 8013d9c:	f004 fc2a 	bl	80185f4 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8013da0:	68fb      	ldr	r3, [r7, #12]
 8013da2:	68da      	ldr	r2, [r3, #12]
 8013da4:	69fb      	ldr	r3, [r7, #28]
 8013da6:	441a      	add	r2, r3
 8013da8:	68fb      	ldr	r3, [r7, #12]
 8013daa:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 8013dac:	68fb      	ldr	r3, [r7, #12]
 8013dae:	699a      	ldr	r2, [r3, #24]
 8013db0:	69fb      	ldr	r3, [r7, #28]
 8013db2:	441a      	add	r2, r3
 8013db4:	68fb      	ldr	r3, [r7, #12]
 8013db6:	619a      	str	r2, [r3, #24]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8013db8:	683b      	ldr	r3, [r7, #0]
 8013dba:	015a      	lsls	r2, r3, #5
 8013dbc:	697b      	ldr	r3, [r7, #20]
 8013dbe:	4413      	add	r3, r2
 8013dc0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8013dc4:	699b      	ldr	r3, [r3, #24]
 8013dc6:	b29b      	uxth	r3, r3
 8013dc8:	69ba      	ldr	r2, [r7, #24]
 8013dca:	429a      	cmp	r2, r3
 8013dcc:	d209      	bcs.n	8013de2 <PCD_WriteEmptyTxFifo+0xd2>
          ep->xfer_count < ep->xfer_len &&
 8013dce:	68fb      	ldr	r3, [r7, #12]
 8013dd0:	699a      	ldr	r2, [r3, #24]
 8013dd2:	68fb      	ldr	r3, [r7, #12]
 8013dd4:	695b      	ldr	r3, [r3, #20]
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8013dd6:	429a      	cmp	r2, r3
 8013dd8:	d203      	bcs.n	8013de2 <PCD_WriteEmptyTxFifo+0xd2>
            ep->xfer_len != 0U)
 8013dda:	68fb      	ldr	r3, [r7, #12]
 8013ddc:	695b      	ldr	r3, [r3, #20]
          ep->xfer_count < ep->xfer_len &&
 8013dde:	2b00      	cmp	r3, #0
 8013de0:	d1be      	bne.n	8013d60 <PCD_WriteEmptyTxFifo+0x50>
  }
  
  if(len <= 0U)
 8013de2:	69fb      	ldr	r3, [r7, #28]
 8013de4:	2b00      	cmp	r3, #0
 8013de6:	d10f      	bne.n	8013e08 <PCD_WriteEmptyTxFifo+0xf8>
  {
    fifoemptymsk = 0x1U << epnum;
 8013de8:	2201      	movs	r2, #1
 8013dea:	683b      	ldr	r3, [r7, #0]
 8013dec:	fa02 f303 	lsl.w	r3, r2, r3
 8013df0:	613b      	str	r3, [r7, #16]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8013df2:	697b      	ldr	r3, [r7, #20]
 8013df4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8013df8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8013dfa:	693b      	ldr	r3, [r7, #16]
 8013dfc:	43db      	mvns	r3, r3
 8013dfe:	6979      	ldr	r1, [r7, #20]
 8013e00:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8013e04:	4013      	ands	r3, r2
 8013e06:	634b      	str	r3, [r1, #52]	; 0x34
    
  }
  
  return HAL_OK;  
 8013e08:	2300      	movs	r3, #0
}
 8013e0a:	4618      	mov	r0, r3
 8013e0c:	3720      	adds	r7, #32
 8013e0e:	46bd      	mov	sp, r7
 8013e10:	bd80      	pop	{r7, pc}

08013e12 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8013e12:	b480      	push	{r7}
 8013e14:	b085      	sub	sp, #20
 8013e16:	af00      	add	r7, sp, #0
 8013e18:	6078      	str	r0, [r7, #4]
 8013e1a:	460b      	mov	r3, r1
 8013e1c:	70fb      	strb	r3, [r7, #3]
 8013e1e:	4613      	mov	r3, r2
 8013e20:	803b      	strh	r3, [r7, #0]
  uint8_t i = 0U;
 8013e22:	2300      	movs	r3, #0
 8013e24:	73fb      	strb	r3, [r7, #15]
  uint32_t Tx_Offset = 0U;
 8013e26:	2300      	movs	r3, #0
 8013e28:	60bb      	str	r3, [r7, #8]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8013e2a:	687b      	ldr	r3, [r7, #4]
 8013e2c:	681b      	ldr	r3, [r3, #0]
 8013e2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013e30:	60bb      	str	r3, [r7, #8]
  
  if(fifo == 0U)
 8013e32:	78fb      	ldrb	r3, [r7, #3]
 8013e34:	2b00      	cmp	r3, #0
 8013e36:	d107      	bne.n	8013e48 <HAL_PCDEx_SetTxFiFo+0x36>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 8013e38:	883b      	ldrh	r3, [r7, #0]
 8013e3a:	0419      	lsls	r1, r3, #16
 8013e3c:	687b      	ldr	r3, [r7, #4]
 8013e3e:	681b      	ldr	r3, [r3, #0]
 8013e40:	68ba      	ldr	r2, [r7, #8]
 8013e42:	430a      	orrs	r2, r1
 8013e44:	629a      	str	r2, [r3, #40]	; 0x28
 8013e46:	e028      	b.n	8013e9a <HAL_PCDEx_SetTxFiFo+0x88>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8013e48:	687b      	ldr	r3, [r7, #4]
 8013e4a:	681b      	ldr	r3, [r3, #0]
 8013e4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e4e:	0c1b      	lsrs	r3, r3, #16
 8013e50:	68ba      	ldr	r2, [r7, #8]
 8013e52:	4413      	add	r3, r2
 8013e54:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8013e56:	2300      	movs	r3, #0
 8013e58:	73fb      	strb	r3, [r7, #15]
 8013e5a:	e00d      	b.n	8013e78 <HAL_PCDEx_SetTxFiFo+0x66>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 8013e5c:	687b      	ldr	r3, [r7, #4]
 8013e5e:	681a      	ldr	r2, [r3, #0]
 8013e60:	7bfb      	ldrb	r3, [r7, #15]
 8013e62:	3340      	adds	r3, #64	; 0x40
 8013e64:	009b      	lsls	r3, r3, #2
 8013e66:	4413      	add	r3, r2
 8013e68:	685b      	ldr	r3, [r3, #4]
 8013e6a:	0c1b      	lsrs	r3, r3, #16
 8013e6c:	68ba      	ldr	r2, [r7, #8]
 8013e6e:	4413      	add	r3, r2
 8013e70:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8013e72:	7bfb      	ldrb	r3, [r7, #15]
 8013e74:	3301      	adds	r3, #1
 8013e76:	73fb      	strb	r3, [r7, #15]
 8013e78:	7bfa      	ldrb	r2, [r7, #15]
 8013e7a:	78fb      	ldrb	r3, [r7, #3]
 8013e7c:	3b01      	subs	r3, #1
 8013e7e:	429a      	cmp	r2, r3
 8013e80:	d3ec      	bcc.n	8013e5c <HAL_PCDEx_SetTxFiFo+0x4a>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 8013e82:	883b      	ldrh	r3, [r7, #0]
 8013e84:	0418      	lsls	r0, r3, #16
 8013e86:	687b      	ldr	r3, [r7, #4]
 8013e88:	6819      	ldr	r1, [r3, #0]
 8013e8a:	78fb      	ldrb	r3, [r7, #3]
 8013e8c:	3b01      	subs	r3, #1
 8013e8e:	68ba      	ldr	r2, [r7, #8]
 8013e90:	4302      	orrs	r2, r0
 8013e92:	3340      	adds	r3, #64	; 0x40
 8013e94:	009b      	lsls	r3, r3, #2
 8013e96:	440b      	add	r3, r1
 8013e98:	605a      	str	r2, [r3, #4]
  }
  
  return HAL_OK;
 8013e9a:	2300      	movs	r3, #0
}
 8013e9c:	4618      	mov	r0, r3
 8013e9e:	3714      	adds	r7, #20
 8013ea0:	46bd      	mov	sp, r7
 8013ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ea6:	4770      	bx	lr

08013ea8 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd: PCD handle
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 8013ea8:	b480      	push	{r7}
 8013eaa:	b083      	sub	sp, #12
 8013eac:	af00      	add	r7, sp, #0
 8013eae:	6078      	str	r0, [r7, #4]
 8013eb0:	460b      	mov	r3, r1
 8013eb2:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 8013eb4:	687b      	ldr	r3, [r7, #4]
 8013eb6:	681b      	ldr	r3, [r3, #0]
 8013eb8:	887a      	ldrh	r2, [r7, #2]
 8013eba:	625a      	str	r2, [r3, #36]	; 0x24
  
  return HAL_OK;
 8013ebc:	2300      	movs	r3, #0
}
 8013ebe:	4618      	mov	r0, r3
 8013ec0:	370c      	adds	r7, #12
 8013ec2:	46bd      	mov	sp, r7
 8013ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013ec8:	4770      	bx	lr
	...

08013ecc <HAL_RCC_OscConfig>:
  *         first and then HSE On or HSE Bypass.
  
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8013ecc:	b580      	push	{r7, lr}
 8013ece:	b08e      	sub	sp, #56	; 0x38
 8013ed0:	af00      	add	r7, sp, #0
 8013ed2:	6078      	str	r0, [r7, #4]
 uint32_t tickstart = 0U;  
 8013ed4:	2300      	movs	r3, #0
 8013ed6:	637b      	str	r3, [r7, #52]	; 0x34
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8013ed8:	687b      	ldr	r3, [r7, #4]
 8013eda:	681b      	ldr	r3, [r3, #0]
 8013edc:	f003 0301 	and.w	r3, r3, #1
 8013ee0:	2b00      	cmp	r3, #0
 8013ee2:	d050      	beq.n	8013f86 <HAL_RCC_OscConfig+0xba>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8013ee4:	4ba5      	ldr	r3, [pc, #660]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013ee6:	689b      	ldr	r3, [r3, #8]
 8013ee8:	f003 030c 	and.w	r3, r3, #12
 8013eec:	2b04      	cmp	r3, #4
 8013eee:	d00c      	beq.n	8013f0a <HAL_RCC_OscConfig+0x3e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8013ef0:	4ba2      	ldr	r3, [pc, #648]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013ef2:	689b      	ldr	r3, [r3, #8]
 8013ef4:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8013ef8:	2b08      	cmp	r3, #8
 8013efa:	d112      	bne.n	8013f22 <HAL_RCC_OscConfig+0x56>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8013efc:	4b9f      	ldr	r3, [pc, #636]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013efe:	685b      	ldr	r3, [r3, #4]
 8013f00:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8013f04:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8013f08:	d10b      	bne.n	8013f22 <HAL_RCC_OscConfig+0x56>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8013f0a:	4b9c      	ldr	r3, [pc, #624]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013f0c:	681b      	ldr	r3, [r3, #0]
 8013f0e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8013f12:	2b00      	cmp	r3, #0
 8013f14:	d036      	beq.n	8013f84 <HAL_RCC_OscConfig+0xb8>
 8013f16:	687b      	ldr	r3, [r7, #4]
 8013f18:	685b      	ldr	r3, [r3, #4]
 8013f1a:	2b00      	cmp	r3, #0
 8013f1c:	d132      	bne.n	8013f84 <HAL_RCC_OscConfig+0xb8>
      {
        return HAL_ERROR;
 8013f1e:	2301      	movs	r3, #1
 8013f20:	e1e0      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8013f22:	687b      	ldr	r3, [r7, #4]
 8013f24:	685a      	ldr	r2, [r3, #4]
 8013f26:	4b96      	ldr	r3, [pc, #600]	; (8014180 <HAL_RCC_OscConfig+0x2b4>)
 8013f28:	b2d2      	uxtb	r2, r2
 8013f2a:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8013f2c:	687b      	ldr	r3, [r7, #4]
 8013f2e:	685b      	ldr	r3, [r3, #4]
 8013f30:	2b00      	cmp	r3, #0
 8013f32:	d013      	beq.n	8013f5c <HAL_RCC_OscConfig+0x90>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8013f34:	f7fd faf8 	bl	8011528 <HAL_GetTick>
 8013f38:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8013f3a:	e008      	b.n	8013f4e <HAL_RCC_OscConfig+0x82>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8013f3c:	f7fd faf4 	bl	8011528 <HAL_GetTick>
 8013f40:	4602      	mov	r2, r0
 8013f42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f44:	1ad3      	subs	r3, r2, r3
 8013f46:	2b64      	cmp	r3, #100	; 0x64
 8013f48:	d901      	bls.n	8013f4e <HAL_RCC_OscConfig+0x82>
          {
            return HAL_TIMEOUT;
 8013f4a:	2303      	movs	r3, #3
 8013f4c:	e1ca      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8013f4e:	4b8b      	ldr	r3, [pc, #556]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013f50:	681b      	ldr	r3, [r3, #0]
 8013f52:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8013f56:	2b00      	cmp	r3, #0
 8013f58:	d0f0      	beq.n	8013f3c <HAL_RCC_OscConfig+0x70>
 8013f5a:	e014      	b.n	8013f86 <HAL_RCC_OscConfig+0xba>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8013f5c:	f7fd fae4 	bl	8011528 <HAL_GetTick>
 8013f60:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8013f62:	e008      	b.n	8013f76 <HAL_RCC_OscConfig+0xaa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8013f64:	f7fd fae0 	bl	8011528 <HAL_GetTick>
 8013f68:	4602      	mov	r2, r0
 8013f6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013f6c:	1ad3      	subs	r3, r2, r3
 8013f6e:	2b64      	cmp	r3, #100	; 0x64
 8013f70:	d901      	bls.n	8013f76 <HAL_RCC_OscConfig+0xaa>
          {
            return HAL_TIMEOUT;
 8013f72:	2303      	movs	r3, #3
 8013f74:	e1b6      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8013f76:	4b81      	ldr	r3, [pc, #516]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013f78:	681b      	ldr	r3, [r3, #0]
 8013f7a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8013f7e:	2b00      	cmp	r3, #0
 8013f80:	d1f0      	bne.n	8013f64 <HAL_RCC_OscConfig+0x98>
 8013f82:	e000      	b.n	8013f86 <HAL_RCC_OscConfig+0xba>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8013f84:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8013f86:	687b      	ldr	r3, [r7, #4]
 8013f88:	681b      	ldr	r3, [r3, #0]
 8013f8a:	f003 0302 	and.w	r3, r3, #2
 8013f8e:	2b00      	cmp	r3, #0
 8013f90:	d077      	beq.n	8014082 <HAL_RCC_OscConfig+0x1b6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8013f92:	4b7a      	ldr	r3, [pc, #488]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013f94:	689b      	ldr	r3, [r3, #8]
 8013f96:	f003 030c 	and.w	r3, r3, #12
 8013f9a:	2b00      	cmp	r3, #0
 8013f9c:	d00b      	beq.n	8013fb6 <HAL_RCC_OscConfig+0xea>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8013f9e:	4b77      	ldr	r3, [pc, #476]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013fa0:	689b      	ldr	r3, [r3, #8]
 8013fa2:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8013fa6:	2b08      	cmp	r3, #8
 8013fa8:	d126      	bne.n	8013ff8 <HAL_RCC_OscConfig+0x12c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8013faa:	4b74      	ldr	r3, [pc, #464]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013fac:	685b      	ldr	r3, [r3, #4]
 8013fae:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8013fb2:	2b00      	cmp	r3, #0
 8013fb4:	d120      	bne.n	8013ff8 <HAL_RCC_OscConfig+0x12c>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8013fb6:	4b71      	ldr	r3, [pc, #452]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013fb8:	681b      	ldr	r3, [r3, #0]
 8013fba:	f003 0302 	and.w	r3, r3, #2
 8013fbe:	2b00      	cmp	r3, #0
 8013fc0:	d005      	beq.n	8013fce <HAL_RCC_OscConfig+0x102>
 8013fc2:	687b      	ldr	r3, [r7, #4]
 8013fc4:	68db      	ldr	r3, [r3, #12]
 8013fc6:	2b01      	cmp	r3, #1
 8013fc8:	d001      	beq.n	8013fce <HAL_RCC_OscConfig+0x102>
      {
        return HAL_ERROR;
 8013fca:	2301      	movs	r3, #1
 8013fcc:	e18a      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8013fce:	4b6b      	ldr	r3, [pc, #428]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013fd0:	681b      	ldr	r3, [r3, #0]
 8013fd2:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8013fd6:	687b      	ldr	r3, [r7, #4]
 8013fd8:	6919      	ldr	r1, [r3, #16]
 8013fda:	23f8      	movs	r3, #248	; 0xf8
 8013fdc:	633b      	str	r3, [r7, #48]	; 0x30
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8013fde:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8013fe0:	fa93 f3a3 	rbit	r3, r3
 8013fe4:	62fb      	str	r3, [r7, #44]	; 0x2c
  return(result);
 8013fe6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013fe8:	fab3 f383 	clz	r3, r3
 8013fec:	fa01 f303 	lsl.w	r3, r1, r3
 8013ff0:	4962      	ldr	r1, [pc, #392]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8013ff2:	4313      	orrs	r3, r2
 8013ff4:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8013ff6:	e044      	b.n	8014082 <HAL_RCC_OscConfig+0x1b6>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8013ff8:	687b      	ldr	r3, [r7, #4]
 8013ffa:	68db      	ldr	r3, [r3, #12]
 8013ffc:	2b00      	cmp	r3, #0
 8013ffe:	d02a      	beq.n	8014056 <HAL_RCC_OscConfig+0x18a>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8014000:	4b60      	ldr	r3, [pc, #384]	; (8014184 <HAL_RCC_OscConfig+0x2b8>)
 8014002:	2201      	movs	r2, #1
 8014004:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8014006:	f7fd fa8f 	bl	8011528 <HAL_GetTick>
 801400a:	6378      	str	r0, [r7, #52]	; 0x34

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 801400c:	e008      	b.n	8014020 <HAL_RCC_OscConfig+0x154>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 801400e:	f7fd fa8b 	bl	8011528 <HAL_GetTick>
 8014012:	4602      	mov	r2, r0
 8014014:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014016:	1ad3      	subs	r3, r2, r3
 8014018:	2b02      	cmp	r3, #2
 801401a:	d901      	bls.n	8014020 <HAL_RCC_OscConfig+0x154>
          {
            return HAL_TIMEOUT;
 801401c:	2303      	movs	r3, #3
 801401e:	e161      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8014020:	4b56      	ldr	r3, [pc, #344]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8014022:	681b      	ldr	r3, [r3, #0]
 8014024:	f003 0302 	and.w	r3, r3, #2
 8014028:	2b00      	cmp	r3, #0
 801402a:	d0f0      	beq.n	801400e <HAL_RCC_OscConfig+0x142>
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 801402c:	4b53      	ldr	r3, [pc, #332]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 801402e:	681b      	ldr	r3, [r3, #0]
 8014030:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8014034:	687b      	ldr	r3, [r7, #4]
 8014036:	6919      	ldr	r1, [r3, #16]
 8014038:	23f8      	movs	r3, #248	; 0xf8
 801403a:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801403c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801403e:	fa93 f3a3 	rbit	r3, r3
 8014042:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8014044:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014046:	fab3 f383 	clz	r3, r3
 801404a:	fa01 f303 	lsl.w	r3, r1, r3
 801404e:	494b      	ldr	r1, [pc, #300]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8014050:	4313      	orrs	r3, r2
 8014052:	600b      	str	r3, [r1, #0]
 8014054:	e015      	b.n	8014082 <HAL_RCC_OscConfig+0x1b6>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8014056:	4b4b      	ldr	r3, [pc, #300]	; (8014184 <HAL_RCC_OscConfig+0x2b8>)
 8014058:	2200      	movs	r2, #0
 801405a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 801405c:	f7fd fa64 	bl	8011528 <HAL_GetTick>
 8014060:	6378      	str	r0, [r7, #52]	; 0x34
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8014062:	e008      	b.n	8014076 <HAL_RCC_OscConfig+0x1aa>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8014064:	f7fd fa60 	bl	8011528 <HAL_GetTick>
 8014068:	4602      	mov	r2, r0
 801406a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801406c:	1ad3      	subs	r3, r2, r3
 801406e:	2b02      	cmp	r3, #2
 8014070:	d901      	bls.n	8014076 <HAL_RCC_OscConfig+0x1aa>
          {
            return HAL_TIMEOUT;
 8014072:	2303      	movs	r3, #3
 8014074:	e136      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8014076:	4b41      	ldr	r3, [pc, #260]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8014078:	681b      	ldr	r3, [r3, #0]
 801407a:	f003 0302 	and.w	r3, r3, #2
 801407e:	2b00      	cmp	r3, #0
 8014080:	d1f0      	bne.n	8014064 <HAL_RCC_OscConfig+0x198>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8014082:	687b      	ldr	r3, [r7, #4]
 8014084:	681b      	ldr	r3, [r3, #0]
 8014086:	f003 0308 	and.w	r3, r3, #8
 801408a:	2b00      	cmp	r3, #0
 801408c:	d030      	beq.n	80140f0 <HAL_RCC_OscConfig+0x224>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 801408e:	687b      	ldr	r3, [r7, #4]
 8014090:	695b      	ldr	r3, [r3, #20]
 8014092:	2b00      	cmp	r3, #0
 8014094:	d016      	beq.n	80140c4 <HAL_RCC_OscConfig+0x1f8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8014096:	4b3c      	ldr	r3, [pc, #240]	; (8014188 <HAL_RCC_OscConfig+0x2bc>)
 8014098:	2201      	movs	r2, #1
 801409a:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 801409c:	f7fd fa44 	bl	8011528 <HAL_GetTick>
 80140a0:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80140a2:	e008      	b.n	80140b6 <HAL_RCC_OscConfig+0x1ea>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80140a4:	f7fd fa40 	bl	8011528 <HAL_GetTick>
 80140a8:	4602      	mov	r2, r0
 80140aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80140ac:	1ad3      	subs	r3, r2, r3
 80140ae:	2b02      	cmp	r3, #2
 80140b0:	d901      	bls.n	80140b6 <HAL_RCC_OscConfig+0x1ea>
        {
          return HAL_TIMEOUT;
 80140b2:	2303      	movs	r3, #3
 80140b4:	e116      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80140b6:	4b31      	ldr	r3, [pc, #196]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 80140b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80140ba:	f003 0302 	and.w	r3, r3, #2
 80140be:	2b00      	cmp	r3, #0
 80140c0:	d0f0      	beq.n	80140a4 <HAL_RCC_OscConfig+0x1d8>
 80140c2:	e015      	b.n	80140f0 <HAL_RCC_OscConfig+0x224>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80140c4:	4b30      	ldr	r3, [pc, #192]	; (8014188 <HAL_RCC_OscConfig+0x2bc>)
 80140c6:	2200      	movs	r2, #0
 80140c8:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80140ca:	f7fd fa2d 	bl	8011528 <HAL_GetTick>
 80140ce:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80140d0:	e008      	b.n	80140e4 <HAL_RCC_OscConfig+0x218>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80140d2:	f7fd fa29 	bl	8011528 <HAL_GetTick>
 80140d6:	4602      	mov	r2, r0
 80140d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80140da:	1ad3      	subs	r3, r2, r3
 80140dc:	2b02      	cmp	r3, #2
 80140de:	d901      	bls.n	80140e4 <HAL_RCC_OscConfig+0x218>
        {
          return HAL_TIMEOUT;
 80140e0:	2303      	movs	r3, #3
 80140e2:	e0ff      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80140e4:	4b25      	ldr	r3, [pc, #148]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 80140e6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80140e8:	f003 0302 	and.w	r3, r3, #2
 80140ec:	2b00      	cmp	r3, #0
 80140ee:	d1f0      	bne.n	80140d2 <HAL_RCC_OscConfig+0x206>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80140f0:	687b      	ldr	r3, [r7, #4]
 80140f2:	681b      	ldr	r3, [r3, #0]
 80140f4:	f003 0304 	and.w	r3, r3, #4
 80140f8:	2b00      	cmp	r3, #0
 80140fa:	d067      	beq.n	80141cc <HAL_RCC_OscConfig+0x300>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80140fc:	2300      	movs	r3, #0
 80140fe:	60bb      	str	r3, [r7, #8]
 8014100:	4b1e      	ldr	r3, [pc, #120]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8014102:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014104:	4a1d      	ldr	r2, [pc, #116]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 8014106:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801410a:	6413      	str	r3, [r2, #64]	; 0x40
 801410c:	4b1b      	ldr	r3, [pc, #108]	; (801417c <HAL_RCC_OscConfig+0x2b0>)
 801410e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8014110:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8014114:	60bb      	str	r3, [r7, #8]
 8014116:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8014118:	4b1c      	ldr	r3, [pc, #112]	; (801418c <HAL_RCC_OscConfig+0x2c0>)
 801411a:	681b      	ldr	r3, [r3, #0]
 801411c:	4a1b      	ldr	r2, [pc, #108]	; (801418c <HAL_RCC_OscConfig+0x2c0>)
 801411e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8014122:	6013      	str	r3, [r2, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8014124:	f7fd fa00 	bl	8011528 <HAL_GetTick>
 8014128:	6378      	str	r0, [r7, #52]	; 0x34
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 801412a:	e008      	b.n	801413e <HAL_RCC_OscConfig+0x272>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 801412c:	f7fd f9fc 	bl	8011528 <HAL_GetTick>
 8014130:	4602      	mov	r2, r0
 8014132:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014134:	1ad3      	subs	r3, r2, r3
 8014136:	2b02      	cmp	r3, #2
 8014138:	d901      	bls.n	801413e <HAL_RCC_OscConfig+0x272>
      {
        return HAL_TIMEOUT;
 801413a:	2303      	movs	r3, #3
 801413c:	e0d2      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 801413e:	4b13      	ldr	r3, [pc, #76]	; (801418c <HAL_RCC_OscConfig+0x2c0>)
 8014140:	681b      	ldr	r3, [r3, #0]
 8014142:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8014146:	2b00      	cmp	r3, #0
 8014148:	d0f0      	beq.n	801412c <HAL_RCC_OscConfig+0x260>
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 801414a:	687b      	ldr	r3, [r7, #4]
 801414c:	689a      	ldr	r2, [r3, #8]
 801414e:	4b10      	ldr	r3, [pc, #64]	; (8014190 <HAL_RCC_OscConfig+0x2c4>)
 8014150:	b2d2      	uxtb	r2, r2
 8014152:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8014154:	687b      	ldr	r3, [r7, #4]
 8014156:	689b      	ldr	r3, [r3, #8]
 8014158:	2b00      	cmp	r3, #0
 801415a:	d022      	beq.n	80141a2 <HAL_RCC_OscConfig+0x2d6>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 801415c:	f7fd f9e4 	bl	8011528 <HAL_GetTick>
 8014160:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8014162:	e017      	b.n	8014194 <HAL_RCC_OscConfig+0x2c8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8014164:	f7fd f9e0 	bl	8011528 <HAL_GetTick>
 8014168:	4602      	mov	r2, r0
 801416a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801416c:	1ad3      	subs	r3, r2, r3
 801416e:	f241 3288 	movw	r2, #5000	; 0x1388
 8014172:	4293      	cmp	r3, r2
 8014174:	d90e      	bls.n	8014194 <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 8014176:	2303      	movs	r3, #3
 8014178:	e0b4      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
 801417a:	bf00      	nop
 801417c:	40023800 	.word	0x40023800
 8014180:	40023802 	.word	0x40023802
 8014184:	42470000 	.word	0x42470000
 8014188:	42470e80 	.word	0x42470e80
 801418c:	40007000 	.word	0x40007000
 8014190:	40023870 	.word	0x40023870
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8014194:	4b55      	ldr	r3, [pc, #340]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 8014196:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8014198:	f003 0302 	and.w	r3, r3, #2
 801419c:	2b00      	cmp	r3, #0
 801419e:	d0e1      	beq.n	8014164 <HAL_RCC_OscConfig+0x298>
 80141a0:	e014      	b.n	80141cc <HAL_RCC_OscConfig+0x300>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80141a2:	f7fd f9c1 	bl	8011528 <HAL_GetTick>
 80141a6:	6378      	str	r0, [r7, #52]	; 0x34
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80141a8:	e00a      	b.n	80141c0 <HAL_RCC_OscConfig+0x2f4>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80141aa:	f7fd f9bd 	bl	8011528 <HAL_GetTick>
 80141ae:	4602      	mov	r2, r0
 80141b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80141b2:	1ad3      	subs	r3, r2, r3
 80141b4:	f241 3288 	movw	r2, #5000	; 0x1388
 80141b8:	4293      	cmp	r3, r2
 80141ba:	d901      	bls.n	80141c0 <HAL_RCC_OscConfig+0x2f4>
        {
          return HAL_TIMEOUT;
 80141bc:	2303      	movs	r3, #3
 80141be:	e091      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80141c0:	4b4a      	ldr	r3, [pc, #296]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 80141c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80141c4:	f003 0302 	and.w	r3, r3, #2
 80141c8:	2b00      	cmp	r3, #0
 80141ca:	d1ee      	bne.n	80141aa <HAL_RCC_OscConfig+0x2de>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80141cc:	687b      	ldr	r3, [r7, #4]
 80141ce:	699b      	ldr	r3, [r3, #24]
 80141d0:	2b00      	cmp	r3, #0
 80141d2:	f000 8086 	beq.w	80142e2 <HAL_RCC_OscConfig+0x416>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80141d6:	4b45      	ldr	r3, [pc, #276]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 80141d8:	689b      	ldr	r3, [r3, #8]
 80141da:	f003 030c 	and.w	r3, r3, #12
 80141de:	2b08      	cmp	r3, #8
 80141e0:	d07d      	beq.n	80142de <HAL_RCC_OscConfig+0x412>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80141e2:	687b      	ldr	r3, [r7, #4]
 80141e4:	699b      	ldr	r3, [r3, #24]
 80141e6:	2b02      	cmp	r3, #2
 80141e8:	d162      	bne.n	80142b0 <HAL_RCC_OscConfig+0x3e4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80141ea:	4b41      	ldr	r3, [pc, #260]	; (80142f0 <HAL_RCC_OscConfig+0x424>)
 80141ec:	2200      	movs	r2, #0
 80141ee:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80141f0:	f7fd f99a 	bl	8011528 <HAL_GetTick>
 80141f4:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80141f6:	e008      	b.n	801420a <HAL_RCC_OscConfig+0x33e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80141f8:	f7fd f996 	bl	8011528 <HAL_GetTick>
 80141fc:	4602      	mov	r2, r0
 80141fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014200:	1ad3      	subs	r3, r2, r3
 8014202:	2b02      	cmp	r3, #2
 8014204:	d901      	bls.n	801420a <HAL_RCC_OscConfig+0x33e>
          {
            return HAL_TIMEOUT;
 8014206:	2303      	movs	r3, #3
 8014208:	e06c      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 801420a:	4b38      	ldr	r3, [pc, #224]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 801420c:	681b      	ldr	r3, [r3, #0]
 801420e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8014212:	2b00      	cmp	r3, #0
 8014214:	d1f0      	bne.n	80141f8 <HAL_RCC_OscConfig+0x32c>
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8014216:	687b      	ldr	r3, [r7, #4]
 8014218:	69da      	ldr	r2, [r3, #28]
 801421a:	687b      	ldr	r3, [r7, #4]
 801421c:	6a1b      	ldr	r3, [r3, #32]
 801421e:	431a      	orrs	r2, r3
 8014220:	687b      	ldr	r3, [r7, #4]
 8014222:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8014224:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8014228:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801422a:	693b      	ldr	r3, [r7, #16]
 801422c:	fa93 f3a3 	rbit	r3, r3
 8014230:	60fb      	str	r3, [r7, #12]
  return(result);
 8014232:	68fb      	ldr	r3, [r7, #12]
 8014234:	fab3 f383 	clz	r3, r3
 8014238:	fa01 f303 	lsl.w	r3, r1, r3
 801423c:	431a      	orrs	r2, r3
 801423e:	687b      	ldr	r3, [r7, #4]
 8014240:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014242:	085b      	lsrs	r3, r3, #1
 8014244:	1e59      	subs	r1, r3, #1
 8014246:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 801424a:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801424c:	69bb      	ldr	r3, [r7, #24]
 801424e:	fa93 f3a3 	rbit	r3, r3
 8014252:	617b      	str	r3, [r7, #20]
  return(result);
 8014254:	697b      	ldr	r3, [r7, #20]
 8014256:	fab3 f383 	clz	r3, r3
 801425a:	fa01 f303 	lsl.w	r3, r1, r3
 801425e:	431a      	orrs	r2, r3
 8014260:	687b      	ldr	r3, [r7, #4]
 8014262:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8014264:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8014268:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801426a:	6a3b      	ldr	r3, [r7, #32]
 801426c:	fa93 f3a3 	rbit	r3, r3
 8014270:	61fb      	str	r3, [r7, #28]
  return(result);
 8014272:	69fb      	ldr	r3, [r7, #28]
 8014274:	fab3 f383 	clz	r3, r3
 8014278:	fa01 f303 	lsl.w	r3, r1, r3
 801427c:	491b      	ldr	r1, [pc, #108]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 801427e:	4313      	orrs	r3, r2
 8014280:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8014282:	4b1b      	ldr	r3, [pc, #108]	; (80142f0 <HAL_RCC_OscConfig+0x424>)
 8014284:	2201      	movs	r2, #1
 8014286:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8014288:	f7fd f94e 	bl	8011528 <HAL_GetTick>
 801428c:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 801428e:	e008      	b.n	80142a2 <HAL_RCC_OscConfig+0x3d6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8014290:	f7fd f94a 	bl	8011528 <HAL_GetTick>
 8014294:	4602      	mov	r2, r0
 8014296:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014298:	1ad3      	subs	r3, r2, r3
 801429a:	2b02      	cmp	r3, #2
 801429c:	d901      	bls.n	80142a2 <HAL_RCC_OscConfig+0x3d6>
          {
            return HAL_TIMEOUT;
 801429e:	2303      	movs	r3, #3
 80142a0:	e020      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80142a2:	4b12      	ldr	r3, [pc, #72]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 80142a4:	681b      	ldr	r3, [r3, #0]
 80142a6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80142aa:	2b00      	cmp	r3, #0
 80142ac:	d0f0      	beq.n	8014290 <HAL_RCC_OscConfig+0x3c4>
 80142ae:	e018      	b.n	80142e2 <HAL_RCC_OscConfig+0x416>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80142b0:	4b0f      	ldr	r3, [pc, #60]	; (80142f0 <HAL_RCC_OscConfig+0x424>)
 80142b2:	2200      	movs	r2, #0
 80142b4:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80142b6:	f7fd f937 	bl	8011528 <HAL_GetTick>
 80142ba:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80142bc:	e008      	b.n	80142d0 <HAL_RCC_OscConfig+0x404>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80142be:	f7fd f933 	bl	8011528 <HAL_GetTick>
 80142c2:	4602      	mov	r2, r0
 80142c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80142c6:	1ad3      	subs	r3, r2, r3
 80142c8:	2b02      	cmp	r3, #2
 80142ca:	d901      	bls.n	80142d0 <HAL_RCC_OscConfig+0x404>
          {
            return HAL_TIMEOUT;
 80142cc:	2303      	movs	r3, #3
 80142ce:	e009      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80142d0:	4b06      	ldr	r3, [pc, #24]	; (80142ec <HAL_RCC_OscConfig+0x420>)
 80142d2:	681b      	ldr	r3, [r3, #0]
 80142d4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80142d8:	2b00      	cmp	r3, #0
 80142da:	d1f0      	bne.n	80142be <HAL_RCC_OscConfig+0x3f2>
 80142dc:	e001      	b.n	80142e2 <HAL_RCC_OscConfig+0x416>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 80142de:	2301      	movs	r3, #1
 80142e0:	e000      	b.n	80142e4 <HAL_RCC_OscConfig+0x418>
    }
  }
  return HAL_OK;
 80142e2:	2300      	movs	r3, #0
}
 80142e4:	4618      	mov	r0, r3
 80142e6:	3738      	adds	r7, #56	; 0x38
 80142e8:	46bd      	mov	sp, r7
 80142ea:	bd80      	pop	{r7, pc}
 80142ec:	40023800 	.word	0x40023800
 80142f0:	42470060 	.word	0x42470060

080142f4 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80142f4:	b580      	push	{r7, lr}
 80142f6:	b084      	sub	sp, #16
 80142f8:	af00      	add	r7, sp, #0
 80142fa:	6078      	str	r0, [r7, #4]
 80142fc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0U;   
 80142fe:	2300      	movs	r3, #0
 8014300:	60fb      	str	r3, [r7, #12]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8014302:	4b73      	ldr	r3, [pc, #460]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 8014304:	681b      	ldr	r3, [r3, #0]
 8014306:	f003 030f 	and.w	r3, r3, #15
 801430a:	683a      	ldr	r2, [r7, #0]
 801430c:	429a      	cmp	r2, r3
 801430e:	d90c      	bls.n	801432a <HAL_RCC_ClockConfig+0x36>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8014310:	4b6f      	ldr	r3, [pc, #444]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 8014312:	683a      	ldr	r2, [r7, #0]
 8014314:	b2d2      	uxtb	r2, r2
 8014316:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8014318:	4b6d      	ldr	r3, [pc, #436]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 801431a:	681b      	ldr	r3, [r3, #0]
 801431c:	f003 030f 	and.w	r3, r3, #15
 8014320:	683a      	ldr	r2, [r7, #0]
 8014322:	429a      	cmp	r2, r3
 8014324:	d001      	beq.n	801432a <HAL_RCC_ClockConfig+0x36>
    {
      return HAL_ERROR;
 8014326:	2301      	movs	r3, #1
 8014328:	e0ce      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 801432a:	687b      	ldr	r3, [r7, #4]
 801432c:	681b      	ldr	r3, [r3, #0]
 801432e:	f003 0302 	and.w	r3, r3, #2
 8014332:	2b00      	cmp	r3, #0
 8014334:	d008      	beq.n	8014348 <HAL_RCC_ClockConfig+0x54>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8014336:	4b67      	ldr	r3, [pc, #412]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014338:	689b      	ldr	r3, [r3, #8]
 801433a:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 801433e:	687b      	ldr	r3, [r7, #4]
 8014340:	689b      	ldr	r3, [r3, #8]
 8014342:	4964      	ldr	r1, [pc, #400]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014344:	4313      	orrs	r3, r2
 8014346:	608b      	str	r3, [r1, #8]
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8014348:	687b      	ldr	r3, [r7, #4]
 801434a:	681b      	ldr	r3, [r3, #0]
 801434c:	f003 0301 	and.w	r3, r3, #1
 8014350:	2b00      	cmp	r3, #0
 8014352:	f000 8082 	beq.w	801445a <HAL_RCC_ClockConfig+0x166>
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8014356:	687b      	ldr	r3, [r7, #4]
 8014358:	685b      	ldr	r3, [r3, #4]
 801435a:	2b01      	cmp	r3, #1
 801435c:	d107      	bne.n	801436e <HAL_RCC_ClockConfig+0x7a>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 801435e:	4b5d      	ldr	r3, [pc, #372]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014360:	681b      	ldr	r3, [r3, #0]
 8014362:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8014366:	2b00      	cmp	r3, #0
 8014368:	d119      	bne.n	801439e <HAL_RCC_ClockConfig+0xaa>
      {
        return HAL_ERROR;
 801436a:	2301      	movs	r3, #1
 801436c:	e0ac      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 801436e:	687b      	ldr	r3, [r7, #4]
 8014370:	685b      	ldr	r3, [r3, #4]
 8014372:	2b02      	cmp	r3, #2
 8014374:	d003      	beq.n	801437e <HAL_RCC_ClockConfig+0x8a>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8014376:	687b      	ldr	r3, [r7, #4]
 8014378:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 801437a:	2b03      	cmp	r3, #3
 801437c:	d107      	bne.n	801438e <HAL_RCC_ClockConfig+0x9a>
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 801437e:	4b55      	ldr	r3, [pc, #340]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014380:	681b      	ldr	r3, [r3, #0]
 8014382:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8014386:	2b00      	cmp	r3, #0
 8014388:	d109      	bne.n	801439e <HAL_RCC_ClockConfig+0xaa>
      {
        return HAL_ERROR;
 801438a:	2301      	movs	r3, #1
 801438c:	e09c      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 801438e:	4b51      	ldr	r3, [pc, #324]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014390:	681b      	ldr	r3, [r3, #0]
 8014392:	f003 0302 	and.w	r3, r3, #2
 8014396:	2b00      	cmp	r3, #0
 8014398:	d101      	bne.n	801439e <HAL_RCC_ClockConfig+0xaa>
      {
        return HAL_ERROR;
 801439a:	2301      	movs	r3, #1
 801439c:	e094      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 801439e:	4b4d      	ldr	r3, [pc, #308]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 80143a0:	689b      	ldr	r3, [r3, #8]
 80143a2:	f023 0203 	bic.w	r2, r3, #3
 80143a6:	687b      	ldr	r3, [r7, #4]
 80143a8:	685b      	ldr	r3, [r3, #4]
 80143aa:	494a      	ldr	r1, [pc, #296]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 80143ac:	4313      	orrs	r3, r2
 80143ae:	608b      	str	r3, [r1, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80143b0:	f7fd f8ba 	bl	8011528 <HAL_GetTick>
 80143b4:	60f8      	str	r0, [r7, #12]
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80143b6:	687b      	ldr	r3, [r7, #4]
 80143b8:	685b      	ldr	r3, [r3, #4]
 80143ba:	2b01      	cmp	r3, #1
 80143bc:	d112      	bne.n	80143e4 <HAL_RCC_ClockConfig+0xf0>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80143be:	e00a      	b.n	80143d6 <HAL_RCC_ClockConfig+0xe2>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80143c0:	f7fd f8b2 	bl	8011528 <HAL_GetTick>
 80143c4:	4602      	mov	r2, r0
 80143c6:	68fb      	ldr	r3, [r7, #12]
 80143c8:	1ad3      	subs	r3, r2, r3
 80143ca:	f241 3288 	movw	r2, #5000	; 0x1388
 80143ce:	4293      	cmp	r3, r2
 80143d0:	d901      	bls.n	80143d6 <HAL_RCC_ClockConfig+0xe2>
        {
          return HAL_TIMEOUT;
 80143d2:	2303      	movs	r3, #3
 80143d4:	e078      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80143d6:	4b3f      	ldr	r3, [pc, #252]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 80143d8:	689b      	ldr	r3, [r3, #8]
 80143da:	f003 030c 	and.w	r3, r3, #12
 80143de:	2b04      	cmp	r3, #4
 80143e0:	d1ee      	bne.n	80143c0 <HAL_RCC_ClockConfig+0xcc>
 80143e2:	e03a      	b.n	801445a <HAL_RCC_ClockConfig+0x166>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80143e4:	687b      	ldr	r3, [r7, #4]
 80143e6:	685b      	ldr	r3, [r3, #4]
 80143e8:	2b02      	cmp	r3, #2
 80143ea:	d112      	bne.n	8014412 <HAL_RCC_ClockConfig+0x11e>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80143ec:	e00a      	b.n	8014404 <HAL_RCC_ClockConfig+0x110>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80143ee:	f7fd f89b 	bl	8011528 <HAL_GetTick>
 80143f2:	4602      	mov	r2, r0
 80143f4:	68fb      	ldr	r3, [r7, #12]
 80143f6:	1ad3      	subs	r3, r2, r3
 80143f8:	f241 3288 	movw	r2, #5000	; 0x1388
 80143fc:	4293      	cmp	r3, r2
 80143fe:	d901      	bls.n	8014404 <HAL_RCC_ClockConfig+0x110>
        {
          return HAL_TIMEOUT;
 8014400:	2303      	movs	r3, #3
 8014402:	e061      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8014404:	4b33      	ldr	r3, [pc, #204]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014406:	689b      	ldr	r3, [r3, #8]
 8014408:	f003 030c 	and.w	r3, r3, #12
 801440c:	2b08      	cmp	r3, #8
 801440e:	d1ee      	bne.n	80143ee <HAL_RCC_ClockConfig+0xfa>
 8014410:	e023      	b.n	801445a <HAL_RCC_ClockConfig+0x166>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8014412:	687b      	ldr	r3, [r7, #4]
 8014414:	685b      	ldr	r3, [r3, #4]
 8014416:	2b03      	cmp	r3, #3
 8014418:	d119      	bne.n	801444e <HAL_RCC_ClockConfig+0x15a>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 801441a:	e00a      	b.n	8014432 <HAL_RCC_ClockConfig+0x13e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 801441c:	f7fd f884 	bl	8011528 <HAL_GetTick>
 8014420:	4602      	mov	r2, r0
 8014422:	68fb      	ldr	r3, [r7, #12]
 8014424:	1ad3      	subs	r3, r2, r3
 8014426:	f241 3288 	movw	r2, #5000	; 0x1388
 801442a:	4293      	cmp	r3, r2
 801442c:	d901      	bls.n	8014432 <HAL_RCC_ClockConfig+0x13e>
        {
          return HAL_TIMEOUT;
 801442e:	2303      	movs	r3, #3
 8014430:	e04a      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8014432:	4b28      	ldr	r3, [pc, #160]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014434:	689b      	ldr	r3, [r3, #8]
 8014436:	e7f1      	b.n	801441c <HAL_RCC_ClockConfig+0x128>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8014438:	f7fd f876 	bl	8011528 <HAL_GetTick>
 801443c:	4602      	mov	r2, r0
 801443e:	68fb      	ldr	r3, [r7, #12]
 8014440:	1ad3      	subs	r3, r2, r3
 8014442:	f241 3288 	movw	r2, #5000	; 0x1388
 8014446:	4293      	cmp	r3, r2
 8014448:	d901      	bls.n	801444e <HAL_RCC_ClockConfig+0x15a>
        {
          return HAL_TIMEOUT;
 801444a:	2303      	movs	r3, #3
 801444c:	e03c      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 801444e:	4b21      	ldr	r3, [pc, #132]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014450:	689b      	ldr	r3, [r3, #8]
 8014452:	f003 030c 	and.w	r3, r3, #12
 8014456:	2b00      	cmp	r3, #0
 8014458:	d1ee      	bne.n	8014438 <HAL_RCC_ClockConfig+0x144>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 801445a:	4b1d      	ldr	r3, [pc, #116]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 801445c:	681b      	ldr	r3, [r3, #0]
 801445e:	f003 030f 	and.w	r3, r3, #15
 8014462:	683a      	ldr	r2, [r7, #0]
 8014464:	429a      	cmp	r2, r3
 8014466:	d20c      	bcs.n	8014482 <HAL_RCC_ClockConfig+0x18e>
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8014468:	4b19      	ldr	r3, [pc, #100]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 801446a:	683a      	ldr	r2, [r7, #0]
 801446c:	b2d2      	uxtb	r2, r2
 801446e:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8014470:	4b17      	ldr	r3, [pc, #92]	; (80144d0 <HAL_RCC_ClockConfig+0x1dc>)
 8014472:	681b      	ldr	r3, [r3, #0]
 8014474:	f003 030f 	and.w	r3, r3, #15
 8014478:	683a      	ldr	r2, [r7, #0]
 801447a:	429a      	cmp	r2, r3
 801447c:	d001      	beq.n	8014482 <HAL_RCC_ClockConfig+0x18e>
    {
      return HAL_ERROR;
 801447e:	2301      	movs	r3, #1
 8014480:	e022      	b.n	80144c8 <HAL_RCC_ClockConfig+0x1d4>
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8014482:	687b      	ldr	r3, [r7, #4]
 8014484:	681b      	ldr	r3, [r3, #0]
 8014486:	f003 0304 	and.w	r3, r3, #4
 801448a:	2b00      	cmp	r3, #0
 801448c:	d008      	beq.n	80144a0 <HAL_RCC_ClockConfig+0x1ac>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 801448e:	4b11      	ldr	r3, [pc, #68]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 8014490:	689b      	ldr	r3, [r3, #8]
 8014492:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8014496:	687b      	ldr	r3, [r7, #4]
 8014498:	68db      	ldr	r3, [r3, #12]
 801449a:	490e      	ldr	r1, [pc, #56]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 801449c:	4313      	orrs	r3, r2
 801449e:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80144a0:	687b      	ldr	r3, [r7, #4]
 80144a2:	681b      	ldr	r3, [r3, #0]
 80144a4:	f003 0308 	and.w	r3, r3, #8
 80144a8:	2b00      	cmp	r3, #0
 80144aa:	d009      	beq.n	80144c0 <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80144ac:	4b09      	ldr	r3, [pc, #36]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 80144ae:	689b      	ldr	r3, [r3, #8]
 80144b0:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 80144b4:	687b      	ldr	r3, [r7, #4]
 80144b6:	691b      	ldr	r3, [r3, #16]
 80144b8:	00db      	lsls	r3, r3, #3
 80144ba:	4906      	ldr	r1, [pc, #24]	; (80144d4 <HAL_RCC_ClockConfig+0x1e0>)
 80144bc:	4313      	orrs	r3, r2
 80144be:	608b      	str	r3, [r1, #8]
  }

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80144c0:	2000      	movs	r0, #0
 80144c2:	f7fd f807 	bl	80114d4 <HAL_InitTick>
  
  return HAL_OK;
 80144c6:	2300      	movs	r3, #0
}
 80144c8:	4618      	mov	r0, r3
 80144ca:	3710      	adds	r7, #16
 80144cc:	46bd      	mov	sp, r7
 80144ce:	bd80      	pop	{r7, pc}
 80144d0:	40023c00 	.word	0x40023c00
 80144d4:	40023800 	.word	0x40023800

080144d8 <HAL_RCC_MCOConfig>:
  * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have
  *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80144d8:	b580      	push	{r7, lr}
 80144da:	b08c      	sub	sp, #48	; 0x30
 80144dc:	af00      	add	r7, sp, #0
 80144de:	60f8      	str	r0, [r7, #12]
 80144e0:	60b9      	str	r1, [r7, #8]
 80144e2:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 80144e4:	68fb      	ldr	r3, [r7, #12]
 80144e6:	2b00      	cmp	r3, #0
 80144e8:	d129      	bne.n	801453e <HAL_RCC_MCOConfig+0x66>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    
    /* MCO1 Clock Enable */
    __MCO1_CLK_ENABLE();
 80144ea:	2300      	movs	r3, #0
 80144ec:	61bb      	str	r3, [r7, #24]
 80144ee:	4b2b      	ldr	r3, [pc, #172]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 80144f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80144f2:	4a2a      	ldr	r2, [pc, #168]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 80144f4:	f043 0301 	orr.w	r3, r3, #1
 80144f8:	6313      	str	r3, [r2, #48]	; 0x30
 80144fa:	4b28      	ldr	r3, [pc, #160]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 80144fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80144fe:	f003 0301 	and.w	r3, r3, #1
 8014502:	61bb      	str	r3, [r7, #24]
 8014504:	69bb      	ldr	r3, [r7, #24]
    
    /* Configure the MCO1 pin in alternate function mode */    
    GPIO_InitStruct.Pin = MCO1_PIN;
 8014506:	f44f 7380 	mov.w	r3, #256	; 0x100
 801450a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801450c:	2302      	movs	r3, #2
 801450e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8014510:	2303      	movs	r3, #3
 8014512:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014514:	2300      	movs	r3, #0
 8014516:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8014518:	2300      	movs	r3, #0
 801451a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 801451c:	f107 031c 	add.w	r3, r7, #28
 8014520:	4619      	mov	r1, r3
 8014522:	481f      	ldr	r0, [pc, #124]	; (80145a0 <HAL_RCC_MCOConfig+0xc8>)
 8014524:	f7fe f99e 	bl	8012864 <HAL_GPIO_Init>
    
    /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 8014528:	4b1c      	ldr	r3, [pc, #112]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 801452a:	689b      	ldr	r3, [r3, #8]
 801452c:	f023 62ec 	bic.w	r2, r3, #123731968	; 0x7600000
 8014530:	68b9      	ldr	r1, [r7, #8]
 8014532:	687b      	ldr	r3, [r7, #4]
 8014534:	430b      	orrs	r3, r1
 8014536:	4919      	ldr	r1, [pc, #100]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 8014538:	4313      	orrs	r3, r2
 801453a:	608b      	str	r3, [r1, #8]
#if defined(RCC_CFGR_MCO2EN)
    __HAL_RCC_MCO2_ENABLE();
#endif /* RCC_CFGR_MCO2EN */
  }
#endif /* RCC_CFGR_MCO2 */
}
 801453c:	e029      	b.n	8014592 <HAL_RCC_MCOConfig+0xba>
    __MCO2_CLK_ENABLE();
 801453e:	2300      	movs	r3, #0
 8014540:	617b      	str	r3, [r7, #20]
 8014542:	4b16      	ldr	r3, [pc, #88]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 8014544:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014546:	4a15      	ldr	r2, [pc, #84]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 8014548:	f043 0304 	orr.w	r3, r3, #4
 801454c:	6313      	str	r3, [r2, #48]	; 0x30
 801454e:	4b13      	ldr	r3, [pc, #76]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 8014550:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014552:	f003 0304 	and.w	r3, r3, #4
 8014556:	617b      	str	r3, [r7, #20]
 8014558:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
 801455a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801455e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8014560:	2302      	movs	r3, #2
 8014562:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8014564:	2303      	movs	r3, #3
 8014566:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014568:	2300      	movs	r3, #0
 801456a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 801456c:	2300      	movs	r3, #0
 801456e:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 8014570:	f107 031c 	add.w	r3, r7, #28
 8014574:	4619      	mov	r1, r3
 8014576:	480b      	ldr	r0, [pc, #44]	; (80145a4 <HAL_RCC_MCOConfig+0xcc>)
 8014578:	f7fe f974 	bl	8012864 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3U)));
 801457c:	4b07      	ldr	r3, [pc, #28]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 801457e:	689b      	ldr	r3, [r3, #8]
 8014580:	f023 4278 	bic.w	r2, r3, #4160749568	; 0xf8000000
 8014584:	687b      	ldr	r3, [r7, #4]
 8014586:	00d9      	lsls	r1, r3, #3
 8014588:	68bb      	ldr	r3, [r7, #8]
 801458a:	430b      	orrs	r3, r1
 801458c:	4903      	ldr	r1, [pc, #12]	; (801459c <HAL_RCC_MCOConfig+0xc4>)
 801458e:	4313      	orrs	r3, r2
 8014590:	608b      	str	r3, [r1, #8]
}
 8014592:	bf00      	nop
 8014594:	3730      	adds	r7, #48	; 0x30
 8014596:	46bd      	mov	sp, r7
 8014598:	bd80      	pop	{r7, pc}
 801459a:	bf00      	nop
 801459c:	40023800 	.word	0x40023800
 80145a0:	40020000 	.word	0x40020000
 80145a4:	40020800 	.word	0x40020800

080145a8 <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80145a8:	b480      	push	{r7}
 80145aa:	b08b      	sub	sp, #44	; 0x2c
 80145ac:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 80145ae:	2300      	movs	r3, #0
 80145b0:	61fb      	str	r3, [r7, #28]
 80145b2:	2300      	movs	r3, #0
 80145b4:	627b      	str	r3, [r7, #36]	; 0x24
 80145b6:	2300      	movs	r3, #0
 80145b8:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0U;
 80145ba:	2300      	movs	r3, #0
 80145bc:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80145be:	4b36      	ldr	r3, [pc, #216]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 80145c0:	689b      	ldr	r3, [r3, #8]
 80145c2:	f003 030c 	and.w	r3, r3, #12
 80145c6:	2b04      	cmp	r3, #4
 80145c8:	d006      	beq.n	80145d8 <HAL_RCC_GetSysClockFreq+0x30>
 80145ca:	2b08      	cmp	r3, #8
 80145cc:	d007      	beq.n	80145de <HAL_RCC_GetSysClockFreq+0x36>
 80145ce:	2b00      	cmp	r3, #0
 80145d0:	d158      	bne.n	8014684 <HAL_RCC_GetSysClockFreq+0xdc>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80145d2:	4b32      	ldr	r3, [pc, #200]	; (801469c <HAL_RCC_GetSysClockFreq+0xf4>)
 80145d4:	623b      	str	r3, [r7, #32]
       break;
 80145d6:	e058      	b.n	801468a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 80145d8:	4b30      	ldr	r3, [pc, #192]	; (801469c <HAL_RCC_GetSysClockFreq+0xf4>)
 80145da:	623b      	str	r3, [r7, #32]
      break;
 80145dc:	e055      	b.n	801468a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80145de:	4b2e      	ldr	r3, [pc, #184]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 80145e0:	685b      	ldr	r3, [r3, #4]
 80145e2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80145e6:	61fb      	str	r3, [r7, #28]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80145e8:	4b2b      	ldr	r3, [pc, #172]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 80145ea:	685b      	ldr	r3, [r3, #4]
 80145ec:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80145f0:	2b00      	cmp	r3, #0
 80145f2:	d017      	beq.n	8014624 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 80145f4:	4a29      	ldr	r2, [pc, #164]	; (801469c <HAL_RCC_GetSysClockFreq+0xf4>)
 80145f6:	69fb      	ldr	r3, [r7, #28]
 80145f8:	fbb2 f2f3 	udiv	r2, r2, r3
 80145fc:	4b26      	ldr	r3, [pc, #152]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 80145fe:	6859      	ldr	r1, [r3, #4]
 8014600:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8014604:	400b      	ands	r3, r1
 8014606:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 801460a:	6179      	str	r1, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801460c:	6979      	ldr	r1, [r7, #20]
 801460e:	fa91 f1a1 	rbit	r1, r1
 8014612:	6139      	str	r1, [r7, #16]
  return(result);
 8014614:	6939      	ldr	r1, [r7, #16]
 8014616:	fab1 f181 	clz	r1, r1
 801461a:	40cb      	lsrs	r3, r1
 801461c:	fb03 f302 	mul.w	r3, r3, r2
 8014620:	627b      	str	r3, [r7, #36]	; 0x24
 8014622:	e016      	b.n	8014652 <HAL_RCC_GetSysClockFreq+0xaa>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8014624:	4a1d      	ldr	r2, [pc, #116]	; (801469c <HAL_RCC_GetSysClockFreq+0xf4>)
 8014626:	69fb      	ldr	r3, [r7, #28]
 8014628:	fbb2 f2f3 	udiv	r2, r2, r3
 801462c:	4b1a      	ldr	r3, [pc, #104]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 801462e:	6859      	ldr	r1, [r3, #4]
 8014630:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8014634:	400b      	ands	r3, r1
 8014636:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 801463a:	60f9      	str	r1, [r7, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801463c:	68f9      	ldr	r1, [r7, #12]
 801463e:	fa91 f1a1 	rbit	r1, r1
 8014642:	60b9      	str	r1, [r7, #8]
  return(result);
 8014644:	68b9      	ldr	r1, [r7, #8]
 8014646:	fab1 f181 	clz	r1, r1
 801464a:	40cb      	lsrs	r3, r1
 801464c:	fb03 f302 	mul.w	r3, r3, r2
 8014650:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8014652:	4b11      	ldr	r3, [pc, #68]	; (8014698 <HAL_RCC_GetSysClockFreq+0xf0>)
 8014654:	685b      	ldr	r3, [r3, #4]
 8014656:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 801465a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 801465e:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8014660:	687b      	ldr	r3, [r7, #4]
 8014662:	fa93 f3a3 	rbit	r3, r3
 8014666:	603b      	str	r3, [r7, #0]
  return(result);
 8014668:	683b      	ldr	r3, [r7, #0]
 801466a:	fab3 f383 	clz	r3, r3
 801466e:	fa22 f303 	lsr.w	r3, r2, r3
 8014672:	3301      	adds	r3, #1
 8014674:	005b      	lsls	r3, r3, #1
 8014676:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 8014678:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801467a:	69bb      	ldr	r3, [r7, #24]
 801467c:	fbb2 f3f3 	udiv	r3, r2, r3
 8014680:	623b      	str	r3, [r7, #32]
      break;
 8014682:	e002      	b.n	801468a <HAL_RCC_GetSysClockFreq+0xe2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8014684:	4b05      	ldr	r3, [pc, #20]	; (801469c <HAL_RCC_GetSysClockFreq+0xf4>)
 8014686:	623b      	str	r3, [r7, #32]
      break;
 8014688:	bf00      	nop
    }
  }
  return sysclockfreq;
 801468a:	6a3b      	ldr	r3, [r7, #32]
}
 801468c:	4618      	mov	r0, r3
 801468e:	372c      	adds	r7, #44	; 0x2c
 8014690:	46bd      	mov	sp, r7
 8014692:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014696:	4770      	bx	lr
 8014698:	40023800 	.word	0x40023800
 801469c:	00f42400 	.word	0x00f42400

080146a0 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80146a0:	b580      	push	{r7, lr}
 80146a2:	b082      	sub	sp, #8
 80146a4:	af00      	add	r7, sp, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 80146a6:	f7ff ff7f 	bl	80145a8 <HAL_RCC_GetSysClockFreq>
 80146aa:	4601      	mov	r1, r0
 80146ac:	4b0d      	ldr	r3, [pc, #52]	; (80146e4 <HAL_RCC_GetHCLKFreq+0x44>)
 80146ae:	689b      	ldr	r3, [r3, #8]
 80146b0:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80146b4:	23f0      	movs	r3, #240	; 0xf0
 80146b6:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80146b8:	687b      	ldr	r3, [r7, #4]
 80146ba:	fa93 f3a3 	rbit	r3, r3
 80146be:	603b      	str	r3, [r7, #0]
  return(result);
 80146c0:	683b      	ldr	r3, [r7, #0]
 80146c2:	fab3 f383 	clz	r3, r3
 80146c6:	fa22 f303 	lsr.w	r3, r2, r3
 80146ca:	4a07      	ldr	r2, [pc, #28]	; (80146e8 <HAL_RCC_GetHCLKFreq+0x48>)
 80146cc:	5cd3      	ldrb	r3, [r2, r3]
 80146ce:	fa21 f303 	lsr.w	r3, r1, r3
 80146d2:	4a06      	ldr	r2, [pc, #24]	; (80146ec <HAL_RCC_GetHCLKFreq+0x4c>)
 80146d4:	6013      	str	r3, [r2, #0]
  return SystemCoreClock;
 80146d6:	4b05      	ldr	r3, [pc, #20]	; (80146ec <HAL_RCC_GetHCLKFreq+0x4c>)
 80146d8:	681b      	ldr	r3, [r3, #0]
}
 80146da:	4618      	mov	r0, r3
 80146dc:	3708      	adds	r7, #8
 80146de:	46bd      	mov	sp, r7
 80146e0:	bd80      	pop	{r7, pc}
 80146e2:	bf00      	nop
 80146e4:	40023800 	.word	0x40023800
 80146e8:	0801e1ec 	.word	0x0801e1ec
 80146ec:	20000358 	.word	0x20000358

080146f0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 80146f0:	b580      	push	{r7, lr}
 80146f2:	b082      	sub	sp, #8
 80146f4:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80146f6:	f7ff ffd3 	bl	80146a0 <HAL_RCC_GetHCLKFreq>
 80146fa:	4601      	mov	r1, r0
 80146fc:	4b0b      	ldr	r3, [pc, #44]	; (801472c <HAL_RCC_GetPCLK1Freq+0x3c>)
 80146fe:	689b      	ldr	r3, [r3, #8]
 8014700:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8014704:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8014708:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801470a:	687b      	ldr	r3, [r7, #4]
 801470c:	fa93 f3a3 	rbit	r3, r3
 8014710:	603b      	str	r3, [r7, #0]
  return(result);
 8014712:	683b      	ldr	r3, [r7, #0]
 8014714:	fab3 f383 	clz	r3, r3
 8014718:	fa22 f303 	lsr.w	r3, r2, r3
 801471c:	4a04      	ldr	r2, [pc, #16]	; (8014730 <HAL_RCC_GetPCLK1Freq+0x40>)
 801471e:	5cd3      	ldrb	r3, [r2, r3]
 8014720:	fa21 f303 	lsr.w	r3, r1, r3
}
 8014724:	4618      	mov	r0, r3
 8014726:	3708      	adds	r7, #8
 8014728:	46bd      	mov	sp, r7
 801472a:	bd80      	pop	{r7, pc}
 801472c:	40023800 	.word	0x40023800
 8014730:	0801e1ec 	.word	0x0801e1ec

08014734 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8014734:	b580      	push	{r7, lr}
 8014736:	b082      	sub	sp, #8
 8014738:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 801473a:	f7ff ffb1 	bl	80146a0 <HAL_RCC_GetHCLKFreq>
 801473e:	4601      	mov	r1, r0
 8014740:	4b0b      	ldr	r3, [pc, #44]	; (8014770 <HAL_RCC_GetPCLK2Freq+0x3c>)
 8014742:	689b      	ldr	r3, [r3, #8]
 8014744:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
 8014748:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 801474c:	607b      	str	r3, [r7, #4]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801474e:	687b      	ldr	r3, [r7, #4]
 8014750:	fa93 f3a3 	rbit	r3, r3
 8014754:	603b      	str	r3, [r7, #0]
  return(result);
 8014756:	683b      	ldr	r3, [r7, #0]
 8014758:	fab3 f383 	clz	r3, r3
 801475c:	fa22 f303 	lsr.w	r3, r2, r3
 8014760:	4a04      	ldr	r2, [pc, #16]	; (8014774 <HAL_RCC_GetPCLK2Freq+0x40>)
 8014762:	5cd3      	ldrb	r3, [r2, r3]
 8014764:	fa21 f303 	lsr.w	r3, r1, r3
} 
 8014768:	4618      	mov	r0, r3
 801476a:	3708      	adds	r7, #8
 801476c:	46bd      	mov	sp, r7
 801476e:	bd80      	pop	{r7, pc}
 8014770:	40023800 	.word	0x40023800
 8014774:	0801e1ec 	.word	0x0801e1ec

08014778 <HAL_RNG_Init>:
  * @param  hrng: pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{ 
 8014778:	b580      	push	{r7, lr}
 801477a:	b082      	sub	sp, #8
 801477c:	af00      	add	r7, sp, #0
 801477e:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if(hrng == NULL)
 8014780:	687b      	ldr	r3, [r7, #4]
 8014782:	2b00      	cmp	r3, #0
 8014784:	d101      	bne.n	801478a <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 8014786:	2301      	movs	r3, #1
 8014788:	e025      	b.n	80147d6 <HAL_RNG_Init+0x5e>
  }
  
  __HAL_LOCK(hrng);
 801478a:	687b      	ldr	r3, [r7, #4]
 801478c:	791b      	ldrb	r3, [r3, #4]
 801478e:	2b01      	cmp	r3, #1
 8014790:	d101      	bne.n	8014796 <HAL_RNG_Init+0x1e>
 8014792:	2302      	movs	r3, #2
 8014794:	e01f      	b.n	80147d6 <HAL_RNG_Init+0x5e>
 8014796:	687b      	ldr	r3, [r7, #4]
 8014798:	2201      	movs	r2, #1
 801479a:	711a      	strb	r2, [r3, #4]
  
  if(hrng->State == HAL_RNG_STATE_RESET)
 801479c:	687b      	ldr	r3, [r7, #4]
 801479e:	795b      	ldrb	r3, [r3, #5]
 80147a0:	b2db      	uxtb	r3, r3
 80147a2:	2b00      	cmp	r3, #0
 80147a4:	d105      	bne.n	80147b2 <HAL_RNG_Init+0x3a>
  {  
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 80147a6:	687b      	ldr	r3, [r7, #4]
 80147a8:	2200      	movs	r2, #0
 80147aa:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 80147ac:	6878      	ldr	r0, [r7, #4]
 80147ae:	f7fb fdfb 	bl	80103a8 <HAL_RNG_MspInit>
  }
  
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 80147b2:	687b      	ldr	r3, [r7, #4]
 80147b4:	2202      	movs	r2, #2
 80147b6:	715a      	strb	r2, [r3, #5]

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 80147b8:	687b      	ldr	r3, [r7, #4]
 80147ba:	681b      	ldr	r3, [r3, #0]
 80147bc:	681a      	ldr	r2, [r3, #0]
 80147be:	687b      	ldr	r3, [r7, #4]
 80147c0:	681b      	ldr	r3, [r3, #0]
 80147c2:	f042 0204 	orr.w	r2, r2, #4
 80147c6:	601a      	str	r2, [r3, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 80147c8:	687b      	ldr	r3, [r7, #4]
 80147ca:	2201      	movs	r2, #1
 80147cc:	715a      	strb	r2, [r3, #5]
  
  __HAL_UNLOCK(hrng);
 80147ce:	687b      	ldr	r3, [r7, #4]
 80147d0:	2200      	movs	r2, #0
 80147d2:	711a      	strb	r2, [r3, #4]
  
  /* Return function status */
  return HAL_OK;
 80147d4:	2300      	movs	r3, #0
}
 80147d6:	4618      	mov	r0, r3
 80147d8:	3708      	adds	r7, #8
 80147da:	46bd      	mov	sp, r7
 80147dc:	bd80      	pop	{r7, pc}

080147de <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit: pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 80147de:	b580      	push	{r7, lr}
 80147e0:	b084      	sub	sp, #16
 80147e2:	af00      	add	r7, sp, #0
 80147e4:	6078      	str	r0, [r7, #4]
 80147e6:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0U;    
 80147e8:	2300      	movs	r3, #0
 80147ea:	60bb      	str	r3, [r7, #8]
  HAL_StatusTypeDef status = HAL_OK;
 80147ec:	2300      	movs	r3, #0
 80147ee:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng); 
 80147f0:	687b      	ldr	r3, [r7, #4]
 80147f2:	791b      	ldrb	r3, [r3, #4]
 80147f4:	2b01      	cmp	r3, #1
 80147f6:	d101      	bne.n	80147fc <HAL_RNG_GenerateRandomNumber+0x1e>
 80147f8:	2302      	movs	r3, #2
 80147fa:	e037      	b.n	801486c <HAL_RNG_GenerateRandomNumber+0x8e>
 80147fc:	687b      	ldr	r3, [r7, #4]
 80147fe:	2201      	movs	r2, #1
 8014800:	711a      	strb	r2, [r3, #4]
  
  /* Check RNG peripheral state */
  if(hrng->State == HAL_RNG_STATE_READY)
 8014802:	687b      	ldr	r3, [r7, #4]
 8014804:	795b      	ldrb	r3, [r3, #5]
 8014806:	b2db      	uxtb	r3, r3
 8014808:	2b01      	cmp	r3, #1
 801480a:	d129      	bne.n	8014860 <HAL_RNG_GenerateRandomNumber+0x82>
  {
    /* Change RNG peripheral state */  
    hrng->State = HAL_RNG_STATE_BUSY;  
 801480c:	687b      	ldr	r3, [r7, #4]
 801480e:	2202      	movs	r2, #2
 8014810:	715a      	strb	r2, [r3, #5]

    /* Get tick */
    tickstart = HAL_GetTick();
 8014812:	f7fc fe89 	bl	8011528 <HAL_GetTick>
 8014816:	60b8      	str	r0, [r7, #8]
  
    /* Check if data register contains valid random data */
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8014818:	e00e      	b.n	8014838 <HAL_RNG_GenerateRandomNumber+0x5a>
    {
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 801481a:	f7fc fe85 	bl	8011528 <HAL_GetTick>
 801481e:	4602      	mov	r2, r0
 8014820:	68bb      	ldr	r3, [r7, #8]
 8014822:	1ad3      	subs	r3, r2, r3
 8014824:	2b02      	cmp	r3, #2
 8014826:	d907      	bls.n	8014838 <HAL_RNG_GenerateRandomNumber+0x5a>
      {    
        hrng->State = HAL_RNG_STATE_ERROR;
 8014828:	687b      	ldr	r3, [r7, #4]
 801482a:	2204      	movs	r2, #4
 801482c:	715a      	strb	r2, [r3, #5]

        /* Process Unlocked */
        __HAL_UNLOCK(hrng);
 801482e:	687b      	ldr	r3, [r7, #4]
 8014830:	2200      	movs	r2, #0
 8014832:	711a      	strb	r2, [r3, #4]
      
        return HAL_TIMEOUT;
 8014834:	2303      	movs	r3, #3
 8014836:	e019      	b.n	801486c <HAL_RNG_GenerateRandomNumber+0x8e>
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8014838:	687b      	ldr	r3, [r7, #4]
 801483a:	681b      	ldr	r3, [r3, #0]
 801483c:	685b      	ldr	r3, [r3, #4]
 801483e:	f003 0301 	and.w	r3, r3, #1
 8014842:	2b01      	cmp	r3, #1
 8014844:	d1e9      	bne.n	801481a <HAL_RNG_GenerateRandomNumber+0x3c>
      } 
    }
  
    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8014846:	687b      	ldr	r3, [r7, #4]
 8014848:	681b      	ldr	r3, [r3, #0]
 801484a:	689a      	ldr	r2, [r3, #8]
 801484c:	687b      	ldr	r3, [r7, #4]
 801484e:	609a      	str	r2, [r3, #8]
    *random32bit = hrng->RandomNumber;
 8014850:	687b      	ldr	r3, [r7, #4]
 8014852:	689a      	ldr	r2, [r3, #8]
 8014854:	683b      	ldr	r3, [r7, #0]
 8014856:	601a      	str	r2, [r3, #0]
  
    hrng->State = HAL_RNG_STATE_READY;
 8014858:	687b      	ldr	r3, [r7, #4]
 801485a:	2201      	movs	r2, #1
 801485c:	715a      	strb	r2, [r3, #5]
 801485e:	e001      	b.n	8014864 <HAL_RNG_GenerateRandomNumber+0x86>
  }
  else
  {
    status = HAL_ERROR;
 8014860:	2301      	movs	r3, #1
 8014862:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8014864:	687b      	ldr	r3, [r7, #4]
 8014866:	2200      	movs	r2, #0
 8014868:	711a      	strb	r2, [r3, #4]
  
  return status;
 801486a:	7bfb      	ldrb	r3, [r7, #15]
}
 801486c:	4618      	mov	r0, r3
 801486e:	3710      	adds	r7, #16
 8014870:	46bd      	mov	sp, r7
 8014872:	bd80      	pop	{r7, pc}

08014874 <HAL_SD_Init>:
  * @param  hsd: SD handle
  * @param  SDCardInfo: HAL_SD_CardInfoTypedef structure for SD card information   
  * @retval HAL SD error state
  */
HAL_SD_ErrorTypedef HAL_SD_Init(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *SDCardInfo)
{ 
 8014874:	b5b0      	push	{r4, r5, r7, lr}
 8014876:	b08e      	sub	sp, #56	; 0x38
 8014878:	af04      	add	r7, sp, #16
 801487a:	6078      	str	r0, [r7, #4]
 801487c:	6039      	str	r1, [r7, #0]
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK;
 801487e:	2300      	movs	r3, #0
 8014880:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  SD_InitTypeDef tmpinit;
  
  /* Allocate lock resource and initialize it */
  hsd->Lock = HAL_UNLOCKED;
 8014884:	687b      	ldr	r3, [r7, #4]
 8014886:	2200      	movs	r2, #0
 8014888:	771a      	strb	r2, [r3, #28]
  /* Initialize the low level hardware (MSP) */
  HAL_SD_MspInit(hsd);
 801488a:	6878      	ldr	r0, [r7, #4]
 801488c:	f7fb fdd6 	bl	801043c <HAL_SD_MspInit>
  
  /* Default SDIO peripheral configuration for SD card initialization */
  tmpinit.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 8014890:	2300      	movs	r3, #0
 8014892:	60fb      	str	r3, [r7, #12]
  tmpinit.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 8014894:	2300      	movs	r3, #0
 8014896:	613b      	str	r3, [r7, #16]
  tmpinit.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8014898:	2300      	movs	r3, #0
 801489a:	617b      	str	r3, [r7, #20]
  tmpinit.BusWide             = SDIO_BUS_WIDE_1B;
 801489c:	2300      	movs	r3, #0
 801489e:	61bb      	str	r3, [r7, #24]
  tmpinit.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 80148a0:	2300      	movs	r3, #0
 80148a2:	61fb      	str	r3, [r7, #28]
  tmpinit.ClockDiv            = SDIO_INIT_CLK_DIV;
 80148a4:	2376      	movs	r3, #118	; 0x76
 80148a6:	623b      	str	r3, [r7, #32]
  
  /* Initialize SDIO peripheral interface with default configuration */
  SDIO_Init(hsd->Instance, tmpinit);
 80148a8:	687b      	ldr	r3, [r7, #4]
 80148aa:	681d      	ldr	r5, [r3, #0]
 80148ac:	466c      	mov	r4, sp
 80148ae:	f107 0318 	add.w	r3, r7, #24
 80148b2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80148b6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80148ba:	f107 030c 	add.w	r3, r7, #12
 80148be:	cb0e      	ldmia	r3, {r1, r2, r3}
 80148c0:	4628      	mov	r0, r5
 80148c2:	f002 fef5 	bl	80176b0 <SDIO_Init>
  
  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd); 
 80148c6:	6878      	ldr	r0, [r7, #4]
 80148c8:	f001 f86c 	bl	80159a4 <SD_PowerON>
 80148cc:	4603      	mov	r3, r0
 80148ce:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  if(errorstate != SD_OK)     
 80148d2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80148d6:	b2db      	uxtb	r3, r3
 80148d8:	2b00      	cmp	r3, #0
 80148da:	d003      	beq.n	80148e4 <HAL_SD_Init+0x70>
  {
    return errorstate;
 80148dc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80148e0:	b2db      	uxtb	r3, r3
 80148e2:	e039      	b.n	8014958 <HAL_SD_Init+0xe4>
  }
  
  /* Initialize the present SDIO card(s) and put them in idle state */
  errorstate = SD_Initialize_Cards(hsd);
 80148e4:	6878      	ldr	r0, [r7, #4]
 80148e6:	f000 ff70 	bl	80157ca <SD_Initialize_Cards>
 80148ea:	4603      	mov	r3, r0
 80148ec:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  if (errorstate != SD_OK)
 80148f0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80148f4:	b2db      	uxtb	r3, r3
 80148f6:	2b00      	cmp	r3, #0
 80148f8:	d003      	beq.n	8014902 <HAL_SD_Init+0x8e>
  {
    return errorstate;
 80148fa:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80148fe:	b2db      	uxtb	r3, r3
 8014900:	e02a      	b.n	8014958 <HAL_SD_Init+0xe4>
  }
  
  /* Read CSD/CID MSD registers */
  errorstate = HAL_SD_Get_CardInfo(hsd, SDCardInfo);
 8014902:	6839      	ldr	r1, [r7, #0]
 8014904:	6878      	ldr	r0, [r7, #4]
 8014906:	f000 fb3e 	bl	8014f86 <HAL_SD_Get_CardInfo>
 801490a:	4603      	mov	r3, r0
 801490c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  if (errorstate == SD_OK)
 8014910:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8014914:	b2db      	uxtb	r3, r3
 8014916:	2b00      	cmp	r3, #0
 8014918:	d10d      	bne.n	8014936 <HAL_SD_Init+0xc2>
  {
    /* Select the Card */
    errorstate = SD_Select_Deselect(hsd, (uint32_t)(((uint32_t)SDCardInfo->RCA) << 16U));
 801491a:	683b      	ldr	r3, [r7, #0]
 801491c:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 8014920:	041b      	lsls	r3, r3, #16
 8014922:	f04f 0400 	mov.w	r4, #0
 8014926:	461a      	mov	r2, r3
 8014928:	4623      	mov	r3, r4
 801492a:	6878      	ldr	r0, [r7, #4]
 801492c:	f001 f810 	bl	8015950 <SD_Select_Deselect>
 8014930:	4603      	mov	r3, r0
 8014932:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }
  
  /* Configure SDIO peripheral interface */
  SDIO_Init(hsd->Instance, hsd->Init);   
 8014936:	687b      	ldr	r3, [r7, #4]
 8014938:	681d      	ldr	r5, [r3, #0]
 801493a:	687b      	ldr	r3, [r7, #4]
 801493c:	466c      	mov	r4, sp
 801493e:	f103 0210 	add.w	r2, r3, #16
 8014942:	ca07      	ldmia	r2, {r0, r1, r2}
 8014944:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8014948:	3304      	adds	r3, #4
 801494a:	cb0e      	ldmia	r3, {r1, r2, r3}
 801494c:	4628      	mov	r0, r5
 801494e:	f002 feaf 	bl	80176b0 <SDIO_Init>
  
  return errorstate;
 8014952:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8014956:	b2db      	uxtb	r3, r3
}
 8014958:	4618      	mov	r0, r3
 801495a:	3728      	adds	r7, #40	; 0x28
 801495c:	46bd      	mov	sp, r7
 801495e:	bdb0      	pop	{r4, r5, r7, pc}

08014960 <HAL_SD_ReadBlocks_DMA>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of blocks to read.
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pReadBuffer, uint64_t ReadAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8014960:	b590      	push	{r4, r7, lr}
 8014962:	b091      	sub	sp, #68	; 0x44
 8014964:	af00      	add	r7, sp, #0
 8014966:	60f8      	str	r0, [r7, #12]
 8014968:	60b9      	str	r1, [r7, #8]
 801496a:	e9c7 2300 	strd	r2, r3, [r7]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 801496e:	2300      	movs	r3, #0
 8014970:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8014974:	68fb      	ldr	r3, [r7, #12]
 8014976:	681b      	ldr	r3, [r3, #0]
 8014978:	2200      	movs	r2, #0
 801497a:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Initialize handle flags */
  hsd->SdTransferCplt  = 0U;
 801497c:	68fb      	ldr	r3, [r7, #12]
 801497e:	2200      	movs	r2, #0
 8014980:	649a      	str	r2, [r3, #72]	; 0x48
  hsd->DmaTransferCplt = 0U;
 8014982:	68fb      	ldr	r3, [r7, #12]
 8014984:	2200      	movs	r2, #0
 8014986:	651a      	str	r2, [r3, #80]	; 0x50
  hsd->SdTransferErr   = SD_OK; 
 8014988:	68fb      	ldr	r3, [r7, #12]
 801498a:	2200      	movs	r2, #0
 801498c:	64da      	str	r2, [r3, #76]	; 0x4c
  
  /* Initialize SD Read operation */
  if(NumberOfBlocks > 1U)
 801498e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014990:	2b01      	cmp	r3, #1
 8014992:	d903      	bls.n	801499c <HAL_SD_ReadBlocks_DMA+0x3c>
  {
    hsd->SdOperation = SD_READ_MULTIPLE_BLOCK;
 8014994:	68fb      	ldr	r3, [r7, #12]
 8014996:	2201      	movs	r2, #1
 8014998:	655a      	str	r2, [r3, #84]	; 0x54
 801499a:	e002      	b.n	80149a2 <HAL_SD_ReadBlocks_DMA+0x42>
  }
  else
  {
    hsd->SdOperation = SD_READ_SINGLE_BLOCK;
 801499c:	68fb      	ldr	r3, [r7, #12]
 801499e:	2200      	movs	r2, #0
 80149a0:	655a      	str	r2, [r3, #84]	; 0x54
  }
  
  /* Enable transfer interrupts */
#ifdef SDIO_STA_STBITERR
  __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
 80149a2:	68fb      	ldr	r3, [r7, #12]
 80149a4:	681b      	ldr	r3, [r3, #0]
 80149a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80149a8:	68fa      	ldr	r2, [r7, #12]
 80149aa:	6812      	ldr	r2, [r2, #0]
 80149ac:	f443 734a 	orr.w	r3, r3, #808	; 0x328
 80149b0:	f043 0302 	orr.w	r3, r3, #2
 80149b4:	63d3      	str	r3, [r2, #60]	; 0x3c
                                SDIO_IT_DATAEND  |\
                                SDIO_IT_RXOVERR));
#endif /* SDIO_STA_STBITERR */
  
  /* Enable SDIO DMA transfer */
  __HAL_SD_SDIO_DMA_ENABLE();
 80149b6:	4b4a      	ldr	r3, [pc, #296]	; (8014ae0 <HAL_SD_ReadBlocks_DMA+0x180>)
 80149b8:	2201      	movs	r2, #1
 80149ba:	601a      	str	r2, [r3, #0]
  
  /* Configure DMA user callbacks */
  hsd->hdmarx->XferCpltCallback  = SD_DMA_RxCplt;
 80149bc:	68fb      	ldr	r3, [r7, #12]
 80149be:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80149c0:	4a48      	ldr	r2, [pc, #288]	; (8014ae4 <HAL_SD_ReadBlocks_DMA+0x184>)
 80149c2:	63da      	str	r2, [r3, #60]	; 0x3c
  hsd->hdmarx->XferErrorCallback = SD_DMA_RxError;
 80149c4:	68fb      	ldr	r3, [r7, #12]
 80149c6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80149c8:	4a47      	ldr	r2, [pc, #284]	; (8014ae8 <HAL_SD_ReadBlocks_DMA+0x188>)
 80149ca:	649a      	str	r2, [r3, #72]	; 0x48
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pReadBuffer, (uint32_t)(BlockSize * NumberOfBlocks)/4);
 80149cc:	68fb      	ldr	r3, [r7, #12]
 80149ce:	6d98      	ldr	r0, [r3, #88]	; 0x58
 80149d0:	68fb      	ldr	r3, [r7, #12]
 80149d2:	681b      	ldr	r3, [r3, #0]
 80149d4:	3380      	adds	r3, #128	; 0x80
 80149d6:	461c      	mov	r4, r3
 80149d8:	68b9      	ldr	r1, [r7, #8]
 80149da:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80149dc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80149de:	fb02 f303 	mul.w	r3, r2, r3
 80149e2:	089b      	lsrs	r3, r3, #2
 80149e4:	460a      	mov	r2, r1
 80149e6:	4621      	mov	r1, r4
 80149e8:	f7fd f9ee 	bl	8011dc8 <HAL_DMA_Start_IT>
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 80149ec:	68fb      	ldr	r3, [r7, #12]
 80149ee:	6a1b      	ldr	r3, [r3, #32]
 80149f0:	2b02      	cmp	r3, #2
 80149f2:	d10e      	bne.n	8014a12 <HAL_SD_ReadBlocks_DMA+0xb2>
  {
    BlockSize = 512U;
 80149f4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80149f8:	653b      	str	r3, [r7, #80]	; 0x50
    ReadAddr /= 512U;
 80149fa:	e9d7 1200 	ldrd	r1, r2, [r7]
 80149fe:	f04f 0300 	mov.w	r3, #0
 8014a02:	f04f 0400 	mov.w	r4, #0
 8014a06:	0a4b      	lsrs	r3, r1, #9
 8014a08:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8014a0c:	0a54      	lsrs	r4, r2, #9
 8014a0e:	e9c7 3400 	strd	r3, r4, [r7]
  }
  
  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 8014a12:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014a14:	62bb      	str	r3, [r7, #40]	; 0x28
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8014a16:	2310      	movs	r3, #16
 8014a18:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8014a1a:	2340      	movs	r3, #64	; 0x40
 8014a1c:	633b      	str	r3, [r7, #48]	; 0x30
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8014a1e:	2300      	movs	r3, #0
 8014a20:	637b      	str	r3, [r7, #52]	; 0x34
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8014a22:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014a26:	63bb      	str	r3, [r7, #56]	; 0x38
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8014a28:	68fb      	ldr	r3, [r7, #12]
 8014a2a:	681b      	ldr	r3, [r3, #0]
 8014a2c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8014a30:	4611      	mov	r1, r2
 8014a32:	4618      	mov	r0, r3
 8014a34:	f002 fe90 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 8014a38:	2110      	movs	r1, #16
 8014a3a:	68f8      	ldr	r0, [r7, #12]
 8014a3c:	f001 f964 	bl	8015d08 <SD_CmdResp1Error>
 8014a40:	4603      	mov	r3, r0
 8014a42:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  
  if (errorstate != SD_OK)
 8014a46:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014a4a:	2b00      	cmp	r3, #0
 8014a4c:	d002      	beq.n	8014a54 <HAL_SD_ReadBlocks_DMA+0xf4>
  {
    return errorstate;
 8014a4e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014a52:	e041      	b.n	8014ad8 <HAL_SD_ReadBlocks_DMA+0x178>
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8014a54:	f04f 33ff 	mov.w	r3, #4294967295
 8014a58:	613b      	str	r3, [r7, #16]
  sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
 8014a5a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014a5c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014a5e:	fb02 f303 	mul.w	r3, r2, r3
 8014a62:	617b      	str	r3, [r7, #20]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8014a64:	2390      	movs	r3, #144	; 0x90
 8014a66:	61bb      	str	r3, [r7, #24]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8014a68:	2302      	movs	r3, #2
 8014a6a:	61fb      	str	r3, [r7, #28]
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8014a6c:	2300      	movs	r3, #0
 8014a6e:	623b      	str	r3, [r7, #32]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8014a70:	2301      	movs	r3, #1
 8014a72:	627b      	str	r3, [r7, #36]	; 0x24
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8014a74:	68fb      	ldr	r3, [r7, #12]
 8014a76:	681b      	ldr	r3, [r3, #0]
 8014a78:	f107 0210 	add.w	r2, r7, #16
 8014a7c:	4611      	mov	r1, r2
 8014a7e:	4618      	mov	r0, r3
 8014a80:	f002 feb6 	bl	80177f0 <SDIO_DataConfig>
  
  /* Check number of blocks command */
  if(NumberOfBlocks > 1U)
 8014a84:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014a86:	2b01      	cmp	r3, #1
 8014a88:	d902      	bls.n	8014a90 <HAL_SD_ReadBlocks_DMA+0x130>
  {
    /* Send CMD18 READ_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_MULT_BLOCK;
 8014a8a:	2312      	movs	r3, #18
 8014a8c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014a8e:	e001      	b.n	8014a94 <HAL_SD_ReadBlocks_DMA+0x134>
  }
  else
  {
    /* Send CMD17 READ_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_READ_SINGLE_BLOCK;
 8014a90:	2311      	movs	r3, #17
 8014a92:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  
  sdio_cmdinitstructure.Argument = (uint32_t)ReadAddr;
 8014a94:	683b      	ldr	r3, [r7, #0]
 8014a96:	62bb      	str	r3, [r7, #40]	; 0x28
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8014a98:	68fb      	ldr	r3, [r7, #12]
 8014a9a:	681b      	ldr	r3, [r3, #0]
 8014a9c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8014aa0:	4611      	mov	r1, r2
 8014aa2:	4618      	mov	r0, r3
 8014aa4:	f002 fe58 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 8014aa8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014aaa:	2b01      	cmp	r3, #1
 8014aac:	d907      	bls.n	8014abe <HAL_SD_ReadBlocks_DMA+0x15e>
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_MULT_BLOCK);
 8014aae:	2112      	movs	r1, #18
 8014ab0:	68f8      	ldr	r0, [r7, #12]
 8014ab2:	f001 f929 	bl	8015d08 <SD_CmdResp1Error>
 8014ab6:	4603      	mov	r3, r0
 8014ab8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 8014abc:	e006      	b.n	8014acc <HAL_SD_ReadBlocks_DMA+0x16c>
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_READ_SINGLE_BLOCK);
 8014abe:	2111      	movs	r1, #17
 8014ac0:	68f8      	ldr	r0, [r7, #12]
 8014ac2:	f001 f921 	bl	8015d08 <SD_CmdResp1Error>
 8014ac6:	4603      	mov	r3, r0
 8014ac8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  }
  
  /* Update the SD transfer error in SD handle */
  hsd->SdTransferErr = errorstate;
 8014acc:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 8014ad0:	68fb      	ldr	r3, [r7, #12]
 8014ad2:	64da      	str	r2, [r3, #76]	; 0x4c
  
  return errorstate;
 8014ad4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
 8014ad8:	4618      	mov	r0, r3
 8014ada:	3744      	adds	r7, #68	; 0x44
 8014adc:	46bd      	mov	sp, r7
 8014ade:	bd90      	pop	{r4, r7, pc}
 8014ae0:	4225858c 	.word	0x4225858c
 8014ae4:	080156e9 	.word	0x080156e9
 8014ae8:	0801571f 	.word	0x0801571f

08014aec <HAL_SD_WriteBlocks_DMA>:
  * @note   BlockSize must be 512 bytes.
  * @param  NumberOfBlocks: Number of blocks to write
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWriteBuffer, uint64_t WriteAddr, uint32_t BlockSize, uint32_t NumberOfBlocks)
{
 8014aec:	b590      	push	{r4, r7, lr}
 8014aee:	b091      	sub	sp, #68	; 0x44
 8014af0:	af00      	add	r7, sp, #0
 8014af2:	60f8      	str	r0, [r7, #12]
 8014af4:	60b9      	str	r1, [r7, #8]
 8014af6:	e9c7 2300 	strd	r2, r3, [r7]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8014afa:	2300      	movs	r3, #0
 8014afc:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  
  /* Initialize data control register */
  hsd->Instance->DCTRL = 0U;
 8014b00:	68fb      	ldr	r3, [r7, #12]
 8014b02:	681b      	ldr	r3, [r3, #0]
 8014b04:	2200      	movs	r2, #0
 8014b06:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Initialize handle flags */
  hsd->SdTransferCplt  = 0U;
 8014b08:	68fb      	ldr	r3, [r7, #12]
 8014b0a:	2200      	movs	r2, #0
 8014b0c:	649a      	str	r2, [r3, #72]	; 0x48
  hsd->DmaTransferCplt = 0U;
 8014b0e:	68fb      	ldr	r3, [r7, #12]
 8014b10:	2200      	movs	r2, #0
 8014b12:	651a      	str	r2, [r3, #80]	; 0x50
  hsd->SdTransferErr   = SD_OK;
 8014b14:	68fb      	ldr	r3, [r7, #12]
 8014b16:	2200      	movs	r2, #0
 8014b18:	64da      	str	r2, [r3, #76]	; 0x4c
  
  /* Initialize SD Write operation */
  if(NumberOfBlocks > 1U)
 8014b1a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014b1c:	2b01      	cmp	r3, #1
 8014b1e:	d903      	bls.n	8014b28 <HAL_SD_WriteBlocks_DMA+0x3c>
  {
    hsd->SdOperation = SD_WRITE_MULTIPLE_BLOCK;
 8014b20:	68fb      	ldr	r3, [r7, #12]
 8014b22:	2203      	movs	r2, #3
 8014b24:	655a      	str	r2, [r3, #84]	; 0x54
 8014b26:	e002      	b.n	8014b2e <HAL_SD_WriteBlocks_DMA+0x42>
  }
  else
  {
    hsd->SdOperation = SD_WRITE_SINGLE_BLOCK;
 8014b28:	68fb      	ldr	r3, [r7, #12]
 8014b2a:	2202      	movs	r2, #2
 8014b2c:	655a      	str	r2, [r3, #84]	; 0x54
  }  
  
  /* Enable transfer interrupts */
#ifdef SDIO_STA_STBITERR
  __HAL_SD_SDIO_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL |\
 8014b2e:	68fb      	ldr	r3, [r7, #12]
 8014b30:	681b      	ldr	r3, [r3, #0]
 8014b32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014b34:	68fa      	ldr	r2, [r7, #12]
 8014b36:	6812      	ldr	r2, [r2, #0]
 8014b38:	f443 7346 	orr.w	r3, r3, #792	; 0x318
 8014b3c:	f043 0302 	orr.w	r3, r3, #2
 8014b40:	63d3      	str	r3, [r2, #60]	; 0x3c
                                SDIO_IT_DATAEND  |\
                                SDIO_IT_TXUNDERR));
#endif /* SDIO_STA_STBITERR */
  
  /* Configure DMA user callbacks */
  hsd->hdmatx->XferCpltCallback  = SD_DMA_TxCplt;
 8014b42:	68fb      	ldr	r3, [r7, #12]
 8014b44:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8014b46:	4a4c      	ldr	r2, [pc, #304]	; (8014c78 <HAL_SD_WriteBlocks_DMA+0x18c>)
 8014b48:	63da      	str	r2, [r3, #60]	; 0x3c
  hsd->hdmatx->XferErrorCallback = SD_DMA_TxError;
 8014b4a:	68fb      	ldr	r3, [r7, #12]
 8014b4c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8014b4e:	4a4b      	ldr	r2, [pc, #300]	; (8014c7c <HAL_SD_WriteBlocks_DMA+0x190>)
 8014b50:	649a      	str	r2, [r3, #72]	; 0x48
  
  /* Enable the DMA Stream */
  HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pWriteBuffer, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BlockSize * NumberOfBlocks)/4);
 8014b52:	68fb      	ldr	r3, [r7, #12]
 8014b54:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 8014b56:	68b9      	ldr	r1, [r7, #8]
 8014b58:	68fb      	ldr	r3, [r7, #12]
 8014b5a:	681b      	ldr	r3, [r3, #0]
 8014b5c:	3380      	adds	r3, #128	; 0x80
 8014b5e:	461c      	mov	r4, r3
 8014b60:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014b62:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014b64:	fb02 f303 	mul.w	r3, r2, r3
 8014b68:	089b      	lsrs	r3, r3, #2
 8014b6a:	4622      	mov	r2, r4
 8014b6c:	f7fd f92c 	bl	8011dc8 <HAL_DMA_Start_IT>

  /* Enable SDIO DMA transfer */
  __HAL_SD_SDIO_DMA_ENABLE();
 8014b70:	4b43      	ldr	r3, [pc, #268]	; (8014c80 <HAL_SD_WriteBlocks_DMA+0x194>)
 8014b72:	2201      	movs	r2, #1
 8014b74:	601a      	str	r2, [r3, #0]
  
  if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 8014b76:	68fb      	ldr	r3, [r7, #12]
 8014b78:	6a1b      	ldr	r3, [r3, #32]
 8014b7a:	2b02      	cmp	r3, #2
 8014b7c:	d10e      	bne.n	8014b9c <HAL_SD_WriteBlocks_DMA+0xb0>
  {
    BlockSize = 512U;
 8014b7e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8014b82:	653b      	str	r3, [r7, #80]	; 0x50
    WriteAddr /= 512U;
 8014b84:	e9d7 1200 	ldrd	r1, r2, [r7]
 8014b88:	f04f 0300 	mov.w	r3, #0
 8014b8c:	f04f 0400 	mov.w	r4, #0
 8014b90:	0a4b      	lsrs	r3, r1, #9
 8014b92:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 8014b96:	0a54      	lsrs	r4, r2, #9
 8014b98:	e9c7 3400 	strd	r3, r4, [r7]
  }

  /* Set Block Size for Card */ 
  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
 8014b9c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014b9e:	62bb      	str	r3, [r7, #40]	; 0x28
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 8014ba0:	2310      	movs	r3, #16
 8014ba2:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8014ba4:	2340      	movs	r3, #64	; 0x40
 8014ba6:	633b      	str	r3, [r7, #48]	; 0x30
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8014ba8:	2300      	movs	r3, #0
 8014baa:	637b      	str	r3, [r7, #52]	; 0x34
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8014bac:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014bb0:	63bb      	str	r3, [r7, #56]	; 0x38
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8014bb2:	68fb      	ldr	r3, [r7, #12]
 8014bb4:	681b      	ldr	r3, [r3, #0]
 8014bb6:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8014bba:	4611      	mov	r1, r2
 8014bbc:	4618      	mov	r0, r3
 8014bbe:	f002 fdcb 	bl	8017758 <SDIO_SendCommand>

  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 8014bc2:	2110      	movs	r1, #16
 8014bc4:	68f8      	ldr	r0, [r7, #12]
 8014bc6:	f001 f89f 	bl	8015d08 <SD_CmdResp1Error>
 8014bca:	4603      	mov	r3, r0
 8014bcc:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

  if (errorstate != SD_OK)
 8014bd0:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014bd4:	2b00      	cmp	r3, #0
 8014bd6:	d002      	beq.n	8014bde <HAL_SD_WriteBlocks_DMA+0xf2>
  {
    return errorstate;
 8014bd8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014bdc:	e048      	b.n	8014c70 <HAL_SD_WriteBlocks_DMA+0x184>
  }
  
  /* Check number of blocks command */
  if(NumberOfBlocks <= 1U)
 8014bde:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014be0:	2b01      	cmp	r3, #1
 8014be2:	d802      	bhi.n	8014bea <HAL_SD_WriteBlocks_DMA+0xfe>
  {
    /* Send CMD24 WRITE_SINGLE_BLOCK */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_SINGLE_BLOCK;
 8014be4:	2318      	movs	r3, #24
 8014be6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8014be8:	e001      	b.n	8014bee <HAL_SD_WriteBlocks_DMA+0x102>
  }
  else
  {
    /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
    sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
 8014bea:	2319      	movs	r3, #25
 8014bec:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  
  sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
 8014bee:	683b      	ldr	r3, [r7, #0]
 8014bf0:	62bb      	str	r3, [r7, #40]	; 0x28
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8014bf2:	68fb      	ldr	r3, [r7, #12]
 8014bf4:	681b      	ldr	r3, [r3, #0]
 8014bf6:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8014bfa:	4611      	mov	r1, r2
 8014bfc:	4618      	mov	r0, r3
 8014bfe:	f002 fdab 	bl	8017758 <SDIO_SendCommand>

  /* Check for error conditions */
  if(NumberOfBlocks > 1U)
 8014c02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014c04:	2b01      	cmp	r3, #1
 8014c06:	d907      	bls.n	8014c18 <HAL_SD_WriteBlocks_DMA+0x12c>
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_MULT_BLOCK);
 8014c08:	2119      	movs	r1, #25
 8014c0a:	68f8      	ldr	r0, [r7, #12]
 8014c0c:	f001 f87c 	bl	8015d08 <SD_CmdResp1Error>
 8014c10:	4603      	mov	r3, r0
 8014c12:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 8014c16:	e006      	b.n	8014c26 <HAL_SD_WriteBlocks_DMA+0x13a>
  }
  else
  {
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_WRITE_SINGLE_BLOCK);
 8014c18:	2118      	movs	r1, #24
 8014c1a:	68f8      	ldr	r0, [r7, #12]
 8014c1c:	f001 f874 	bl	8015d08 <SD_CmdResp1Error>
 8014c20:	4603      	mov	r3, r0
 8014c22:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  }
  
  if (errorstate != SD_OK)
 8014c26:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014c2a:	2b00      	cmp	r3, #0
 8014c2c:	d002      	beq.n	8014c34 <HAL_SD_WriteBlocks_DMA+0x148>
  {
    return errorstate;
 8014c2e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8014c32:	e01d      	b.n	8014c70 <HAL_SD_WriteBlocks_DMA+0x184>
  }
  
  /* Configure the SD DPSM (Data Path State Machine) */ 
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 8014c34:	f04f 33ff 	mov.w	r3, #4294967295
 8014c38:	613b      	str	r3, [r7, #16]
  sdio_datainitstructure.DataLength    = BlockSize * NumberOfBlocks;
 8014c3a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014c3c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014c3e:	fb02 f303 	mul.w	r3, r2, r3
 8014c42:	617b      	str	r3, [r7, #20]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8014c44:	2390      	movs	r3, #144	; 0x90
 8014c46:	61bb      	str	r3, [r7, #24]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 8014c48:	2300      	movs	r3, #0
 8014c4a:	61fb      	str	r3, [r7, #28]
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8014c4c:	2300      	movs	r3, #0
 8014c4e:	623b      	str	r3, [r7, #32]
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 8014c50:	2301      	movs	r3, #1
 8014c52:	627b      	str	r3, [r7, #36]	; 0x24
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 8014c54:	68fb      	ldr	r3, [r7, #12]
 8014c56:	681b      	ldr	r3, [r3, #0]
 8014c58:	f107 0210 	add.w	r2, r7, #16
 8014c5c:	4611      	mov	r1, r2
 8014c5e:	4618      	mov	r0, r3
 8014c60:	f002 fdc6 	bl	80177f0 <SDIO_DataConfig>
  
  hsd->SdTransferErr = errorstate;
 8014c64:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 8014c68:	68fb      	ldr	r3, [r7, #12]
 8014c6a:	64da      	str	r2, [r3, #76]	; 0x4c
  
  return errorstate;
 8014c6c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
 8014c70:	4618      	mov	r0, r3
 8014c72:	3744      	adds	r7, #68	; 0x44
 8014c74:	46bd      	mov	sp, r7
 8014c76:	bd90      	pop	{r4, r7, pc}
 8014c78:	0801573f 	.word	0x0801573f
 8014c7c:	08015775 	.word	0x08015775
 8014c80:	4225858c 	.word	0x4225858c

08014c84 <HAL_SD_CheckReadOperation>:
  * @param  hsd: SD handle
  * @param  Timeout: Timeout duration  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_CheckReadOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
{
 8014c84:	b580      	push	{r7, lr}
 8014c86:	b088      	sub	sp, #32
 8014c88:	af00      	add	r7, sp, #0
 8014c8a:	6078      	str	r0, [r7, #4]
 8014c8c:	6039      	str	r1, [r7, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8014c8e:	2300      	movs	r3, #0
 8014c90:	77fb      	strb	r3, [r7, #31]
  uint32_t timeout = Timeout;
 8014c92:	683b      	ldr	r3, [r7, #0]
 8014c94:	61bb      	str	r3, [r7, #24]
  uint32_t tmp1, tmp2;
  HAL_SD_ErrorTypedef tmp3;
  
  /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
  tmp1 = hsd->DmaTransferCplt; 
 8014c96:	687b      	ldr	r3, [r7, #4]
 8014c98:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014c9a:	617b      	str	r3, [r7, #20]
  tmp2 = hsd->SdTransferCplt;
 8014c9c:	687b      	ldr	r3, [r7, #4]
 8014c9e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014ca0:	613b      	str	r3, [r7, #16]
  tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
 8014ca2:	687b      	ldr	r3, [r7, #4]
 8014ca4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014ca6:	73fb      	strb	r3, [r7, #15]
    
  while ((tmp1 == 0U) && (tmp2 == 0U) && (tmp3 == SD_OK) && (timeout > 0U))
 8014ca8:	e00b      	b.n	8014cc2 <HAL_SD_CheckReadOperation+0x3e>
  {
    tmp1 = hsd->DmaTransferCplt; 
 8014caa:	687b      	ldr	r3, [r7, #4]
 8014cac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014cae:	617b      	str	r3, [r7, #20]
    tmp2 = hsd->SdTransferCplt;
 8014cb0:	687b      	ldr	r3, [r7, #4]
 8014cb2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014cb4:	613b      	str	r3, [r7, #16]
    tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;    
 8014cb6:	687b      	ldr	r3, [r7, #4]
 8014cb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014cba:	73fb      	strb	r3, [r7, #15]
    timeout--;
 8014cbc:	69bb      	ldr	r3, [r7, #24]
 8014cbe:	3b01      	subs	r3, #1
 8014cc0:	61bb      	str	r3, [r7, #24]
  while ((tmp1 == 0U) && (tmp2 == 0U) && (tmp3 == SD_OK) && (timeout > 0U))
 8014cc2:	697b      	ldr	r3, [r7, #20]
 8014cc4:	2b00      	cmp	r3, #0
 8014cc6:	d108      	bne.n	8014cda <HAL_SD_CheckReadOperation+0x56>
 8014cc8:	693b      	ldr	r3, [r7, #16]
 8014cca:	2b00      	cmp	r3, #0
 8014ccc:	d105      	bne.n	8014cda <HAL_SD_CheckReadOperation+0x56>
 8014cce:	7bfb      	ldrb	r3, [r7, #15]
 8014cd0:	2b00      	cmp	r3, #0
 8014cd2:	d102      	bne.n	8014cda <HAL_SD_CheckReadOperation+0x56>
 8014cd4:	69bb      	ldr	r3, [r7, #24]
 8014cd6:	2b00      	cmp	r3, #0
 8014cd8:	d1e7      	bne.n	8014caa <HAL_SD_CheckReadOperation+0x26>
  }
  
  timeout = Timeout;
 8014cda:	683b      	ldr	r3, [r7, #0]
 8014cdc:	61bb      	str	r3, [r7, #24]
  
  /* Wait until the Rx transfer is no longer active */
  while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXACT)) && (timeout > 0U))
 8014cde:	e002      	b.n	8014ce6 <HAL_SD_CheckReadOperation+0x62>
  {
    timeout--;  
 8014ce0:	69bb      	ldr	r3, [r7, #24]
 8014ce2:	3b01      	subs	r3, #1
 8014ce4:	61bb      	str	r3, [r7, #24]
  while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXACT)) && (timeout > 0U))
 8014ce6:	687b      	ldr	r3, [r7, #4]
 8014ce8:	681b      	ldr	r3, [r3, #0]
 8014cea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014cec:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8014cf0:	2b00      	cmp	r3, #0
 8014cf2:	d002      	beq.n	8014cfa <HAL_SD_CheckReadOperation+0x76>
 8014cf4:	69bb      	ldr	r3, [r7, #24]
 8014cf6:	2b00      	cmp	r3, #0
 8014cf8:	d1f2      	bne.n	8014ce0 <HAL_SD_CheckReadOperation+0x5c>
  }
  
  /* Send stop command in multiblock read */
  if (hsd->SdOperation == SD_READ_MULTIPLE_BLOCK)
 8014cfa:	687b      	ldr	r3, [r7, #4]
 8014cfc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014cfe:	2b01      	cmp	r3, #1
 8014d00:	d104      	bne.n	8014d0c <HAL_SD_CheckReadOperation+0x88>
  {
    errorstate = HAL_SD_StopTransfer(hsd);
 8014d02:	6878      	ldr	r0, [r7, #4]
 8014d04:	f000 fcb2 	bl	801566c <HAL_SD_StopTransfer>
 8014d08:	4603      	mov	r3, r0
 8014d0a:	77fb      	strb	r3, [r7, #31]
  }
  
  if ((timeout == 0U) && (errorstate == SD_OK))
 8014d0c:	69bb      	ldr	r3, [r7, #24]
 8014d0e:	2b00      	cmp	r3, #0
 8014d10:	d104      	bne.n	8014d1c <HAL_SD_CheckReadOperation+0x98>
 8014d12:	7ffb      	ldrb	r3, [r7, #31]
 8014d14:	2b00      	cmp	r3, #0
 8014d16:	d101      	bne.n	8014d1c <HAL_SD_CheckReadOperation+0x98>
  {
    errorstate = SD_DATA_TIMEOUT;
 8014d18:	2304      	movs	r3, #4
 8014d1a:	77fb      	strb	r3, [r7, #31]
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8014d1c:	687b      	ldr	r3, [r7, #4]
 8014d1e:	681b      	ldr	r3, [r3, #0]
 8014d20:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8014d24:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Return error state */
  if (hsd->SdTransferErr != SD_OK)
 8014d26:	687b      	ldr	r3, [r7, #4]
 8014d28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014d2a:	2b00      	cmp	r3, #0
 8014d2c:	d003      	beq.n	8014d36 <HAL_SD_CheckReadOperation+0xb2>
  {
    return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
 8014d2e:	687b      	ldr	r3, [r7, #4]
 8014d30:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014d32:	b2db      	uxtb	r3, r3
 8014d34:	e000      	b.n	8014d38 <HAL_SD_CheckReadOperation+0xb4>
  }
  
  return errorstate;
 8014d36:	7ffb      	ldrb	r3, [r7, #31]
}
 8014d38:	4618      	mov	r0, r3
 8014d3a:	3720      	adds	r7, #32
 8014d3c:	46bd      	mov	sp, r7
 8014d3e:	bd80      	pop	{r7, pc}

08014d40 <HAL_SD_CheckWriteOperation>:
  * @param  hsd: SD handle
  * @param  Timeout: Timeout duration  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_CheckWriteOperation(SD_HandleTypeDef *hsd, uint32_t Timeout)
{
 8014d40:	b580      	push	{r7, lr}
 8014d42:	b088      	sub	sp, #32
 8014d44:	af00      	add	r7, sp, #0
 8014d46:	6078      	str	r0, [r7, #4]
 8014d48:	6039      	str	r1, [r7, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8014d4a:	2300      	movs	r3, #0
 8014d4c:	77fb      	strb	r3, [r7, #31]
  uint32_t timeout = Timeout;
 8014d4e:	683b      	ldr	r3, [r7, #0]
 8014d50:	61bb      	str	r3, [r7, #24]
  uint32_t tmp1, tmp2;
  HAL_SD_ErrorTypedef tmp3;

  /* Wait for DMA/SD transfer end or SD error variables to be in SD handle */
  tmp1 = hsd->DmaTransferCplt; 
 8014d52:	687b      	ldr	r3, [r7, #4]
 8014d54:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014d56:	617b      	str	r3, [r7, #20]
  tmp2 = hsd->SdTransferCplt;
 8014d58:	687b      	ldr	r3, [r7, #4]
 8014d5a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014d5c:	613b      	str	r3, [r7, #16]
  tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
 8014d5e:	687b      	ldr	r3, [r7, #4]
 8014d60:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014d62:	73fb      	strb	r3, [r7, #15]
    
  while ((tmp1 == 0U) && (tmp2 == 0U) && (tmp3 == SD_OK) && (timeout > 0U))
 8014d64:	e00b      	b.n	8014d7e <HAL_SD_CheckWriteOperation+0x3e>
  {
    tmp1 = hsd->DmaTransferCplt; 
 8014d66:	687b      	ldr	r3, [r7, #4]
 8014d68:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8014d6a:	617b      	str	r3, [r7, #20]
    tmp2 = hsd->SdTransferCplt;
 8014d6c:	687b      	ldr	r3, [r7, #4]
 8014d6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8014d70:	613b      	str	r3, [r7, #16]
    tmp3 = (HAL_SD_ErrorTypedef)hsd->SdTransferErr;
 8014d72:	687b      	ldr	r3, [r7, #4]
 8014d74:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014d76:	73fb      	strb	r3, [r7, #15]
    timeout--;
 8014d78:	69bb      	ldr	r3, [r7, #24]
 8014d7a:	3b01      	subs	r3, #1
 8014d7c:	61bb      	str	r3, [r7, #24]
  while ((tmp1 == 0U) && (tmp2 == 0U) && (tmp3 == SD_OK) && (timeout > 0U))
 8014d7e:	697b      	ldr	r3, [r7, #20]
 8014d80:	2b00      	cmp	r3, #0
 8014d82:	d108      	bne.n	8014d96 <HAL_SD_CheckWriteOperation+0x56>
 8014d84:	693b      	ldr	r3, [r7, #16]
 8014d86:	2b00      	cmp	r3, #0
 8014d88:	d105      	bne.n	8014d96 <HAL_SD_CheckWriteOperation+0x56>
 8014d8a:	7bfb      	ldrb	r3, [r7, #15]
 8014d8c:	2b00      	cmp	r3, #0
 8014d8e:	d102      	bne.n	8014d96 <HAL_SD_CheckWriteOperation+0x56>
 8014d90:	69bb      	ldr	r3, [r7, #24]
 8014d92:	2b00      	cmp	r3, #0
 8014d94:	d1e7      	bne.n	8014d66 <HAL_SD_CheckWriteOperation+0x26>
  }
  
  timeout = Timeout;
 8014d96:	683b      	ldr	r3, [r7, #0]
 8014d98:	61bb      	str	r3, [r7, #24]
  
  /* Wait until the Tx transfer is no longer active */
  while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXACT))  && (timeout > 0U))
 8014d9a:	e002      	b.n	8014da2 <HAL_SD_CheckWriteOperation+0x62>
  {
    timeout--;  
 8014d9c:	69bb      	ldr	r3, [r7, #24]
 8014d9e:	3b01      	subs	r3, #1
 8014da0:	61bb      	str	r3, [r7, #24]
  while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_TXACT))  && (timeout > 0U))
 8014da2:	687b      	ldr	r3, [r7, #4]
 8014da4:	681b      	ldr	r3, [r3, #0]
 8014da6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014da8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8014dac:	2b00      	cmp	r3, #0
 8014dae:	d002      	beq.n	8014db6 <HAL_SD_CheckWriteOperation+0x76>
 8014db0:	69bb      	ldr	r3, [r7, #24]
 8014db2:	2b00      	cmp	r3, #0
 8014db4:	d1f2      	bne.n	8014d9c <HAL_SD_CheckWriteOperation+0x5c>
  }

  /* Send stop command in multiblock write */
  if (hsd->SdOperation == SD_WRITE_MULTIPLE_BLOCK)
 8014db6:	687b      	ldr	r3, [r7, #4]
 8014db8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8014dba:	2b03      	cmp	r3, #3
 8014dbc:	d104      	bne.n	8014dc8 <HAL_SD_CheckWriteOperation+0x88>
  {
    errorstate = HAL_SD_StopTransfer(hsd);
 8014dbe:	6878      	ldr	r0, [r7, #4]
 8014dc0:	f000 fc54 	bl	801566c <HAL_SD_StopTransfer>
 8014dc4:	4603      	mov	r3, r0
 8014dc6:	77fb      	strb	r3, [r7, #31]
  }
  
  if ((timeout == 0U) && (errorstate == SD_OK))
 8014dc8:	69bb      	ldr	r3, [r7, #24]
 8014dca:	2b00      	cmp	r3, #0
 8014dcc:	d104      	bne.n	8014dd8 <HAL_SD_CheckWriteOperation+0x98>
 8014dce:	7ffb      	ldrb	r3, [r7, #31]
 8014dd0:	2b00      	cmp	r3, #0
 8014dd2:	d101      	bne.n	8014dd8 <HAL_SD_CheckWriteOperation+0x98>
  {
    errorstate = SD_DATA_TIMEOUT;
 8014dd4:	2304      	movs	r3, #4
 8014dd6:	77fb      	strb	r3, [r7, #31]
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8014dd8:	687b      	ldr	r3, [r7, #4]
 8014dda:	681b      	ldr	r3, [r3, #0]
 8014ddc:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8014de0:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Return error state */
  if (hsd->SdTransferErr != SD_OK)
 8014de2:	687b      	ldr	r3, [r7, #4]
 8014de4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014de6:	2b00      	cmp	r3, #0
 8014de8:	d003      	beq.n	8014df2 <HAL_SD_CheckWriteOperation+0xb2>
  {
    return (HAL_SD_ErrorTypedef)(hsd->SdTransferErr);
 8014dea:	687b      	ldr	r3, [r7, #4]
 8014dec:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8014dee:	b2db      	uxtb	r3, r3
 8014df0:	e007      	b.n	8014e02 <HAL_SD_CheckWriteOperation+0xc2>
  }
  
  /* Wait until write is complete */
  while(HAL_SD_GetStatus(hsd) != SD_TRANSFER_OK)
 8014df2:	bf00      	nop
 8014df4:	6878      	ldr	r0, [r7, #4]
 8014df6:	f000 fc5d 	bl	80156b4 <HAL_SD_GetStatus>
 8014dfa:	4603      	mov	r3, r0
 8014dfc:	2b00      	cmp	r3, #0
 8014dfe:	d1f9      	bne.n	8014df4 <HAL_SD_CheckWriteOperation+0xb4>
  {    
  }

  return errorstate; 
 8014e00:	7ffb      	ldrb	r3, [r7, #31]
}
 8014e02:	4618      	mov	r0, r3
 8014e04:	3720      	adds	r7, #32
 8014e06:	46bd      	mov	sp, r7
 8014e08:	bd80      	pop	{r7, pc}

08014e0a <HAL_SD_IRQHandler>:
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{  
 8014e0a:	b580      	push	{r7, lr}
 8014e0c:	b082      	sub	sp, #8
 8014e0e:	af00      	add	r7, sp, #0
 8014e10:	6078      	str	r0, [r7, #4]
  /* Check for SDIO interrupt flags */
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DATAEND))
 8014e12:	687b      	ldr	r3, [r7, #4]
 8014e14:	681b      	ldr	r3, [r3, #0]
 8014e16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014e18:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8014e1c:	2b00      	cmp	r3, #0
 8014e1e:	d00e      	beq.n	8014e3e <HAL_SD_IRQHandler+0x34>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_IT_DATAEND);  
 8014e20:	687b      	ldr	r3, [r7, #4]
 8014e22:	681b      	ldr	r3, [r3, #0]
 8014e24:	f44f 7280 	mov.w	r2, #256	; 0x100
 8014e28:	639a      	str	r2, [r3, #56]	; 0x38
      
    /* SD transfer is complete */
    hsd->SdTransferCplt = 1U;
 8014e2a:	687b      	ldr	r3, [r7, #4]
 8014e2c:	2201      	movs	r2, #1
 8014e2e:	649a      	str	r2, [r3, #72]	; 0x48

    /* No transfer error */ 
    hsd->SdTransferErr  = SD_OK;
 8014e30:	687b      	ldr	r3, [r7, #4]
 8014e32:	2200      	movs	r2, #0
 8014e34:	64da      	str	r2, [r3, #76]	; 0x4c

    HAL_SD_XferCpltCallback(hsd);  
 8014e36:	6878      	ldr	r0, [r7, #4]
 8014e38:	f000 f869 	bl	8014f0e <HAL_SD_XferCpltCallback>
 8014e3c:	e059      	b.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
  }  
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DCRCFAIL))
 8014e3e:	687b      	ldr	r3, [r7, #4]
 8014e40:	681b      	ldr	r3, [r3, #0]
 8014e42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014e44:	f003 0302 	and.w	r3, r3, #2
 8014e48:	2b00      	cmp	r3, #0
 8014e4a:	d00a      	beq.n	8014e62 <HAL_SD_IRQHandler+0x58>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 8014e4c:	687b      	ldr	r3, [r7, #4]
 8014e4e:	681b      	ldr	r3, [r3, #0]
 8014e50:	2202      	movs	r2, #2
 8014e52:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_DATA_CRC_FAIL;
 8014e54:	687b      	ldr	r3, [r7, #4]
 8014e56:	2202      	movs	r2, #2
 8014e58:	64da      	str	r2, [r3, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8014e5a:	6878      	ldr	r0, [r7, #4]
 8014e5c:	f000 f861 	bl	8014f22 <HAL_SD_XferErrorCallback>
 8014e60:	e047      	b.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
    
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_DTIMEOUT))
 8014e62:	687b      	ldr	r3, [r7, #4]
 8014e64:	681b      	ldr	r3, [r3, #0]
 8014e66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014e68:	f003 0308 	and.w	r3, r3, #8
 8014e6c:	2b00      	cmp	r3, #0
 8014e6e:	d00a      	beq.n	8014e86 <HAL_SD_IRQHandler+0x7c>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 8014e70:	687b      	ldr	r3, [r7, #4]
 8014e72:	681b      	ldr	r3, [r3, #0]
 8014e74:	2208      	movs	r2, #8
 8014e76:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_DATA_TIMEOUT;
 8014e78:	687b      	ldr	r3, [r7, #4]
 8014e7a:	2204      	movs	r2, #4
 8014e7c:	64da      	str	r2, [r3, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8014e7e:	6878      	ldr	r0, [r7, #4]
 8014e80:	f000 f84f 	bl	8014f22 <HAL_SD_XferErrorCallback>
 8014e84:	e035      	b.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_RXOVERR))
 8014e86:	687b      	ldr	r3, [r7, #4]
 8014e88:	681b      	ldr	r3, [r3, #0]
 8014e8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014e8c:	f003 0320 	and.w	r3, r3, #32
 8014e90:	2b00      	cmp	r3, #0
 8014e92:	d00a      	beq.n	8014eaa <HAL_SD_IRQHandler+0xa0>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8014e94:	687b      	ldr	r3, [r7, #4]
 8014e96:	681b      	ldr	r3, [r3, #0]
 8014e98:	2220      	movs	r2, #32
 8014e9a:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_RX_OVERRUN;
 8014e9c:	687b      	ldr	r3, [r7, #4]
 8014e9e:	2206      	movs	r2, #6
 8014ea0:	64da      	str	r2, [r3, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8014ea2:	6878      	ldr	r0, [r7, #4]
 8014ea4:	f000 f83d 	bl	8014f22 <HAL_SD_XferErrorCallback>
 8014ea8:	e023      	b.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_TXUNDERR))
 8014eaa:	687b      	ldr	r3, [r7, #4]
 8014eac:	681b      	ldr	r3, [r3, #0]
 8014eae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014eb0:	f003 0310 	and.w	r3, r3, #16
 8014eb4:	2b00      	cmp	r3, #0
 8014eb6:	d00a      	beq.n	8014ece <HAL_SD_IRQHandler+0xc4>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_TXUNDERR);
 8014eb8:	687b      	ldr	r3, [r7, #4]
 8014eba:	681b      	ldr	r3, [r3, #0]
 8014ebc:	2210      	movs	r2, #16
 8014ebe:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_TX_UNDERRUN;
 8014ec0:	687b      	ldr	r3, [r7, #4]
 8014ec2:	2205      	movs	r2, #5
 8014ec4:	64da      	str	r2, [r3, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8014ec6:	6878      	ldr	r0, [r7, #4]
 8014ec8:	f000 f82b 	bl	8014f22 <HAL_SD_XferErrorCallback>
 8014ecc:	e011      	b.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
  }
#ifdef SDIO_STA_STBITERR
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_IT_STBITERR))
 8014ece:	687b      	ldr	r3, [r7, #4]
 8014ed0:	681b      	ldr	r3, [r3, #0]
 8014ed2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8014ed4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8014ed8:	2b00      	cmp	r3, #0
 8014eda:	d00a      	beq.n	8014ef2 <HAL_SD_IRQHandler+0xe8>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 8014edc:	687b      	ldr	r3, [r7, #4]
 8014ede:	681b      	ldr	r3, [r3, #0]
 8014ee0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8014ee4:	639a      	str	r2, [r3, #56]	; 0x38
    
    hsd->SdTransferErr = SD_START_BIT_ERR;
 8014ee6:	687b      	ldr	r3, [r7, #4]
 8014ee8:	2207      	movs	r2, #7
 8014eea:	64da      	str	r2, [r3, #76]	; 0x4c
    
    HAL_SD_XferErrorCallback(hsd);
 8014eec:	6878      	ldr	r0, [r7, #4]
 8014eee:	f000 f818 	bl	8014f22 <HAL_SD_XferErrorCallback>
    /* No error flag set */
  }

  /* Disable all SDIO peripheral interrupt sources */
#ifdef SDIO_STA_STBITERR
  __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
 8014ef2:	687b      	ldr	r3, [r7, #4]
 8014ef4:	681b      	ldr	r3, [r3, #0]
 8014ef6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8014ef8:	687a      	ldr	r2, [r7, #4]
 8014efa:	6812      	ldr	r2, [r2, #0]
 8014efc:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 8014f00:	f023 033a 	bic.w	r3, r3, #58	; 0x3a
 8014f04:	63d3      	str	r3, [r2, #60]	; 0x3c
#else /* SDIO_STA_STBITERR not defined */
  __HAL_SD_SDIO_DISABLE_IT(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND  |\
                                SDIO_IT_TXFIFOHE | SDIO_IT_RXFIFOHF | SDIO_IT_TXUNDERR |\
                                SDIO_IT_RXOVERR);
#endif /* SDIO_STA_STBITERR */
}
 8014f06:	bf00      	nop
 8014f08:	3708      	adds	r7, #8
 8014f0a:	46bd      	mov	sp, r7
 8014f0c:	bd80      	pop	{r7, pc}

08014f0e <HAL_SD_XferCpltCallback>:
  * @brief  SD end of transfer callback.
  * @param  hsd: SD handle 
  * @retval None
  */
__weak void HAL_SD_XferCpltCallback(SD_HandleTypeDef *hsd)
{
 8014f0e:	b480      	push	{r7}
 8014f10:	b083      	sub	sp, #12
 8014f12:	af00      	add	r7, sp, #0
 8014f14:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsd);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_XferCpltCallback could be implemented in the user file
   */ 
}
 8014f16:	bf00      	nop
 8014f18:	370c      	adds	r7, #12
 8014f1a:	46bd      	mov	sp, r7
 8014f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f20:	4770      	bx	lr

08014f22 <HAL_SD_XferErrorCallback>:
  * @brief  SD Transfer Error callback.
  * @param  hsd: SD handle
  * @retval None
  */
__weak void HAL_SD_XferErrorCallback(SD_HandleTypeDef *hsd)
{
 8014f22:	b480      	push	{r7}
 8014f24:	b083      	sub	sp, #12
 8014f26:	af00      	add	r7, sp, #0
 8014f28:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsd);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_XferErrorCallback could be implemented in the user file
   */ 
}
 8014f2a:	bf00      	nop
 8014f2c:	370c      	adds	r7, #12
 8014f2e:	46bd      	mov	sp, r7
 8014f30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f34:	4770      	bx	lr

08014f36 <HAL_SD_DMA_RxCpltCallback>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
__weak void HAL_SD_DMA_RxCpltCallback(DMA_HandleTypeDef *hdma)
{
 8014f36:	b480      	push	{r7}
 8014f38:	b083      	sub	sp, #12
 8014f3a:	af00      	add	r7, sp, #0
 8014f3c:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdma);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_DMA_RxCpltCallback could be implemented in the user file
   */ 
}  
 8014f3e:	bf00      	nop
 8014f40:	370c      	adds	r7, #12
 8014f42:	46bd      	mov	sp, r7
 8014f44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f48:	4770      	bx	lr

08014f4a <HAL_SD_DMA_RxErrorCallback>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
__weak void HAL_SD_DMA_RxErrorCallback(DMA_HandleTypeDef *hdma)
{
 8014f4a:	b480      	push	{r7}
 8014f4c:	b083      	sub	sp, #12
 8014f4e:	af00      	add	r7, sp, #0
 8014f50:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdma);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_DMA_RxErrorCallback could be implemented in the user file
   */ 
}
 8014f52:	bf00      	nop
 8014f54:	370c      	adds	r7, #12
 8014f56:	46bd      	mov	sp, r7
 8014f58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f5c:	4770      	bx	lr

08014f5e <HAL_SD_DMA_TxCpltCallback>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
__weak void HAL_SD_DMA_TxCpltCallback(DMA_HandleTypeDef *hdma)
{
 8014f5e:	b480      	push	{r7}
 8014f60:	b083      	sub	sp, #12
 8014f62:	af00      	add	r7, sp, #0
 8014f64:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdma);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_DMA_TxCpltCallback could be implemented in the user file
   */ 
}  
 8014f66:	bf00      	nop
 8014f68:	370c      	adds	r7, #12
 8014f6a:	46bd      	mov	sp, r7
 8014f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f70:	4770      	bx	lr

08014f72 <HAL_SD_DMA_TxErrorCallback>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
__weak void HAL_SD_DMA_TxErrorCallback(DMA_HandleTypeDef *hdma)
{
 8014f72:	b480      	push	{r7}
 8014f74:	b083      	sub	sp, #12
 8014f76:	af00      	add	r7, sp, #0
 8014f78:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdma);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SD_DMA_TxErrorCallback could be implemented in the user file
   */ 
}
 8014f7a:	bf00      	nop
 8014f7c:	370c      	adds	r7, #12
 8014f7e:	46bd      	mov	sp, r7
 8014f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f84:	4770      	bx	lr

08014f86 <HAL_SD_Get_CardInfo>:
  * @param  pCardInfo: Pointer to a HAL_SD_CardInfoTypedef structure that  
  *         contains all SD cardinformation  
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_Get_CardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypedef *pCardInfo)
{
 8014f86:	b4b0      	push	{r4, r5, r7}
 8014f88:	b085      	sub	sp, #20
 8014f8a:	af00      	add	r7, sp, #0
 8014f8c:	6078      	str	r0, [r7, #4]
 8014f8e:	6039      	str	r1, [r7, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8014f90:	2300      	movs	r3, #0
 8014f92:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = 0U;
 8014f94:	2300      	movs	r3, #0
 8014f96:	60bb      	str	r3, [r7, #8]
  
  pCardInfo->CardType = (uint8_t)(hsd->CardType);
 8014f98:	687b      	ldr	r3, [r7, #4]
 8014f9a:	6a1b      	ldr	r3, [r3, #32]
 8014f9c:	b2da      	uxtb	r2, r3
 8014f9e:	683b      	ldr	r3, [r7, #0]
 8014fa0:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
  pCardInfo->RCA      = (uint16_t)(hsd->RCA);
 8014fa4:	687b      	ldr	r3, [r7, #4]
 8014fa6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014fa8:	b29a      	uxth	r2, r3
 8014faa:	683b      	ldr	r3, [r7, #0]
 8014fac:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
  
  /* Byte 0 */
  tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
 8014fb0:	687b      	ldr	r3, [r7, #4]
 8014fb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014fb4:	0e1b      	lsrs	r3, r3, #24
 8014fb6:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
 8014fb8:	68bb      	ldr	r3, [r7, #8]
 8014fba:	099b      	lsrs	r3, r3, #6
 8014fbc:	b2db      	uxtb	r3, r3
 8014fbe:	f003 0303 	and.w	r3, r3, #3
 8014fc2:	b2da      	uxtb	r2, r3
 8014fc4:	683b      	ldr	r3, [r7, #0]
 8014fc6:	701a      	strb	r2, [r3, #0]
  pCardInfo->SD_csd.SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
 8014fc8:	68bb      	ldr	r3, [r7, #8]
 8014fca:	089b      	lsrs	r3, r3, #2
 8014fcc:	b2db      	uxtb	r3, r3
 8014fce:	f003 030f 	and.w	r3, r3, #15
 8014fd2:	b2da      	uxtb	r2, r3
 8014fd4:	683b      	ldr	r3, [r7, #0]
 8014fd6:	705a      	strb	r2, [r3, #1]
  pCardInfo->SD_csd.Reserved1      = tmp & 0x03U;
 8014fd8:	68bb      	ldr	r3, [r7, #8]
 8014fda:	b2db      	uxtb	r3, r3
 8014fdc:	f003 0303 	and.w	r3, r3, #3
 8014fe0:	b2da      	uxtb	r2, r3
 8014fe2:	683b      	ldr	r3, [r7, #0]
 8014fe4:	709a      	strb	r2, [r3, #2]
  
  /* Byte 1 */
  tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
 8014fe6:	687b      	ldr	r3, [r7, #4]
 8014fe8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014fea:	0c1b      	lsrs	r3, r3, #16
 8014fec:	b2db      	uxtb	r3, r3
 8014fee:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.TAAC = (uint8_t)tmp;
 8014ff0:	68bb      	ldr	r3, [r7, #8]
 8014ff2:	b2da      	uxtb	r2, r3
 8014ff4:	683b      	ldr	r3, [r7, #0]
 8014ff6:	70da      	strb	r2, [r3, #3]
  
  /* Byte 2 */
  tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
 8014ff8:	687b      	ldr	r3, [r7, #4]
 8014ffa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014ffc:	0a1b      	lsrs	r3, r3, #8
 8014ffe:	b2db      	uxtb	r3, r3
 8015000:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.NSAC = (uint8_t)tmp;
 8015002:	68bb      	ldr	r3, [r7, #8]
 8015004:	b2da      	uxtb	r2, r3
 8015006:	683b      	ldr	r3, [r7, #0]
 8015008:	711a      	strb	r2, [r3, #4]
  
  /* Byte 3 */
  tmp = hsd->CSD[0U] & 0x000000FFU;
 801500a:	687b      	ldr	r3, [r7, #4]
 801500c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801500e:	b2db      	uxtb	r3, r3
 8015010:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.MaxBusClkFrec = (uint8_t)tmp;
 8015012:	68bb      	ldr	r3, [r7, #8]
 8015014:	b2da      	uxtb	r2, r3
 8015016:	683b      	ldr	r3, [r7, #0]
 8015018:	715a      	strb	r2, [r3, #5]
  
  /* Byte 4 */
  tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
 801501a:	687b      	ldr	r3, [r7, #4]
 801501c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801501e:	0e1b      	lsrs	r3, r3, #24
 8015020:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.CardComdClasses = (uint16_t)(tmp << 4U);
 8015022:	68bb      	ldr	r3, [r7, #8]
 8015024:	b29b      	uxth	r3, r3
 8015026:	011b      	lsls	r3, r3, #4
 8015028:	b29a      	uxth	r2, r3
 801502a:	683b      	ldr	r3, [r7, #0]
 801502c:	80da      	strh	r2, [r3, #6]
  
  /* Byte 5 */
  tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
 801502e:	687b      	ldr	r3, [r7, #4]
 8015030:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015032:	0c1b      	lsrs	r3, r3, #16
 8015034:	b2db      	uxtb	r3, r3
 8015036:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.CardComdClasses |= (uint16_t)((tmp & 0xF0) >> 4U);
 8015038:	683b      	ldr	r3, [r7, #0]
 801503a:	88db      	ldrh	r3, [r3, #6]
 801503c:	b29a      	uxth	r2, r3
 801503e:	68bb      	ldr	r3, [r7, #8]
 8015040:	091b      	lsrs	r3, r3, #4
 8015042:	b29b      	uxth	r3, r3
 8015044:	f003 030f 	and.w	r3, r3, #15
 8015048:	b29b      	uxth	r3, r3
 801504a:	4313      	orrs	r3, r2
 801504c:	b29a      	uxth	r2, r3
 801504e:	683b      	ldr	r3, [r7, #0]
 8015050:	80da      	strh	r2, [r3, #6]
  pCardInfo->SD_csd.RdBlockLen       = (uint8_t)(tmp & 0x0FU);
 8015052:	68bb      	ldr	r3, [r7, #8]
 8015054:	b2db      	uxtb	r3, r3
 8015056:	f003 030f 	and.w	r3, r3, #15
 801505a:	b2da      	uxtb	r2, r3
 801505c:	683b      	ldr	r3, [r7, #0]
 801505e:	721a      	strb	r2, [r3, #8]
  
  /* Byte 6 */
  tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
 8015060:	687b      	ldr	r3, [r7, #4]
 8015062:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015064:	0a1b      	lsrs	r3, r3, #8
 8015066:	b2db      	uxtb	r3, r3
 8015068:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
 801506a:	68bb      	ldr	r3, [r7, #8]
 801506c:	09db      	lsrs	r3, r3, #7
 801506e:	b2db      	uxtb	r3, r3
 8015070:	f003 0301 	and.w	r3, r3, #1
 8015074:	b2da      	uxtb	r2, r3
 8015076:	683b      	ldr	r3, [r7, #0]
 8015078:	725a      	strb	r2, [r3, #9]
  pCardInfo->SD_csd.WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
 801507a:	68bb      	ldr	r3, [r7, #8]
 801507c:	099b      	lsrs	r3, r3, #6
 801507e:	b2db      	uxtb	r3, r3
 8015080:	f003 0301 	and.w	r3, r3, #1
 8015084:	b2da      	uxtb	r2, r3
 8015086:	683b      	ldr	r3, [r7, #0]
 8015088:	729a      	strb	r2, [r3, #10]
  pCardInfo->SD_csd.RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
 801508a:	68bb      	ldr	r3, [r7, #8]
 801508c:	095b      	lsrs	r3, r3, #5
 801508e:	b2db      	uxtb	r3, r3
 8015090:	f003 0301 	and.w	r3, r3, #1
 8015094:	b2da      	uxtb	r2, r3
 8015096:	683b      	ldr	r3, [r7, #0]
 8015098:	72da      	strb	r2, [r3, #11]
  pCardInfo->SD_csd.DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
 801509a:	68bb      	ldr	r3, [r7, #8]
 801509c:	091b      	lsrs	r3, r3, #4
 801509e:	b2db      	uxtb	r3, r3
 80150a0:	f003 0301 	and.w	r3, r3, #1
 80150a4:	b2da      	uxtb	r2, r3
 80150a6:	683b      	ldr	r3, [r7, #0]
 80150a8:	731a      	strb	r2, [r3, #12]
  pCardInfo->SD_csd.Reserved2       = 0U; /*!< Reserved */
 80150aa:	683b      	ldr	r3, [r7, #0]
 80150ac:	2200      	movs	r2, #0
 80150ae:	735a      	strb	r2, [r3, #13]
  
  if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0))
 80150b0:	687b      	ldr	r3, [r7, #4]
 80150b2:	6a1b      	ldr	r3, [r3, #32]
 80150b4:	2b00      	cmp	r3, #0
 80150b6:	d004      	beq.n	80150c2 <HAL_SD_Get_CardInfo+0x13c>
 80150b8:	687b      	ldr	r3, [r7, #4]
 80150ba:	6a1b      	ldr	r3, [r3, #32]
 80150bc:	2b01      	cmp	r3, #1
 80150be:	f040 809b 	bne.w	80151f8 <HAL_SD_Get_CardInfo+0x272>
  {
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x03U) << 10U;
 80150c2:	68bb      	ldr	r3, [r7, #8]
 80150c4:	029b      	lsls	r3, r3, #10
 80150c6:	f403 6240 	and.w	r2, r3, #3072	; 0xc00
 80150ca:	683b      	ldr	r3, [r7, #0]
 80150cc:	611a      	str	r2, [r3, #16]
    
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
 80150ce:	687b      	ldr	r3, [r7, #4]
 80150d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80150d2:	b2db      	uxtb	r3, r3
 80150d4:	60bb      	str	r3, [r7, #8]
    pCardInfo->SD_csd.DeviceSize |= (tmp) << 2U;
 80150d6:	683b      	ldr	r3, [r7, #0]
 80150d8:	691a      	ldr	r2, [r3, #16]
 80150da:	68bb      	ldr	r3, [r7, #8]
 80150dc:	009b      	lsls	r3, r3, #2
 80150de:	431a      	orrs	r2, r3
 80150e0:	683b      	ldr	r3, [r7, #0]
 80150e2:	611a      	str	r2, [r3, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 80150e4:	687b      	ldr	r3, [r7, #4]
 80150e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80150e8:	0e1b      	lsrs	r3, r3, #24
 80150ea:	b2db      	uxtb	r3, r3
 80150ec:	60bb      	str	r3, [r7, #8]
    pCardInfo->SD_csd.DeviceSize |= (tmp & 0xC0U) >> 6U;
 80150ee:	683b      	ldr	r3, [r7, #0]
 80150f0:	691a      	ldr	r2, [r3, #16]
 80150f2:	68bb      	ldr	r3, [r7, #8]
 80150f4:	099b      	lsrs	r3, r3, #6
 80150f6:	f003 0303 	and.w	r3, r3, #3
 80150fa:	431a      	orrs	r2, r3
 80150fc:	683b      	ldr	r3, [r7, #0]
 80150fe:	611a      	str	r2, [r3, #16]
    
    pCardInfo->SD_csd.MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
 8015100:	68bb      	ldr	r3, [r7, #8]
 8015102:	08db      	lsrs	r3, r3, #3
 8015104:	b2db      	uxtb	r3, r3
 8015106:	f003 0307 	and.w	r3, r3, #7
 801510a:	b2da      	uxtb	r2, r3
 801510c:	683b      	ldr	r3, [r7, #0]
 801510e:	751a      	strb	r2, [r3, #20]
    pCardInfo->SD_csd.MaxRdCurrentVDDMax = (tmp & 0x07U);
 8015110:	68bb      	ldr	r3, [r7, #8]
 8015112:	b2db      	uxtb	r3, r3
 8015114:	f003 0307 	and.w	r3, r3, #7
 8015118:	b2da      	uxtb	r2, r3
 801511a:	683b      	ldr	r3, [r7, #0]
 801511c:	755a      	strb	r2, [r3, #21]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 801511e:	687b      	ldr	r3, [r7, #4]
 8015120:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015122:	0c1b      	lsrs	r3, r3, #16
 8015124:	b2db      	uxtb	r3, r3
 8015126:	60bb      	str	r3, [r7, #8]
    pCardInfo->SD_csd.MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
 8015128:	68bb      	ldr	r3, [r7, #8]
 801512a:	095b      	lsrs	r3, r3, #5
 801512c:	b2db      	uxtb	r3, r3
 801512e:	f003 0307 	and.w	r3, r3, #7
 8015132:	b2da      	uxtb	r2, r3
 8015134:	683b      	ldr	r3, [r7, #0]
 8015136:	759a      	strb	r2, [r3, #22]
    pCardInfo->SD_csd.MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
 8015138:	68bb      	ldr	r3, [r7, #8]
 801513a:	089b      	lsrs	r3, r3, #2
 801513c:	b2db      	uxtb	r3, r3
 801513e:	f003 0307 	and.w	r3, r3, #7
 8015142:	b2da      	uxtb	r2, r3
 8015144:	683b      	ldr	r3, [r7, #0]
 8015146:	75da      	strb	r2, [r3, #23]
    pCardInfo->SD_csd.DeviceSizeMul      = (tmp & 0x03U) << 1U;
 8015148:	68bb      	ldr	r3, [r7, #8]
 801514a:	b2db      	uxtb	r3, r3
 801514c:	005b      	lsls	r3, r3, #1
 801514e:	b2db      	uxtb	r3, r3
 8015150:	f003 0306 	and.w	r3, r3, #6
 8015154:	b2da      	uxtb	r2, r3
 8015156:	683b      	ldr	r3, [r7, #0]
 8015158:	761a      	strb	r2, [r3, #24]
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 801515a:	687b      	ldr	r3, [r7, #4]
 801515c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801515e:	0a1b      	lsrs	r3, r3, #8
 8015160:	b2db      	uxtb	r3, r3
 8015162:	60bb      	str	r3, [r7, #8]
    pCardInfo->SD_csd.DeviceSizeMul |= (tmp & 0x80U) >> 7U;
 8015164:	683b      	ldr	r3, [r7, #0]
 8015166:	7e1b      	ldrb	r3, [r3, #24]
 8015168:	b2da      	uxtb	r2, r3
 801516a:	68bb      	ldr	r3, [r7, #8]
 801516c:	09db      	lsrs	r3, r3, #7
 801516e:	b2db      	uxtb	r3, r3
 8015170:	f003 0301 	and.w	r3, r3, #1
 8015174:	b2db      	uxtb	r3, r3
 8015176:	4313      	orrs	r3, r2
 8015178:	b2da      	uxtb	r2, r3
 801517a:	683b      	ldr	r3, [r7, #0]
 801517c:	761a      	strb	r2, [r3, #24]
    
    pCardInfo->CardCapacity  = (pCardInfo->SD_csd.DeviceSize + 1U) ;
 801517e:	683b      	ldr	r3, [r7, #0]
 8015180:	691b      	ldr	r3, [r3, #16]
 8015182:	3301      	adds	r3, #1
 8015184:	f04f 0400 	mov.w	r4, #0
 8015188:	683a      	ldr	r2, [r7, #0]
 801518a:	e9c2 3412 	strd	r3, r4, [r2, #72]	; 0x48
    pCardInfo->CardCapacity *= (1U << (pCardInfo->SD_csd.DeviceSizeMul + 2U));
 801518e:	683b      	ldr	r3, [r7, #0]
 8015190:	7e1b      	ldrb	r3, [r3, #24]
 8015192:	b2db      	uxtb	r3, r3
 8015194:	3302      	adds	r3, #2
 8015196:	2201      	movs	r2, #1
 8015198:	fa02 f303 	lsl.w	r3, r2, r3
 801519c:	683a      	ldr	r2, [r7, #0]
 801519e:	e9d2 1212 	ldrd	r1, r2, [r2, #72]	; 0x48
 80151a2:	f04f 0400 	mov.w	r4, #0
 80151a6:	fb03 f502 	mul.w	r5, r3, r2
 80151aa:	fb01 f004 	mul.w	r0, r1, r4
 80151ae:	4428      	add	r0, r5
 80151b0:	fba1 3403 	umull	r3, r4, r1, r3
 80151b4:	1902      	adds	r2, r0, r4
 80151b6:	4614      	mov	r4, r2
 80151b8:	683a      	ldr	r2, [r7, #0]
 80151ba:	e9c2 3412 	strd	r3, r4, [r2, #72]	; 0x48
    pCardInfo->CardBlockSize = 1U << (pCardInfo->SD_csd.RdBlockLen);
 80151be:	683b      	ldr	r3, [r7, #0]
 80151c0:	7a1b      	ldrb	r3, [r3, #8]
 80151c2:	b2db      	uxtb	r3, r3
 80151c4:	461a      	mov	r2, r3
 80151c6:	2301      	movs	r3, #1
 80151c8:	fa03 f202 	lsl.w	r2, r3, r2
 80151cc:	683b      	ldr	r3, [r7, #0]
 80151ce:	651a      	str	r2, [r3, #80]	; 0x50
    pCardInfo->CardCapacity *= pCardInfo->CardBlockSize;
 80151d0:	683b      	ldr	r3, [r7, #0]
 80151d2:	e9d3 1212 	ldrd	r1, r2, [r3, #72]	; 0x48
 80151d6:	683b      	ldr	r3, [r7, #0]
 80151d8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80151da:	f04f 0400 	mov.w	r4, #0
 80151de:	fb03 f502 	mul.w	r5, r3, r2
 80151e2:	fb01 f004 	mul.w	r0, r1, r4
 80151e6:	4428      	add	r0, r5
 80151e8:	fba1 3403 	umull	r3, r4, r1, r3
 80151ec:	1902      	adds	r2, r0, r4
 80151ee:	4614      	mov	r4, r2
 80151f0:	683a      	ldr	r2, [r7, #0]
 80151f2:	e9c2 3412 	strd	r3, r4, [r2, #72]	; 0x48
 80151f6:	e042      	b.n	801527e <HAL_SD_Get_CardInfo+0x2f8>
  }
  else if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
 80151f8:	687b      	ldr	r3, [r7, #4]
 80151fa:	6a1b      	ldr	r3, [r3, #32]
 80151fc:	2b02      	cmp	r3, #2
 80151fe:	d13c      	bne.n	801527a <HAL_SD_Get_CardInfo+0x2f4>
  {
    /* Byte 7 */
    tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
 8015200:	687b      	ldr	r3, [r7, #4]
 8015202:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8015204:	b2db      	uxtb	r3, r3
 8015206:	60bb      	str	r3, [r7, #8]
    pCardInfo->SD_csd.DeviceSize = (tmp & 0x3FU) << 16U;
 8015208:	68bb      	ldr	r3, [r7, #8]
 801520a:	041b      	lsls	r3, r3, #16
 801520c:	f403 127c 	and.w	r2, r3, #4128768	; 0x3f0000
 8015210:	683b      	ldr	r3, [r7, #0]
 8015212:	611a      	str	r2, [r3, #16]
    
    /* Byte 8 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
 8015214:	687b      	ldr	r3, [r7, #4]
 8015216:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015218:	0e1b      	lsrs	r3, r3, #24
 801521a:	b2db      	uxtb	r3, r3
 801521c:	60bb      	str	r3, [r7, #8]
    
    pCardInfo->SD_csd.DeviceSize |= (tmp << 8U);
 801521e:	683b      	ldr	r3, [r7, #0]
 8015220:	691a      	ldr	r2, [r3, #16]
 8015222:	68bb      	ldr	r3, [r7, #8]
 8015224:	021b      	lsls	r3, r3, #8
 8015226:	431a      	orrs	r2, r3
 8015228:	683b      	ldr	r3, [r7, #0]
 801522a:	611a      	str	r2, [r3, #16]
    
    /* Byte 9 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
 801522c:	687b      	ldr	r3, [r7, #4]
 801522e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015230:	0c1b      	lsrs	r3, r3, #16
 8015232:	b2db      	uxtb	r3, r3
 8015234:	60bb      	str	r3, [r7, #8]
    
    pCardInfo->SD_csd.DeviceSize |= (tmp);
 8015236:	683b      	ldr	r3, [r7, #0]
 8015238:	691a      	ldr	r2, [r3, #16]
 801523a:	68bb      	ldr	r3, [r7, #8]
 801523c:	431a      	orrs	r2, r3
 801523e:	683b      	ldr	r3, [r7, #0]
 8015240:	611a      	str	r2, [r3, #16]
    
    /* Byte 10 */
    tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
 8015242:	687b      	ldr	r3, [r7, #4]
 8015244:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8015246:	0a1b      	lsrs	r3, r3, #8
 8015248:	b2db      	uxtb	r3, r3
 801524a:	60bb      	str	r3, [r7, #8]
    
    pCardInfo->CardCapacity = (uint64_t)((((uint64_t)pCardInfo->SD_csd.DeviceSize + 1U)) * 512U * 1024U);
 801524c:	683b      	ldr	r3, [r7, #0]
 801524e:	691b      	ldr	r3, [r3, #16]
 8015250:	f04f 0400 	mov.w	r4, #0
 8015254:	1c59      	adds	r1, r3, #1
 8015256:	f144 0200 	adc.w	r2, r4, #0
 801525a:	f04f 0300 	mov.w	r3, #0
 801525e:	f04f 0400 	mov.w	r4, #0
 8015262:	04d4      	lsls	r4, r2, #19
 8015264:	ea44 3451 	orr.w	r4, r4, r1, lsr #13
 8015268:	04cb      	lsls	r3, r1, #19
 801526a:	683a      	ldr	r2, [r7, #0]
 801526c:	e9c2 3412 	strd	r3, r4, [r2, #72]	; 0x48
    pCardInfo->CardBlockSize = 512U;    
 8015270:	683b      	ldr	r3, [r7, #0]
 8015272:	f44f 7200 	mov.w	r2, #512	; 0x200
 8015276:	651a      	str	r2, [r3, #80]	; 0x50
 8015278:	e001      	b.n	801527e <HAL_SD_Get_CardInfo+0x2f8>
  }
  else
  {
    /* Not supported card type */
    errorstate = SD_ERROR;
 801527a:	2329      	movs	r3, #41	; 0x29
 801527c:	73fb      	strb	r3, [r7, #15]
  }
    
  pCardInfo->SD_csd.EraseGrSize = (tmp & 0x40U) >> 6U;
 801527e:	68bb      	ldr	r3, [r7, #8]
 8015280:	099b      	lsrs	r3, r3, #6
 8015282:	b2db      	uxtb	r3, r3
 8015284:	f003 0301 	and.w	r3, r3, #1
 8015288:	b2da      	uxtb	r2, r3
 801528a:	683b      	ldr	r3, [r7, #0]
 801528c:	765a      	strb	r2, [r3, #25]
  pCardInfo->SD_csd.EraseGrMul  = (tmp & 0x3FU) << 1U;
 801528e:	68bb      	ldr	r3, [r7, #8]
 8015290:	b2db      	uxtb	r3, r3
 8015292:	005b      	lsls	r3, r3, #1
 8015294:	b2db      	uxtb	r3, r3
 8015296:	f003 037e 	and.w	r3, r3, #126	; 0x7e
 801529a:	b2da      	uxtb	r2, r3
 801529c:	683b      	ldr	r3, [r7, #0]
 801529e:	769a      	strb	r2, [r3, #26]
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
 80152a0:	687b      	ldr	r3, [r7, #4]
 80152a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80152a4:	b2db      	uxtb	r3, r3
 80152a6:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.EraseGrMul     |= (tmp & 0x80U) >> 7U;
 80152a8:	683b      	ldr	r3, [r7, #0]
 80152aa:	7e9b      	ldrb	r3, [r3, #26]
 80152ac:	b2da      	uxtb	r2, r3
 80152ae:	68bb      	ldr	r3, [r7, #8]
 80152b0:	09db      	lsrs	r3, r3, #7
 80152b2:	b2db      	uxtb	r3, r3
 80152b4:	f003 0301 	and.w	r3, r3, #1
 80152b8:	b2db      	uxtb	r3, r3
 80152ba:	4313      	orrs	r3, r2
 80152bc:	b2da      	uxtb	r2, r3
 80152be:	683b      	ldr	r3, [r7, #0]
 80152c0:	769a      	strb	r2, [r3, #26]
  pCardInfo->SD_csd.WrProtectGrSize = (tmp & 0x7FU);
 80152c2:	68bb      	ldr	r3, [r7, #8]
 80152c4:	b2db      	uxtb	r3, r3
 80152c6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80152ca:	b2da      	uxtb	r2, r3
 80152cc:	683b      	ldr	r3, [r7, #0]
 80152ce:	76da      	strb	r2, [r3, #27]
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
 80152d0:	687b      	ldr	r3, [r7, #4]
 80152d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80152d4:	0e1b      	lsrs	r3, r3, #24
 80152d6:	b2db      	uxtb	r3, r3
 80152d8:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.WrProtectGrEnable = (tmp & 0x80U) >> 7U;
 80152da:	68bb      	ldr	r3, [r7, #8]
 80152dc:	09db      	lsrs	r3, r3, #7
 80152de:	b2db      	uxtb	r3, r3
 80152e0:	f003 0301 	and.w	r3, r3, #1
 80152e4:	b2da      	uxtb	r2, r3
 80152e6:	683b      	ldr	r3, [r7, #0]
 80152e8:	771a      	strb	r2, [r3, #28]
  pCardInfo->SD_csd.ManDeflECC        = (tmp & 0x60U) >> 5U;
 80152ea:	68bb      	ldr	r3, [r7, #8]
 80152ec:	095b      	lsrs	r3, r3, #5
 80152ee:	b2db      	uxtb	r3, r3
 80152f0:	f003 0303 	and.w	r3, r3, #3
 80152f4:	b2da      	uxtb	r2, r3
 80152f6:	683b      	ldr	r3, [r7, #0]
 80152f8:	775a      	strb	r2, [r3, #29]
  pCardInfo->SD_csd.WrSpeedFact       = (tmp & 0x1CU) >> 2U;
 80152fa:	68bb      	ldr	r3, [r7, #8]
 80152fc:	089b      	lsrs	r3, r3, #2
 80152fe:	b2db      	uxtb	r3, r3
 8015300:	f003 0307 	and.w	r3, r3, #7
 8015304:	b2da      	uxtb	r2, r3
 8015306:	683b      	ldr	r3, [r7, #0]
 8015308:	779a      	strb	r2, [r3, #30]
  pCardInfo->SD_csd.MaxWrBlockLen     = (tmp & 0x03U) << 2U;
 801530a:	68bb      	ldr	r3, [r7, #8]
 801530c:	b2db      	uxtb	r3, r3
 801530e:	009b      	lsls	r3, r3, #2
 8015310:	b2db      	uxtb	r3, r3
 8015312:	f003 030c 	and.w	r3, r3, #12
 8015316:	b2da      	uxtb	r2, r3
 8015318:	683b      	ldr	r3, [r7, #0]
 801531a:	77da      	strb	r2, [r3, #31]
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
 801531c:	687b      	ldr	r3, [r7, #4]
 801531e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015320:	0c1b      	lsrs	r3, r3, #16
 8015322:	b2db      	uxtb	r3, r3
 8015324:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
 8015326:	683b      	ldr	r3, [r7, #0]
 8015328:	7fdb      	ldrb	r3, [r3, #31]
 801532a:	b2da      	uxtb	r2, r3
 801532c:	68bb      	ldr	r3, [r7, #8]
 801532e:	099b      	lsrs	r3, r3, #6
 8015330:	b2db      	uxtb	r3, r3
 8015332:	f003 0303 	and.w	r3, r3, #3
 8015336:	b2db      	uxtb	r3, r3
 8015338:	4313      	orrs	r3, r2
 801533a:	b2da      	uxtb	r2, r3
 801533c:	683b      	ldr	r3, [r7, #0]
 801533e:	77da      	strb	r2, [r3, #31]
  pCardInfo->SD_csd.WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
 8015340:	68bb      	ldr	r3, [r7, #8]
 8015342:	095b      	lsrs	r3, r3, #5
 8015344:	b2db      	uxtb	r3, r3
 8015346:	f003 0301 	and.w	r3, r3, #1
 801534a:	b2da      	uxtb	r2, r3
 801534c:	683b      	ldr	r3, [r7, #0]
 801534e:	f883 2020 	strb.w	r2, [r3, #32]
  pCardInfo->SD_csd.Reserved3           = 0U;
 8015352:	683b      	ldr	r3, [r7, #0]
 8015354:	2200      	movs	r2, #0
 8015356:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  pCardInfo->SD_csd.ContentProtectAppli = (tmp & 0x01U);
 801535a:	68bb      	ldr	r3, [r7, #8]
 801535c:	b2db      	uxtb	r3, r3
 801535e:	f003 0301 	and.w	r3, r3, #1
 8015362:	b2da      	uxtb	r2, r3
 8015364:	683b      	ldr	r3, [r7, #0]
 8015366:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
 801536a:	687b      	ldr	r3, [r7, #4]
 801536c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801536e:	0a1b      	lsrs	r3, r3, #8
 8015370:	b2db      	uxtb	r3, r3
 8015372:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.FileFormatGrouop = (tmp & 0x80U) >> 7U;
 8015374:	68bb      	ldr	r3, [r7, #8]
 8015376:	09db      	lsrs	r3, r3, #7
 8015378:	b2db      	uxtb	r3, r3
 801537a:	f003 0301 	and.w	r3, r3, #1
 801537e:	b2da      	uxtb	r2, r3
 8015380:	683b      	ldr	r3, [r7, #0]
 8015382:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  pCardInfo->SD_csd.CopyFlag         = (tmp & 0x40U) >> 6U;
 8015386:	68bb      	ldr	r3, [r7, #8]
 8015388:	099b      	lsrs	r3, r3, #6
 801538a:	b2db      	uxtb	r3, r3
 801538c:	f003 0301 	and.w	r3, r3, #1
 8015390:	b2da      	uxtb	r2, r3
 8015392:	683b      	ldr	r3, [r7, #0]
 8015394:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  pCardInfo->SD_csd.PermWrProtect    = (tmp & 0x20U) >> 5U;
 8015398:	68bb      	ldr	r3, [r7, #8]
 801539a:	095b      	lsrs	r3, r3, #5
 801539c:	b2db      	uxtb	r3, r3
 801539e:	f003 0301 	and.w	r3, r3, #1
 80153a2:	b2da      	uxtb	r2, r3
 80153a4:	683b      	ldr	r3, [r7, #0]
 80153a6:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
  pCardInfo->SD_csd.TempWrProtect    = (tmp & 0x10U) >> 4U;
 80153aa:	68bb      	ldr	r3, [r7, #8]
 80153ac:	091b      	lsrs	r3, r3, #4
 80153ae:	b2db      	uxtb	r3, r3
 80153b0:	f003 0301 	and.w	r3, r3, #1
 80153b4:	b2da      	uxtb	r2, r3
 80153b6:	683b      	ldr	r3, [r7, #0]
 80153b8:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
  pCardInfo->SD_csd.FileFormat       = (tmp & 0x0CU) >> 2U;
 80153bc:	68bb      	ldr	r3, [r7, #8]
 80153be:	089b      	lsrs	r3, r3, #2
 80153c0:	b2db      	uxtb	r3, r3
 80153c2:	f003 0303 	and.w	r3, r3, #3
 80153c6:	b2da      	uxtb	r2, r3
 80153c8:	683b      	ldr	r3, [r7, #0]
 80153ca:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
  pCardInfo->SD_csd.ECC              = (tmp & 0x03U);
 80153ce:	68bb      	ldr	r3, [r7, #8]
 80153d0:	b2db      	uxtb	r3, r3
 80153d2:	f003 0303 	and.w	r3, r3, #3
 80153d6:	b2da      	uxtb	r2, r3
 80153d8:	683b      	ldr	r3, [r7, #0]
 80153da:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
 80153de:	687b      	ldr	r3, [r7, #4]
 80153e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80153e2:	b2db      	uxtb	r3, r3
 80153e4:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_csd.CSD_CRC   = (tmp & 0xFEU) >> 1U;
 80153e6:	68bb      	ldr	r3, [r7, #8]
 80153e8:	085b      	lsrs	r3, r3, #1
 80153ea:	b2db      	uxtb	r3, r3
 80153ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80153f0:	b2da      	uxtb	r2, r3
 80153f2:	683b      	ldr	r3, [r7, #0]
 80153f4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  pCardInfo->SD_csd.Reserved4 = 1U;
 80153f8:	683b      	ldr	r3, [r7, #0]
 80153fa:	2201      	movs	r2, #1
 80153fc:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  
  /* Byte 0 */
  tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
 8015400:	687b      	ldr	r3, [r7, #4]
 8015402:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015404:	0e1b      	lsrs	r3, r3, #24
 8015406:	b2db      	uxtb	r3, r3
 8015408:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ManufacturerID = tmp;
 801540a:	68bb      	ldr	r3, [r7, #8]
 801540c:	b2da      	uxtb	r2, r3
 801540e:	683b      	ldr	r3, [r7, #0]
 8015410:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Byte 1 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
 8015414:	687b      	ldr	r3, [r7, #4]
 8015416:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015418:	0c1b      	lsrs	r3, r3, #16
 801541a:	b2db      	uxtb	r3, r3
 801541c:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.OEM_AppliID = tmp << 8U;
 801541e:	68bb      	ldr	r3, [r7, #8]
 8015420:	b29b      	uxth	r3, r3
 8015422:	021b      	lsls	r3, r3, #8
 8015424:	b29a      	uxth	r2, r3
 8015426:	683b      	ldr	r3, [r7, #0]
 8015428:	85da      	strh	r2, [r3, #46]	; 0x2e
  
  /* Byte 2 */
  tmp = (uint8_t)((hsd->CID[0U] & 0x0000FF00U) >> 8U);
 801542a:	687b      	ldr	r3, [r7, #4]
 801542c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801542e:	0a1b      	lsrs	r3, r3, #8
 8015430:	b2db      	uxtb	r3, r3
 8015432:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.OEM_AppliID |= tmp;
 8015434:	683b      	ldr	r3, [r7, #0]
 8015436:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8015438:	b29a      	uxth	r2, r3
 801543a:	68bb      	ldr	r3, [r7, #8]
 801543c:	b29b      	uxth	r3, r3
 801543e:	4313      	orrs	r3, r2
 8015440:	b29a      	uxth	r2, r3
 8015442:	683b      	ldr	r3, [r7, #0]
 8015444:	85da      	strh	r2, [r3, #46]	; 0x2e
  
  /* Byte 3 */
  tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
 8015446:	687b      	ldr	r3, [r7, #4]
 8015448:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801544a:	b2db      	uxtb	r3, r3
 801544c:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdName1 = tmp << 24U;
 801544e:	68bb      	ldr	r3, [r7, #8]
 8015450:	061a      	lsls	r2, r3, #24
 8015452:	683b      	ldr	r3, [r7, #0]
 8015454:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Byte 4 */
  tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
 8015456:	687b      	ldr	r3, [r7, #4]
 8015458:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801545a:	0e1b      	lsrs	r3, r3, #24
 801545c:	b2db      	uxtb	r3, r3
 801545e:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdName1 |= tmp << 16U;
 8015460:	683b      	ldr	r3, [r7, #0]
 8015462:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8015464:	68bb      	ldr	r3, [r7, #8]
 8015466:	041b      	lsls	r3, r3, #16
 8015468:	431a      	orrs	r2, r3
 801546a:	683b      	ldr	r3, [r7, #0]
 801546c:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Byte 5 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
 801546e:	687b      	ldr	r3, [r7, #4]
 8015470:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8015472:	0c1b      	lsrs	r3, r3, #16
 8015474:	b2db      	uxtb	r3, r3
 8015476:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdName1 |= tmp << 8U;
 8015478:	683b      	ldr	r3, [r7, #0]
 801547a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 801547c:	68bb      	ldr	r3, [r7, #8]
 801547e:	021b      	lsls	r3, r3, #8
 8015480:	431a      	orrs	r2, r3
 8015482:	683b      	ldr	r3, [r7, #0]
 8015484:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Byte 6 */
  tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
 8015486:	687b      	ldr	r3, [r7, #4]
 8015488:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801548a:	0a1b      	lsrs	r3, r3, #8
 801548c:	b2db      	uxtb	r3, r3
 801548e:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdName1 |= tmp;
 8015490:	683b      	ldr	r3, [r7, #0]
 8015492:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8015494:	68bb      	ldr	r3, [r7, #8]
 8015496:	431a      	orrs	r2, r3
 8015498:	683b      	ldr	r3, [r7, #0]
 801549a:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Byte 7 */
  tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
 801549c:	687b      	ldr	r3, [r7, #4]
 801549e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80154a0:	b2db      	uxtb	r3, r3
 80154a2:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdName2 = tmp;
 80154a4:	68bb      	ldr	r3, [r7, #8]
 80154a6:	b2da      	uxtb	r2, r3
 80154a8:	683b      	ldr	r3, [r7, #0]
 80154aa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  /* Byte 8 */
  tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
 80154ae:	687b      	ldr	r3, [r7, #4]
 80154b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80154b2:	0e1b      	lsrs	r3, r3, #24
 80154b4:	b2db      	uxtb	r3, r3
 80154b6:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdRev = tmp;
 80154b8:	68bb      	ldr	r3, [r7, #8]
 80154ba:	b2da      	uxtb	r2, r3
 80154bc:	683b      	ldr	r3, [r7, #0]
 80154be:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Byte 9 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
 80154c2:	687b      	ldr	r3, [r7, #4]
 80154c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80154c6:	0c1b      	lsrs	r3, r3, #16
 80154c8:	b2db      	uxtb	r3, r3
 80154ca:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdSN = tmp << 24U;
 80154cc:	68bb      	ldr	r3, [r7, #8]
 80154ce:	061a      	lsls	r2, r3, #24
 80154d0:	683b      	ldr	r3, [r7, #0]
 80154d2:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Byte 10 */
  tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
 80154d4:	687b      	ldr	r3, [r7, #4]
 80154d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80154d8:	0a1b      	lsrs	r3, r3, #8
 80154da:	b2db      	uxtb	r3, r3
 80154dc:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdSN |= tmp << 16U;
 80154de:	683b      	ldr	r3, [r7, #0]
 80154e0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80154e2:	68bb      	ldr	r3, [r7, #8]
 80154e4:	041b      	lsls	r3, r3, #16
 80154e6:	431a      	orrs	r2, r3
 80154e8:	683b      	ldr	r3, [r7, #0]
 80154ea:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Byte 11 */
  tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
 80154ec:	687b      	ldr	r3, [r7, #4]
 80154ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80154f0:	b2db      	uxtb	r3, r3
 80154f2:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdSN |= tmp << 8U;
 80154f4:	683b      	ldr	r3, [r7, #0]
 80154f6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80154f8:	68bb      	ldr	r3, [r7, #8]
 80154fa:	021b      	lsls	r3, r3, #8
 80154fc:	431a      	orrs	r2, r3
 80154fe:	683b      	ldr	r3, [r7, #0]
 8015500:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Byte 12 */
  tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
 8015502:	687b      	ldr	r3, [r7, #4]
 8015504:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015506:	0e1b      	lsrs	r3, r3, #24
 8015508:	b2db      	uxtb	r3, r3
 801550a:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ProdSN |= tmp;
 801550c:	683b      	ldr	r3, [r7, #0]
 801550e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8015510:	68bb      	ldr	r3, [r7, #8]
 8015512:	431a      	orrs	r2, r3
 8015514:	683b      	ldr	r3, [r7, #0]
 8015516:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Byte 13 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
 8015518:	687b      	ldr	r3, [r7, #4]
 801551a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801551c:	0c1b      	lsrs	r3, r3, #16
 801551e:	b2db      	uxtb	r3, r3
 8015520:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.Reserved1   |= (tmp & 0xF0U) >> 4U;
 8015522:	683b      	ldr	r3, [r7, #0]
 8015524:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8015528:	b2da      	uxtb	r2, r3
 801552a:	68bb      	ldr	r3, [r7, #8]
 801552c:	091b      	lsrs	r3, r3, #4
 801552e:	b2db      	uxtb	r3, r3
 8015530:	f003 030f 	and.w	r3, r3, #15
 8015534:	b2db      	uxtb	r3, r3
 8015536:	4313      	orrs	r3, r2
 8015538:	b2da      	uxtb	r2, r3
 801553a:	683b      	ldr	r3, [r7, #0]
 801553c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  pCardInfo->SD_cid.ManufactDate = (tmp & 0x0FU) << 8U;
 8015540:	68bb      	ldr	r3, [r7, #8]
 8015542:	b29b      	uxth	r3, r3
 8015544:	021b      	lsls	r3, r3, #8
 8015546:	b29b      	uxth	r3, r3
 8015548:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 801554c:	b29a      	uxth	r2, r3
 801554e:	683b      	ldr	r3, [r7, #0]
 8015550:	87da      	strh	r2, [r3, #62]	; 0x3e
  
  /* Byte 14 */
  tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
 8015552:	687b      	ldr	r3, [r7, #4]
 8015554:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015556:	0a1b      	lsrs	r3, r3, #8
 8015558:	b2db      	uxtb	r3, r3
 801555a:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.ManufactDate |= tmp;
 801555c:	683b      	ldr	r3, [r7, #0]
 801555e:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8015560:	b29a      	uxth	r2, r3
 8015562:	68bb      	ldr	r3, [r7, #8]
 8015564:	b29b      	uxth	r3, r3
 8015566:	4313      	orrs	r3, r2
 8015568:	b29a      	uxth	r2, r3
 801556a:	683b      	ldr	r3, [r7, #0]
 801556c:	87da      	strh	r2, [r3, #62]	; 0x3e
  
  /* Byte 15 */
  tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
 801556e:	687b      	ldr	r3, [r7, #4]
 8015570:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8015572:	b2db      	uxtb	r3, r3
 8015574:	60bb      	str	r3, [r7, #8]
  pCardInfo->SD_cid.CID_CRC   = (tmp & 0xFEU) >> 1U;
 8015576:	68bb      	ldr	r3, [r7, #8]
 8015578:	085b      	lsrs	r3, r3, #1
 801557a:	b2db      	uxtb	r3, r3
 801557c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015580:	b2da      	uxtb	r2, r3
 8015582:	683b      	ldr	r3, [r7, #0]
 8015584:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  pCardInfo->SD_cid.Reserved2 = 1U;
 8015588:	683b      	ldr	r3, [r7, #0]
 801558a:	2201      	movs	r2, #1
 801558c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  
  return errorstate;
 8015590:	7bfb      	ldrb	r3, [r7, #15]
}
 8015592:	4618      	mov	r0, r3
 8015594:	3714      	adds	r7, #20
 8015596:	46bd      	mov	sp, r7
 8015598:	bcb0      	pop	{r4, r5, r7}
 801559a:	4770      	bx	lr

0801559c <HAL_SD_WideBusOperation_Config>:
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_WideBusOperation_Config(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 801559c:	b5b0      	push	{r4, r5, r7, lr}
 801559e:	b08e      	sub	sp, #56	; 0x38
 80155a0:	af04      	add	r7, sp, #16
 80155a2:	6078      	str	r0, [r7, #4]
 80155a4:	6039      	str	r1, [r7, #0]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 80155a6:	2300      	movs	r3, #0
 80155a8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  SDIO_InitTypeDef tmpinit;
  
  /* MMC Card does not support this feature */
  if (hsd->CardType == MULTIMEDIA_CARD)
 80155ac:	687b      	ldr	r3, [r7, #4]
 80155ae:	6a1b      	ldr	r3, [r3, #32]
 80155b0:	2b03      	cmp	r3, #3
 80155b2:	d105      	bne.n	80155c0 <HAL_SD_WideBusOperation_Config+0x24>
  {
    errorstate = SD_UNSUPPORTED_FEATURE;
 80155b4:	2327      	movs	r3, #39	; 0x27
 80155b6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 80155ba:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80155be:	e051      	b.n	8015664 <HAL_SD_WideBusOperation_Config+0xc8>
  }
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 80155c0:	687b      	ldr	r3, [r7, #4]
 80155c2:	6a1b      	ldr	r3, [r3, #32]
 80155c4:	2b00      	cmp	r3, #0
 80155c6:	d007      	beq.n	80155d8 <HAL_SD_WideBusOperation_Config+0x3c>
 80155c8:	687b      	ldr	r3, [r7, #4]
 80155ca:	6a1b      	ldr	r3, [r3, #32]
 80155cc:	2b01      	cmp	r3, #1
 80155ce:	d003      	beq.n	80155d8 <HAL_SD_WideBusOperation_Config+0x3c>
    (hsd->CardType == HIGH_CAPACITY_SD_CARD))
 80155d0:	687b      	ldr	r3, [r7, #4]
 80155d2:	6a1b      	ldr	r3, [r3, #32]
  else if ((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1) || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 80155d4:	2b02      	cmp	r3, #2
 80155d6:	d143      	bne.n	8015660 <HAL_SD_WideBusOperation_Config+0xc4>
  {
    if (WideMode == SDIO_BUS_WIDE_8B)
 80155d8:	683b      	ldr	r3, [r7, #0]
 80155da:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80155de:	d103      	bne.n	80155e8 <HAL_SD_WideBusOperation_Config+0x4c>
    {
      errorstate = SD_UNSUPPORTED_FEATURE;
 80155e0:	2327      	movs	r3, #39	; 0x27
 80155e2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80155e6:	e017      	b.n	8015618 <HAL_SD_WideBusOperation_Config+0x7c>
    }
    else if (WideMode == SDIO_BUS_WIDE_4B)
 80155e8:	683b      	ldr	r3, [r7, #0]
 80155ea:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80155ee:	d106      	bne.n	80155fe <HAL_SD_WideBusOperation_Config+0x62>
    {
      errorstate = SD_WideBus_Enable(hsd);
 80155f0:	6878      	ldr	r0, [r7, #4]
 80155f2:	f000 fd2c 	bl	801604e <SD_WideBus_Enable>
 80155f6:	4603      	mov	r3, r0
 80155f8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 80155fc:	e00c      	b.n	8015618 <HAL_SD_WideBusOperation_Config+0x7c>
    }
    else if (WideMode == SDIO_BUS_WIDE_1B)
 80155fe:	683b      	ldr	r3, [r7, #0]
 8015600:	2b00      	cmp	r3, #0
 8015602:	d106      	bne.n	8015612 <HAL_SD_WideBusOperation_Config+0x76>
    {
      errorstate = SD_WideBus_Disable(hsd);
 8015604:	6878      	ldr	r0, [r7, #4]
 8015606:	f000 fd9a 	bl	801613e <SD_WideBus_Disable>
 801560a:	4603      	mov	r3, r0
 801560c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8015610:	e002      	b.n	8015618 <HAL_SD_WideBusOperation_Config+0x7c>
    }
    else
    {
      /* WideMode is not a valid argument*/
      errorstate = SD_INVALID_PARAMETER;
 8015612:	2326      	movs	r3, #38	; 0x26
 8015614:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
      
    if (errorstate == SD_OK)
 8015618:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801561c:	2b00      	cmp	r3, #0
 801561e:	d11f      	bne.n	8015660 <HAL_SD_WideBusOperation_Config+0xc4>
    {
      /* Configure the SDIO peripheral */
      tmpinit.ClockEdge           = hsd->Init.ClockEdge;
 8015620:	687b      	ldr	r3, [r7, #4]
 8015622:	685b      	ldr	r3, [r3, #4]
 8015624:	60fb      	str	r3, [r7, #12]
      tmpinit.ClockBypass         = hsd->Init.ClockBypass;
 8015626:	687b      	ldr	r3, [r7, #4]
 8015628:	689b      	ldr	r3, [r3, #8]
 801562a:	613b      	str	r3, [r7, #16]
      tmpinit.ClockPowerSave      = hsd->Init.ClockPowerSave;
 801562c:	687b      	ldr	r3, [r7, #4]
 801562e:	68db      	ldr	r3, [r3, #12]
 8015630:	617b      	str	r3, [r7, #20]
      tmpinit.BusWide             = WideMode;
 8015632:	683b      	ldr	r3, [r7, #0]
 8015634:	61bb      	str	r3, [r7, #24]
      tmpinit.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 8015636:	687b      	ldr	r3, [r7, #4]
 8015638:	695b      	ldr	r3, [r3, #20]
 801563a:	61fb      	str	r3, [r7, #28]
      tmpinit.ClockDiv            = hsd->Init.ClockDiv;
 801563c:	687b      	ldr	r3, [r7, #4]
 801563e:	699b      	ldr	r3, [r3, #24]
 8015640:	623b      	str	r3, [r7, #32]
      SDIO_Init(hsd->Instance, tmpinit);
 8015642:	687b      	ldr	r3, [r7, #4]
 8015644:	681d      	ldr	r5, [r3, #0]
 8015646:	466c      	mov	r4, sp
 8015648:	f107 0318 	add.w	r3, r7, #24
 801564c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8015650:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8015654:	f107 030c 	add.w	r3, r7, #12
 8015658:	cb0e      	ldmia	r3, {r1, r2, r3}
 801565a:	4628      	mov	r0, r5
 801565c:	f002 f828 	bl	80176b0 <SDIO_Init>
    }
  }
  
  return errorstate;
 8015660:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8015664:	4618      	mov	r0, r3
 8015666:	3728      	adds	r7, #40	; 0x28
 8015668:	46bd      	mov	sp, r7
 801566a:	bdb0      	pop	{r4, r5, r7, pc}

0801566c <HAL_SD_StopTransfer>:
  * @brief  Aborts an ongoing data transfer.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
HAL_SD_ErrorTypedef HAL_SD_StopTransfer(SD_HandleTypeDef *hsd)
{
 801566c:	b580      	push	{r7, lr}
 801566e:	b088      	sub	sp, #32
 8015670:	af00      	add	r7, sp, #0
 8015672:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015674:	2300      	movs	r3, #0
 8015676:	77fb      	strb	r3, [r7, #31]
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdio_cmdinitstructure.Argument         = 0U;
 8015678:	2300      	movs	r3, #0
 801567a:	60bb      	str	r3, [r7, #8]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_STOP_TRANSMISSION;
 801567c:	230c      	movs	r3, #12
 801567e:	60fb      	str	r3, [r7, #12]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015680:	2340      	movs	r3, #64	; 0x40
 8015682:	613b      	str	r3, [r7, #16]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8015684:	2300      	movs	r3, #0
 8015686:	617b      	str	r3, [r7, #20]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015688:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801568c:	61bb      	str	r3, [r7, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 801568e:	687b      	ldr	r3, [r7, #4]
 8015690:	681b      	ldr	r3, [r3, #0]
 8015692:	f107 0208 	add.w	r2, r7, #8
 8015696:	4611      	mov	r1, r2
 8015698:	4618      	mov	r0, r3
 801569a:	f002 f85d 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_STOP_TRANSMISSION);
 801569e:	210c      	movs	r1, #12
 80156a0:	6878      	ldr	r0, [r7, #4]
 80156a2:	f000 fb31 	bl	8015d08 <SD_CmdResp1Error>
 80156a6:	4603      	mov	r3, r0
 80156a8:	77fb      	strb	r3, [r7, #31]
  
  return errorstate;
 80156aa:	7ffb      	ldrb	r3, [r7, #31]
}
 80156ac:	4618      	mov	r0, r3
 80156ae:	3720      	adds	r7, #32
 80156b0:	46bd      	mov	sp, r7
 80156b2:	bd80      	pop	{r7, pc}

080156b4 <HAL_SD_GetStatus>:
  * @brief  Gets the current sd card data status.
  * @param  hsd: SD handle
  * @retval Data Transfer state
  */
HAL_SD_TransferStateTypedef HAL_SD_GetStatus(SD_HandleTypeDef *hsd)
{
 80156b4:	b580      	push	{r7, lr}
 80156b6:	b084      	sub	sp, #16
 80156b8:	af00      	add	r7, sp, #0
 80156ba:	6078      	str	r0, [r7, #4]
  HAL_SD_CardStateTypedef cardstate =  SD_CARD_TRANSFER;
 80156bc:	2304      	movs	r3, #4
 80156be:	73fb      	strb	r3, [r7, #15]

  /* Get SD card state */
  cardstate = SD_GetState(hsd);
 80156c0:	6878      	ldr	r0, [r7, #4]
 80156c2:	f000 f867 	bl	8015794 <SD_GetState>
 80156c6:	4603      	mov	r3, r0
 80156c8:	73fb      	strb	r3, [r7, #15]
  
  /* Find SD status according to card state*/
  if (cardstate == SD_CARD_TRANSFER)
 80156ca:	7bfb      	ldrb	r3, [r7, #15]
 80156cc:	2b04      	cmp	r3, #4
 80156ce:	d101      	bne.n	80156d4 <HAL_SD_GetStatus+0x20>
  {
    return SD_TRANSFER_OK;
 80156d0:	2300      	movs	r3, #0
 80156d2:	e005      	b.n	80156e0 <HAL_SD_GetStatus+0x2c>
  }
  else if(cardstate == SD_CARD_ERROR)
 80156d4:	7bfb      	ldrb	r3, [r7, #15]
 80156d6:	2bff      	cmp	r3, #255	; 0xff
 80156d8:	d101      	bne.n	80156de <HAL_SD_GetStatus+0x2a>
  {
    return SD_TRANSFER_ERROR;
 80156da:	2302      	movs	r3, #2
 80156dc:	e000      	b.n	80156e0 <HAL_SD_GetStatus+0x2c>
  }
  else
  {
    return SD_TRANSFER_BUSY;
 80156de:	2301      	movs	r3, #1
  }
}
 80156e0:	4618      	mov	r0, r3
 80156e2:	3710      	adds	r7, #16
 80156e4:	46bd      	mov	sp, r7
 80156e6:	bd80      	pop	{r7, pc}

080156e8 <SD_DMA_RxCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SD_DMA_RxCplt(DMA_HandleTypeDef *hdma)
{
 80156e8:	b580      	push	{r7, lr}
 80156ea:	b084      	sub	sp, #16
 80156ec:	af00      	add	r7, sp, #0
 80156ee:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 80156f0:	687b      	ldr	r3, [r7, #4]
 80156f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80156f4:	60fb      	str	r3, [r7, #12]
  
  /* DMA transfer is complete */
  hsd->DmaTransferCplt = 1U;
 80156f6:	68fb      	ldr	r3, [r7, #12]
 80156f8:	2201      	movs	r2, #1
 80156fa:	651a      	str	r2, [r3, #80]	; 0x50
  
  /* Wait until SD transfer is complete */
  while(hsd->SdTransferCplt == 0U)
 80156fc:	bf00      	nop
 80156fe:	68fb      	ldr	r3, [r7, #12]
 8015700:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015702:	2b00      	cmp	r3, #0
 8015704:	d0fb      	beq.n	80156fe <SD_DMA_RxCplt+0x16>
  {
  }
  
  /* Disable the DMA channel */
  HAL_DMA_Abort(hdma);
 8015706:	6878      	ldr	r0, [r7, #4]
 8015708:	f7fc fb9f 	bl	8011e4a <HAL_DMA_Abort>

  /* Transfer complete user callback */
  HAL_SD_DMA_RxCpltCallback(hsd->hdmarx);   
 801570c:	68fb      	ldr	r3, [r7, #12]
 801570e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8015710:	4618      	mov	r0, r3
 8015712:	f7ff fc10 	bl	8014f36 <HAL_SD_DMA_RxCpltCallback>
}
 8015716:	bf00      	nop
 8015718:	3710      	adds	r7, #16
 801571a:	46bd      	mov	sp, r7
 801571c:	bd80      	pop	{r7, pc}

0801571e <SD_DMA_RxError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SD_DMA_RxError(DMA_HandleTypeDef *hdma)
{
 801571e:	b580      	push	{r7, lr}
 8015720:	b084      	sub	sp, #16
 8015722:	af00      	add	r7, sp, #0
 8015724:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8015726:	687b      	ldr	r3, [r7, #4]
 8015728:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801572a:	60fb      	str	r3, [r7, #12]
  
  /* Transfer complete user callback */
  HAL_SD_DMA_RxErrorCallback(hsd->hdmarx);
 801572c:	68fb      	ldr	r3, [r7, #12]
 801572e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8015730:	4618      	mov	r0, r3
 8015732:	f7ff fc0a 	bl	8014f4a <HAL_SD_DMA_RxErrorCallback>
}
 8015736:	bf00      	nop
 8015738:	3710      	adds	r7, #16
 801573a:	46bd      	mov	sp, r7
 801573c:	bd80      	pop	{r7, pc}

0801573e <SD_DMA_TxCplt>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SD_DMA_TxCplt(DMA_HandleTypeDef *hdma)
{
 801573e:	b580      	push	{r7, lr}
 8015740:	b084      	sub	sp, #16
 8015742:	af00      	add	r7, sp, #0
 8015744:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef *hsd = (SD_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
 8015746:	687b      	ldr	r3, [r7, #4]
 8015748:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801574a:	60fb      	str	r3, [r7, #12]
  
  /* DMA transfer is complete */
  hsd->DmaTransferCplt = 1U;
 801574c:	68fb      	ldr	r3, [r7, #12]
 801574e:	2201      	movs	r2, #1
 8015750:	651a      	str	r2, [r3, #80]	; 0x50
  
  /* Wait until SD transfer is complete */
  while(hsd->SdTransferCplt == 0U)
 8015752:	bf00      	nop
 8015754:	68fb      	ldr	r3, [r7, #12]
 8015756:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8015758:	2b00      	cmp	r3, #0
 801575a:	d0fb      	beq.n	8015754 <SD_DMA_TxCplt+0x16>
  {
  }
 
  /* Disable the DMA channel */
  HAL_DMA_Abort(hdma);
 801575c:	6878      	ldr	r0, [r7, #4]
 801575e:	f7fc fb74 	bl	8011e4a <HAL_DMA_Abort>

  /* Transfer complete user callback */
  HAL_SD_DMA_TxCpltCallback(hsd->hdmatx);  
 8015762:	68fb      	ldr	r3, [r7, #12]
 8015764:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8015766:	4618      	mov	r0, r3
 8015768:	f7ff fbf9 	bl	8014f5e <HAL_SD_DMA_TxCpltCallback>
}
 801576c:	bf00      	nop
 801576e:	3710      	adds	r7, #16
 8015770:	46bd      	mov	sp, r7
 8015772:	bd80      	pop	{r7, pc}

08015774 <SD_DMA_TxError>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SD_DMA_TxError(DMA_HandleTypeDef *hdma)
{
 8015774:	b580      	push	{r7, lr}
 8015776:	b084      	sub	sp, #16
 8015778:	af00      	add	r7, sp, #0
 801577a:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef *hsd = ( SD_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 801577c:	687b      	ldr	r3, [r7, #4]
 801577e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8015780:	60fb      	str	r3, [r7, #12]
  
  /* Transfer complete user callback */
  HAL_SD_DMA_TxErrorCallback(hsd->hdmatx);
 8015782:	68fb      	ldr	r3, [r7, #12]
 8015784:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8015786:	4618      	mov	r0, r3
 8015788:	f7ff fbf3 	bl	8014f72 <HAL_SD_DMA_TxErrorCallback>
}
 801578c:	bf00      	nop
 801578e:	3710      	adds	r7, #16
 8015790:	46bd      	mov	sp, r7
 8015792:	bd80      	pop	{r7, pc}

08015794 <SD_GetState>:
  * @brief  Returns the SD current state.
  * @param  hsd: SD handle
  * @retval SD card current state
  */
static HAL_SD_CardStateTypedef SD_GetState(SD_HandleTypeDef *hsd)
{
 8015794:	b580      	push	{r7, lr}
 8015796:	b084      	sub	sp, #16
 8015798:	af00      	add	r7, sp, #0
 801579a:	6078      	str	r0, [r7, #4]
  uint32_t resp1 = 0U;
 801579c:	2300      	movs	r3, #0
 801579e:	60fb      	str	r3, [r7, #12]
  
  if (SD_SendStatus(hsd, &resp1) != SD_OK)
 80157a0:	f107 030c 	add.w	r3, r7, #12
 80157a4:	4619      	mov	r1, r3
 80157a6:	6878      	ldr	r0, [r7, #4]
 80157a8:	f000 f9e0 	bl	8015b6c <SD_SendStatus>
 80157ac:	4603      	mov	r3, r0
 80157ae:	2b00      	cmp	r3, #0
 80157b0:	d001      	beq.n	80157b6 <SD_GetState+0x22>
  {
    return SD_CARD_ERROR;
 80157b2:	23ff      	movs	r3, #255	; 0xff
 80157b4:	e005      	b.n	80157c2 <SD_GetState+0x2e>
  }
  else
  {
    return (HAL_SD_CardStateTypedef)((resp1 >> 9U) & 0x0FU);
 80157b6:	68fb      	ldr	r3, [r7, #12]
 80157b8:	0a5b      	lsrs	r3, r3, #9
 80157ba:	b2db      	uxtb	r3, r3
 80157bc:	f003 030f 	and.w	r3, r3, #15
 80157c0:	b2db      	uxtb	r3, r3
  }
}
 80157c2:	4618      	mov	r0, r3
 80157c4:	3710      	adds	r7, #16
 80157c6:	46bd      	mov	sp, r7
 80157c8:	bd80      	pop	{r7, pc}

080157ca <SD_Initialize_Cards>:
  *         into standby state.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_Initialize_Cards(SD_HandleTypeDef *hsd)
{
 80157ca:	b580      	push	{r7, lr}
 80157cc:	b08a      	sub	sp, #40	; 0x28
 80157ce:	af00      	add	r7, sp, #0
 80157d0:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 80157d2:	2300      	movs	r3, #0
 80157d4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint16_t sd_rca = 1U;
 80157d8:	2301      	movs	r3, #1
 80157da:	81fb      	strh	r3, [r7, #14]
  
  if(SDIO_GetPowerState(hsd->Instance) == 0U) /* Power off */
 80157dc:	687b      	ldr	r3, [r7, #4]
 80157de:	681b      	ldr	r3, [r3, #0]
 80157e0:	4618      	mov	r0, r3
 80157e2:	f001 ffab 	bl	801773c <SDIO_GetPowerState>
 80157e6:	4603      	mov	r3, r0
 80157e8:	2b00      	cmp	r3, #0
 80157ea:	d105      	bne.n	80157f8 <SD_Initialize_Cards+0x2e>
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
 80157ec:	2325      	movs	r3, #37	; 0x25
 80157ee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 80157f2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80157f6:	e0a7      	b.n	8015948 <SD_Initialize_Cards+0x17e>
  }
  
  if(hsd->CardType != SECURE_DIGITAL_IO_CARD)
 80157f8:	687b      	ldr	r3, [r7, #4]
 80157fa:	6a1b      	ldr	r3, [r3, #32]
 80157fc:	2b04      	cmp	r3, #4
 80157fe:	d037      	beq.n	8015870 <SD_Initialize_Cards+0xa6>
  {
    /* Send CMD2 ALL_SEND_CID */
    sdio_cmdinitstructure.Argument         = 0U;
 8015800:	2300      	movs	r3, #0
 8015802:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_ALL_SEND_CID;
 8015804:	2302      	movs	r3, #2
 8015806:	617b      	str	r3, [r7, #20]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 8015808:	23c0      	movs	r3, #192	; 0xc0
 801580a:	61bb      	str	r3, [r7, #24]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 801580c:	2300      	movs	r3, #0
 801580e:	61fb      	str	r3, [r7, #28]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015810:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015814:	623b      	str	r3, [r7, #32]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015816:	687b      	ldr	r3, [r7, #4]
 8015818:	681b      	ldr	r3, [r3, #0]
 801581a:	f107 0210 	add.w	r2, r7, #16
 801581e:	4611      	mov	r1, r2
 8015820:	4618      	mov	r0, r3
 8015822:	f001 ff99 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 8015826:	6878      	ldr	r0, [r7, #4]
 8015828:	f000 fb6d 	bl	8015f06 <SD_CmdResp2Error>
 801582c:	4603      	mov	r3, r0
 801582e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 8015832:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8015836:	2b00      	cmp	r3, #0
 8015838:	d002      	beq.n	8015840 <SD_Initialize_Cards+0x76>
    {
      return errorstate;
 801583a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801583e:	e083      	b.n	8015948 <SD_Initialize_Cards+0x17e>
    }
    
    /* Get Card identification number data */
    hsd->CID[0U] = SDIO_GetResponse(SDIO_RESP1);
 8015840:	2000      	movs	r0, #0
 8015842:	f001 ffc1 	bl	80177c8 <SDIO_GetResponse>
 8015846:	4602      	mov	r2, r0
 8015848:	687b      	ldr	r3, [r7, #4]
 801584a:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->CID[1U] = SDIO_GetResponse(SDIO_RESP2);
 801584c:	2004      	movs	r0, #4
 801584e:	f001 ffbb 	bl	80177c8 <SDIO_GetResponse>
 8015852:	4602      	mov	r2, r0
 8015854:	687b      	ldr	r3, [r7, #4]
 8015856:	63da      	str	r2, [r3, #60]	; 0x3c
    hsd->CID[2U] = SDIO_GetResponse(SDIO_RESP3);
 8015858:	2008      	movs	r0, #8
 801585a:	f001 ffb5 	bl	80177c8 <SDIO_GetResponse>
 801585e:	4602      	mov	r2, r0
 8015860:	687b      	ldr	r3, [r7, #4]
 8015862:	641a      	str	r2, [r3, #64]	; 0x40
    hsd->CID[3U] = SDIO_GetResponse(SDIO_RESP4);
 8015864:	200c      	movs	r0, #12
 8015866:	f001 ffaf 	bl	80177c8 <SDIO_GetResponse>
 801586a:	4602      	mov	r2, r0
 801586c:	687b      	ldr	r3, [r7, #4]
 801586e:	645a      	str	r2, [r3, #68]	; 0x44
  }
  
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8015870:	687b      	ldr	r3, [r7, #4]
 8015872:	6a1b      	ldr	r3, [r3, #32]
 8015874:	2b00      	cmp	r3, #0
 8015876:	d00b      	beq.n	8015890 <SD_Initialize_Cards+0xc6>
 8015878:	687b      	ldr	r3, [r7, #4]
 801587a:	6a1b      	ldr	r3, [r3, #32]
 801587c:	2b01      	cmp	r3, #1
 801587e:	d007      	beq.n	8015890 <SD_Initialize_Cards+0xc6>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
 8015880:	687b      	ldr	r3, [r7, #4]
 8015882:	6a1b      	ldr	r3, [r3, #32]
  if((hsd->CardType == STD_CAPACITY_SD_CARD_V1_1)    || (hsd->CardType == STD_CAPACITY_SD_CARD_V2_0) ||\
 8015884:	2b06      	cmp	r3, #6
 8015886:	d003      	beq.n	8015890 <SD_Initialize_Cards+0xc6>
     (hsd->CardType == SECURE_DIGITAL_IO_COMBO_CARD) || (hsd->CardType == HIGH_CAPACITY_SD_CARD))
 8015888:	687b      	ldr	r3, [r7, #4]
 801588a:	6a1b      	ldr	r3, [r3, #32]
 801588c:	2b02      	cmp	r3, #2
 801588e:	d11c      	bne.n	80158ca <SD_Initialize_Cards+0x100>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_REL_ADDR;
 8015890:	2303      	movs	r3, #3
 8015892:	617b      	str	r3, [r7, #20]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015894:	2340      	movs	r3, #64	; 0x40
 8015896:	61bb      	str	r3, [r7, #24]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015898:	687b      	ldr	r3, [r7, #4]
 801589a:	681b      	ldr	r3, [r3, #0]
 801589c:	f107 0210 	add.w	r2, r7, #16
 80158a0:	4611      	mov	r1, r2
 80158a2:	4618      	mov	r0, r3
 80158a4:	f001 ff58 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp6Error(hsd, SD_CMD_SET_REL_ADDR, &sd_rca);
 80158a8:	f107 030e 	add.w	r3, r7, #14
 80158ac:	461a      	mov	r2, r3
 80158ae:	2103      	movs	r1, #3
 80158b0:	6878      	ldr	r0, [r7, #4]
 80158b2:	f000 fb60 	bl	8015f76 <SD_CmdResp6Error>
 80158b6:	4603      	mov	r3, r0
 80158b8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 80158bc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80158c0:	2b00      	cmp	r3, #0
 80158c2:	d002      	beq.n	80158ca <SD_Initialize_Cards+0x100>
    {
      return errorstate;
 80158c4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80158c8:	e03e      	b.n	8015948 <SD_Initialize_Cards+0x17e>
    }
  }
  
  if (hsd->CardType != SECURE_DIGITAL_IO_CARD)
 80158ca:	687b      	ldr	r3, [r7, #4]
 80158cc:	6a1b      	ldr	r3, [r3, #32]
 80158ce:	2b04      	cmp	r3, #4
 80158d0:	d038      	beq.n	8015944 <SD_Initialize_Cards+0x17a>
  {
    /* Get the SD card RCA */
    hsd->RCA = sd_rca;
 80158d2:	89fb      	ldrh	r3, [r7, #14]
 80158d4:	461a      	mov	r2, r3
 80158d6:	687b      	ldr	r3, [r7, #4]
 80158d8:	625a      	str	r2, [r3, #36]	; 0x24
    
    /* Send CMD9 SEND_CSD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80158da:	687b      	ldr	r3, [r7, #4]
 80158dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80158de:	041b      	lsls	r3, r3, #16
 80158e0:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_CSD;
 80158e2:	2309      	movs	r3, #9
 80158e4:	617b      	str	r3, [r7, #20]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_LONG;
 80158e6:	23c0      	movs	r3, #192	; 0xc0
 80158e8:	61bb      	str	r3, [r7, #24]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80158ea:	687b      	ldr	r3, [r7, #4]
 80158ec:	681b      	ldr	r3, [r3, #0]
 80158ee:	f107 0210 	add.w	r2, r7, #16
 80158f2:	4611      	mov	r1, r2
 80158f4:	4618      	mov	r0, r3
 80158f6:	f001 ff2f 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp2Error(hsd);
 80158fa:	6878      	ldr	r0, [r7, #4]
 80158fc:	f000 fb03 	bl	8015f06 <SD_CmdResp2Error>
 8015900:	4603      	mov	r3, r0
 8015902:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 8015906:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801590a:	2b00      	cmp	r3, #0
 801590c:	d002      	beq.n	8015914 <SD_Initialize_Cards+0x14a>
    {
      return errorstate;
 801590e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8015912:	e019      	b.n	8015948 <SD_Initialize_Cards+0x17e>
    }
    
    /* Get Card Specific Data */
    hsd->CSD[0U] = SDIO_GetResponse(SDIO_RESP1);
 8015914:	2000      	movs	r0, #0
 8015916:	f001 ff57 	bl	80177c8 <SDIO_GetResponse>
 801591a:	4602      	mov	r2, r0
 801591c:	687b      	ldr	r3, [r7, #4]
 801591e:	629a      	str	r2, [r3, #40]	; 0x28
    hsd->CSD[1U] = SDIO_GetResponse(SDIO_RESP2);
 8015920:	2004      	movs	r0, #4
 8015922:	f001 ff51 	bl	80177c8 <SDIO_GetResponse>
 8015926:	4602      	mov	r2, r0
 8015928:	687b      	ldr	r3, [r7, #4]
 801592a:	62da      	str	r2, [r3, #44]	; 0x2c
    hsd->CSD[2U] = SDIO_GetResponse(SDIO_RESP3);
 801592c:	2008      	movs	r0, #8
 801592e:	f001 ff4b 	bl	80177c8 <SDIO_GetResponse>
 8015932:	4602      	mov	r2, r0
 8015934:	687b      	ldr	r3, [r7, #4]
 8015936:	631a      	str	r2, [r3, #48]	; 0x30
    hsd->CSD[3U] = SDIO_GetResponse(SDIO_RESP4);
 8015938:	200c      	movs	r0, #12
 801593a:	f001 ff45 	bl	80177c8 <SDIO_GetResponse>
 801593e:	4602      	mov	r2, r0
 8015940:	687b      	ldr	r3, [r7, #4]
 8015942:	635a      	str	r2, [r3, #52]	; 0x34
  }
  
  /* All cards are initialized */
  return errorstate;
 8015944:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8015948:	4618      	mov	r0, r3
 801594a:	3728      	adds	r7, #40	; 0x28
 801594c:	46bd      	mov	sp, r7
 801594e:	bd80      	pop	{r7, pc}

08015950 <SD_Select_Deselect>:
  * @param  hsd: SD handle
  * @param  addr: Address of the card to be selected  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_Select_Deselect(SD_HandleTypeDef *hsd, uint64_t addr)
{
 8015950:	b580      	push	{r7, lr}
 8015952:	b08a      	sub	sp, #40	; 0x28
 8015954:	af00      	add	r7, sp, #0
 8015956:	60f8      	str	r0, [r7, #12]
 8015958:	e9c7 2300 	strd	r2, r3, [r7]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 801595c:	2300      	movs	r3, #0
 801595e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  /* Send CMD7 SDIO_SEL_DESEL_CARD */
  sdio_cmdinitstructure.Argument         = (uint32_t)addr;
 8015962:	683b      	ldr	r3, [r7, #0]
 8015964:	613b      	str	r3, [r7, #16]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEL_DESEL_CARD;
 8015966:	2307      	movs	r3, #7
 8015968:	617b      	str	r3, [r7, #20]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 801596a:	2340      	movs	r3, #64	; 0x40
 801596c:	61bb      	str	r3, [r7, #24]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 801596e:	2300      	movs	r3, #0
 8015970:	61fb      	str	r3, [r7, #28]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015972:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015976:	623b      	str	r3, [r7, #32]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015978:	68fb      	ldr	r3, [r7, #12]
 801597a:	681b      	ldr	r3, [r3, #0]
 801597c:	f107 0210 	add.w	r2, r7, #16
 8015980:	4611      	mov	r1, r2
 8015982:	4618      	mov	r0, r3
 8015984:	f001 fee8 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEL_DESEL_CARD);
 8015988:	2107      	movs	r1, #7
 801598a:	68f8      	ldr	r0, [r7, #12]
 801598c:	f000 f9bc 	bl	8015d08 <SD_CmdResp1Error>
 8015990:	4603      	mov	r3, r0
 8015992:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  return errorstate;
 8015996:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 801599a:	4618      	mov	r0, r3
 801599c:	3728      	adds	r7, #40	; 0x28
 801599e:	46bd      	mov	sp, r7
 80159a0:	bd80      	pop	{r7, pc}
	...

080159a4 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_PowerON(SD_HandleTypeDef *hsd)
{
 80159a4:	b580      	push	{r7, lr}
 80159a6:	b08c      	sub	sp, #48	; 0x30
 80159a8:	af00      	add	r7, sp, #0
 80159aa:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure; 
  __IO HAL_SD_ErrorTypedef errorstate = SD_OK; 
 80159ac:	2300      	movs	r3, #0
 80159ae:	72fb      	strb	r3, [r7, #11]
  uint32_t response = 0U, count = 0U, validvoltage = 0U;
 80159b0:	2300      	movs	r3, #0
 80159b2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80159b4:	2300      	movs	r3, #0
 80159b6:	62bb      	str	r3, [r7, #40]	; 0x28
 80159b8:	2300      	movs	r3, #0
 80159ba:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t sdtype = SD_STD_CAPACITY;
 80159bc:	2300      	movs	r3, #0
 80159be:	623b      	str	r3, [r7, #32]
  
  /* Power ON Sequence -------------------------------------------------------*/
  /* Disable SDIO Clock */
  __HAL_SD_SDIO_DISABLE(); 
 80159c0:	4b69      	ldr	r3, [pc, #420]	; (8015b68 <SD_PowerON+0x1c4>)
 80159c2:	2200      	movs	r2, #0
 80159c4:	601a      	str	r2, [r3, #0]
  
  /* Set Power State to ON */
  SDIO_PowerState_ON(hsd->Instance);
 80159c6:	687b      	ldr	r3, [r7, #4]
 80159c8:	681b      	ldr	r3, [r3, #0]
 80159ca:	4618      	mov	r0, r3
 80159cc:	f001 fea8 	bl	8017720 <SDIO_PowerState_ON>
  
  /* 1ms: required power up waiting time before starting the SD initialization 
     sequence */
  HAL_Delay(1);
 80159d0:	2001      	movs	r0, #1
 80159d2:	f7fb fdb5 	bl	8011540 <HAL_Delay>
  
  /* Enable SDIO Clock */
  __HAL_SD_SDIO_ENABLE();
 80159d6:	4b64      	ldr	r3, [pc, #400]	; (8015b68 <SD_PowerON+0x1c4>)
 80159d8:	2201      	movs	r2, #1
 80159da:	601a      	str	r2, [r3, #0]
  
  /* CMD0: GO_IDLE_STATE -----------------------------------------------------*/
  /* No CMD response required */
  sdio_cmdinitstructure.Argument         = 0U;
 80159dc:	2300      	movs	r3, #0
 80159de:	60fb      	str	r3, [r7, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_GO_IDLE_STATE;
 80159e0:	2300      	movs	r3, #0
 80159e2:	613b      	str	r3, [r7, #16]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_NO;
 80159e4:	2300      	movs	r3, #0
 80159e6:	617b      	str	r3, [r7, #20]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80159e8:	2300      	movs	r3, #0
 80159ea:	61bb      	str	r3, [r7, #24]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80159ec:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80159f0:	61fb      	str	r3, [r7, #28]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80159f2:	687b      	ldr	r3, [r7, #4]
 80159f4:	681b      	ldr	r3, [r3, #0]
 80159f6:	f107 020c 	add.w	r2, r7, #12
 80159fa:	4611      	mov	r1, r2
 80159fc:	4618      	mov	r0, r3
 80159fe:	f001 feab 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdError(hsd);
 8015a02:	6878      	ldr	r0, [r7, #4]
 8015a04:	f000 f8eb 	bl	8015bde <SD_CmdError>
 8015a08:	4603      	mov	r3, r0
 8015a0a:	72fb      	strb	r3, [r7, #11]
  
  if(errorstate != SD_OK)
 8015a0c:	7afb      	ldrb	r3, [r7, #11]
 8015a0e:	b2db      	uxtb	r3, r3
 8015a10:	2b00      	cmp	r3, #0
 8015a12:	d002      	beq.n	8015a1a <SD_PowerON+0x76>
  {
    /* CMD Response Timeout (wait for CMDSENT flag) */
    return errorstate;
 8015a14:	7afb      	ldrb	r3, [r7, #11]
 8015a16:	b2db      	uxtb	r3, r3
 8015a18:	e0a2      	b.n	8015b60 <SD_PowerON+0x1bc>
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdio_cmdinitstructure.Argument         = SD_CHECK_PATTERN;
 8015a1a:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 8015a1e:	60fb      	str	r3, [r7, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_SDIO_SEND_IF_COND;
 8015a20:	2308      	movs	r3, #8
 8015a22:	613b      	str	r3, [r7, #16]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015a24:	2340      	movs	r3, #64	; 0x40
 8015a26:	617b      	str	r3, [r7, #20]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015a28:	687b      	ldr	r3, [r7, #4]
 8015a2a:	681b      	ldr	r3, [r3, #0]
 8015a2c:	f107 020c 	add.w	r2, r7, #12
 8015a30:	4611      	mov	r1, r2
 8015a32:	4618      	mov	r0, r3
 8015a34:	f001 fe90 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */ 
  errorstate = SD_CmdResp7Error(hsd);
 8015a38:	6878      	ldr	r0, [r7, #4]
 8015a3a:	f000 f90c 	bl	8015c56 <SD_CmdResp7Error>
 8015a3e:	4603      	mov	r3, r0
 8015a40:	72fb      	strb	r3, [r7, #11]
  
  if (errorstate == SD_OK)
 8015a42:	7afb      	ldrb	r3, [r7, #11]
 8015a44:	b2db      	uxtb	r3, r3
 8015a46:	2b00      	cmp	r3, #0
 8015a48:	d105      	bne.n	8015a56 <SD_PowerON+0xb2>
  {
    /* SD Card 2.0 */
    hsd->CardType = STD_CAPACITY_SD_CARD_V2_0; 
 8015a4a:	687b      	ldr	r3, [r7, #4]
 8015a4c:	2201      	movs	r2, #1
 8015a4e:	621a      	str	r2, [r3, #32]
    sdtype        = SD_HIGH_CAPACITY;
 8015a50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8015a54:	623b      	str	r3, [r7, #32]
  }
  
  /* Send CMD55 */
  sdio_cmdinitstructure.Argument         = 0U;
 8015a56:	2300      	movs	r3, #0
 8015a58:	60fb      	str	r3, [r7, #12]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8015a5a:	2337      	movs	r3, #55	; 0x37
 8015a5c:	613b      	str	r3, [r7, #16]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015a5e:	687b      	ldr	r3, [r7, #4]
 8015a60:	681b      	ldr	r3, [r3, #0]
 8015a62:	f107 020c 	add.w	r2, r7, #12
 8015a66:	4611      	mov	r1, r2
 8015a68:	4618      	mov	r0, r3
 8015a6a:	f001 fe75 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8015a6e:	2137      	movs	r1, #55	; 0x37
 8015a70:	6878      	ldr	r0, [r7, #4]
 8015a72:	f000 f949 	bl	8015d08 <SD_CmdResp1Error>
 8015a76:	4603      	mov	r3, r0
 8015a78:	72fb      	strb	r3, [r7, #11]
  
  /* If errorstate is Command Timeout, it is a MMC card */
  /* If errorstate is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  if(errorstate == SD_OK)
 8015a7a:	7afb      	ldrb	r3, [r7, #11]
 8015a7c:	b2db      	uxtb	r3, r3
 8015a7e:	2b00      	cmp	r3, #0
 8015a80:	d16c      	bne.n	8015b5c <SD_PowerON+0x1b8>
  {
    /* SD CARD */
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 8015a82:	e051      	b.n	8015b28 <SD_PowerON+0x184>
    {
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      sdio_cmdinitstructure.Argument         = 0U;
 8015a84:	2300      	movs	r3, #0
 8015a86:	60fb      	str	r3, [r7, #12]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8015a88:	2337      	movs	r3, #55	; 0x37
 8015a8a:	613b      	str	r3, [r7, #16]
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015a8c:	2340      	movs	r3, #64	; 0x40
 8015a8e:	617b      	str	r3, [r7, #20]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8015a90:	2300      	movs	r3, #0
 8015a92:	61bb      	str	r3, [r7, #24]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015a94:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015a98:	61fb      	str	r3, [r7, #28]
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015a9a:	687b      	ldr	r3, [r7, #4]
 8015a9c:	681b      	ldr	r3, [r3, #0]
 8015a9e:	f107 020c 	add.w	r2, r7, #12
 8015aa2:	4611      	mov	r1, r2
 8015aa4:	4618      	mov	r0, r3
 8015aa6:	f001 fe57 	bl	8017758 <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 8015aaa:	2137      	movs	r1, #55	; 0x37
 8015aac:	6878      	ldr	r0, [r7, #4]
 8015aae:	f000 f92b 	bl	8015d08 <SD_CmdResp1Error>
 8015ab2:	4603      	mov	r3, r0
 8015ab4:	72fb      	strb	r3, [r7, #11]
      
      if(errorstate != SD_OK)
 8015ab6:	7afb      	ldrb	r3, [r7, #11]
 8015ab8:	b2db      	uxtb	r3, r3
 8015aba:	2b00      	cmp	r3, #0
 8015abc:	d002      	beq.n	8015ac4 <SD_PowerON+0x120>
      {
        return errorstate;
 8015abe:	7afb      	ldrb	r3, [r7, #11]
 8015ac0:	b2db      	uxtb	r3, r3
 8015ac2:	e04d      	b.n	8015b60 <SD_PowerON+0x1bc>
      }
      
      /* Send CMD41 */
      sdio_cmdinitstructure.Argument         = SD_VOLTAGE_WINDOW_SD | sdtype;
 8015ac4:	6a3b      	ldr	r3, [r7, #32]
 8015ac6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8015aca:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8015ace:	60fb      	str	r3, [r7, #12]
      sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_OP_COND;
 8015ad0:	2329      	movs	r3, #41	; 0x29
 8015ad2:	613b      	str	r3, [r7, #16]
      sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015ad4:	2340      	movs	r3, #64	; 0x40
 8015ad6:	617b      	str	r3, [r7, #20]
      sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8015ad8:	2300      	movs	r3, #0
 8015ada:	61bb      	str	r3, [r7, #24]
      sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015adc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015ae0:	61fb      	str	r3, [r7, #28]
      SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015ae2:	687b      	ldr	r3, [r7, #4]
 8015ae4:	681b      	ldr	r3, [r3, #0]
 8015ae6:	f107 020c 	add.w	r2, r7, #12
 8015aea:	4611      	mov	r1, r2
 8015aec:	4618      	mov	r0, r3
 8015aee:	f001 fe33 	bl	8017758 <SDIO_SendCommand>
      
      /* Check for error conditions */
      errorstate = SD_CmdResp3Error(hsd);
 8015af2:	6878      	ldr	r0, [r7, #4]
 8015af4:	f000 f9de 	bl	8015eb4 <SD_CmdResp3Error>
 8015af8:	4603      	mov	r3, r0
 8015afa:	72fb      	strb	r3, [r7, #11]
      
      if(errorstate != SD_OK)
 8015afc:	7afb      	ldrb	r3, [r7, #11]
 8015afe:	b2db      	uxtb	r3, r3
 8015b00:	2b00      	cmp	r3, #0
 8015b02:	d002      	beq.n	8015b0a <SD_PowerON+0x166>
      {
        return errorstate;
 8015b04:	7afb      	ldrb	r3, [r7, #11]
 8015b06:	b2db      	uxtb	r3, r3
 8015b08:	e02a      	b.n	8015b60 <SD_PowerON+0x1bc>
      }
      
      /* Get command response */
      response = SDIO_GetResponse(SDIO_RESP1);
 8015b0a:	2000      	movs	r0, #0
 8015b0c:	f001 fe5c 	bl	80177c8 <SDIO_GetResponse>
 8015b10:	62f8      	str	r0, [r7, #44]	; 0x2c
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8015b12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b14:	0fdb      	lsrs	r3, r3, #31
 8015b16:	2b01      	cmp	r3, #1
 8015b18:	d101      	bne.n	8015b1e <SD_PowerON+0x17a>
 8015b1a:	2301      	movs	r3, #1
 8015b1c:	e000      	b.n	8015b20 <SD_PowerON+0x17c>
 8015b1e:	2300      	movs	r3, #0
 8015b20:	627b      	str	r3, [r7, #36]	; 0x24
      
      count++;
 8015b22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015b24:	3301      	adds	r3, #1
 8015b26:	62bb      	str	r3, [r7, #40]	; 0x28
    while((!validvoltage) && (count < SD_MAX_VOLT_TRIAL))
 8015b28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015b2a:	2b00      	cmp	r3, #0
 8015b2c:	d104      	bne.n	8015b38 <SD_PowerON+0x194>
 8015b2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015b30:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8015b34:	4293      	cmp	r3, r2
 8015b36:	d9a5      	bls.n	8015a84 <SD_PowerON+0xe0>
    }
    
    if(count >= SD_MAX_VOLT_TRIAL)
 8015b38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015b3a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8015b3e:	4293      	cmp	r3, r2
 8015b40:	d904      	bls.n	8015b4c <SD_PowerON+0x1a8>
    {
      errorstate = SD_INVALID_VOLTRANGE;
 8015b42:	231b      	movs	r3, #27
 8015b44:	72fb      	strb	r3, [r7, #11]
      
      return errorstate;
 8015b46:	7afb      	ldrb	r3, [r7, #11]
 8015b48:	b2db      	uxtb	r3, r3
 8015b4a:	e009      	b.n	8015b60 <SD_PowerON+0x1bc>
    }
    
    if((response & SD_HIGH_CAPACITY) == SD_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8015b4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015b4e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8015b52:	2b00      	cmp	r3, #0
 8015b54:	d002      	beq.n	8015b5c <SD_PowerON+0x1b8>
    {
      hsd->CardType = HIGH_CAPACITY_SD_CARD;
 8015b56:	687b      	ldr	r3, [r7, #4]
 8015b58:	2202      	movs	r2, #2
 8015b5a:	621a      	str	r2, [r3, #32]
    }
    
  } /* else MMC Card */
  
  return errorstate;
 8015b5c:	7afb      	ldrb	r3, [r7, #11]
 8015b5e:	b2db      	uxtb	r3, r3
}
 8015b60:	4618      	mov	r0, r3
 8015b62:	3730      	adds	r7, #48	; 0x30
 8015b64:	46bd      	mov	sp, r7
 8015b66:	bd80      	pop	{r7, pc}
 8015b68:	422580a0 	.word	0x422580a0

08015b6c <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card 
  *         status (Card Status register)  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
 8015b6c:	b580      	push	{r7, lr}
 8015b6e:	b088      	sub	sp, #32
 8015b70:	af00      	add	r7, sp, #0
 8015b72:	6078      	str	r0, [r7, #4]
 8015b74:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015b76:	2300      	movs	r3, #0
 8015b78:	77fb      	strb	r3, [r7, #31]
  
  if(pCardStatus == NULL)
 8015b7a:	683b      	ldr	r3, [r7, #0]
 8015b7c:	2b00      	cmp	r3, #0
 8015b7e:	d103      	bne.n	8015b88 <SD_SendStatus+0x1c>
  {
    errorstate = SD_INVALID_PARAMETER;
 8015b80:	2326      	movs	r3, #38	; 0x26
 8015b82:	77fb      	strb	r3, [r7, #31]
    
    return errorstate;
 8015b84:	7ffb      	ldrb	r3, [r7, #31]
 8015b86:	e026      	b.n	8015bd6 <SD_SendStatus+0x6a>
  }
  
  /* Send Status command */
  sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 8015b88:	687b      	ldr	r3, [r7, #4]
 8015b8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015b8c:	041b      	lsls	r3, r3, #16
 8015b8e:	60bb      	str	r3, [r7, #8]
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SEND_STATUS;
 8015b90:	230d      	movs	r3, #13
 8015b92:	60fb      	str	r3, [r7, #12]
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8015b94:	2340      	movs	r3, #64	; 0x40
 8015b96:	613b      	str	r3, [r7, #16]
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8015b98:	2300      	movs	r3, #0
 8015b9a:	617b      	str	r3, [r7, #20]
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 8015b9c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015ba0:	61bb      	str	r3, [r7, #24]
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8015ba2:	687b      	ldr	r3, [r7, #4]
 8015ba4:	681b      	ldr	r3, [r3, #0]
 8015ba6:	f107 0208 	add.w	r2, r7, #8
 8015baa:	4611      	mov	r1, r2
 8015bac:	4618      	mov	r0, r3
 8015bae:	f001 fdd3 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SEND_STATUS);
 8015bb2:	210d      	movs	r1, #13
 8015bb4:	6878      	ldr	r0, [r7, #4]
 8015bb6:	f000 f8a7 	bl	8015d08 <SD_CmdResp1Error>
 8015bba:	4603      	mov	r3, r0
 8015bbc:	77fb      	strb	r3, [r7, #31]
  
  if(errorstate != SD_OK)
 8015bbe:	7ffb      	ldrb	r3, [r7, #31]
 8015bc0:	2b00      	cmp	r3, #0
 8015bc2:	d001      	beq.n	8015bc8 <SD_SendStatus+0x5c>
  {
    return errorstate;
 8015bc4:	7ffb      	ldrb	r3, [r7, #31]
 8015bc6:	e006      	b.n	8015bd6 <SD_SendStatus+0x6a>
  }
  
  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(SDIO_RESP1);
 8015bc8:	2000      	movs	r0, #0
 8015bca:	f001 fdfd 	bl	80177c8 <SDIO_GetResponse>
 8015bce:	4602      	mov	r2, r0
 8015bd0:	683b      	ldr	r3, [r7, #0]
 8015bd2:	601a      	str	r2, [r3, #0]
  
  return errorstate;
 8015bd4:	7ffb      	ldrb	r3, [r7, #31]
}
 8015bd6:	4618      	mov	r0, r3
 8015bd8:	3720      	adds	r7, #32
 8015bda:	46bd      	mov	sp, r7
 8015bdc:	bd80      	pop	{r7, pc}

08015bde <SD_CmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdError(SD_HandleTypeDef *hsd)
{
 8015bde:	b480      	push	{r7}
 8015be0:	b087      	sub	sp, #28
 8015be2:	af00      	add	r7, sp, #0
 8015be4:	6078      	str	r0, [r7, #4]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015be6:	2300      	movs	r3, #0
 8015be8:	73fb      	strb	r3, [r7, #15]
  uint32_t timeout, tmp;
  
  timeout = SDIO_CMD0TIMEOUT;
 8015bea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8015bee:	617b      	str	r3, [r7, #20]
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8015bf0:	687b      	ldr	r3, [r7, #4]
 8015bf2:	681b      	ldr	r3, [r3, #0]
 8015bf4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015bf6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8015bfa:	2b00      	cmp	r3, #0
 8015bfc:	bf14      	ite	ne
 8015bfe:	2301      	movne	r3, #1
 8015c00:	2300      	moveq	r3, #0
 8015c02:	b2db      	uxtb	r3, r3
 8015c04:	613b      	str	r3, [r7, #16]
    
  while((timeout > 0U) && (!tmp))
 8015c06:	e00d      	b.n	8015c24 <SD_CmdError+0x46>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDSENT);
 8015c08:	687b      	ldr	r3, [r7, #4]
 8015c0a:	681b      	ldr	r3, [r3, #0]
 8015c0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015c0e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8015c12:	2b00      	cmp	r3, #0
 8015c14:	bf14      	ite	ne
 8015c16:	2301      	movne	r3, #1
 8015c18:	2300      	moveq	r3, #0
 8015c1a:	b2db      	uxtb	r3, r3
 8015c1c:	613b      	str	r3, [r7, #16]
    timeout--;
 8015c1e:	697b      	ldr	r3, [r7, #20]
 8015c20:	3b01      	subs	r3, #1
 8015c22:	617b      	str	r3, [r7, #20]
  while((timeout > 0U) && (!tmp))
 8015c24:	697b      	ldr	r3, [r7, #20]
 8015c26:	2b00      	cmp	r3, #0
 8015c28:	d002      	beq.n	8015c30 <SD_CmdError+0x52>
 8015c2a:	693b      	ldr	r3, [r7, #16]
 8015c2c:	2b00      	cmp	r3, #0
 8015c2e:	d0eb      	beq.n	8015c08 <SD_CmdError+0x2a>
  }
  
  if(timeout == 0U)
 8015c30:	697b      	ldr	r3, [r7, #20]
 8015c32:	2b00      	cmp	r3, #0
 8015c34:	d103      	bne.n	8015c3e <SD_CmdError+0x60>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015c36:	2303      	movs	r3, #3
 8015c38:	73fb      	strb	r3, [r7, #15]
    return errorstate;
 8015c3a:	7bfb      	ldrb	r3, [r7, #15]
 8015c3c:	e005      	b.n	8015c4a <SD_CmdError+0x6c>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8015c3e:	687b      	ldr	r3, [r7, #4]
 8015c40:	681b      	ldr	r3, [r3, #0]
 8015c42:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8015c46:	639a      	str	r2, [r3, #56]	; 0x38
  
  return errorstate;
 8015c48:	7bfb      	ldrb	r3, [r7, #15]
}
 8015c4a:	4618      	mov	r0, r3
 8015c4c:	371c      	adds	r7, #28
 8015c4e:	46bd      	mov	sp, r7
 8015c50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c54:	4770      	bx	lr

08015c56 <SD_CmdResp7Error>:
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp7Error(SD_HandleTypeDef *hsd)
{
 8015c56:	b480      	push	{r7}
 8015c58:	b087      	sub	sp, #28
 8015c5a:	af00      	add	r7, sp, #0
 8015c5c:	6078      	str	r0, [r7, #4]
  HAL_SD_ErrorTypedef errorstate = SD_ERROR;
 8015c5e:	2329      	movs	r3, #41	; 0x29
 8015c60:	73fb      	strb	r3, [r7, #15]
  uint32_t timeout = SDIO_CMD0TIMEOUT, tmp;
 8015c62:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8015c66:	617b      	str	r3, [r7, #20]
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT); 
 8015c68:	687b      	ldr	r3, [r7, #4]
 8015c6a:	681b      	ldr	r3, [r3, #0]
 8015c6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015c6e:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015c72:	2b00      	cmp	r3, #0
 8015c74:	bf14      	ite	ne
 8015c76:	2301      	movne	r3, #1
 8015c78:	2300      	moveq	r3, #0
 8015c7a:	b2db      	uxtb	r3, r3
 8015c7c:	613b      	str	r3, [r7, #16]
  
  while((!tmp) && (timeout > 0U))
 8015c7e:	e00d      	b.n	8015c9c <SD_CmdResp7Error+0x46>
  {
    tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT);
 8015c80:	687b      	ldr	r3, [r7, #4]
 8015c82:	681b      	ldr	r3, [r3, #0]
 8015c84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015c86:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015c8a:	2b00      	cmp	r3, #0
 8015c8c:	bf14      	ite	ne
 8015c8e:	2301      	movne	r3, #1
 8015c90:	2300      	moveq	r3, #0
 8015c92:	b2db      	uxtb	r3, r3
 8015c94:	613b      	str	r3, [r7, #16]
    timeout--;
 8015c96:	697b      	ldr	r3, [r7, #20]
 8015c98:	3b01      	subs	r3, #1
 8015c9a:	617b      	str	r3, [r7, #20]
  while((!tmp) && (timeout > 0U))
 8015c9c:	693b      	ldr	r3, [r7, #16]
 8015c9e:	2b00      	cmp	r3, #0
 8015ca0:	d102      	bne.n	8015ca8 <SD_CmdResp7Error+0x52>
 8015ca2:	697b      	ldr	r3, [r7, #20]
 8015ca4:	2b00      	cmp	r3, #0
 8015ca6:	d1eb      	bne.n	8015c80 <SD_CmdResp7Error+0x2a>
  }
  
  tmp = __HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT); 
 8015ca8:	687b      	ldr	r3, [r7, #4]
 8015caa:	681b      	ldr	r3, [r3, #0]
 8015cac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015cae:	f003 0304 	and.w	r3, r3, #4
 8015cb2:	2b00      	cmp	r3, #0
 8015cb4:	bf14      	ite	ne
 8015cb6:	2301      	movne	r3, #1
 8015cb8:	2300      	moveq	r3, #0
 8015cba:	b2db      	uxtb	r3, r3
 8015cbc:	613b      	str	r3, [r7, #16]
  
  if((timeout == 0U) || tmp)
 8015cbe:	697b      	ldr	r3, [r7, #20]
 8015cc0:	2b00      	cmp	r3, #0
 8015cc2:	d002      	beq.n	8015cca <SD_CmdResp7Error+0x74>
 8015cc4:	693b      	ldr	r3, [r7, #16]
 8015cc6:	2b00      	cmp	r3, #0
 8015cc8:	d007      	beq.n	8015cda <SD_CmdResp7Error+0x84>
  {
    /* Card is not V2.0 compliant or card does not support the set voltage range */
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015cca:	2303      	movs	r3, #3
 8015ccc:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8015cce:	687b      	ldr	r3, [r7, #4]
 8015cd0:	681b      	ldr	r3, [r3, #0]
 8015cd2:	2204      	movs	r2, #4
 8015cd4:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015cd6:	7bfb      	ldrb	r3, [r7, #15]
 8015cd8:	e00f      	b.n	8015cfa <SD_CmdResp7Error+0xa4>
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CMDREND))
 8015cda:	687b      	ldr	r3, [r7, #4]
 8015cdc:	681b      	ldr	r3, [r3, #0]
 8015cde:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015ce0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015ce4:	2b00      	cmp	r3, #0
 8015ce6:	d007      	beq.n	8015cf8 <SD_CmdResp7Error+0xa2>
  {
    /* Card is SD V2.0 compliant */
    errorstate = SD_OK;
 8015ce8:	2300      	movs	r3, #0
 8015cea:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CMDREND);
 8015cec:	687b      	ldr	r3, [r7, #4]
 8015cee:	681b      	ldr	r3, [r3, #0]
 8015cf0:	2240      	movs	r2, #64	; 0x40
 8015cf2:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015cf4:	7bfb      	ldrb	r3, [r7, #15]
 8015cf6:	e000      	b.n	8015cfa <SD_CmdResp7Error+0xa4>
  }
  
  return errorstate;
 8015cf8:	7bfb      	ldrb	r3, [r7, #15]
}
 8015cfa:	4618      	mov	r0, r3
 8015cfc:	371c      	adds	r7, #28
 8015cfe:	46bd      	mov	sp, r7
 8015d00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015d04:	4770      	bx	lr
	...

08015d08 <SD_CmdResp1Error>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp1Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD)
{
 8015d08:	b580      	push	{r7, lr}
 8015d0a:	b084      	sub	sp, #16
 8015d0c:	af00      	add	r7, sp, #0
 8015d0e:	6078      	str	r0, [r7, #4]
 8015d10:	460b      	mov	r3, r1
 8015d12:	70fb      	strb	r3, [r7, #3]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015d14:	2300      	movs	r3, #0
 8015d16:	73fb      	strb	r3, [r7, #15]
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8015d18:	bf00      	nop
 8015d1a:	687b      	ldr	r3, [r7, #4]
 8015d1c:	681b      	ldr	r3, [r3, #0]
 8015d1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015d20:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015d24:	2b00      	cmp	r3, #0
 8015d26:	d0f8      	beq.n	8015d1a <SD_CmdResp1Error+0x12>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8015d28:	687b      	ldr	r3, [r7, #4]
 8015d2a:	681b      	ldr	r3, [r3, #0]
 8015d2c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015d2e:	f003 0304 	and.w	r3, r3, #4
 8015d32:	2b00      	cmp	r3, #0
 8015d34:	d007      	beq.n	8015d46 <SD_CmdResp1Error+0x3e>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015d36:	2303      	movs	r3, #3
 8015d38:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8015d3a:	687b      	ldr	r3, [r7, #4]
 8015d3c:	681b      	ldr	r3, [r3, #0]
 8015d3e:	2204      	movs	r2, #4
 8015d40:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015d42:	7bfb      	ldrb	r3, [r7, #15]
 8015d44:	e0b0      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8015d46:	687b      	ldr	r3, [r7, #4]
 8015d48:	681b      	ldr	r3, [r3, #0]
 8015d4a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015d4c:	f003 0301 	and.w	r3, r3, #1
 8015d50:	2b00      	cmp	r3, #0
 8015d52:	d007      	beq.n	8015d64 <SD_CmdResp1Error+0x5c>
  {
    errorstate = SD_CMD_CRC_FAIL;
 8015d54:	2301      	movs	r3, #1
 8015d56:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8015d58:	687b      	ldr	r3, [r7, #4]
 8015d5a:	681b      	ldr	r3, [r3, #0]
 8015d5c:	2201      	movs	r2, #1
 8015d5e:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015d60:	7bfb      	ldrb	r3, [r7, #15]
 8015d62:	e0a1      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8015d64:	687b      	ldr	r3, [r7, #4]
 8015d66:	681b      	ldr	r3, [r3, #0]
 8015d68:	4618      	mov	r0, r3
 8015d6a:	f001 fd1f 	bl	80177ac <SDIO_GetCommandResponse>
 8015d6e:	4603      	mov	r3, r0
 8015d70:	461a      	mov	r2, r3
 8015d72:	78fb      	ldrb	r3, [r7, #3]
 8015d74:	4293      	cmp	r3, r2
 8015d76:	d003      	beq.n	8015d80 <SD_CmdResp1Error+0x78>
  {
    errorstate = SD_ILLEGAL_CMD;
 8015d78:	2310      	movs	r3, #16
 8015d7a:	73fb      	strb	r3, [r7, #15]
    
    return errorstate;
 8015d7c:	7bfb      	ldrb	r3, [r7, #15]
 8015d7e:	e093      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8015d80:	687b      	ldr	r3, [r7, #4]
 8015d82:	681b      	ldr	r3, [r3, #0]
 8015d84:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8015d88:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8015d8a:	2000      	movs	r0, #0
 8015d8c:	f001 fd1c 	bl	80177c8 <SDIO_GetResponse>
 8015d90:	60b8      	str	r0, [r7, #8]
  
  if((response_r1 & SD_OCR_ERRORBITS) == SD_ALLZERO)
 8015d92:	68ba      	ldr	r2, [r7, #8]
 8015d94:	4b46      	ldr	r3, [pc, #280]	; (8015eb0 <SD_CmdResp1Error+0x1a8>)
 8015d96:	4013      	ands	r3, r2
 8015d98:	2b00      	cmp	r3, #0
 8015d9a:	d101      	bne.n	8015da0 <SD_CmdResp1Error+0x98>
  {
    return errorstate;
 8015d9c:	7bfb      	ldrb	r3, [r7, #15]
 8015d9e:	e083      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_ADDR_OUT_OF_RANGE) == SD_OCR_ADDR_OUT_OF_RANGE)
 8015da0:	68bb      	ldr	r3, [r7, #8]
 8015da2:	2b00      	cmp	r3, #0
 8015da4:	da01      	bge.n	8015daa <SD_CmdResp1Error+0xa2>
  {
    return(SD_ADDR_OUT_OF_RANGE);
 8015da6:	231c      	movs	r3, #28
 8015da8:	e07e      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_ADDR_MISALIGNED) == SD_OCR_ADDR_MISALIGNED)
 8015daa:	68bb      	ldr	r3, [r7, #8]
 8015dac:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8015db0:	2b00      	cmp	r3, #0
 8015db2:	d001      	beq.n	8015db8 <SD_CmdResp1Error+0xb0>
  {
    return(SD_ADDR_MISALIGNED);
 8015db4:	2309      	movs	r3, #9
 8015db6:	e077      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_BLOCK_LEN_ERR) == SD_OCR_BLOCK_LEN_ERR)
 8015db8:	68bb      	ldr	r3, [r7, #8]
 8015dba:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8015dbe:	2b00      	cmp	r3, #0
 8015dc0:	d001      	beq.n	8015dc6 <SD_CmdResp1Error+0xbe>
  {
    return(SD_BLOCK_LEN_ERR);
 8015dc2:	230a      	movs	r3, #10
 8015dc4:	e070      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_ERASE_SEQ_ERR) == SD_OCR_ERASE_SEQ_ERR)
 8015dc6:	68bb      	ldr	r3, [r7, #8]
 8015dc8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8015dcc:	2b00      	cmp	r3, #0
 8015dce:	d001      	beq.n	8015dd4 <SD_CmdResp1Error+0xcc>
  {
    return(SD_ERASE_SEQ_ERR);
 8015dd0:	230b      	movs	r3, #11
 8015dd2:	e069      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_BAD_ERASE_PARAM) == SD_OCR_BAD_ERASE_PARAM)
 8015dd4:	68bb      	ldr	r3, [r7, #8]
 8015dd6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8015dda:	2b00      	cmp	r3, #0
 8015ddc:	d001      	beq.n	8015de2 <SD_CmdResp1Error+0xda>
  {
    return(SD_BAD_ERASE_PARAM);
 8015dde:	230c      	movs	r3, #12
 8015de0:	e062      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_WRITE_PROT_VIOLATION) == SD_OCR_WRITE_PROT_VIOLATION)
 8015de2:	68bb      	ldr	r3, [r7, #8]
 8015de4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8015de8:	2b00      	cmp	r3, #0
 8015dea:	d001      	beq.n	8015df0 <SD_CmdResp1Error+0xe8>
  {
    return(SD_WRITE_PROT_VIOLATION);
 8015dec:	230d      	movs	r3, #13
 8015dee:	e05b      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_LOCK_UNLOCK_FAILED) == SD_OCR_LOCK_UNLOCK_FAILED)
 8015df0:	68bb      	ldr	r3, [r7, #8]
 8015df2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8015df6:	2b00      	cmp	r3, #0
 8015df8:	d001      	beq.n	8015dfe <SD_CmdResp1Error+0xf6>
  {
    return(SD_LOCK_UNLOCK_FAILED);
 8015dfa:	230e      	movs	r3, #14
 8015dfc:	e054      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_COM_CRC_FAILED) == SD_OCR_COM_CRC_FAILED)
 8015dfe:	68bb      	ldr	r3, [r7, #8]
 8015e00:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8015e04:	2b00      	cmp	r3, #0
 8015e06:	d001      	beq.n	8015e0c <SD_CmdResp1Error+0x104>
  {
    return(SD_COM_CRC_FAILED);
 8015e08:	230f      	movs	r3, #15
 8015e0a:	e04d      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_ILLEGAL_CMD) == SD_OCR_ILLEGAL_CMD)
 8015e0c:	68bb      	ldr	r3, [r7, #8]
 8015e0e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8015e12:	2b00      	cmp	r3, #0
 8015e14:	d001      	beq.n	8015e1a <SD_CmdResp1Error+0x112>
  {
    return(SD_ILLEGAL_CMD);
 8015e16:	2310      	movs	r3, #16
 8015e18:	e046      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_FAILED) == SD_OCR_CARD_ECC_FAILED)
 8015e1a:	68bb      	ldr	r3, [r7, #8]
 8015e1c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8015e20:	2b00      	cmp	r3, #0
 8015e22:	d001      	beq.n	8015e28 <SD_CmdResp1Error+0x120>
  {
    return(SD_CARD_ECC_FAILED);
 8015e24:	2311      	movs	r3, #17
 8015e26:	e03f      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_CC_ERROR) == SD_OCR_CC_ERROR)
 8015e28:	68bb      	ldr	r3, [r7, #8]
 8015e2a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8015e2e:	2b00      	cmp	r3, #0
 8015e30:	d001      	beq.n	8015e36 <SD_CmdResp1Error+0x12e>
  {
    return(SD_CC_ERROR);
 8015e32:	2312      	movs	r3, #18
 8015e34:	e038      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_GENERAL_UNKNOWN_ERROR) == SD_OCR_GENERAL_UNKNOWN_ERROR)
 8015e36:	68bb      	ldr	r3, [r7, #8]
 8015e38:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8015e3c:	2b00      	cmp	r3, #0
 8015e3e:	d001      	beq.n	8015e44 <SD_CmdResp1Error+0x13c>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8015e40:	2313      	movs	r3, #19
 8015e42:	e031      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_STREAM_READ_UNDERRUN) == SD_OCR_STREAM_READ_UNDERRUN)
 8015e44:	68bb      	ldr	r3, [r7, #8]
 8015e46:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8015e4a:	2b00      	cmp	r3, #0
 8015e4c:	d001      	beq.n	8015e52 <SD_CmdResp1Error+0x14a>
  {
    return(SD_STREAM_READ_UNDERRUN);
 8015e4e:	2314      	movs	r3, #20
 8015e50:	e02a      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_STREAM_WRITE_OVERRUN) == SD_OCR_STREAM_WRITE_OVERRUN)
 8015e52:	68bb      	ldr	r3, [r7, #8]
 8015e54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8015e58:	2b00      	cmp	r3, #0
 8015e5a:	d001      	beq.n	8015e60 <SD_CmdResp1Error+0x158>
  {
    return(SD_STREAM_WRITE_OVERRUN);
 8015e5c:	2315      	movs	r3, #21
 8015e5e:	e023      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_CID_CSD_OVERWRITE) == SD_OCR_CID_CSD_OVERWRITE)
 8015e60:	68bb      	ldr	r3, [r7, #8]
 8015e62:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8015e66:	2b00      	cmp	r3, #0
 8015e68:	d001      	beq.n	8015e6e <SD_CmdResp1Error+0x166>
  {
    return(SD_CID_CSD_OVERWRITE);
 8015e6a:	2316      	movs	r3, #22
 8015e6c:	e01c      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_WP_ERASE_SKIP) == SD_OCR_WP_ERASE_SKIP)
 8015e6e:	68bb      	ldr	r3, [r7, #8]
 8015e70:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8015e74:	2b00      	cmp	r3, #0
 8015e76:	d001      	beq.n	8015e7c <SD_CmdResp1Error+0x174>
  {
    return(SD_WP_ERASE_SKIP);
 8015e78:	2317      	movs	r3, #23
 8015e7a:	e015      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_CARD_ECC_DISABLED) == SD_OCR_CARD_ECC_DISABLED)
 8015e7c:	68bb      	ldr	r3, [r7, #8]
 8015e7e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8015e82:	2b00      	cmp	r3, #0
 8015e84:	d001      	beq.n	8015e8a <SD_CmdResp1Error+0x182>
  {
    return(SD_CARD_ECC_DISABLED);
 8015e86:	2318      	movs	r3, #24
 8015e88:	e00e      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_ERASE_RESET) == SD_OCR_ERASE_RESET)
 8015e8a:	68bb      	ldr	r3, [r7, #8]
 8015e8c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8015e90:	2b00      	cmp	r3, #0
 8015e92:	d001      	beq.n	8015e98 <SD_CmdResp1Error+0x190>
  {
    return(SD_ERASE_RESET);
 8015e94:	2319      	movs	r3, #25
 8015e96:	e007      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  if((response_r1 & SD_OCR_AKE_SEQ_ERROR) == SD_OCR_AKE_SEQ_ERROR)
 8015e98:	68bb      	ldr	r3, [r7, #8]
 8015e9a:	f003 0308 	and.w	r3, r3, #8
 8015e9e:	2b00      	cmp	r3, #0
 8015ea0:	d001      	beq.n	8015ea6 <SD_CmdResp1Error+0x19e>
  {
    return(SD_AKE_SEQ_ERROR);
 8015ea2:	231a      	movs	r3, #26
 8015ea4:	e000      	b.n	8015ea8 <SD_CmdResp1Error+0x1a0>
  }
  
  return errorstate;
 8015ea6:	7bfb      	ldrb	r3, [r7, #15]
}
 8015ea8:	4618      	mov	r0, r3
 8015eaa:	3710      	adds	r7, #16
 8015eac:	46bd      	mov	sp, r7
 8015eae:	bd80      	pop	{r7, pc}
 8015eb0:	fdffe008 	.word	0xfdffe008

08015eb4 <SD_CmdResp3Error>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp3Error(SD_HandleTypeDef *hsd)
{
 8015eb4:	b480      	push	{r7}
 8015eb6:	b085      	sub	sp, #20
 8015eb8:	af00      	add	r7, sp, #0
 8015eba:	6078      	str	r0, [r7, #4]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015ebc:	2300      	movs	r3, #0
 8015ebe:	73fb      	strb	r3, [r7, #15]
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8015ec0:	bf00      	nop
 8015ec2:	687b      	ldr	r3, [r7, #4]
 8015ec4:	681b      	ldr	r3, [r3, #0]
 8015ec6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015ec8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015ecc:	2b00      	cmp	r3, #0
 8015ece:	d0f8      	beq.n	8015ec2 <SD_CmdResp3Error+0xe>
  {
  }
  
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8015ed0:	687b      	ldr	r3, [r7, #4]
 8015ed2:	681b      	ldr	r3, [r3, #0]
 8015ed4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015ed6:	f003 0304 	and.w	r3, r3, #4
 8015eda:	2b00      	cmp	r3, #0
 8015edc:	d007      	beq.n	8015eee <SD_CmdResp3Error+0x3a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015ede:	2303      	movs	r3, #3
 8015ee0:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8015ee2:	687b      	ldr	r3, [r7, #4]
 8015ee4:	681b      	ldr	r3, [r3, #0]
 8015ee6:	2204      	movs	r2, #4
 8015ee8:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015eea:	7bfb      	ldrb	r3, [r7, #15]
 8015eec:	e005      	b.n	8015efa <SD_CmdResp3Error+0x46>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8015eee:	687b      	ldr	r3, [r7, #4]
 8015ef0:	681b      	ldr	r3, [r3, #0]
 8015ef2:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8015ef6:	639a      	str	r2, [r3, #56]	; 0x38
  
  return errorstate;
 8015ef8:	7bfb      	ldrb	r3, [r7, #15]
}
 8015efa:	4618      	mov	r0, r3
 8015efc:	3714      	adds	r7, #20
 8015efe:	46bd      	mov	sp, r7
 8015f00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f04:	4770      	bx	lr

08015f06 <SD_CmdResp2Error>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp2Error(SD_HandleTypeDef *hsd)
{
 8015f06:	b480      	push	{r7}
 8015f08:	b085      	sub	sp, #20
 8015f0a:	af00      	add	r7, sp, #0
 8015f0c:	6078      	str	r0, [r7, #4]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015f0e:	2300      	movs	r3, #0
 8015f10:	73fb      	strb	r3, [r7, #15]
  
  while (!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8015f12:	bf00      	nop
 8015f14:	687b      	ldr	r3, [r7, #4]
 8015f16:	681b      	ldr	r3, [r3, #0]
 8015f18:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f1a:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015f1e:	2b00      	cmp	r3, #0
 8015f20:	d0f8      	beq.n	8015f14 <SD_CmdResp2Error+0xe>
  {
  }
    
  if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8015f22:	687b      	ldr	r3, [r7, #4]
 8015f24:	681b      	ldr	r3, [r3, #0]
 8015f26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f28:	f003 0304 	and.w	r3, r3, #4
 8015f2c:	2b00      	cmp	r3, #0
 8015f2e:	d007      	beq.n	8015f40 <SD_CmdResp2Error+0x3a>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015f30:	2303      	movs	r3, #3
 8015f32:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8015f34:	687b      	ldr	r3, [r7, #4]
 8015f36:	681b      	ldr	r3, [r3, #0]
 8015f38:	2204      	movs	r2, #4
 8015f3a:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015f3c:	7bfb      	ldrb	r3, [r7, #15]
 8015f3e:	e014      	b.n	8015f6a <SD_CmdResp2Error+0x64>
  }
  else if (__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8015f40:	687b      	ldr	r3, [r7, #4]
 8015f42:	681b      	ldr	r3, [r3, #0]
 8015f44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f46:	f003 0301 	and.w	r3, r3, #1
 8015f4a:	2b00      	cmp	r3, #0
 8015f4c:	d007      	beq.n	8015f5e <SD_CmdResp2Error+0x58>
  {
    errorstate = SD_CMD_CRC_FAIL;
 8015f4e:	2301      	movs	r3, #1
 8015f50:	73fb      	strb	r3, [r7, #15]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8015f52:	687b      	ldr	r3, [r7, #4]
 8015f54:	681b      	ldr	r3, [r3, #0]
 8015f56:	2201      	movs	r2, #1
 8015f58:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015f5a:	7bfb      	ldrb	r3, [r7, #15]
 8015f5c:	e005      	b.n	8015f6a <SD_CmdResp2Error+0x64>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8015f5e:	687b      	ldr	r3, [r7, #4]
 8015f60:	681b      	ldr	r3, [r3, #0]
 8015f62:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8015f66:	639a      	str	r2, [r3, #56]	; 0x38
  
  return errorstate;
 8015f68:	7bfb      	ldrb	r3, [r7, #15]
}
 8015f6a:	4618      	mov	r0, r3
 8015f6c:	3714      	adds	r7, #20
 8015f6e:	46bd      	mov	sp, r7
 8015f70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f74:	4770      	bx	lr

08015f76 <SD_CmdResp6Error>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative 
  *         address RCA   
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_CmdResp6Error(SD_HandleTypeDef *hsd, uint8_t SD_CMD, uint16_t *pRCA)
{
 8015f76:	b580      	push	{r7, lr}
 8015f78:	b086      	sub	sp, #24
 8015f7a:	af00      	add	r7, sp, #0
 8015f7c:	60f8      	str	r0, [r7, #12]
 8015f7e:	460b      	mov	r3, r1
 8015f80:	607a      	str	r2, [r7, #4]
 8015f82:	72fb      	strb	r3, [r7, #11]
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8015f84:	2300      	movs	r3, #0
 8015f86:	75fb      	strb	r3, [r7, #23]
  uint32_t response_r1;
  
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT))
 8015f88:	bf00      	nop
 8015f8a:	68fb      	ldr	r3, [r7, #12]
 8015f8c:	681b      	ldr	r3, [r3, #0]
 8015f8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f90:	f003 0345 	and.w	r3, r3, #69	; 0x45
 8015f94:	2b00      	cmp	r3, #0
 8015f96:	d0f8      	beq.n	8015f8a <SD_CmdResp6Error+0x14>
  {
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CTIMEOUT))
 8015f98:	68fb      	ldr	r3, [r7, #12]
 8015f9a:	681b      	ldr	r3, [r3, #0]
 8015f9c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015f9e:	f003 0304 	and.w	r3, r3, #4
 8015fa2:	2b00      	cmp	r3, #0
 8015fa4:	d007      	beq.n	8015fb6 <SD_CmdResp6Error+0x40>
  {
    errorstate = SD_CMD_RSP_TIMEOUT;
 8015fa6:	2303      	movs	r3, #3
 8015fa8:	75fb      	strb	r3, [r7, #23]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CTIMEOUT);
 8015faa:	68fb      	ldr	r3, [r7, #12]
 8015fac:	681b      	ldr	r3, [r3, #0]
 8015fae:	2204      	movs	r2, #4
 8015fb0:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015fb2:	7dfb      	ldrb	r3, [r7, #23]
 8015fb4:	e047      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_CCRCFAIL))
 8015fb6:	68fb      	ldr	r3, [r7, #12]
 8015fb8:	681b      	ldr	r3, [r3, #0]
 8015fba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8015fbc:	f003 0301 	and.w	r3, r3, #1
 8015fc0:	2b00      	cmp	r3, #0
 8015fc2:	d007      	beq.n	8015fd4 <SD_CmdResp6Error+0x5e>
  {
    errorstate = SD_CMD_CRC_FAIL;
 8015fc4:	2301      	movs	r3, #1
 8015fc6:	75fb      	strb	r3, [r7, #23]
    
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_CCRCFAIL);
 8015fc8:	68fb      	ldr	r3, [r7, #12]
 8015fca:	681b      	ldr	r3, [r3, #0]
 8015fcc:	2201      	movs	r2, #1
 8015fce:	639a      	str	r2, [r3, #56]	; 0x38
    
    return errorstate;
 8015fd0:	7dfb      	ldrb	r3, [r7, #23]
 8015fd2:	e038      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  {
    /* No error flag set */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(hsd->Instance) != SD_CMD)
 8015fd4:	68fb      	ldr	r3, [r7, #12]
 8015fd6:	681b      	ldr	r3, [r3, #0]
 8015fd8:	4618      	mov	r0, r3
 8015fda:	f001 fbe7 	bl	80177ac <SDIO_GetCommandResponse>
 8015fde:	4603      	mov	r3, r0
 8015fe0:	461a      	mov	r2, r3
 8015fe2:	7afb      	ldrb	r3, [r7, #11]
 8015fe4:	4293      	cmp	r3, r2
 8015fe6:	d003      	beq.n	8015ff0 <SD_CmdResp6Error+0x7a>
  {
    errorstate = SD_ILLEGAL_CMD;
 8015fe8:	2310      	movs	r3, #16
 8015fea:	75fb      	strb	r3, [r7, #23]
    
    return errorstate;
 8015fec:	7dfb      	ldrb	r3, [r7, #23]
 8015fee:	e02a      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8015ff0:	68fb      	ldr	r3, [r7, #12]
 8015ff2:	681b      	ldr	r3, [r3, #0]
 8015ff4:	f240 52ff 	movw	r2, #1535	; 0x5ff
 8015ff8:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIO_RESP1);
 8015ffa:	2000      	movs	r0, #0
 8015ffc:	f001 fbe4 	bl	80177c8 <SDIO_GetResponse>
 8016000:	6138      	str	r0, [r7, #16]
  
  if((response_r1 & (SD_R6_GENERAL_UNKNOWN_ERROR | SD_R6_ILLEGAL_CMD | SD_R6_COM_CRC_FAILED)) == SD_ALLZERO)
 8016002:	693b      	ldr	r3, [r7, #16]
 8016004:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8016008:	2b00      	cmp	r3, #0
 801600a:	d106      	bne.n	801601a <SD_CmdResp6Error+0xa4>
  {
    *pRCA = (uint16_t) (response_r1 >> 16U);
 801600c:	693b      	ldr	r3, [r7, #16]
 801600e:	0c1b      	lsrs	r3, r3, #16
 8016010:	b29a      	uxth	r2, r3
 8016012:	687b      	ldr	r3, [r7, #4]
 8016014:	801a      	strh	r2, [r3, #0]
    
    return errorstate;
 8016016:	7dfb      	ldrb	r3, [r7, #23]
 8016018:	e015      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  
  if((response_r1 & SD_R6_GENERAL_UNKNOWN_ERROR) == SD_R6_GENERAL_UNKNOWN_ERROR)
 801601a:	693b      	ldr	r3, [r7, #16]
 801601c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8016020:	2b00      	cmp	r3, #0
 8016022:	d001      	beq.n	8016028 <SD_CmdResp6Error+0xb2>
  {
    return(SD_GENERAL_UNKNOWN_ERROR);
 8016024:	2313      	movs	r3, #19
 8016026:	e00e      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  
  if((response_r1 & SD_R6_ILLEGAL_CMD) == SD_R6_ILLEGAL_CMD)
 8016028:	693b      	ldr	r3, [r7, #16]
 801602a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801602e:	2b00      	cmp	r3, #0
 8016030:	d001      	beq.n	8016036 <SD_CmdResp6Error+0xc0>
  {
    return(SD_ILLEGAL_CMD);
 8016032:	2310      	movs	r3, #16
 8016034:	e007      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  
  if((response_r1 & SD_R6_COM_CRC_FAILED) == SD_R6_COM_CRC_FAILED)
 8016036:	693b      	ldr	r3, [r7, #16]
 8016038:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801603c:	2b00      	cmp	r3, #0
 801603e:	d001      	beq.n	8016044 <SD_CmdResp6Error+0xce>
  {
    return(SD_COM_CRC_FAILED);
 8016040:	230f      	movs	r3, #15
 8016042:	e000      	b.n	8016046 <SD_CmdResp6Error+0xd0>
  }
  
  return errorstate;
 8016044:	7dfb      	ldrb	r3, [r7, #23]
}
 8016046:	4618      	mov	r0, r3
 8016048:	3718      	adds	r7, #24
 801604a:	46bd      	mov	sp, r7
 801604c:	bd80      	pop	{r7, pc}

0801604e <SD_WideBus_Enable>:
  * @brief  Enables the SDIO wide bus mode.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
 801604e:	b580      	push	{r7, lr}
 8016050:	b08a      	sub	sp, #40	; 0x28
 8016052:	af00      	add	r7, sp, #0
 8016054:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8016056:	2300      	movs	r3, #0
 8016058:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  uint32_t scr[2U] = {0U, 0U};
 801605c:	2300      	movs	r3, #0
 801605e:	60bb      	str	r3, [r7, #8]
 8016060:	2300      	movs	r3, #0
 8016062:	60fb      	str	r3, [r7, #12]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8016064:	2000      	movs	r0, #0
 8016066:	f001 fbaf 	bl	80177c8 <SDIO_GetResponse>
 801606a:	4603      	mov	r3, r0
 801606c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8016070:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8016074:	d105      	bne.n	8016082 <SD_WideBus_Enable+0x34>
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
 8016076:	230e      	movs	r3, #14
 8016078:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 801607c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016080:	e059      	b.n	8016136 <SD_WideBus_Enable+0xe8>
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8016082:	f107 0308 	add.w	r3, r7, #8
 8016086:	4619      	mov	r1, r3
 8016088:	6878      	ldr	r0, [r7, #4]
 801608a:	f000 f8d0 	bl	801622e <SD_FindSCR>
 801608e:	4603      	mov	r3, r0
 8016090:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  if(errorstate != SD_OK)
 8016094:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016098:	2b00      	cmp	r3, #0
 801609a:	d002      	beq.n	80160a2 <SD_WideBus_Enable+0x54>
  {
    return errorstate;
 801609c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80160a0:	e049      	b.n	8016136 <SD_WideBus_Enable+0xe8>
  }
  
  /* If requested card supports wide bus operation */
  if((scr[1U] & SD_WIDE_BUS_SUPPORT) != SD_ALLZERO)
 80160a2:	68fb      	ldr	r3, [r7, #12]
 80160a4:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80160a8:	2b00      	cmp	r3, #0
 80160aa:	d03f      	beq.n	801612c <SD_WideBus_Enable+0xde>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 80160ac:	687b      	ldr	r3, [r7, #4]
 80160ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80160b0:	041b      	lsls	r3, r3, #16
 80160b2:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80160b4:	2337      	movs	r3, #55	; 0x37
 80160b6:	617b      	str	r3, [r7, #20]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80160b8:	2340      	movs	r3, #64	; 0x40
 80160ba:	61bb      	str	r3, [r7, #24]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80160bc:	2300      	movs	r3, #0
 80160be:	61fb      	str	r3, [r7, #28]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80160c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80160c4:	623b      	str	r3, [r7, #32]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80160c6:	687b      	ldr	r3, [r7, #4]
 80160c8:	681b      	ldr	r3, [r3, #0]
 80160ca:	f107 0210 	add.w	r2, r7, #16
 80160ce:	4611      	mov	r1, r2
 80160d0:	4618      	mov	r0, r3
 80160d2:	f001 fb41 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80160d6:	2137      	movs	r1, #55	; 0x37
 80160d8:	6878      	ldr	r0, [r7, #4]
 80160da:	f7ff fe15 	bl	8015d08 <SD_CmdResp1Error>
 80160de:	4603      	mov	r3, r0
 80160e0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 80160e4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80160e8:	2b00      	cmp	r3, #0
 80160ea:	d002      	beq.n	80160f2 <SD_WideBus_Enable+0xa4>
    {
      return errorstate;
 80160ec:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80160f0:	e021      	b.n	8016136 <SD_WideBus_Enable+0xe8>
    }
    
    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    sdio_cmdinitstructure.Argument         = 2U;
 80160f2:	2302      	movs	r3, #2
 80160f4:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80160f6:	2306      	movs	r3, #6
 80160f8:	617b      	str	r3, [r7, #20]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80160fa:	687b      	ldr	r3, [r7, #4]
 80160fc:	681b      	ldr	r3, [r3, #0]
 80160fe:	f107 0210 	add.w	r2, r7, #16
 8016102:	4611      	mov	r1, r2
 8016104:	4618      	mov	r0, r3
 8016106:	f001 fb27 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
 801610a:	2106      	movs	r1, #6
 801610c:	6878      	ldr	r0, [r7, #4]
 801610e:	f7ff fdfb 	bl	8015d08 <SD_CmdResp1Error>
 8016112:	4603      	mov	r3, r0
 8016114:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 8016118:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801611c:	2b00      	cmp	r3, #0
 801611e:	d002      	beq.n	8016126 <SD_WideBus_Enable+0xd8>
    {
      return errorstate;
 8016120:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016124:	e007      	b.n	8016136 <SD_WideBus_Enable+0xe8>
    }
    
    return errorstate;
 8016126:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801612a:	e004      	b.n	8016136 <SD_WideBus_Enable+0xe8>
  }
  else
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
 801612c:	2325      	movs	r3, #37	; 0x25
 801612e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 8016132:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  }
}   
 8016136:	4618      	mov	r0, r3
 8016138:	3728      	adds	r7, #40	; 0x28
 801613a:	46bd      	mov	sp, r7
 801613c:	bd80      	pop	{r7, pc}

0801613e <SD_WideBus_Disable>:
  * @brief  Disables the SDIO wide bus mode.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
 801613e:	b580      	push	{r7, lr}
 8016140:	b08a      	sub	sp, #40	; 0x28
 8016142:	af00      	add	r7, sp, #0
 8016144:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef sdio_cmdinitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8016146:	2300      	movs	r3, #0
 8016148:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  uint32_t scr[2U] = {0U, 0U};
 801614c:	2300      	movs	r3, #0
 801614e:	60bb      	str	r3, [r7, #8]
 8016150:	2300      	movs	r3, #0
 8016152:	60fb      	str	r3, [r7, #12]
  
  if((SDIO_GetResponse(SDIO_RESP1) & SD_CARD_LOCKED) == SD_CARD_LOCKED)
 8016154:	2000      	movs	r0, #0
 8016156:	f001 fb37 	bl	80177c8 <SDIO_GetResponse>
 801615a:	4603      	mov	r3, r0
 801615c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8016160:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8016164:	d105      	bne.n	8016172 <SD_WideBus_Disable+0x34>
  {
    errorstate = SD_LOCK_UNLOCK_FAILED;
 8016166:	230e      	movs	r3, #14
 8016168:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 801616c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016170:	e059      	b.n	8016226 <SD_WideBus_Disable+0xe8>
  }
  
  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8016172:	f107 0308 	add.w	r3, r7, #8
 8016176:	4619      	mov	r1, r3
 8016178:	6878      	ldr	r0, [r7, #4]
 801617a:	f000 f858 	bl	801622e <SD_FindSCR>
 801617e:	4603      	mov	r3, r0
 8016180:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  
  if(errorstate != SD_OK)
 8016184:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016188:	2b00      	cmp	r3, #0
 801618a:	d002      	beq.n	8016192 <SD_WideBus_Disable+0x54>
  {
    return errorstate;
 801618c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016190:	e049      	b.n	8016226 <SD_WideBus_Disable+0xe8>
  }
  
  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SD_SINGLE_BUS_SUPPORT) != SD_ALLZERO)
 8016192:	68fb      	ldr	r3, [r7, #12]
 8016194:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8016198:	2b00      	cmp	r3, #0
 801619a:	d03f      	beq.n	801621c <SD_WideBus_Disable+0xde>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16U);
 801619c:	687b      	ldr	r3, [r7, #4]
 801619e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80161a0:	041b      	lsls	r3, r3, #16
 80161a2:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 80161a4:	2337      	movs	r3, #55	; 0x37
 80161a6:	617b      	str	r3, [r7, #20]
    sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 80161a8:	2340      	movs	r3, #64	; 0x40
 80161aa:	61bb      	str	r3, [r7, #24]
    sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 80161ac:	2300      	movs	r3, #0
 80161ae:	61fb      	str	r3, [r7, #28]
    sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 80161b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80161b4:	623b      	str	r3, [r7, #32]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80161b6:	687b      	ldr	r3, [r7, #4]
 80161b8:	681b      	ldr	r3, [r3, #0]
 80161ba:	f107 0210 	add.w	r2, r7, #16
 80161be:	4611      	mov	r1, r2
 80161c0:	4618      	mov	r0, r3
 80161c2:	f001 fac9 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80161c6:	2137      	movs	r1, #55	; 0x37
 80161c8:	6878      	ldr	r0, [r7, #4]
 80161ca:	f7ff fd9d 	bl	8015d08 <SD_CmdResp1Error>
 80161ce:	4603      	mov	r3, r0
 80161d0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 80161d4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80161d8:	2b00      	cmp	r3, #0
 80161da:	d002      	beq.n	80161e2 <SD_WideBus_Disable+0xa4>
    {
      return errorstate;
 80161dc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80161e0:	e021      	b.n	8016226 <SD_WideBus_Disable+0xe8>
    }
    
    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    sdio_cmdinitstructure.Argument         = 0U;
 80161e2:	2300      	movs	r3, #0
 80161e4:	613b      	str	r3, [r7, #16]
    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_SD_SET_BUSWIDTH;
 80161e6:	2306      	movs	r3, #6
 80161e8:	617b      	str	r3, [r7, #20]
    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80161ea:	687b      	ldr	r3, [r7, #4]
 80161ec:	681b      	ldr	r3, [r3, #0]
 80161ee:	f107 0210 	add.w	r2, r7, #16
 80161f2:	4611      	mov	r1, r2
 80161f4:	4618      	mov	r0, r3
 80161f6:	f001 faaf 	bl	8017758 <SDIO_SendCommand>
    
    /* Check for error conditions */
    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_SD_SET_BUSWIDTH);
 80161fa:	2106      	movs	r1, #6
 80161fc:	6878      	ldr	r0, [r7, #4]
 80161fe:	f7ff fd83 	bl	8015d08 <SD_CmdResp1Error>
 8016202:	4603      	mov	r3, r0
 8016204:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    if(errorstate != SD_OK)
 8016208:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801620c:	2b00      	cmp	r3, #0
 801620e:	d002      	beq.n	8016216 <SD_WideBus_Disable+0xd8>
    {
      return errorstate;
 8016210:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8016214:	e007      	b.n	8016226 <SD_WideBus_Disable+0xe8>
    }
    
    return errorstate;
 8016216:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801621a:	e004      	b.n	8016226 <SD_WideBus_Disable+0xe8>
  }
  else
  {
    errorstate = SD_REQUEST_NOT_APPLICABLE;
 801621c:	2325      	movs	r3, #37	; 0x25
 801621e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    
    return errorstate;
 8016222:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  }
}
 8016226:	4618      	mov	r0, r3
 8016228:	3728      	adds	r7, #40	; 0x28
 801622a:	46bd      	mov	sp, r7
 801622c:	bd80      	pop	{r7, pc}

0801622e <SD_FindSCR>:
  * @param  hsd: SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value  
  * @retval SD Card error state
  */
static HAL_SD_ErrorTypedef SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 801622e:	b590      	push	{r4, r7, lr}
 8016230:	b093      	sub	sp, #76	; 0x4c
 8016232:	af00      	add	r7, sp, #0
 8016234:	6078      	str	r0, [r7, #4]
 8016236:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdio_cmdinitstructure;
  SDIO_DataInitTypeDef sdio_datainitstructure;
  HAL_SD_ErrorTypedef errorstate = SD_OK;
 8016238:	2300      	movs	r3, #0
 801623a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
  uint32_t index = 0U;
 801623e:	2300      	movs	r3, #0
 8016240:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t tempscr[2U] = {0U, 0U};
 8016242:	2300      	movs	r3, #0
 8016244:	60fb      	str	r3, [r7, #12]
 8016246:	2300      	movs	r3, #0
 8016248:	613b      	str	r3, [r7, #16]
  
  /* Set Block Size To 8 Bytes */
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)8U;
 801624a:	2308      	movs	r3, #8
 801624c:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 801624e:	2310      	movs	r3, #16
 8016250:	633b      	str	r3, [r7, #48]	; 0x30
  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
 8016252:	2340      	movs	r3, #64	; 0x40
 8016254:	637b      	str	r3, [r7, #52]	; 0x34
  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
 8016256:	2300      	movs	r3, #0
 8016258:	63bb      	str	r3, [r7, #56]	; 0x38
  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
 801625a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801625e:	63fb      	str	r3, [r7, #60]	; 0x3c
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8016260:	687b      	ldr	r3, [r7, #4]
 8016262:	681b      	ldr	r3, [r3, #0]
 8016264:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 8016268:	4611      	mov	r1, r2
 801626a:	4618      	mov	r0, r3
 801626c:	f001 fa74 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 8016270:	2110      	movs	r1, #16
 8016272:	6878      	ldr	r0, [r7, #4]
 8016274:	f7ff fd48 	bl	8015d08 <SD_CmdResp1Error>
 8016278:	4603      	mov	r3, r0
 801627a:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
  
  if(errorstate != SD_OK)
 801627e:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8016282:	2b00      	cmp	r3, #0
 8016284:	d002      	beq.n	801628c <SD_FindSCR+0x5e>
  {
    return errorstate;
 8016286:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801628a:	e0d8      	b.n	801643e <SD_FindSCR+0x210>
  }
  
  /* Send CMD55 APP_CMD with argument as card's RCA */
  sdio_cmdinitstructure.Argument         = (uint32_t)((hsd->RCA) << 16U);
 801628c:	687b      	ldr	r3, [r7, #4]
 801628e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016290:	041b      	lsls	r3, r3, #16
 8016292:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
 8016294:	2337      	movs	r3, #55	; 0x37
 8016296:	633b      	str	r3, [r7, #48]	; 0x30
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 8016298:	687b      	ldr	r3, [r7, #4]
 801629a:	681b      	ldr	r3, [r3, #0]
 801629c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80162a0:	4611      	mov	r1, r2
 80162a2:	4618      	mov	r0, r3
 80162a4:	f001 fa58 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
 80162a8:	2137      	movs	r1, #55	; 0x37
 80162aa:	6878      	ldr	r0, [r7, #4]
 80162ac:	f7ff fd2c 	bl	8015d08 <SD_CmdResp1Error>
 80162b0:	4603      	mov	r3, r0
 80162b2:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
  
  if(errorstate != SD_OK)
 80162b6:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80162ba:	2b00      	cmp	r3, #0
 80162bc:	d002      	beq.n	80162c4 <SD_FindSCR+0x96>
  {
    return errorstate;
 80162be:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80162c2:	e0bc      	b.n	801643e <SD_FindSCR+0x210>
  }
  sdio_datainitstructure.DataTimeOut   = SD_DATATIMEOUT;
 80162c4:	f04f 33ff 	mov.w	r3, #4294967295
 80162c8:	617b      	str	r3, [r7, #20]
  sdio_datainitstructure.DataLength    = 8U;
 80162ca:	2308      	movs	r3, #8
 80162cc:	61bb      	str	r3, [r7, #24]
  sdio_datainitstructure.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 80162ce:	2330      	movs	r3, #48	; 0x30
 80162d0:	61fb      	str	r3, [r7, #28]
  sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 80162d2:	2302      	movs	r3, #2
 80162d4:	623b      	str	r3, [r7, #32]
  sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 80162d6:	2300      	movs	r3, #0
 80162d8:	627b      	str	r3, [r7, #36]	; 0x24
  sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
 80162da:	2301      	movs	r3, #1
 80162dc:	62bb      	str	r3, [r7, #40]	; 0x28
  SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
 80162de:	687b      	ldr	r3, [r7, #4]
 80162e0:	681b      	ldr	r3, [r3, #0]
 80162e2:	f107 0214 	add.w	r2, r7, #20
 80162e6:	4611      	mov	r1, r2
 80162e8:	4618      	mov	r0, r3
 80162ea:	f001 fa81 	bl	80177f0 <SDIO_DataConfig>
  
  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  sdio_cmdinitstructure.Argument         = 0U;
 80162ee:	2300      	movs	r3, #0
 80162f0:	62fb      	str	r3, [r7, #44]	; 0x2c
  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SD_APP_SEND_SCR;
 80162f2:	2333      	movs	r3, #51	; 0x33
 80162f4:	633b      	str	r3, [r7, #48]	; 0x30
  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 80162f6:	687b      	ldr	r3, [r7, #4]
 80162f8:	681b      	ldr	r3, [r3, #0]
 80162fa:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 80162fe:	4611      	mov	r1, r2
 8016300:	4618      	mov	r0, r3
 8016302:	f001 fa29 	bl	8017758 <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SD_APP_SEND_SCR);
 8016306:	2133      	movs	r1, #51	; 0x33
 8016308:	6878      	ldr	r0, [r7, #4]
 801630a:	f7ff fcfd 	bl	8015d08 <SD_CmdResp1Error>
 801630e:	4603      	mov	r3, r0
 8016310:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
  
  if(errorstate != SD_OK)
 8016314:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8016318:	2b00      	cmp	r3, #0
 801631a:	d018      	beq.n	801634e <SD_FindSCR+0x120>
  {
    return errorstate;
 801631c:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8016320:	e08d      	b.n	801643e <SD_FindSCR+0x210>
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
#else /* SDIO_STA_STBITERR not defined */
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
#endif /* SDIO_STA_STBITERR */
  {
    if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8016322:	687b      	ldr	r3, [r7, #4]
 8016324:	681b      	ldr	r3, [r3, #0]
 8016326:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016328:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 801632c:	2b00      	cmp	r3, #0
 801632e:	d00e      	beq.n	801634e <SD_FindSCR+0x120>
    {
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8016330:	687b      	ldr	r3, [r7, #4]
 8016332:	6819      	ldr	r1, [r3, #0]
 8016334:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016336:	009b      	lsls	r3, r3, #2
 8016338:	f107 020c 	add.w	r2, r7, #12
 801633c:	18d4      	adds	r4, r2, r3
 801633e:	4608      	mov	r0, r1
 8016340:	f001 f9e1 	bl	8017706 <SDIO_ReadFIFO>
 8016344:	4603      	mov	r3, r0
 8016346:	6023      	str	r3, [r4, #0]
      index++;
 8016348:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801634a:	3301      	adds	r3, #1
 801634c:	647b      	str	r3, [r7, #68]	; 0x44
  while(!__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND | SDIO_FLAG_STBITERR))
 801634e:	687b      	ldr	r3, [r7, #4]
 8016350:	681b      	ldr	r3, [r3, #0]
 8016352:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8016354:	f240 632a 	movw	r3, #1578	; 0x62a
 8016358:	4013      	ands	r3, r2
 801635a:	2b00      	cmp	r3, #0
 801635c:	d0e1      	beq.n	8016322 <SD_FindSCR+0xf4>
    }
  }
  
  if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
 801635e:	687b      	ldr	r3, [r7, #4]
 8016360:	681b      	ldr	r3, [r3, #0]
 8016362:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016364:	f003 0308 	and.w	r3, r3, #8
 8016368:	2b00      	cmp	r3, #0
 801636a:	d009      	beq.n	8016380 <SD_FindSCR+0x152>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 801636c:	687b      	ldr	r3, [r7, #4]
 801636e:	681b      	ldr	r3, [r3, #0]
 8016370:	2208      	movs	r2, #8
 8016372:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_TIMEOUT;
 8016374:	2304      	movs	r3, #4
 8016376:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    
    return errorstate;
 801637a:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801637e:	e05e      	b.n	801643e <SD_FindSCR+0x210>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 8016380:	687b      	ldr	r3, [r7, #4]
 8016382:	681b      	ldr	r3, [r3, #0]
 8016384:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8016386:	f003 0302 	and.w	r3, r3, #2
 801638a:	2b00      	cmp	r3, #0
 801638c:	d009      	beq.n	80163a2 <SD_FindSCR+0x174>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 801638e:	687b      	ldr	r3, [r7, #4]
 8016390:	681b      	ldr	r3, [r3, #0]
 8016392:	2202      	movs	r2, #2
 8016394:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_DATA_CRC_FAIL;
 8016396:	2302      	movs	r3, #2
 8016398:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    
    return errorstate;
 801639c:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80163a0:	e04d      	b.n	801643e <SD_FindSCR+0x210>
  }
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 80163a2:	687b      	ldr	r3, [r7, #4]
 80163a4:	681b      	ldr	r3, [r3, #0]
 80163a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80163a8:	f003 0320 	and.w	r3, r3, #32
 80163ac:	2b00      	cmp	r3, #0
 80163ae:	d009      	beq.n	80163c4 <SD_FindSCR+0x196>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 80163b0:	687b      	ldr	r3, [r7, #4]
 80163b2:	681b      	ldr	r3, [r3, #0]
 80163b4:	2220      	movs	r2, #32
 80163b6:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_RX_OVERRUN;
 80163b8:	2306      	movs	r3, #6
 80163ba:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    
    return errorstate;
 80163be:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80163c2:	e03c      	b.n	801643e <SD_FindSCR+0x210>
  }
#ifdef SDIO_STA_STBITERR
  else if(__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_STBITERR))
 80163c4:	687b      	ldr	r3, [r7, #4]
 80163c6:	681b      	ldr	r3, [r3, #0]
 80163c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80163ca:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80163ce:	2b00      	cmp	r3, #0
 80163d0:	d00a      	beq.n	80163e8 <SD_FindSCR+0x1ba>
  {
    __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_FLAG_STBITERR);
 80163d2:	687b      	ldr	r3, [r7, #4]
 80163d4:	681b      	ldr	r3, [r3, #0]
 80163d6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80163da:	639a      	str	r2, [r3, #56]	; 0x38
    
    errorstate = SD_START_BIT_ERR;
 80163dc:	2307      	movs	r3, #7
 80163de:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    
    return errorstate;
 80163e2:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 80163e6:	e02a      	b.n	801643e <SD_FindSCR+0x210>
  {
    /* No error flag set */
  }
  
  /* Clear all the static flags */
  __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80163e8:	687b      	ldr	r3, [r7, #4]
 80163ea:	681b      	ldr	r3, [r3, #0]
 80163ec:	f240 52ff 	movw	r2, #1535	; 0x5ff
 80163f0:	639a      	str	r2, [r3, #56]	; 0x38
  
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 80163f2:	68fb      	ldr	r3, [r7, #12]
 80163f4:	061a      	lsls	r2, r3, #24
 80163f6:	68fb      	ldr	r3, [r7, #12]
 80163f8:	021b      	lsls	r3, r3, #8
 80163fa:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80163fe:	431a      	orrs	r2, r3
    ((tempscr[0U] & SD_16TO23BITS) >> 8U) | ((tempscr[0U] & SD_24TO31BITS) >> 24U);
 8016400:	68fb      	ldr	r3, [r7, #12]
 8016402:	0a1b      	lsrs	r3, r3, #8
 8016404:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 8016408:	ea42 0103 	orr.w	r1, r2, r3
    ((tempscr[0U] & SD_16TO23BITS) >> 8U) | ((tempscr[0U] & SD_24TO31BITS) >> 24U);
 801640c:	68fb      	ldr	r3, [r7, #12]
 801640e:	0e1a      	lsrs	r2, r3, #24
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 8016410:	683b      	ldr	r3, [r7, #0]
 8016412:	3304      	adds	r3, #4
    ((tempscr[0U] & SD_16TO23BITS) >> 8U) | ((tempscr[0U] & SD_24TO31BITS) >> 24U);
 8016414:	430a      	orrs	r2, r1
  *(pSCR + 1U) = ((tempscr[0U] & SD_0TO7BITS) << 24U)  | ((tempscr[0U] & SD_8TO15BITS) << 8U) |\
 8016416:	601a      	str	r2, [r3, #0]
  
  *(pSCR) = ((tempscr[1U] & SD_0TO7BITS) << 24U)  | ((tempscr[1U] & SD_8TO15BITS) << 8U) |\
 8016418:	693b      	ldr	r3, [r7, #16]
 801641a:	061a      	lsls	r2, r3, #24
 801641c:	693b      	ldr	r3, [r7, #16]
 801641e:	021b      	lsls	r3, r3, #8
 8016420:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8016424:	431a      	orrs	r2, r3
    ((tempscr[1U] & SD_16TO23BITS) >> 8U) | ((tempscr[1U] & SD_24TO31BITS) >> 24U);
 8016426:	693b      	ldr	r3, [r7, #16]
 8016428:	0a1b      	lsrs	r3, r3, #8
 801642a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  *(pSCR) = ((tempscr[1U] & SD_0TO7BITS) << 24U)  | ((tempscr[1U] & SD_8TO15BITS) << 8U) |\
 801642e:	431a      	orrs	r2, r3
    ((tempscr[1U] & SD_16TO23BITS) >> 8U) | ((tempscr[1U] & SD_24TO31BITS) >> 24U);
 8016430:	693b      	ldr	r3, [r7, #16]
 8016432:	0e1b      	lsrs	r3, r3, #24
 8016434:	431a      	orrs	r2, r3
  *(pSCR) = ((tempscr[1U] & SD_0TO7BITS) << 24U)  | ((tempscr[1U] & SD_8TO15BITS) << 8U) |\
 8016436:	683b      	ldr	r3, [r7, #0]
 8016438:	601a      	str	r2, [r3, #0]
  
  return errorstate;
 801643a:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
}
 801643e:	4618      	mov	r0, r3
 8016440:	374c      	adds	r7, #76	; 0x4c
 8016442:	46bd      	mov	sp, r7
 8016444:	bd90      	pop	{r4, r7, pc}

08016446 <HAL_SMARTCARD_Init>:
  * @param  hsc: pointer to a SMARTCARD_HandleTypeDef structure that contains
  *                the configuration information for SMARTCARD module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SMARTCARD_Init(SMARTCARD_HandleTypeDef *hsc)
{
 8016446:	b580      	push	{r7, lr}
 8016448:	b082      	sub	sp, #8
 801644a:	af00      	add	r7, sp, #0
 801644c:	6078      	str	r0, [r7, #4]
  /* Check the SMARTCARD handle allocation */
  if(hsc == NULL)
 801644e:	687b      	ldr	r3, [r7, #4]
 8016450:	2b00      	cmp	r3, #0
 8016452:	d101      	bne.n	8016458 <HAL_SMARTCARD_Init+0x12>
  {
    return HAL_ERROR;
 8016454:	2301      	movs	r3, #1
 8016456:	e071      	b.n	801653c <HAL_SMARTCARD_Init+0xf6>

  /* Check the parameters */
  assert_param(IS_SMARTCARD_INSTANCE(hsc->Instance));
  assert_param(IS_SMARTCARD_NACK_STATE(hsc->Init.NACKState));

  if(hsc->gState == HAL_SMARTCARD_STATE_RESET)
 8016458:	687b      	ldr	r3, [r7, #4]
 801645a:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 801645e:	b2db      	uxtb	r3, r3
 8016460:	2b00      	cmp	r3, #0
 8016462:	d106      	bne.n	8016472 <HAL_SMARTCARD_Init+0x2c>
  {  
    /* Allocate lock resource and initialize it */
    hsc->Lock = HAL_UNLOCKED;
 8016464:	687b      	ldr	r3, [r7, #4]
 8016466:	2200      	movs	r2, #0
 8016468:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SMARTCARD_MspInit(hsc);
 801646c:	6878      	ldr	r0, [r7, #4]
 801646e:	f7fa fb8b 	bl	8010b88 <HAL_SMARTCARD_MspInit>
  }
  
  hsc->gState = HAL_SMARTCARD_STATE_BUSY;
 8016472:	687b      	ldr	r3, [r7, #4]
 8016474:	2224      	movs	r2, #36	; 0x24
 8016476:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49

  /* Set the Prescaler */
  MODIFY_REG(hsc->Instance->GTPR, USART_GTPR_PSC, hsc->Init.Prescaler);
 801647a:	687b      	ldr	r3, [r7, #4]
 801647c:	681b      	ldr	r3, [r3, #0]
 801647e:	699b      	ldr	r3, [r3, #24]
 8016480:	f023 01ff 	bic.w	r1, r3, #255	; 0xff
 8016484:	687b      	ldr	r3, [r7, #4]
 8016486:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016488:	687b      	ldr	r3, [r7, #4]
 801648a:	681b      	ldr	r3, [r3, #0]
 801648c:	430a      	orrs	r2, r1
 801648e:	619a      	str	r2, [r3, #24]

  /* Set the Guard Time */
  MODIFY_REG(hsc->Instance->GTPR, USART_GTPR_GT, ((hsc->Init.GuardTime)<<8));
 8016490:	687b      	ldr	r3, [r7, #4]
 8016492:	681b      	ldr	r3, [r3, #0]
 8016494:	699b      	ldr	r3, [r3, #24]
 8016496:	f423 417f 	bic.w	r1, r3, #65280	; 0xff00
 801649a:	687b      	ldr	r3, [r7, #4]
 801649c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801649e:	021a      	lsls	r2, r3, #8
 80164a0:	687b      	ldr	r3, [r7, #4]
 80164a2:	681b      	ldr	r3, [r3, #0]
 80164a4:	430a      	orrs	r2, r1
 80164a6:	619a      	str	r2, [r3, #24]

  /* Set the Smartcard Communication parameters */
  SMARTCARD_SetConfig(hsc);
 80164a8:	6878      	ldr	r0, [r7, #4]
 80164aa:	f000 f84b 	bl	8016544 <SMARTCARD_SetConfig>

  /* In SmartCard mode, the following bits must be kept cleared: 
  - LINEN bit in the USART_CR2 register
  - HDSEL and IREN bits in the USART_CR3 register.*/
  hsc->Instance->CR2 &= ~USART_CR2_LINEN;
 80164ae:	687b      	ldr	r3, [r7, #4]
 80164b0:	681b      	ldr	r3, [r3, #0]
 80164b2:	691a      	ldr	r2, [r3, #16]
 80164b4:	687b      	ldr	r3, [r7, #4]
 80164b6:	681b      	ldr	r3, [r3, #0]
 80164b8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80164bc:	611a      	str	r2, [r3, #16]
  hsc->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_HDSEL);
 80164be:	687b      	ldr	r3, [r7, #4]
 80164c0:	681b      	ldr	r3, [r3, #0]
 80164c2:	695a      	ldr	r2, [r3, #20]
 80164c4:	687b      	ldr	r3, [r7, #4]
 80164c6:	681b      	ldr	r3, [r3, #0]
 80164c8:	f022 020a 	bic.w	r2, r2, #10
 80164cc:	615a      	str	r2, [r3, #20]

  /* Enable the SMARTCARD Parity Error Interrupt */
  __HAL_SMARTCARD_ENABLE_IT(hsc, SMARTCARD_IT_PE);
 80164ce:	687b      	ldr	r3, [r7, #4]
 80164d0:	681b      	ldr	r3, [r3, #0]
 80164d2:	68da      	ldr	r2, [r3, #12]
 80164d4:	687b      	ldr	r3, [r7, #4]
 80164d6:	681b      	ldr	r3, [r3, #0]
 80164d8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80164dc:	60da      	str	r2, [r3, #12]

  /* Enable the SMARTCARD Framing Error Interrupt */
  __HAL_SMARTCARD_ENABLE_IT(hsc, SMARTCARD_IT_ERR);
 80164de:	687b      	ldr	r3, [r7, #4]
 80164e0:	681b      	ldr	r3, [r3, #0]
 80164e2:	695a      	ldr	r2, [r3, #20]
 80164e4:	687b      	ldr	r3, [r7, #4]
 80164e6:	681b      	ldr	r3, [r3, #0]
 80164e8:	f042 0201 	orr.w	r2, r2, #1
 80164ec:	615a      	str	r2, [r3, #20]

  /* Enable the Peripheral */
  __HAL_SMARTCARD_ENABLE(hsc);
 80164ee:	687b      	ldr	r3, [r7, #4]
 80164f0:	681b      	ldr	r3, [r3, #0]
 80164f2:	68da      	ldr	r2, [r3, #12]
 80164f4:	687b      	ldr	r3, [r7, #4]
 80164f6:	681b      	ldr	r3, [r3, #0]
 80164f8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80164fc:	60da      	str	r2, [r3, #12]

  /* Configure the Smartcard NACK state */
  MODIFY_REG(hsc->Instance->CR3, USART_CR3_NACK, hsc->Init.NACKState);
 80164fe:	687b      	ldr	r3, [r7, #4]
 8016500:	681b      	ldr	r3, [r3, #0]
 8016502:	695b      	ldr	r3, [r3, #20]
 8016504:	f023 0110 	bic.w	r1, r3, #16
 8016508:	687b      	ldr	r3, [r7, #4]
 801650a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801650c:	687b      	ldr	r3, [r7, #4]
 801650e:	681b      	ldr	r3, [r3, #0]
 8016510:	430a      	orrs	r2, r1
 8016512:	615a      	str	r2, [r3, #20]

  /* Enable the SC mode by setting the SCEN bit in the CR3 register */
  hsc->Instance->CR3 |= (USART_CR3_SCEN);
 8016514:	687b      	ldr	r3, [r7, #4]
 8016516:	681b      	ldr	r3, [r3, #0]
 8016518:	695a      	ldr	r2, [r3, #20]
 801651a:	687b      	ldr	r3, [r7, #4]
 801651c:	681b      	ldr	r3, [r3, #0]
 801651e:	f042 0220 	orr.w	r2, r2, #32
 8016522:	615a      	str	r2, [r3, #20]

  /* Initialize the SMARTCARD state*/
  hsc->ErrorCode = HAL_SMARTCARD_ERROR_NONE;
 8016524:	687b      	ldr	r3, [r7, #4]
 8016526:	2200      	movs	r2, #0
 8016528:	64da      	str	r2, [r3, #76]	; 0x4c
  hsc->gState= HAL_SMARTCARD_STATE_READY;
 801652a:	687b      	ldr	r3, [r7, #4]
 801652c:	2220      	movs	r2, #32
 801652e:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
  hsc->RxState= HAL_SMARTCARD_STATE_READY;
 8016532:	687b      	ldr	r3, [r7, #4]
 8016534:	2220      	movs	r2, #32
 8016536:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

  return HAL_OK;
 801653a:	2300      	movs	r3, #0
}
 801653c:	4618      	mov	r0, r3
 801653e:	3708      	adds	r7, #8
 8016540:	46bd      	mov	sp, r7
 8016542:	bd80      	pop	{r7, pc}

08016544 <SMARTCARD_SetConfig>:
  * @param  hsc: pointer to a SMARTCARD_HandleTypeDef structure that contains
  *                the configuration information for SMARTCARD module.
  * @retval None
  */
static void SMARTCARD_SetConfig(SMARTCARD_HandleTypeDef *hsc)
{
 8016544:	b5b0      	push	{r4, r5, r7, lr}
 8016546:	b084      	sub	sp, #16
 8016548:	af00      	add	r7, sp, #0
 801654a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0x00U;
 801654c:	2300      	movs	r3, #0
 801654e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SMARTCARD_MODE(hsc->Init.Mode));
  assert_param(IS_SMARTCARD_NACK_STATE(hsc->Init.NACKState));

  /* The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
     receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. */
  hsc->Instance->CR1 &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
 8016550:	687b      	ldr	r3, [r7, #4]
 8016552:	681b      	ldr	r3, [r3, #0]
 8016554:	68da      	ldr	r2, [r3, #12]
 8016556:	687b      	ldr	r3, [r7, #4]
 8016558:	681b      	ldr	r3, [r3, #0]
 801655a:	f022 020c 	bic.w	r2, r2, #12
 801655e:	60da      	str	r2, [r3, #12]
  
  /*---------------------------- USART CR2 Configuration ---------------------*/
  tmpreg = hsc->Instance->CR2;
 8016560:	687b      	ldr	r3, [r7, #4]
 8016562:	681b      	ldr	r3, [r3, #0]
 8016564:	691b      	ldr	r3, [r3, #16]
 8016566:	60fb      	str	r3, [r7, #12]
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | USART_CR2_LBCL));
 8016568:	68fb      	ldr	r3, [r7, #12]
 801656a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 801656e:	60fb      	str	r3, [r7, #12]
  /* Configure the SMARTCARD Clock, CPOL, CPHA and LastBit -----------------------*/
  /* Set CPOL bit according to hsc->Init.CLKPolarity value */
  /* Set CPHA bit according to hsc->Init.CLKPhase value */
  /* Set LBCL bit according to hsc->Init.CLKLastBit value */
  /* Set Stop Bits: Set STOP[13:12] bits according to hsc->Init.StopBits value */
  tmpreg |= (uint32_t)(USART_CR2_CLKEN | hsc->Init.CLKPolarity | 
 8016570:	687b      	ldr	r3, [r7, #4]
 8016572:	699a      	ldr	r2, [r3, #24]
                      hsc->Init.CLKPhase| hsc->Init.CLKLastBit | hsc->Init.StopBits);
 8016574:	687b      	ldr	r3, [r7, #4]
 8016576:	69db      	ldr	r3, [r3, #28]
  tmpreg |= (uint32_t)(USART_CR2_CLKEN | hsc->Init.CLKPolarity | 
 8016578:	431a      	orrs	r2, r3
                      hsc->Init.CLKPhase| hsc->Init.CLKLastBit | hsc->Init.StopBits);
 801657a:	687b      	ldr	r3, [r7, #4]
 801657c:	6a1b      	ldr	r3, [r3, #32]
 801657e:	431a      	orrs	r2, r3
 8016580:	687b      	ldr	r3, [r7, #4]
 8016582:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(USART_CR2_CLKEN | hsc->Init.CLKPolarity | 
 8016584:	431a      	orrs	r2, r3
 8016586:	68fb      	ldr	r3, [r7, #12]
 8016588:	4313      	orrs	r3, r2
 801658a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 801658e:	60fb      	str	r3, [r7, #12]
  /* Write to USART CR2 */
  hsc->Instance->CR2 = (uint32_t)tmpreg;
 8016590:	687b      	ldr	r3, [r7, #4]
 8016592:	681b      	ldr	r3, [r3, #0]
 8016594:	68fa      	ldr	r2, [r7, #12]
 8016596:	611a      	str	r2, [r3, #16]
  
  tmpreg = hsc->Instance->CR2;
 8016598:	687b      	ldr	r3, [r7, #4]
 801659a:	681b      	ldr	r3, [r3, #0]
 801659c:	691b      	ldr	r3, [r3, #16]
 801659e:	60fb      	str	r3, [r7, #12]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80165a0:	68fb      	ldr	r3, [r7, #12]
 80165a2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80165a6:	60fb      	str	r3, [r7, #12]

  /* Set Stop Bits: Set STOP[13:12] bits according to hsc->Init.StopBits value */
  tmpreg |= (uint32_t)(hsc->Init.StopBits);
 80165a8:	687b      	ldr	r3, [r7, #4]
 80165aa:	68db      	ldr	r3, [r3, #12]
 80165ac:	68fa      	ldr	r2, [r7, #12]
 80165ae:	4313      	orrs	r3, r2
 80165b0:	60fb      	str	r3, [r7, #12]
  
  /* Write to USART CR2 */
  hsc->Instance->CR2 = (uint32_t)tmpreg;
 80165b2:	687b      	ldr	r3, [r7, #4]
 80165b4:	681b      	ldr	r3, [r3, #0]
 80165b6:	68fa      	ldr	r2, [r7, #12]
 80165b8:	611a      	str	r2, [r3, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = hsc->Instance->CR1;
 80165ba:	687b      	ldr	r3, [r7, #4]
 80165bc:	681b      	ldr	r3, [r3, #0]
 80165be:	68db      	ldr	r3, [r3, #12]
 80165c0:	60fb      	str	r3, [r7, #12]

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80165c2:	68fb      	ldr	r3, [r7, #12]
 80165c4:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 80165c8:	f023 030c 	bic.w	r3, r3, #12
 80165cc:	60fb      	str	r3, [r7, #12]

  /* Configure the SMARTCARD Word Length, Parity and mode: 
     Set the M bits according to hsc->Init.WordLength value 
     Set PCE and PS bits according to hsc->Init.Parity value
     Set TE and RE bits according to hsc->Init.Mode value */
  tmpreg |= (uint32_t)hsc->Init.WordLength | hsc->Init.Parity | hsc->Init.Mode;
 80165ce:	687b      	ldr	r3, [r7, #4]
 80165d0:	689a      	ldr	r2, [r3, #8]
 80165d2:	687b      	ldr	r3, [r7, #4]
 80165d4:	691b      	ldr	r3, [r3, #16]
 80165d6:	431a      	orrs	r2, r3
 80165d8:	687b      	ldr	r3, [r7, #4]
 80165da:	695b      	ldr	r3, [r3, #20]
 80165dc:	4313      	orrs	r3, r2
 80165de:	68fa      	ldr	r2, [r7, #12]
 80165e0:	4313      	orrs	r3, r2
 80165e2:	60fb      	str	r3, [r7, #12]

  /* Write to USART CR1 */
  hsc->Instance->CR1 = (uint32_t)tmpreg;
 80165e4:	687b      	ldr	r3, [r7, #4]
 80165e6:	681b      	ldr	r3, [r3, #0]
 80165e8:	68fa      	ldr	r2, [r7, #12]
 80165ea:	60da      	str	r2, [r3, #12]

  /*-------------------------- USART CR3 Configuration -----------------------*/  
  /* Clear CTSE and RTSE bits */
  hsc->Instance->CR3 &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80165ec:	687b      	ldr	r3, [r7, #4]
 80165ee:	681b      	ldr	r3, [r3, #0]
 80165f0:	695a      	ldr	r2, [r3, #20]
 80165f2:	687b      	ldr	r3, [r7, #4]
 80165f4:	681b      	ldr	r3, [r3, #0]
 80165f6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80165fa:	615a      	str	r2, [r3, #20]

  /*-------------------------- USART BRR Configuration -----------------------*/
  if((hsc->Instance == USART1) || (hsc->Instance == USART6))
 80165fc:	687b      	ldr	r3, [r7, #4]
 80165fe:	681b      	ldr	r3, [r3, #0]
 8016600:	4a71      	ldr	r2, [pc, #452]	; (80167c8 <SMARTCARD_SetConfig+0x284>)
 8016602:	4293      	cmp	r3, r2
 8016604:	d004      	beq.n	8016610 <SMARTCARD_SetConfig+0xcc>
 8016606:	687b      	ldr	r3, [r7, #4]
 8016608:	681b      	ldr	r3, [r3, #0]
 801660a:	4a70      	ldr	r2, [pc, #448]	; (80167cc <SMARTCARD_SetConfig+0x288>)
 801660c:	4293      	cmp	r3, r2
 801660e:	d16b      	bne.n	80166e8 <SMARTCARD_SetConfig+0x1a4>
  {
    hsc->Instance->BRR = SMARTCARD_BRR(HAL_RCC_GetPCLK2Freq(), hsc->Init.BaudRate);
 8016610:	f7fe f890 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8016614:	4602      	mov	r2, r0
 8016616:	4613      	mov	r3, r2
 8016618:	009b      	lsls	r3, r3, #2
 801661a:	4413      	add	r3, r2
 801661c:	009a      	lsls	r2, r3, #2
 801661e:	441a      	add	r2, r3
 8016620:	687b      	ldr	r3, [r7, #4]
 8016622:	685b      	ldr	r3, [r3, #4]
 8016624:	009b      	lsls	r3, r3, #2
 8016626:	fbb2 f3f3 	udiv	r3, r2, r3
 801662a:	4a69      	ldr	r2, [pc, #420]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 801662c:	fba2 2303 	umull	r2, r3, r2, r3
 8016630:	095b      	lsrs	r3, r3, #5
 8016632:	011c      	lsls	r4, r3, #4
 8016634:	f7fe f87e 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8016638:	4602      	mov	r2, r0
 801663a:	4613      	mov	r3, r2
 801663c:	009b      	lsls	r3, r3, #2
 801663e:	4413      	add	r3, r2
 8016640:	009a      	lsls	r2, r3, #2
 8016642:	441a      	add	r2, r3
 8016644:	687b      	ldr	r3, [r7, #4]
 8016646:	685b      	ldr	r3, [r3, #4]
 8016648:	009b      	lsls	r3, r3, #2
 801664a:	fbb2 f5f3 	udiv	r5, r2, r3
 801664e:	f7fe f871 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8016652:	4602      	mov	r2, r0
 8016654:	4613      	mov	r3, r2
 8016656:	009b      	lsls	r3, r3, #2
 8016658:	4413      	add	r3, r2
 801665a:	009a      	lsls	r2, r3, #2
 801665c:	441a      	add	r2, r3
 801665e:	687b      	ldr	r3, [r7, #4]
 8016660:	685b      	ldr	r3, [r3, #4]
 8016662:	009b      	lsls	r3, r3, #2
 8016664:	fbb2 f3f3 	udiv	r3, r2, r3
 8016668:	4a59      	ldr	r2, [pc, #356]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 801666a:	fba2 2303 	umull	r2, r3, r2, r3
 801666e:	095b      	lsrs	r3, r3, #5
 8016670:	2264      	movs	r2, #100	; 0x64
 8016672:	fb02 f303 	mul.w	r3, r2, r3
 8016676:	1aeb      	subs	r3, r5, r3
 8016678:	011b      	lsls	r3, r3, #4
 801667a:	3332      	adds	r3, #50	; 0x32
 801667c:	4a54      	ldr	r2, [pc, #336]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 801667e:	fba2 2303 	umull	r2, r3, r2, r3
 8016682:	095b      	lsrs	r3, r3, #5
 8016684:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8016688:	441c      	add	r4, r3
 801668a:	f7fe f853 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 801668e:	4602      	mov	r2, r0
 8016690:	4613      	mov	r3, r2
 8016692:	009b      	lsls	r3, r3, #2
 8016694:	4413      	add	r3, r2
 8016696:	009a      	lsls	r2, r3, #2
 8016698:	441a      	add	r2, r3
 801669a:	687b      	ldr	r3, [r7, #4]
 801669c:	685b      	ldr	r3, [r3, #4]
 801669e:	009b      	lsls	r3, r3, #2
 80166a0:	fbb2 f5f3 	udiv	r5, r2, r3
 80166a4:	f7fe f846 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 80166a8:	4602      	mov	r2, r0
 80166aa:	4613      	mov	r3, r2
 80166ac:	009b      	lsls	r3, r3, #2
 80166ae:	4413      	add	r3, r2
 80166b0:	009a      	lsls	r2, r3, #2
 80166b2:	441a      	add	r2, r3
 80166b4:	687b      	ldr	r3, [r7, #4]
 80166b6:	685b      	ldr	r3, [r3, #4]
 80166b8:	009b      	lsls	r3, r3, #2
 80166ba:	fbb2 f3f3 	udiv	r3, r2, r3
 80166be:	4a44      	ldr	r2, [pc, #272]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 80166c0:	fba2 2303 	umull	r2, r3, r2, r3
 80166c4:	095b      	lsrs	r3, r3, #5
 80166c6:	2264      	movs	r2, #100	; 0x64
 80166c8:	fb02 f303 	mul.w	r3, r2, r3
 80166cc:	1aeb      	subs	r3, r5, r3
 80166ce:	011b      	lsls	r3, r3, #4
 80166d0:	3332      	adds	r3, #50	; 0x32
 80166d2:	4a3f      	ldr	r2, [pc, #252]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 80166d4:	fba2 2303 	umull	r2, r3, r2, r3
 80166d8:	095b      	lsrs	r3, r3, #5
 80166da:	f003 020f 	and.w	r2, r3, #15
 80166de:	687b      	ldr	r3, [r7, #4]
 80166e0:	681b      	ldr	r3, [r3, #0]
 80166e2:	4422      	add	r2, r4
 80166e4:	609a      	str	r2, [r3, #8]
 80166e6:	e06a      	b.n	80167be <SMARTCARD_SetConfig+0x27a>
  }
  else
  {
    hsc->Instance->BRR = SMARTCARD_BRR(HAL_RCC_GetPCLK1Freq(), hsc->Init.BaudRate);
 80166e8:	f7fe f802 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 80166ec:	4602      	mov	r2, r0
 80166ee:	4613      	mov	r3, r2
 80166f0:	009b      	lsls	r3, r3, #2
 80166f2:	4413      	add	r3, r2
 80166f4:	009a      	lsls	r2, r3, #2
 80166f6:	441a      	add	r2, r3
 80166f8:	687b      	ldr	r3, [r7, #4]
 80166fa:	685b      	ldr	r3, [r3, #4]
 80166fc:	009b      	lsls	r3, r3, #2
 80166fe:	fbb2 f3f3 	udiv	r3, r2, r3
 8016702:	4a33      	ldr	r2, [pc, #204]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 8016704:	fba2 2303 	umull	r2, r3, r2, r3
 8016708:	095b      	lsrs	r3, r3, #5
 801670a:	011c      	lsls	r4, r3, #4
 801670c:	f7fd fff0 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8016710:	4602      	mov	r2, r0
 8016712:	4613      	mov	r3, r2
 8016714:	009b      	lsls	r3, r3, #2
 8016716:	4413      	add	r3, r2
 8016718:	009a      	lsls	r2, r3, #2
 801671a:	441a      	add	r2, r3
 801671c:	687b      	ldr	r3, [r7, #4]
 801671e:	685b      	ldr	r3, [r3, #4]
 8016720:	009b      	lsls	r3, r3, #2
 8016722:	fbb2 f5f3 	udiv	r5, r2, r3
 8016726:	f7fd ffe3 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 801672a:	4602      	mov	r2, r0
 801672c:	4613      	mov	r3, r2
 801672e:	009b      	lsls	r3, r3, #2
 8016730:	4413      	add	r3, r2
 8016732:	009a      	lsls	r2, r3, #2
 8016734:	441a      	add	r2, r3
 8016736:	687b      	ldr	r3, [r7, #4]
 8016738:	685b      	ldr	r3, [r3, #4]
 801673a:	009b      	lsls	r3, r3, #2
 801673c:	fbb2 f3f3 	udiv	r3, r2, r3
 8016740:	4a23      	ldr	r2, [pc, #140]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 8016742:	fba2 2303 	umull	r2, r3, r2, r3
 8016746:	095b      	lsrs	r3, r3, #5
 8016748:	2264      	movs	r2, #100	; 0x64
 801674a:	fb02 f303 	mul.w	r3, r2, r3
 801674e:	1aeb      	subs	r3, r5, r3
 8016750:	011b      	lsls	r3, r3, #4
 8016752:	3332      	adds	r3, #50	; 0x32
 8016754:	4a1e      	ldr	r2, [pc, #120]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 8016756:	fba2 2303 	umull	r2, r3, r2, r3
 801675a:	095b      	lsrs	r3, r3, #5
 801675c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8016760:	441c      	add	r4, r3
 8016762:	f7fd ffc5 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8016766:	4602      	mov	r2, r0
 8016768:	4613      	mov	r3, r2
 801676a:	009b      	lsls	r3, r3, #2
 801676c:	4413      	add	r3, r2
 801676e:	009a      	lsls	r2, r3, #2
 8016770:	441a      	add	r2, r3
 8016772:	687b      	ldr	r3, [r7, #4]
 8016774:	685b      	ldr	r3, [r3, #4]
 8016776:	009b      	lsls	r3, r3, #2
 8016778:	fbb2 f5f3 	udiv	r5, r2, r3
 801677c:	f7fd ffb8 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8016780:	4602      	mov	r2, r0
 8016782:	4613      	mov	r3, r2
 8016784:	009b      	lsls	r3, r3, #2
 8016786:	4413      	add	r3, r2
 8016788:	009a      	lsls	r2, r3, #2
 801678a:	441a      	add	r2, r3
 801678c:	687b      	ldr	r3, [r7, #4]
 801678e:	685b      	ldr	r3, [r3, #4]
 8016790:	009b      	lsls	r3, r3, #2
 8016792:	fbb2 f3f3 	udiv	r3, r2, r3
 8016796:	4a0e      	ldr	r2, [pc, #56]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 8016798:	fba2 2303 	umull	r2, r3, r2, r3
 801679c:	095b      	lsrs	r3, r3, #5
 801679e:	2264      	movs	r2, #100	; 0x64
 80167a0:	fb02 f303 	mul.w	r3, r2, r3
 80167a4:	1aeb      	subs	r3, r5, r3
 80167a6:	011b      	lsls	r3, r3, #4
 80167a8:	3332      	adds	r3, #50	; 0x32
 80167aa:	4a09      	ldr	r2, [pc, #36]	; (80167d0 <SMARTCARD_SetConfig+0x28c>)
 80167ac:	fba2 2303 	umull	r2, r3, r2, r3
 80167b0:	095b      	lsrs	r3, r3, #5
 80167b2:	f003 020f 	and.w	r2, r3, #15
 80167b6:	687b      	ldr	r3, [r7, #4]
 80167b8:	681b      	ldr	r3, [r3, #0]
 80167ba:	4422      	add	r2, r4
 80167bc:	609a      	str	r2, [r3, #8]
  }
}
 80167be:	bf00      	nop
 80167c0:	3710      	adds	r7, #16
 80167c2:	46bd      	mov	sp, r7
 80167c4:	bdb0      	pop	{r4, r5, r7, pc}
 80167c6:	bf00      	nop
 80167c8:	40011000 	.word	0x40011000
 80167cc:	40011400 	.word	0x40011400
 80167d0:	51eb851f 	.word	0x51eb851f

080167d4 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80167d4:	b580      	push	{r7, lr}
 80167d6:	b082      	sub	sp, #8
 80167d8:	af00      	add	r7, sp, #0
 80167da:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80167dc:	687b      	ldr	r3, [r7, #4]
 80167de:	2b00      	cmp	r3, #0
 80167e0:	d101      	bne.n	80167e6 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80167e2:	2301      	movs	r3, #1
 80167e4:	e05d      	b.n	80168a2 <HAL_SPI_Init+0xce>
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
#endif

  if(hspi->State == HAL_SPI_STATE_RESET)
 80167e6:	687b      	ldr	r3, [r7, #4]
 80167e8:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80167ec:	b2db      	uxtb	r3, r3
 80167ee:	2b00      	cmp	r3, #0
 80167f0:	d106      	bne.n	8016800 <HAL_SPI_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80167f2:	687b      	ldr	r3, [r7, #4]
 80167f4:	2200      	movs	r2, #0
 80167f6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80167fa:	6878      	ldr	r0, [r7, #4]
 80167fc:	f7fa f81a 	bl	8010834 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8016800:	687b      	ldr	r3, [r7, #4]
 8016802:	2202      	movs	r2, #2
 8016804:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8016808:	687b      	ldr	r3, [r7, #4]
 801680a:	681b      	ldr	r3, [r3, #0]
 801680c:	681a      	ldr	r2, [r3, #0]
 801680e:	687b      	ldr	r3, [r7, #4]
 8016810:	681b      	ldr	r3, [r3, #0]
 8016812:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8016816:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8016818:	687b      	ldr	r3, [r7, #4]
 801681a:	685a      	ldr	r2, [r3, #4]
 801681c:	687b      	ldr	r3, [r7, #4]
 801681e:	689b      	ldr	r3, [r3, #8]
 8016820:	431a      	orrs	r2, r3
 8016822:	687b      	ldr	r3, [r7, #4]
 8016824:	68db      	ldr	r3, [r3, #12]
 8016826:	431a      	orrs	r2, r3
 8016828:	687b      	ldr	r3, [r7, #4]
 801682a:	691b      	ldr	r3, [r3, #16]
 801682c:	431a      	orrs	r2, r3
 801682e:	687b      	ldr	r3, [r7, #4]
 8016830:	695b      	ldr	r3, [r3, #20]
 8016832:	431a      	orrs	r2, r3
 8016834:	687b      	ldr	r3, [r7, #4]
 8016836:	699b      	ldr	r3, [r3, #24]
 8016838:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801683c:	431a      	orrs	r2, r3
 801683e:	687b      	ldr	r3, [r7, #4]
 8016840:	69db      	ldr	r3, [r3, #28]
 8016842:	431a      	orrs	r2, r3
 8016844:	687b      	ldr	r3, [r7, #4]
 8016846:	6a1b      	ldr	r3, [r3, #32]
 8016848:	ea42 0103 	orr.w	r1, r2, r3
 801684c:	687b      	ldr	r3, [r7, #4]
 801684e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8016850:	687b      	ldr	r3, [r7, #4]
 8016852:	681b      	ldr	r3, [r3, #0]
 8016854:	430a      	orrs	r2, r1
 8016856:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 8016858:	687b      	ldr	r3, [r7, #4]
 801685a:	699b      	ldr	r3, [r3, #24]
 801685c:	0c1b      	lsrs	r3, r3, #16
 801685e:	f003 0104 	and.w	r1, r3, #4
 8016862:	687b      	ldr	r3, [r7, #4]
 8016864:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016866:	687b      	ldr	r3, [r7, #4]
 8016868:	681b      	ldr	r3, [r3, #0]
 801686a:	430a      	orrs	r2, r1
 801686c:	605a      	str	r2, [r3, #4]

#ifdef USE_SPI_CRC
  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 801686e:	687b      	ldr	r3, [r7, #4]
 8016870:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8016872:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8016876:	d104      	bne.n	8016882 <HAL_SPI_Init+0xae>
  {
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 8016878:	687b      	ldr	r3, [r7, #4]
 801687a:	681b      	ldr	r3, [r3, #0]
 801687c:	687a      	ldr	r2, [r7, #4]
 801687e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8016880:	611a      	str	r2, [r3, #16]
  }
#endif

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8016882:	687b      	ldr	r3, [r7, #4]
 8016884:	681b      	ldr	r3, [r3, #0]
 8016886:	69da      	ldr	r2, [r3, #28]
 8016888:	687b      	ldr	r3, [r7, #4]
 801688a:	681b      	ldr	r3, [r3, #0]
 801688c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8016890:	61da      	str	r2, [r3, #28]
#endif

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8016892:	687b      	ldr	r3, [r7, #4]
 8016894:	2200      	movs	r2, #0
 8016896:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 8016898:	687b      	ldr	r3, [r7, #4]
 801689a:	2201      	movs	r2, #1
 801689c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 80168a0:	2300      	movs	r3, #0
}
 80168a2:	4618      	mov	r0, r3
 80168a4:	3708      	adds	r7, #8
 80168a6:	46bd      	mov	sp, r7
 80168a8:	bd80      	pop	{r7, pc}

080168aa <HAL_TIM_PWM_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80168aa:	b580      	push	{r7, lr}
 80168ac:	b082      	sub	sp, #8
 80168ae:	af00      	add	r7, sp, #0
 80168b0:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 80168b2:	687b      	ldr	r3, [r7, #4]
 80168b4:	2b00      	cmp	r3, #0
 80168b6:	d101      	bne.n	80168bc <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 80168b8:	2301      	movs	r3, #1
 80168ba:	e01d      	b.n	80168f8 <HAL_TIM_PWM_Init+0x4e>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80168bc:	687b      	ldr	r3, [r7, #4]
 80168be:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 80168c2:	b2db      	uxtb	r3, r3
 80168c4:	2b00      	cmp	r3, #0
 80168c6:	d106      	bne.n	80168d6 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80168c8:	687b      	ldr	r3, [r7, #4]
 80168ca:	2200      	movs	r2, #0
 80168cc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 80168d0:	6878      	ldr	r0, [r7, #4]
 80168d2:	f7fa f865 	bl	80109a0 <HAL_TIM_PWM_MspInit>
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;  
 80168d6:	687b      	ldr	r3, [r7, #4]
 80168d8:	2202      	movs	r2, #2
 80168da:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Init the base time for the PWM */  
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 80168de:	687b      	ldr	r3, [r7, #4]
 80168e0:	681a      	ldr	r2, [r3, #0]
 80168e2:	687b      	ldr	r3, [r7, #4]
 80168e4:	3304      	adds	r3, #4
 80168e6:	4619      	mov	r1, r3
 80168e8:	4610      	mov	r0, r2
 80168ea:	f000 f8cf 	bl	8016a8c <TIM_Base_SetConfig>
   
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80168ee:	687b      	ldr	r3, [r7, #4]
 80168f0:	2201      	movs	r2, #1
 80168f2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 80168f6:	2300      	movs	r3, #0
}  
 80168f8:	4618      	mov	r0, r3
 80168fa:	3708      	adds	r7, #8
 80168fc:	46bd      	mov	sp, r7
 80168fe:	bd80      	pop	{r7, pc}

08016900 <HAL_TIM_PWM_ConfigChannel>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
 8016900:	b580      	push	{r7, lr}
 8016902:	b084      	sub	sp, #16
 8016904:	af00      	add	r7, sp, #0
 8016906:	60f8      	str	r0, [r7, #12]
 8016908:	60b9      	str	r1, [r7, #8]
 801690a:	607a      	str	r2, [r7, #4]
  __HAL_LOCK(htim);
 801690c:	68fb      	ldr	r3, [r7, #12]
 801690e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8016912:	2b01      	cmp	r3, #1
 8016914:	d101      	bne.n	801691a <HAL_TIM_PWM_ConfigChannel+0x1a>
 8016916:	2302      	movs	r3, #2
 8016918:	e0b4      	b.n	8016a84 <HAL_TIM_PWM_ConfigChannel+0x184>
 801691a:	68fb      	ldr	r3, [r7, #12]
 801691c:	2201      	movs	r2, #1
 801691e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  assert_param(IS_TIM_CHANNELS(Channel)); 
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;
 8016922:	68fb      	ldr	r3, [r7, #12]
 8016924:	2202      	movs	r2, #2
 8016926:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  switch (Channel)
 801692a:	687b      	ldr	r3, [r7, #4]
 801692c:	2b0c      	cmp	r3, #12
 801692e:	f200 809f 	bhi.w	8016a70 <HAL_TIM_PWM_ConfigChannel+0x170>
 8016932:	a201      	add	r2, pc, #4	; (adr r2, 8016938 <HAL_TIM_PWM_ConfigChannel+0x38>)
 8016934:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016938:	0801696d 	.word	0x0801696d
 801693c:	08016a71 	.word	0x08016a71
 8016940:	08016a71 	.word	0x08016a71
 8016944:	08016a71 	.word	0x08016a71
 8016948:	080169ad 	.word	0x080169ad
 801694c:	08016a71 	.word	0x08016a71
 8016950:	08016a71 	.word	0x08016a71
 8016954:	08016a71 	.word	0x08016a71
 8016958:	080169ef 	.word	0x080169ef
 801695c:	08016a71 	.word	0x08016a71
 8016960:	08016a71 	.word	0x08016a71
 8016964:	08016a71 	.word	0x08016a71
 8016968:	08016a2f 	.word	0x08016a2f
  {
    case TIM_CHANNEL_1:
    {
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 801696c:	68fb      	ldr	r3, [r7, #12]
 801696e:	681b      	ldr	r3, [r3, #0]
 8016970:	68b9      	ldr	r1, [r7, #8]
 8016972:	4618      	mov	r0, r3
 8016974:	f000 f9ac 	bl	8016cd0 <TIM_OC1_SetConfig>
      
      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8016978:	68fb      	ldr	r3, [r7, #12]
 801697a:	681b      	ldr	r3, [r3, #0]
 801697c:	699a      	ldr	r2, [r3, #24]
 801697e:	68fb      	ldr	r3, [r7, #12]
 8016980:	681b      	ldr	r3, [r3, #0]
 8016982:	f042 0208 	orr.w	r2, r2, #8
 8016986:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8016988:	68fb      	ldr	r3, [r7, #12]
 801698a:	681b      	ldr	r3, [r3, #0]
 801698c:	699a      	ldr	r2, [r3, #24]
 801698e:	68fb      	ldr	r3, [r7, #12]
 8016990:	681b      	ldr	r3, [r3, #0]
 8016992:	f022 0204 	bic.w	r2, r2, #4
 8016996:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8016998:	68fb      	ldr	r3, [r7, #12]
 801699a:	681b      	ldr	r3, [r3, #0]
 801699c:	6999      	ldr	r1, [r3, #24]
 801699e:	68bb      	ldr	r3, [r7, #8]
 80169a0:	691a      	ldr	r2, [r3, #16]
 80169a2:	68fb      	ldr	r3, [r7, #12]
 80169a4:	681b      	ldr	r3, [r3, #0]
 80169a6:	430a      	orrs	r2, r1
 80169a8:	619a      	str	r2, [r3, #24]
    }
    break;
 80169aa:	e062      	b.n	8016a72 <HAL_TIM_PWM_ConfigChannel+0x172>
    
    case TIM_CHANNEL_2:
    {
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80169ac:	68fb      	ldr	r3, [r7, #12]
 80169ae:	681b      	ldr	r3, [r3, #0]
 80169b0:	68b9      	ldr	r1, [r7, #8]
 80169b2:	4618      	mov	r0, r3
 80169b4:	f000 f914 	bl	8016be0 <TIM_OC2_SetConfig>
      
      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80169b8:	68fb      	ldr	r3, [r7, #12]
 80169ba:	681b      	ldr	r3, [r3, #0]
 80169bc:	699a      	ldr	r2, [r3, #24]
 80169be:	68fb      	ldr	r3, [r7, #12]
 80169c0:	681b      	ldr	r3, [r3, #0]
 80169c2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80169c6:	619a      	str	r2, [r3, #24]
      
      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80169c8:	68fb      	ldr	r3, [r7, #12]
 80169ca:	681b      	ldr	r3, [r3, #0]
 80169cc:	699a      	ldr	r2, [r3, #24]
 80169ce:	68fb      	ldr	r3, [r7, #12]
 80169d0:	681b      	ldr	r3, [r3, #0]
 80169d2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80169d6:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80169d8:	68fb      	ldr	r3, [r7, #12]
 80169da:	681b      	ldr	r3, [r3, #0]
 80169dc:	6999      	ldr	r1, [r3, #24]
 80169de:	68bb      	ldr	r3, [r7, #8]
 80169e0:	691b      	ldr	r3, [r3, #16]
 80169e2:	021a      	lsls	r2, r3, #8
 80169e4:	68fb      	ldr	r3, [r7, #12]
 80169e6:	681b      	ldr	r3, [r3, #0]
 80169e8:	430a      	orrs	r2, r1
 80169ea:	619a      	str	r2, [r3, #24]
    }
    break;
 80169ec:	e041      	b.n	8016a72 <HAL_TIM_PWM_ConfigChannel+0x172>
    
    case TIM_CHANNEL_3:
    {
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80169ee:	68fb      	ldr	r3, [r7, #12]
 80169f0:	681b      	ldr	r3, [r3, #0]
 80169f2:	68b9      	ldr	r1, [r7, #8]
 80169f4:	4618      	mov	r0, r3
 80169f6:	f000 f9df 	bl	8016db8 <TIM_OC3_SetConfig>
      
      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80169fa:	68fb      	ldr	r3, [r7, #12]
 80169fc:	681b      	ldr	r3, [r3, #0]
 80169fe:	69da      	ldr	r2, [r3, #28]
 8016a00:	68fb      	ldr	r3, [r7, #12]
 8016a02:	681b      	ldr	r3, [r3, #0]
 8016a04:	f042 0208 	orr.w	r2, r2, #8
 8016a08:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8016a0a:	68fb      	ldr	r3, [r7, #12]
 8016a0c:	681b      	ldr	r3, [r3, #0]
 8016a0e:	69da      	ldr	r2, [r3, #28]
 8016a10:	68fb      	ldr	r3, [r7, #12]
 8016a12:	681b      	ldr	r3, [r3, #0]
 8016a14:	f022 0204 	bic.w	r2, r2, #4
 8016a18:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;  
 8016a1a:	68fb      	ldr	r3, [r7, #12]
 8016a1c:	681b      	ldr	r3, [r3, #0]
 8016a1e:	69d9      	ldr	r1, [r3, #28]
 8016a20:	68bb      	ldr	r3, [r7, #8]
 8016a22:	691a      	ldr	r2, [r3, #16]
 8016a24:	68fb      	ldr	r3, [r7, #12]
 8016a26:	681b      	ldr	r3, [r3, #0]
 8016a28:	430a      	orrs	r2, r1
 8016a2a:	61da      	str	r2, [r3, #28]
    }
    break;
 8016a2c:	e021      	b.n	8016a72 <HAL_TIM_PWM_ConfigChannel+0x172>
    
    case TIM_CHANNEL_4:
    {
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8016a2e:	68fb      	ldr	r3, [r7, #12]
 8016a30:	681b      	ldr	r3, [r3, #0]
 8016a32:	68b9      	ldr	r1, [r7, #8]
 8016a34:	4618      	mov	r0, r3
 8016a36:	f000 fa37 	bl	8016ea8 <TIM_OC4_SetConfig>
      
      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8016a3a:	68fb      	ldr	r3, [r7, #12]
 8016a3c:	681b      	ldr	r3, [r3, #0]
 8016a3e:	69da      	ldr	r2, [r3, #28]
 8016a40:	68fb      	ldr	r3, [r7, #12]
 8016a42:	681b      	ldr	r3, [r3, #0]
 8016a44:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8016a48:	61da      	str	r2, [r3, #28]
      
     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8016a4a:	68fb      	ldr	r3, [r7, #12]
 8016a4c:	681b      	ldr	r3, [r3, #0]
 8016a4e:	69da      	ldr	r2, [r3, #28]
 8016a50:	68fb      	ldr	r3, [r7, #12]
 8016a52:	681b      	ldr	r3, [r3, #0]
 8016a54:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8016a58:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
 8016a5a:	68fb      	ldr	r3, [r7, #12]
 8016a5c:	681b      	ldr	r3, [r3, #0]
 8016a5e:	69d9      	ldr	r1, [r3, #28]
 8016a60:	68bb      	ldr	r3, [r7, #8]
 8016a62:	691b      	ldr	r3, [r3, #16]
 8016a64:	021a      	lsls	r2, r3, #8
 8016a66:	68fb      	ldr	r3, [r7, #12]
 8016a68:	681b      	ldr	r3, [r3, #0]
 8016a6a:	430a      	orrs	r2, r1
 8016a6c:	61da      	str	r2, [r3, #28]
    }
    break;
 8016a6e:	e000      	b.n	8016a72 <HAL_TIM_PWM_ConfigChannel+0x172>
    
    default:
    break;    
 8016a70:	bf00      	nop
  }
  
  htim->State = HAL_TIM_STATE_READY;
 8016a72:	68fb      	ldr	r3, [r7, #12]
 8016a74:	2201      	movs	r2, #1
 8016a76:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    
  __HAL_UNLOCK(htim);
 8016a7a:	68fb      	ldr	r3, [r7, #12]
 8016a7c:	2200      	movs	r2, #0
 8016a7e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 8016a82:	2300      	movs	r3, #0
}
 8016a84:	4618      	mov	r0, r3
 8016a86:	3710      	adds	r7, #16
 8016a88:	46bd      	mov	sp, r7
 8016a8a:	bd80      	pop	{r7, pc}

08016a8c <TIM_Base_SetConfig>:
  * @param  TIMx: TIM peripheral
  * @param  Structure: pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8016a8c:	b480      	push	{r7}
 8016a8e:	b085      	sub	sp, #20
 8016a90:	af00      	add	r7, sp, #0
 8016a92:	6078      	str	r0, [r7, #4]
 8016a94:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1 = 0U;
 8016a96:	2300      	movs	r3, #0
 8016a98:	60fb      	str	r3, [r7, #12]
  tmpcr1 = TIMx->CR1;
 8016a9a:	687b      	ldr	r3, [r7, #4]
 8016a9c:	681b      	ldr	r3, [r3, #0]
 8016a9e:	60fb      	str	r3, [r7, #12]
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 8016aa0:	687b      	ldr	r3, [r7, #4]
 8016aa2:	4a44      	ldr	r2, [pc, #272]	; (8016bb4 <TIM_Base_SetConfig+0x128>)
 8016aa4:	4293      	cmp	r3, r2
 8016aa6:	d013      	beq.n	8016ad0 <TIM_Base_SetConfig+0x44>
 8016aa8:	687b      	ldr	r3, [r7, #4]
 8016aaa:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8016aae:	d00f      	beq.n	8016ad0 <TIM_Base_SetConfig+0x44>
 8016ab0:	687b      	ldr	r3, [r7, #4]
 8016ab2:	4a41      	ldr	r2, [pc, #260]	; (8016bb8 <TIM_Base_SetConfig+0x12c>)
 8016ab4:	4293      	cmp	r3, r2
 8016ab6:	d00b      	beq.n	8016ad0 <TIM_Base_SetConfig+0x44>
 8016ab8:	687b      	ldr	r3, [r7, #4]
 8016aba:	4a40      	ldr	r2, [pc, #256]	; (8016bbc <TIM_Base_SetConfig+0x130>)
 8016abc:	4293      	cmp	r3, r2
 8016abe:	d007      	beq.n	8016ad0 <TIM_Base_SetConfig+0x44>
 8016ac0:	687b      	ldr	r3, [r7, #4]
 8016ac2:	4a3f      	ldr	r2, [pc, #252]	; (8016bc0 <TIM_Base_SetConfig+0x134>)
 8016ac4:	4293      	cmp	r3, r2
 8016ac6:	d003      	beq.n	8016ad0 <TIM_Base_SetConfig+0x44>
 8016ac8:	687b      	ldr	r3, [r7, #4]
 8016aca:	4a3e      	ldr	r2, [pc, #248]	; (8016bc4 <TIM_Base_SetConfig+0x138>)
 8016acc:	4293      	cmp	r3, r2
 8016ace:	d101      	bne.n	8016ad4 <TIM_Base_SetConfig+0x48>
 8016ad0:	2301      	movs	r3, #1
 8016ad2:	e000      	b.n	8016ad6 <TIM_Base_SetConfig+0x4a>
 8016ad4:	2300      	movs	r3, #0
 8016ad6:	2b00      	cmp	r3, #0
 8016ad8:	d008      	beq.n	8016aec <TIM_Base_SetConfig+0x60>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8016ada:	68fb      	ldr	r3, [r7, #12]
 8016adc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016ae0:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8016ae2:	683b      	ldr	r3, [r7, #0]
 8016ae4:	685b      	ldr	r3, [r3, #4]
 8016ae6:	68fa      	ldr	r2, [r7, #12]
 8016ae8:	4313      	orrs	r3, r2
 8016aea:	60fb      	str	r3, [r7, #12]
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8016aec:	687b      	ldr	r3, [r7, #4]
 8016aee:	4a31      	ldr	r2, [pc, #196]	; (8016bb4 <TIM_Base_SetConfig+0x128>)
 8016af0:	4293      	cmp	r3, r2
 8016af2:	d02b      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016af4:	687b      	ldr	r3, [r7, #4]
 8016af6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8016afa:	d027      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016afc:	687b      	ldr	r3, [r7, #4]
 8016afe:	4a2e      	ldr	r2, [pc, #184]	; (8016bb8 <TIM_Base_SetConfig+0x12c>)
 8016b00:	4293      	cmp	r3, r2
 8016b02:	d023      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b04:	687b      	ldr	r3, [r7, #4]
 8016b06:	4a2d      	ldr	r2, [pc, #180]	; (8016bbc <TIM_Base_SetConfig+0x130>)
 8016b08:	4293      	cmp	r3, r2
 8016b0a:	d01f      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b0c:	687b      	ldr	r3, [r7, #4]
 8016b0e:	4a2c      	ldr	r2, [pc, #176]	; (8016bc0 <TIM_Base_SetConfig+0x134>)
 8016b10:	4293      	cmp	r3, r2
 8016b12:	d01b      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b14:	687b      	ldr	r3, [r7, #4]
 8016b16:	4a2b      	ldr	r2, [pc, #172]	; (8016bc4 <TIM_Base_SetConfig+0x138>)
 8016b18:	4293      	cmp	r3, r2
 8016b1a:	d017      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b1c:	687b      	ldr	r3, [r7, #4]
 8016b1e:	4a2a      	ldr	r2, [pc, #168]	; (8016bc8 <TIM_Base_SetConfig+0x13c>)
 8016b20:	4293      	cmp	r3, r2
 8016b22:	d013      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b24:	687b      	ldr	r3, [r7, #4]
 8016b26:	4a29      	ldr	r2, [pc, #164]	; (8016bcc <TIM_Base_SetConfig+0x140>)
 8016b28:	4293      	cmp	r3, r2
 8016b2a:	d00f      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b2c:	687b      	ldr	r3, [r7, #4]
 8016b2e:	4a28      	ldr	r2, [pc, #160]	; (8016bd0 <TIM_Base_SetConfig+0x144>)
 8016b30:	4293      	cmp	r3, r2
 8016b32:	d00b      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b34:	687b      	ldr	r3, [r7, #4]
 8016b36:	4a27      	ldr	r2, [pc, #156]	; (8016bd4 <TIM_Base_SetConfig+0x148>)
 8016b38:	4293      	cmp	r3, r2
 8016b3a:	d007      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b3c:	687b      	ldr	r3, [r7, #4]
 8016b3e:	4a26      	ldr	r2, [pc, #152]	; (8016bd8 <TIM_Base_SetConfig+0x14c>)
 8016b40:	4293      	cmp	r3, r2
 8016b42:	d003      	beq.n	8016b4c <TIM_Base_SetConfig+0xc0>
 8016b44:	687b      	ldr	r3, [r7, #4]
 8016b46:	4a25      	ldr	r2, [pc, #148]	; (8016bdc <TIM_Base_SetConfig+0x150>)
 8016b48:	4293      	cmp	r3, r2
 8016b4a:	d101      	bne.n	8016b50 <TIM_Base_SetConfig+0xc4>
 8016b4c:	2301      	movs	r3, #1
 8016b4e:	e000      	b.n	8016b52 <TIM_Base_SetConfig+0xc6>
 8016b50:	2300      	movs	r3, #0
 8016b52:	2b00      	cmp	r3, #0
 8016b54:	d008      	beq.n	8016b68 <TIM_Base_SetConfig+0xdc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8016b56:	68fb      	ldr	r3, [r7, #12]
 8016b58:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8016b5c:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8016b5e:	683b      	ldr	r3, [r7, #0]
 8016b60:	68db      	ldr	r3, [r3, #12]
 8016b62:	68fa      	ldr	r2, [r7, #12]
 8016b64:	4313      	orrs	r3, r2
 8016b66:	60fb      	str	r3, [r7, #12]
  }

  TIMx->CR1 = tmpcr1;
 8016b68:	687b      	ldr	r3, [r7, #4]
 8016b6a:	68fa      	ldr	r2, [r7, #12]
 8016b6c:	601a      	str	r2, [r3, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8016b6e:	683b      	ldr	r3, [r7, #0]
 8016b70:	689a      	ldr	r2, [r3, #8]
 8016b72:	687b      	ldr	r3, [r7, #4]
 8016b74:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8016b76:	683b      	ldr	r3, [r7, #0]
 8016b78:	681a      	ldr	r2, [r3, #0]
 8016b7a:	687b      	ldr	r3, [r7, #4]
 8016b7c:	629a      	str	r2, [r3, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 8016b7e:	687b      	ldr	r3, [r7, #4]
 8016b80:	4a0c      	ldr	r2, [pc, #48]	; (8016bb4 <TIM_Base_SetConfig+0x128>)
 8016b82:	4293      	cmp	r3, r2
 8016b84:	d003      	beq.n	8016b8e <TIM_Base_SetConfig+0x102>
 8016b86:	687b      	ldr	r3, [r7, #4]
 8016b88:	4a0e      	ldr	r2, [pc, #56]	; (8016bc4 <TIM_Base_SetConfig+0x138>)
 8016b8a:	4293      	cmp	r3, r2
 8016b8c:	d101      	bne.n	8016b92 <TIM_Base_SetConfig+0x106>
 8016b8e:	2301      	movs	r3, #1
 8016b90:	e000      	b.n	8016b94 <TIM_Base_SetConfig+0x108>
 8016b92:	2300      	movs	r3, #0
 8016b94:	2b00      	cmp	r3, #0
 8016b96:	d003      	beq.n	8016ba0 <TIM_Base_SetConfig+0x114>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8016b98:	683b      	ldr	r3, [r7, #0]
 8016b9a:	691a      	ldr	r2, [r3, #16]
 8016b9c:	687b      	ldr	r3, [r7, #4]
 8016b9e:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8016ba0:	687b      	ldr	r3, [r7, #4]
 8016ba2:	2201      	movs	r2, #1
 8016ba4:	615a      	str	r2, [r3, #20]
}
 8016ba6:	bf00      	nop
 8016ba8:	3714      	adds	r7, #20
 8016baa:	46bd      	mov	sp, r7
 8016bac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016bb0:	4770      	bx	lr
 8016bb2:	bf00      	nop
 8016bb4:	40010000 	.word	0x40010000
 8016bb8:	40000400 	.word	0x40000400
 8016bbc:	40000800 	.word	0x40000800
 8016bc0:	40000c00 	.word	0x40000c00
 8016bc4:	40010400 	.word	0x40010400
 8016bc8:	40014000 	.word	0x40014000
 8016bcc:	40014400 	.word	0x40014400
 8016bd0:	40014800 	.word	0x40014800
 8016bd4:	40001800 	.word	0x40001800
 8016bd8:	40001c00 	.word	0x40001c00
 8016bdc:	40002000 	.word	0x40002000

08016be0 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8016be0:	b480      	push	{r7}
 8016be2:	b087      	sub	sp, #28
 8016be4:	af00      	add	r7, sp, #0
 8016be6:	6078      	str	r0, [r7, #4]
 8016be8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0U;
 8016bea:	2300      	movs	r3, #0
 8016bec:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0U;
 8016bee:	2300      	movs	r3, #0
 8016bf0:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0U;
 8016bf2:	2300      	movs	r3, #0
 8016bf4:	613b      	str	r3, [r7, #16]
   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8016bf6:	687b      	ldr	r3, [r7, #4]
 8016bf8:	6a1b      	ldr	r3, [r3, #32]
 8016bfa:	f023 0210 	bic.w	r2, r3, #16
 8016bfe:	687b      	ldr	r3, [r7, #4]
 8016c00:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8016c02:	687b      	ldr	r3, [r7, #4]
 8016c04:	6a1b      	ldr	r3, [r3, #32]
 8016c06:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8016c08:	687b      	ldr	r3, [r7, #4]
 8016c0a:	685b      	ldr	r3, [r3, #4]
 8016c0c:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8016c0e:	687b      	ldr	r3, [r7, #4]
 8016c10:	699b      	ldr	r3, [r3, #24]
 8016c12:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8016c14:	68fb      	ldr	r3, [r7, #12]
 8016c16:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016c1a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8016c1c:	68fb      	ldr	r3, [r7, #12]
 8016c1e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8016c22:	60fb      	str	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8016c24:	683b      	ldr	r3, [r7, #0]
 8016c26:	681b      	ldr	r3, [r3, #0]
 8016c28:	021b      	lsls	r3, r3, #8
 8016c2a:	68fa      	ldr	r2, [r7, #12]
 8016c2c:	4313      	orrs	r3, r2
 8016c2e:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8016c30:	697b      	ldr	r3, [r7, #20]
 8016c32:	f023 0320 	bic.w	r3, r3, #32
 8016c36:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8016c38:	683b      	ldr	r3, [r7, #0]
 8016c3a:	689b      	ldr	r3, [r3, #8]
 8016c3c:	011b      	lsls	r3, r3, #4
 8016c3e:	697a      	ldr	r2, [r7, #20]
 8016c40:	4313      	orrs	r3, r2
 8016c42:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8016c44:	687b      	ldr	r3, [r7, #4]
 8016c46:	4a20      	ldr	r2, [pc, #128]	; (8016cc8 <TIM_OC2_SetConfig+0xe8>)
 8016c48:	4293      	cmp	r3, r2
 8016c4a:	d003      	beq.n	8016c54 <TIM_OC2_SetConfig+0x74>
 8016c4c:	687b      	ldr	r3, [r7, #4]
 8016c4e:	4a1f      	ldr	r2, [pc, #124]	; (8016ccc <TIM_OC2_SetConfig+0xec>)
 8016c50:	4293      	cmp	r3, r2
 8016c52:	d101      	bne.n	8016c58 <TIM_OC2_SetConfig+0x78>
 8016c54:	2301      	movs	r3, #1
 8016c56:	e000      	b.n	8016c5a <TIM_OC2_SetConfig+0x7a>
 8016c58:	2300      	movs	r3, #0
 8016c5a:	2b00      	cmp	r3, #0
 8016c5c:	d021      	beq.n	8016ca2 <TIM_OC2_SetConfig+0xc2>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8016c5e:	697b      	ldr	r3, [r7, #20]
 8016c60:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8016c64:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8016c66:	683b      	ldr	r3, [r7, #0]
 8016c68:	68db      	ldr	r3, [r3, #12]
 8016c6a:	011b      	lsls	r3, r3, #4
 8016c6c:	697a      	ldr	r2, [r7, #20]
 8016c6e:	4313      	orrs	r3, r2
 8016c70:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8016c72:	697b      	ldr	r3, [r7, #20]
 8016c74:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8016c78:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8016c7a:	693b      	ldr	r3, [r7, #16]
 8016c7c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8016c80:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8016c82:	693b      	ldr	r3, [r7, #16]
 8016c84:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8016c88:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8016c8a:	683b      	ldr	r3, [r7, #0]
 8016c8c:	695b      	ldr	r3, [r3, #20]
 8016c8e:	009b      	lsls	r3, r3, #2
 8016c90:	693a      	ldr	r2, [r7, #16]
 8016c92:	4313      	orrs	r3, r2
 8016c94:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8016c96:	683b      	ldr	r3, [r7, #0]
 8016c98:	699b      	ldr	r3, [r3, #24]
 8016c9a:	009b      	lsls	r3, r3, #2
 8016c9c:	693a      	ldr	r2, [r7, #16]
 8016c9e:	4313      	orrs	r3, r2
 8016ca0:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8016ca2:	687b      	ldr	r3, [r7, #4]
 8016ca4:	693a      	ldr	r2, [r7, #16]
 8016ca6:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8016ca8:	687b      	ldr	r3, [r7, #4]
 8016caa:	68fa      	ldr	r2, [r7, #12]
 8016cac:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8016cae:	683b      	ldr	r3, [r7, #0]
 8016cb0:	685a      	ldr	r2, [r3, #4]
 8016cb2:	687b      	ldr	r3, [r7, #4]
 8016cb4:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8016cb6:	687b      	ldr	r3, [r7, #4]
 8016cb8:	697a      	ldr	r2, [r7, #20]
 8016cba:	621a      	str	r2, [r3, #32]
}
 8016cbc:	bf00      	nop
 8016cbe:	371c      	adds	r7, #28
 8016cc0:	46bd      	mov	sp, r7
 8016cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016cc6:	4770      	bx	lr
 8016cc8:	40010000 	.word	0x40010000
 8016ccc:	40010400 	.word	0x40010400

08016cd0 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8016cd0:	b480      	push	{r7}
 8016cd2:	b087      	sub	sp, #28
 8016cd4:	af00      	add	r7, sp, #0
 8016cd6:	6078      	str	r0, [r7, #4]
 8016cd8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0U;
 8016cda:	2300      	movs	r3, #0
 8016cdc:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0U;
 8016cde:	2300      	movs	r3, #0
 8016ce0:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0U;  
 8016ce2:	2300      	movs	r3, #0
 8016ce4:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8016ce6:	687b      	ldr	r3, [r7, #4]
 8016ce8:	6a1b      	ldr	r3, [r3, #32]
 8016cea:	f023 0201 	bic.w	r2, r3, #1
 8016cee:	687b      	ldr	r3, [r7, #4]
 8016cf0:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8016cf2:	687b      	ldr	r3, [r7, #4]
 8016cf4:	6a1b      	ldr	r3, [r3, #32]
 8016cf6:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8016cf8:	687b      	ldr	r3, [r7, #4]
 8016cfa:	685b      	ldr	r3, [r3, #4]
 8016cfc:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8016cfe:	687b      	ldr	r3, [r7, #4]
 8016d00:	699b      	ldr	r3, [r3, #24]
 8016d02:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8016d04:	68fb      	ldr	r3, [r7, #12]
 8016d06:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016d0a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8016d0c:	68fb      	ldr	r3, [r7, #12]
 8016d0e:	f023 0303 	bic.w	r3, r3, #3
 8016d12:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8016d14:	683b      	ldr	r3, [r7, #0]
 8016d16:	681b      	ldr	r3, [r3, #0]
 8016d18:	68fa      	ldr	r2, [r7, #12]
 8016d1a:	4313      	orrs	r3, r2
 8016d1c:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8016d1e:	697b      	ldr	r3, [r7, #20]
 8016d20:	f023 0302 	bic.w	r3, r3, #2
 8016d24:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8016d26:	683b      	ldr	r3, [r7, #0]
 8016d28:	689b      	ldr	r3, [r3, #8]
 8016d2a:	697a      	ldr	r2, [r7, #20]
 8016d2c:	4313      	orrs	r3, r2
 8016d2e:	617b      	str	r3, [r7, #20]

    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8016d30:	687b      	ldr	r3, [r7, #4]
 8016d32:	4a1f      	ldr	r2, [pc, #124]	; (8016db0 <TIM_OC1_SetConfig+0xe0>)
 8016d34:	4293      	cmp	r3, r2
 8016d36:	d003      	beq.n	8016d40 <TIM_OC1_SetConfig+0x70>
 8016d38:	687b      	ldr	r3, [r7, #4]
 8016d3a:	4a1e      	ldr	r2, [pc, #120]	; (8016db4 <TIM_OC1_SetConfig+0xe4>)
 8016d3c:	4293      	cmp	r3, r2
 8016d3e:	d101      	bne.n	8016d44 <TIM_OC1_SetConfig+0x74>
 8016d40:	2301      	movs	r3, #1
 8016d42:	e000      	b.n	8016d46 <TIM_OC1_SetConfig+0x76>
 8016d44:	2300      	movs	r3, #0
 8016d46:	2b00      	cmp	r3, #0
 8016d48:	d01e      	beq.n	8016d88 <TIM_OC1_SetConfig+0xb8>
  {   
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8016d4a:	697b      	ldr	r3, [r7, #20]
 8016d4c:	f023 0308 	bic.w	r3, r3, #8
 8016d50:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8016d52:	683b      	ldr	r3, [r7, #0]
 8016d54:	68db      	ldr	r3, [r3, #12]
 8016d56:	697a      	ldr	r2, [r7, #20]
 8016d58:	4313      	orrs	r3, r2
 8016d5a:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8016d5c:	697b      	ldr	r3, [r7, #20]
 8016d5e:	f023 0304 	bic.w	r3, r3, #4
 8016d62:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8016d64:	693b      	ldr	r3, [r7, #16]
 8016d66:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8016d6a:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8016d6c:	693b      	ldr	r3, [r7, #16]
 8016d6e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8016d72:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8016d74:	683b      	ldr	r3, [r7, #0]
 8016d76:	695b      	ldr	r3, [r3, #20]
 8016d78:	693a      	ldr	r2, [r7, #16]
 8016d7a:	4313      	orrs	r3, r2
 8016d7c:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8016d7e:	683b      	ldr	r3, [r7, #0]
 8016d80:	699b      	ldr	r3, [r3, #24]
 8016d82:	693a      	ldr	r2, [r7, #16]
 8016d84:	4313      	orrs	r3, r2
 8016d86:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8016d88:	687b      	ldr	r3, [r7, #4]
 8016d8a:	693a      	ldr	r2, [r7, #16]
 8016d8c:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8016d8e:	687b      	ldr	r3, [r7, #4]
 8016d90:	68fa      	ldr	r2, [r7, #12]
 8016d92:	619a      	str	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8016d94:	683b      	ldr	r3, [r7, #0]
 8016d96:	685a      	ldr	r2, [r3, #4]
 8016d98:	687b      	ldr	r3, [r7, #4]
 8016d9a:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;  
 8016d9c:	687b      	ldr	r3, [r7, #4]
 8016d9e:	697a      	ldr	r2, [r7, #20]
 8016da0:	621a      	str	r2, [r3, #32]
} 
 8016da2:	bf00      	nop
 8016da4:	371c      	adds	r7, #28
 8016da6:	46bd      	mov	sp, r7
 8016da8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016dac:	4770      	bx	lr
 8016dae:	bf00      	nop
 8016db0:	40010000 	.word	0x40010000
 8016db4:	40010400 	.word	0x40010400

08016db8 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8016db8:	b480      	push	{r7}
 8016dba:	b087      	sub	sp, #28
 8016dbc:	af00      	add	r7, sp, #0
 8016dbe:	6078      	str	r0, [r7, #4]
 8016dc0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0U;
 8016dc2:	2300      	movs	r3, #0
 8016dc4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpccer = 0U;
 8016dc6:	2300      	movs	r3, #0
 8016dc8:	617b      	str	r3, [r7, #20]
  uint32_t tmpcr2 = 0U;   
 8016dca:	2300      	movs	r3, #0
 8016dcc:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8016dce:	687b      	ldr	r3, [r7, #4]
 8016dd0:	6a1b      	ldr	r3, [r3, #32]
 8016dd2:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8016dd6:	687b      	ldr	r3, [r7, #4]
 8016dd8:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8016dda:	687b      	ldr	r3, [r7, #4]
 8016ddc:	6a1b      	ldr	r3, [r3, #32]
 8016dde:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8016de0:	687b      	ldr	r3, [r7, #4]
 8016de2:	685b      	ldr	r3, [r3, #4]
 8016de4:	613b      	str	r3, [r7, #16]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8016de6:	687b      	ldr	r3, [r7, #4]
 8016de8:	69db      	ldr	r3, [r3, #28]
 8016dea:	60fb      	str	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8016dec:	68fb      	ldr	r3, [r7, #12]
 8016dee:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8016df2:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;  
 8016df4:	68fb      	ldr	r3, [r7, #12]
 8016df6:	f023 0303 	bic.w	r3, r3, #3
 8016dfa:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8016dfc:	683b      	ldr	r3, [r7, #0]
 8016dfe:	681b      	ldr	r3, [r3, #0]
 8016e00:	68fa      	ldr	r2, [r7, #12]
 8016e02:	4313      	orrs	r3, r2
 8016e04:	60fb      	str	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8016e06:	697b      	ldr	r3, [r7, #20]
 8016e08:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8016e0c:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8016e0e:	683b      	ldr	r3, [r7, #0]
 8016e10:	689b      	ldr	r3, [r3, #8]
 8016e12:	021b      	lsls	r3, r3, #8
 8016e14:	697a      	ldr	r2, [r7, #20]
 8016e16:	4313      	orrs	r3, r2
 8016e18:	617b      	str	r3, [r7, #20]
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8016e1a:	687b      	ldr	r3, [r7, #4]
 8016e1c:	4a20      	ldr	r2, [pc, #128]	; (8016ea0 <TIM_OC3_SetConfig+0xe8>)
 8016e1e:	4293      	cmp	r3, r2
 8016e20:	d003      	beq.n	8016e2a <TIM_OC3_SetConfig+0x72>
 8016e22:	687b      	ldr	r3, [r7, #4]
 8016e24:	4a1f      	ldr	r2, [pc, #124]	; (8016ea4 <TIM_OC3_SetConfig+0xec>)
 8016e26:	4293      	cmp	r3, r2
 8016e28:	d101      	bne.n	8016e2e <TIM_OC3_SetConfig+0x76>
 8016e2a:	2301      	movs	r3, #1
 8016e2c:	e000      	b.n	8016e30 <TIM_OC3_SetConfig+0x78>
 8016e2e:	2300      	movs	r3, #0
 8016e30:	2b00      	cmp	r3, #0
 8016e32:	d021      	beq.n	8016e78 <TIM_OC3_SetConfig+0xc0>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8016e34:	697b      	ldr	r3, [r7, #20]
 8016e36:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8016e3a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8016e3c:	683b      	ldr	r3, [r7, #0]
 8016e3e:	68db      	ldr	r3, [r3, #12]
 8016e40:	021b      	lsls	r3, r3, #8
 8016e42:	697a      	ldr	r2, [r7, #20]
 8016e44:	4313      	orrs	r3, r2
 8016e46:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8016e48:	697b      	ldr	r3, [r7, #20]
 8016e4a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8016e4e:	617b      	str	r3, [r7, #20]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8016e50:	693b      	ldr	r3, [r7, #16]
 8016e52:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8016e56:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8016e58:	693b      	ldr	r3, [r7, #16]
 8016e5a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8016e5e:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8016e60:	683b      	ldr	r3, [r7, #0]
 8016e62:	695b      	ldr	r3, [r3, #20]
 8016e64:	011b      	lsls	r3, r3, #4
 8016e66:	693a      	ldr	r2, [r7, #16]
 8016e68:	4313      	orrs	r3, r2
 8016e6a:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8016e6c:	683b      	ldr	r3, [r7, #0]
 8016e6e:	699b      	ldr	r3, [r3, #24]
 8016e70:	011b      	lsls	r3, r3, #4
 8016e72:	693a      	ldr	r2, [r7, #16]
 8016e74:	4313      	orrs	r3, r2
 8016e76:	613b      	str	r3, [r7, #16]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8016e78:	687b      	ldr	r3, [r7, #4]
 8016e7a:	693a      	ldr	r2, [r7, #16]
 8016e7c:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8016e7e:	687b      	ldr	r3, [r7, #4]
 8016e80:	68fa      	ldr	r2, [r7, #12]
 8016e82:	61da      	str	r2, [r3, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8016e84:	683b      	ldr	r3, [r7, #0]
 8016e86:	685a      	ldr	r2, [r3, #4]
 8016e88:	687b      	ldr	r3, [r7, #4]
 8016e8a:	63da      	str	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8016e8c:	687b      	ldr	r3, [r7, #4]
 8016e8e:	697a      	ldr	r2, [r7, #20]
 8016e90:	621a      	str	r2, [r3, #32]
}
 8016e92:	bf00      	nop
 8016e94:	371c      	adds	r7, #28
 8016e96:	46bd      	mov	sp, r7
 8016e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e9c:	4770      	bx	lr
 8016e9e:	bf00      	nop
 8016ea0:	40010000 	.word	0x40010000
 8016ea4:	40010400 	.word	0x40010400

08016ea8 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config: The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8016ea8:	b480      	push	{r7}
 8016eaa:	b087      	sub	sp, #28
 8016eac:	af00      	add	r7, sp, #0
 8016eae:	6078      	str	r0, [r7, #4]
 8016eb0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx = 0U;
 8016eb2:	2300      	movs	r3, #0
 8016eb4:	613b      	str	r3, [r7, #16]
  uint32_t tmpccer = 0U;
 8016eb6:	2300      	movs	r3, #0
 8016eb8:	60fb      	str	r3, [r7, #12]
  uint32_t tmpcr2 = 0U;
 8016eba:	2300      	movs	r3, #0
 8016ebc:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8016ebe:	687b      	ldr	r3, [r7, #4]
 8016ec0:	6a1b      	ldr	r3, [r3, #32]
 8016ec2:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8016ec6:	687b      	ldr	r3, [r7, #4]
 8016ec8:	621a      	str	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8016eca:	687b      	ldr	r3, [r7, #4]
 8016ecc:	6a1b      	ldr	r3, [r3, #32]
 8016ece:	60fb      	str	r3, [r7, #12]
  /* Get the TIMx CR2 register value */
  tmpcr2 = TIMx->CR2;
 8016ed0:	687b      	ldr	r3, [r7, #4]
 8016ed2:	685b      	ldr	r3, [r3, #4]
 8016ed4:	617b      	str	r3, [r7, #20]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8016ed6:	687b      	ldr	r3, [r7, #4]
 8016ed8:	69db      	ldr	r3, [r3, #28]
 8016eda:	613b      	str	r3, [r7, #16]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8016edc:	693b      	ldr	r3, [r7, #16]
 8016ede:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8016ee2:	613b      	str	r3, [r7, #16]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8016ee4:	693b      	ldr	r3, [r7, #16]
 8016ee6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8016eea:	613b      	str	r3, [r7, #16]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8016eec:	683b      	ldr	r3, [r7, #0]
 8016eee:	681b      	ldr	r3, [r3, #0]
 8016ef0:	021b      	lsls	r3, r3, #8
 8016ef2:	693a      	ldr	r2, [r7, #16]
 8016ef4:	4313      	orrs	r3, r2
 8016ef6:	613b      	str	r3, [r7, #16]
  
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8016ef8:	68fb      	ldr	r3, [r7, #12]
 8016efa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8016efe:	60fb      	str	r3, [r7, #12]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8016f00:	683b      	ldr	r3, [r7, #0]
 8016f02:	689b      	ldr	r3, [r3, #8]
 8016f04:	031b      	lsls	r3, r3, #12
 8016f06:	68fa      	ldr	r2, [r7, #12]
 8016f08:	4313      	orrs	r3, r2
 8016f0a:	60fb      	str	r3, [r7, #12]
   
  /*if((TIMx == TIM1) || (TIMx == TIM8))*/
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
 8016f0c:	687b      	ldr	r3, [r7, #4]
 8016f0e:	4a14      	ldr	r2, [pc, #80]	; (8016f60 <TIM_OC4_SetConfig+0xb8>)
 8016f10:	4293      	cmp	r3, r2
 8016f12:	d003      	beq.n	8016f1c <TIM_OC4_SetConfig+0x74>
 8016f14:	687b      	ldr	r3, [r7, #4]
 8016f16:	4a13      	ldr	r2, [pc, #76]	; (8016f64 <TIM_OC4_SetConfig+0xbc>)
 8016f18:	4293      	cmp	r3, r2
 8016f1a:	d101      	bne.n	8016f20 <TIM_OC4_SetConfig+0x78>
 8016f1c:	2301      	movs	r3, #1
 8016f1e:	e000      	b.n	8016f22 <TIM_OC4_SetConfig+0x7a>
 8016f20:	2300      	movs	r3, #0
 8016f22:	2b00      	cmp	r3, #0
 8016f24:	d009      	beq.n	8016f3a <TIM_OC4_SetConfig+0x92>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8016f26:	697b      	ldr	r3, [r7, #20]
 8016f28:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8016f2c:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8016f2e:	683b      	ldr	r3, [r7, #0]
 8016f30:	695b      	ldr	r3, [r3, #20]
 8016f32:	019b      	lsls	r3, r3, #6
 8016f34:	697a      	ldr	r2, [r7, #20]
 8016f36:	4313      	orrs	r3, r2
 8016f38:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8016f3a:	687b      	ldr	r3, [r7, #4]
 8016f3c:	697a      	ldr	r2, [r7, #20]
 8016f3e:	605a      	str	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8016f40:	687b      	ldr	r3, [r7, #4]
 8016f42:	693a      	ldr	r2, [r7, #16]
 8016f44:	61da      	str	r2, [r3, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8016f46:	683b      	ldr	r3, [r7, #0]
 8016f48:	685a      	ldr	r2, [r3, #4]
 8016f4a:	687b      	ldr	r3, [r7, #4]
 8016f4c:	641a      	str	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8016f4e:	687b      	ldr	r3, [r7, #4]
 8016f50:	68fa      	ldr	r2, [r7, #12]
 8016f52:	621a      	str	r2, [r3, #32]
}
 8016f54:	bf00      	nop
 8016f56:	371c      	adds	r7, #28
 8016f58:	46bd      	mov	sp, r7
 8016f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016f5e:	4770      	bx	lr
 8016f60:	40010000 	.word	0x40010000
 8016f64:	40010400 	.word	0x40010400

08016f68 <HAL_TIMEx_MasterConfigSynchronization>:
  *         contains the selected trigger output (TRGO) and the Master/Slave 
  *         mode. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 8016f68:	b480      	push	{r7}
 8016f6a:	b083      	sub	sp, #12
 8016f6c:	af00      	add	r7, sp, #0
 8016f6e:	6078      	str	r0, [r7, #4]
 8016f70:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
  
  __HAL_LOCK(htim);
 8016f72:	687b      	ldr	r3, [r7, #4]
 8016f74:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8016f78:	2b01      	cmp	r3, #1
 8016f7a:	d101      	bne.n	8016f80 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8016f7c:	2302      	movs	r3, #2
 8016f7e:	e032      	b.n	8016fe6 <HAL_TIMEx_MasterConfigSynchronization+0x7e>
 8016f80:	687b      	ldr	r3, [r7, #4]
 8016f82:	2201      	movs	r2, #1
 8016f84:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  htim->State = HAL_TIM_STATE_BUSY;
 8016f88:	687b      	ldr	r3, [r7, #4]
 8016f8a:	2202      	movs	r2, #2
 8016f8c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8016f90:	687b      	ldr	r3, [r7, #4]
 8016f92:	681b      	ldr	r3, [r3, #0]
 8016f94:	685a      	ldr	r2, [r3, #4]
 8016f96:	687b      	ldr	r3, [r7, #4]
 8016f98:	681b      	ldr	r3, [r3, #0]
 8016f9a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8016f9e:	605a      	str	r2, [r3, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |= sMasterConfig->MasterOutputTrigger;
 8016fa0:	687b      	ldr	r3, [r7, #4]
 8016fa2:	681b      	ldr	r3, [r3, #0]
 8016fa4:	6859      	ldr	r1, [r3, #4]
 8016fa6:	683b      	ldr	r3, [r7, #0]
 8016fa8:	681a      	ldr	r2, [r3, #0]
 8016faa:	687b      	ldr	r3, [r7, #4]
 8016fac:	681b      	ldr	r3, [r3, #0]
 8016fae:	430a      	orrs	r2, r1
 8016fb0:	605a      	str	r2, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8016fb2:	687b      	ldr	r3, [r7, #4]
 8016fb4:	681b      	ldr	r3, [r3, #0]
 8016fb6:	689a      	ldr	r2, [r3, #8]
 8016fb8:	687b      	ldr	r3, [r7, #4]
 8016fba:	681b      	ldr	r3, [r3, #0]
 8016fbc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8016fc0:	609a      	str	r2, [r3, #8]
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8016fc2:	687b      	ldr	r3, [r7, #4]
 8016fc4:	681b      	ldr	r3, [r3, #0]
 8016fc6:	6899      	ldr	r1, [r3, #8]
 8016fc8:	683b      	ldr	r3, [r7, #0]
 8016fca:	685a      	ldr	r2, [r3, #4]
 8016fcc:	687b      	ldr	r3, [r7, #4]
 8016fce:	681b      	ldr	r3, [r3, #0]
 8016fd0:	430a      	orrs	r2, r1
 8016fd2:	609a      	str	r2, [r3, #8]
  
  htim->State = HAL_TIM_STATE_READY;
 8016fd4:	687b      	ldr	r3, [r7, #4]
 8016fd6:	2201      	movs	r2, #1
 8016fd8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  __HAL_UNLOCK(htim);
 8016fdc:	687b      	ldr	r3, [r7, #4]
 8016fde:	2200      	movs	r2, #0
 8016fe0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  
  return HAL_OK;
 8016fe4:	2300      	movs	r3, #0
} 
 8016fe6:	4618      	mov	r0, r3
 8016fe8:	370c      	adds	r7, #12
 8016fea:	46bd      	mov	sp, r7
 8016fec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016ff0:	4770      	bx	lr

08016ff2 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8016ff2:	b580      	push	{r7, lr}
 8016ff4:	b082      	sub	sp, #8
 8016ff6:	af00      	add	r7, sp, #0
 8016ff8:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if(huart == NULL)
 8016ffa:	687b      	ldr	r3, [r7, #4]
 8016ffc:	2b00      	cmp	r3, #0
 8016ffe:	d101      	bne.n	8017004 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8017000:	2301      	movs	r3, #1
 8017002:	e03f      	b.n	8017084 <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8017004:	687b      	ldr	r3, [r7, #4]
 8017006:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 801700a:	b2db      	uxtb	r3, r3
 801700c:	2b00      	cmp	r3, #0
 801700e:	d106      	bne.n	801701e <HAL_UART_Init+0x2c>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8017010:	687b      	ldr	r3, [r7, #4]
 8017012:	2200      	movs	r2, #0
 8017014:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8017018:	6878      	ldr	r0, [r7, #4]
 801701a:	f7f9 fd5f 	bl	8010adc <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;
 801701e:	687b      	ldr	r3, [r7, #4]
 8017020:	2224      	movs	r2, #36	; 0x24
 8017022:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8017026:	687b      	ldr	r3, [r7, #4]
 8017028:	681b      	ldr	r3, [r3, #0]
 801702a:	68da      	ldr	r2, [r3, #12]
 801702c:	687b      	ldr	r3, [r7, #4]
 801702e:	681b      	ldr	r3, [r3, #0]
 8017030:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8017034:	60da      	str	r2, [r3, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8017036:	6878      	ldr	r0, [r7, #4]
 8017038:	f000 f828 	bl	801708c <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 801703c:	687b      	ldr	r3, [r7, #4]
 801703e:	681b      	ldr	r3, [r3, #0]
 8017040:	691a      	ldr	r2, [r3, #16]
 8017042:	687b      	ldr	r3, [r7, #4]
 8017044:	681b      	ldr	r3, [r3, #0]
 8017046:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 801704a:	611a      	str	r2, [r3, #16]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 801704c:	687b      	ldr	r3, [r7, #4]
 801704e:	681b      	ldr	r3, [r3, #0]
 8017050:	695a      	ldr	r2, [r3, #20]
 8017052:	687b      	ldr	r3, [r7, #4]
 8017054:	681b      	ldr	r3, [r3, #0]
 8017056:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 801705a:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 801705c:	687b      	ldr	r3, [r7, #4]
 801705e:	681b      	ldr	r3, [r3, #0]
 8017060:	68da      	ldr	r2, [r3, #12]
 8017062:	687b      	ldr	r3, [r7, #4]
 8017064:	681b      	ldr	r3, [r3, #0]
 8017066:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 801706a:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 801706c:	687b      	ldr	r3, [r7, #4]
 801706e:	2200      	movs	r2, #0
 8017070:	63da      	str	r2, [r3, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8017072:	687b      	ldr	r3, [r7, #4]
 8017074:	2220      	movs	r2, #32
 8017076:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 801707a:	687b      	ldr	r3, [r7, #4]
 801707c:	2220      	movs	r2, #32
 801707e:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
  
  return HAL_OK;
 8017082:	2300      	movs	r3, #0
}
 8017084:	4618      	mov	r0, r3
 8017086:	3708      	adds	r7, #8
 8017088:	46bd      	mov	sp, r7
 801708a:	bd80      	pop	{r7, pc}

0801708c <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 801708c:	b5b0      	push	{r4, r5, r7, lr}
 801708e:	b084      	sub	sp, #16
 8017090:	af00      	add	r7, sp, #0
 8017092:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0x00U;
 8017094:	2300      	movs	r3, #0
 8017096:	60fb      	str	r3, [r7, #12]
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 8017098:	687b      	ldr	r3, [r7, #4]
 801709a:	681b      	ldr	r3, [r3, #0]
 801709c:	691b      	ldr	r3, [r3, #16]
 801709e:	60fb      	str	r3, [r7, #12]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80170a0:	68fb      	ldr	r3, [r7, #12]
 80170a2:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80170a6:	60fb      	str	r3, [r7, #12]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80170a8:	687b      	ldr	r3, [r7, #4]
 80170aa:	68db      	ldr	r3, [r3, #12]
 80170ac:	68fa      	ldr	r2, [r7, #12]
 80170ae:	4313      	orrs	r3, r2
 80170b0:	60fb      	str	r3, [r7, #12]
  
  /* Write to USART CR2 */
  huart->Instance->CR2 = (uint32_t)tmpreg;
 80170b2:	687b      	ldr	r3, [r7, #4]
 80170b4:	681b      	ldr	r3, [r3, #0]
 80170b6:	68fa      	ldr	r2, [r7, #12]
 80170b8:	611a      	str	r2, [r3, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 80170ba:	687b      	ldr	r3, [r7, #4]
 80170bc:	681b      	ldr	r3, [r3, #0]
 80170be:	68db      	ldr	r3, [r3, #12]
 80170c0:	60fb      	str	r3, [r7, #12]

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80170c2:	68fb      	ldr	r3, [r7, #12]
 80170c4:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 80170c8:	f023 030c 	bic.w	r3, r3, #12
 80170cc:	60fb      	str	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80170ce:	687b      	ldr	r3, [r7, #4]
 80170d0:	689a      	ldr	r2, [r3, #8]
 80170d2:	687b      	ldr	r3, [r7, #4]
 80170d4:	691b      	ldr	r3, [r3, #16]
 80170d6:	431a      	orrs	r2, r3
 80170d8:	687b      	ldr	r3, [r7, #4]
 80170da:	695b      	ldr	r3, [r3, #20]
 80170dc:	431a      	orrs	r2, r3
 80170de:	687b      	ldr	r3, [r7, #4]
 80170e0:	69db      	ldr	r3, [r3, #28]
 80170e2:	4313      	orrs	r3, r2
 80170e4:	68fa      	ldr	r2, [r7, #12]
 80170e6:	4313      	orrs	r3, r2
 80170e8:	60fb      	str	r3, [r7, #12]
  
  /* Write to USART CR1 */
  huart->Instance->CR1 = (uint32_t)tmpreg;
 80170ea:	687b      	ldr	r3, [r7, #4]
 80170ec:	681b      	ldr	r3, [r3, #0]
 80170ee:	68fa      	ldr	r2, [r7, #12]
 80170f0:	60da      	str	r2, [r3, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 80170f2:	687b      	ldr	r3, [r7, #4]
 80170f4:	681b      	ldr	r3, [r3, #0]
 80170f6:	695b      	ldr	r3, [r3, #20]
 80170f8:	60fb      	str	r3, [r7, #12]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80170fa:	68fb      	ldr	r3, [r7, #12]
 80170fc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8017100:	60fb      	str	r3, [r7, #12]
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 8017102:	687b      	ldr	r3, [r7, #4]
 8017104:	699b      	ldr	r3, [r3, #24]
 8017106:	68fa      	ldr	r2, [r7, #12]
 8017108:	4313      	orrs	r3, r2
 801710a:	60fb      	str	r3, [r7, #12]
  
  /* Write to USART CR3 */
  huart->Instance->CR3 = (uint32_t)tmpreg;
 801710c:	687b      	ldr	r3, [r7, #4]
 801710e:	681b      	ldr	r3, [r3, #0]
 8017110:	68fa      	ldr	r2, [r7, #12]
 8017112:	615a      	str	r2, [r3, #20]
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8017114:	687b      	ldr	r3, [r7, #4]
 8017116:	69db      	ldr	r3, [r3, #28]
 8017118:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 801711c:	f040 80e4 	bne.w	80172e8 <UART_SetConfig+0x25c>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8017120:	687b      	ldr	r3, [r7, #4]
 8017122:	681b      	ldr	r3, [r3, #0]
 8017124:	4aab      	ldr	r2, [pc, #684]	; (80173d4 <UART_SetConfig+0x348>)
 8017126:	4293      	cmp	r3, r2
 8017128:	d004      	beq.n	8017134 <UART_SetConfig+0xa8>
 801712a:	687b      	ldr	r3, [r7, #4]
 801712c:	681b      	ldr	r3, [r3, #0]
 801712e:	4aaa      	ldr	r2, [pc, #680]	; (80173d8 <UART_SetConfig+0x34c>)
 8017130:	4293      	cmp	r3, r2
 8017132:	d16c      	bne.n	801720e <UART_SetConfig+0x182>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8017134:	f7fd fafe 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8017138:	4602      	mov	r2, r0
 801713a:	4613      	mov	r3, r2
 801713c:	009b      	lsls	r3, r3, #2
 801713e:	4413      	add	r3, r2
 8017140:	009a      	lsls	r2, r3, #2
 8017142:	441a      	add	r2, r3
 8017144:	687b      	ldr	r3, [r7, #4]
 8017146:	685b      	ldr	r3, [r3, #4]
 8017148:	005b      	lsls	r3, r3, #1
 801714a:	fbb2 f3f3 	udiv	r3, r2, r3
 801714e:	4aa3      	ldr	r2, [pc, #652]	; (80173dc <UART_SetConfig+0x350>)
 8017150:	fba2 2303 	umull	r2, r3, r2, r3
 8017154:	095b      	lsrs	r3, r3, #5
 8017156:	011c      	lsls	r4, r3, #4
 8017158:	f7fd faec 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 801715c:	4602      	mov	r2, r0
 801715e:	4613      	mov	r3, r2
 8017160:	009b      	lsls	r3, r3, #2
 8017162:	4413      	add	r3, r2
 8017164:	009a      	lsls	r2, r3, #2
 8017166:	441a      	add	r2, r3
 8017168:	687b      	ldr	r3, [r7, #4]
 801716a:	685b      	ldr	r3, [r3, #4]
 801716c:	005b      	lsls	r3, r3, #1
 801716e:	fbb2 f5f3 	udiv	r5, r2, r3
 8017172:	f7fd fadf 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8017176:	4602      	mov	r2, r0
 8017178:	4613      	mov	r3, r2
 801717a:	009b      	lsls	r3, r3, #2
 801717c:	4413      	add	r3, r2
 801717e:	009a      	lsls	r2, r3, #2
 8017180:	441a      	add	r2, r3
 8017182:	687b      	ldr	r3, [r7, #4]
 8017184:	685b      	ldr	r3, [r3, #4]
 8017186:	005b      	lsls	r3, r3, #1
 8017188:	fbb2 f3f3 	udiv	r3, r2, r3
 801718c:	4a93      	ldr	r2, [pc, #588]	; (80173dc <UART_SetConfig+0x350>)
 801718e:	fba2 2303 	umull	r2, r3, r2, r3
 8017192:	095b      	lsrs	r3, r3, #5
 8017194:	2264      	movs	r2, #100	; 0x64
 8017196:	fb02 f303 	mul.w	r3, r2, r3
 801719a:	1aeb      	subs	r3, r5, r3
 801719c:	00db      	lsls	r3, r3, #3
 801719e:	3332      	adds	r3, #50	; 0x32
 80171a0:	4a8e      	ldr	r2, [pc, #568]	; (80173dc <UART_SetConfig+0x350>)
 80171a2:	fba2 2303 	umull	r2, r3, r2, r3
 80171a6:	095b      	lsrs	r3, r3, #5
 80171a8:	005b      	lsls	r3, r3, #1
 80171aa:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 80171ae:	441c      	add	r4, r3
 80171b0:	f7fd fac0 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 80171b4:	4602      	mov	r2, r0
 80171b6:	4613      	mov	r3, r2
 80171b8:	009b      	lsls	r3, r3, #2
 80171ba:	4413      	add	r3, r2
 80171bc:	009a      	lsls	r2, r3, #2
 80171be:	441a      	add	r2, r3
 80171c0:	687b      	ldr	r3, [r7, #4]
 80171c2:	685b      	ldr	r3, [r3, #4]
 80171c4:	005b      	lsls	r3, r3, #1
 80171c6:	fbb2 f5f3 	udiv	r5, r2, r3
 80171ca:	f7fd fab3 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 80171ce:	4602      	mov	r2, r0
 80171d0:	4613      	mov	r3, r2
 80171d2:	009b      	lsls	r3, r3, #2
 80171d4:	4413      	add	r3, r2
 80171d6:	009a      	lsls	r2, r3, #2
 80171d8:	441a      	add	r2, r3
 80171da:	687b      	ldr	r3, [r7, #4]
 80171dc:	685b      	ldr	r3, [r3, #4]
 80171de:	005b      	lsls	r3, r3, #1
 80171e0:	fbb2 f3f3 	udiv	r3, r2, r3
 80171e4:	4a7d      	ldr	r2, [pc, #500]	; (80173dc <UART_SetConfig+0x350>)
 80171e6:	fba2 2303 	umull	r2, r3, r2, r3
 80171ea:	095b      	lsrs	r3, r3, #5
 80171ec:	2264      	movs	r2, #100	; 0x64
 80171ee:	fb02 f303 	mul.w	r3, r2, r3
 80171f2:	1aeb      	subs	r3, r5, r3
 80171f4:	00db      	lsls	r3, r3, #3
 80171f6:	3332      	adds	r3, #50	; 0x32
 80171f8:	4a78      	ldr	r2, [pc, #480]	; (80173dc <UART_SetConfig+0x350>)
 80171fa:	fba2 2303 	umull	r2, r3, r2, r3
 80171fe:	095b      	lsrs	r3, r3, #5
 8017200:	f003 0207 	and.w	r2, r3, #7
 8017204:	687b      	ldr	r3, [r7, #4]
 8017206:	681b      	ldr	r3, [r3, #0]
 8017208:	4422      	add	r2, r4
 801720a:	609a      	str	r2, [r3, #8]
 801720c:	e154      	b.n	80174b8 <UART_SetConfig+0x42c>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 801720e:	f7fd fa6f 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017212:	4602      	mov	r2, r0
 8017214:	4613      	mov	r3, r2
 8017216:	009b      	lsls	r3, r3, #2
 8017218:	4413      	add	r3, r2
 801721a:	009a      	lsls	r2, r3, #2
 801721c:	441a      	add	r2, r3
 801721e:	687b      	ldr	r3, [r7, #4]
 8017220:	685b      	ldr	r3, [r3, #4]
 8017222:	005b      	lsls	r3, r3, #1
 8017224:	fbb2 f3f3 	udiv	r3, r2, r3
 8017228:	4a6c      	ldr	r2, [pc, #432]	; (80173dc <UART_SetConfig+0x350>)
 801722a:	fba2 2303 	umull	r2, r3, r2, r3
 801722e:	095b      	lsrs	r3, r3, #5
 8017230:	011c      	lsls	r4, r3, #4
 8017232:	f7fd fa5d 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017236:	4602      	mov	r2, r0
 8017238:	4613      	mov	r3, r2
 801723a:	009b      	lsls	r3, r3, #2
 801723c:	4413      	add	r3, r2
 801723e:	009a      	lsls	r2, r3, #2
 8017240:	441a      	add	r2, r3
 8017242:	687b      	ldr	r3, [r7, #4]
 8017244:	685b      	ldr	r3, [r3, #4]
 8017246:	005b      	lsls	r3, r3, #1
 8017248:	fbb2 f5f3 	udiv	r5, r2, r3
 801724c:	f7fd fa50 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017250:	4602      	mov	r2, r0
 8017252:	4613      	mov	r3, r2
 8017254:	009b      	lsls	r3, r3, #2
 8017256:	4413      	add	r3, r2
 8017258:	009a      	lsls	r2, r3, #2
 801725a:	441a      	add	r2, r3
 801725c:	687b      	ldr	r3, [r7, #4]
 801725e:	685b      	ldr	r3, [r3, #4]
 8017260:	005b      	lsls	r3, r3, #1
 8017262:	fbb2 f3f3 	udiv	r3, r2, r3
 8017266:	4a5d      	ldr	r2, [pc, #372]	; (80173dc <UART_SetConfig+0x350>)
 8017268:	fba2 2303 	umull	r2, r3, r2, r3
 801726c:	095b      	lsrs	r3, r3, #5
 801726e:	2264      	movs	r2, #100	; 0x64
 8017270:	fb02 f303 	mul.w	r3, r2, r3
 8017274:	1aeb      	subs	r3, r5, r3
 8017276:	00db      	lsls	r3, r3, #3
 8017278:	3332      	adds	r3, #50	; 0x32
 801727a:	4a58      	ldr	r2, [pc, #352]	; (80173dc <UART_SetConfig+0x350>)
 801727c:	fba2 2303 	umull	r2, r3, r2, r3
 8017280:	095b      	lsrs	r3, r3, #5
 8017282:	005b      	lsls	r3, r3, #1
 8017284:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 8017288:	441c      	add	r4, r3
 801728a:	f7fd fa31 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 801728e:	4602      	mov	r2, r0
 8017290:	4613      	mov	r3, r2
 8017292:	009b      	lsls	r3, r3, #2
 8017294:	4413      	add	r3, r2
 8017296:	009a      	lsls	r2, r3, #2
 8017298:	441a      	add	r2, r3
 801729a:	687b      	ldr	r3, [r7, #4]
 801729c:	685b      	ldr	r3, [r3, #4]
 801729e:	005b      	lsls	r3, r3, #1
 80172a0:	fbb2 f5f3 	udiv	r5, r2, r3
 80172a4:	f7fd fa24 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 80172a8:	4602      	mov	r2, r0
 80172aa:	4613      	mov	r3, r2
 80172ac:	009b      	lsls	r3, r3, #2
 80172ae:	4413      	add	r3, r2
 80172b0:	009a      	lsls	r2, r3, #2
 80172b2:	441a      	add	r2, r3
 80172b4:	687b      	ldr	r3, [r7, #4]
 80172b6:	685b      	ldr	r3, [r3, #4]
 80172b8:	005b      	lsls	r3, r3, #1
 80172ba:	fbb2 f3f3 	udiv	r3, r2, r3
 80172be:	4a47      	ldr	r2, [pc, #284]	; (80173dc <UART_SetConfig+0x350>)
 80172c0:	fba2 2303 	umull	r2, r3, r2, r3
 80172c4:	095b      	lsrs	r3, r3, #5
 80172c6:	2264      	movs	r2, #100	; 0x64
 80172c8:	fb02 f303 	mul.w	r3, r2, r3
 80172cc:	1aeb      	subs	r3, r5, r3
 80172ce:	00db      	lsls	r3, r3, #3
 80172d0:	3332      	adds	r3, #50	; 0x32
 80172d2:	4a42      	ldr	r2, [pc, #264]	; (80173dc <UART_SetConfig+0x350>)
 80172d4:	fba2 2303 	umull	r2, r3, r2, r3
 80172d8:	095b      	lsrs	r3, r3, #5
 80172da:	f003 0207 	and.w	r2, r3, #7
 80172de:	687b      	ldr	r3, [r7, #4]
 80172e0:	681b      	ldr	r3, [r3, #0]
 80172e2:	4422      	add	r2, r4
 80172e4:	609a      	str	r2, [r3, #8]
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
    }
  }
}
 80172e6:	e0e7      	b.n	80174b8 <UART_SetConfig+0x42c>
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80172e8:	687b      	ldr	r3, [r7, #4]
 80172ea:	681b      	ldr	r3, [r3, #0]
 80172ec:	4a39      	ldr	r2, [pc, #228]	; (80173d4 <UART_SetConfig+0x348>)
 80172ee:	4293      	cmp	r3, r2
 80172f0:	d004      	beq.n	80172fc <UART_SetConfig+0x270>
 80172f2:	687b      	ldr	r3, [r7, #4]
 80172f4:	681b      	ldr	r3, [r3, #0]
 80172f6:	4a38      	ldr	r2, [pc, #224]	; (80173d8 <UART_SetConfig+0x34c>)
 80172f8:	4293      	cmp	r3, r2
 80172fa:	d171      	bne.n	80173e0 <UART_SetConfig+0x354>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80172fc:	f7fd fa1a 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8017300:	4602      	mov	r2, r0
 8017302:	4613      	mov	r3, r2
 8017304:	009b      	lsls	r3, r3, #2
 8017306:	4413      	add	r3, r2
 8017308:	009a      	lsls	r2, r3, #2
 801730a:	441a      	add	r2, r3
 801730c:	687b      	ldr	r3, [r7, #4]
 801730e:	685b      	ldr	r3, [r3, #4]
 8017310:	009b      	lsls	r3, r3, #2
 8017312:	fbb2 f3f3 	udiv	r3, r2, r3
 8017316:	4a31      	ldr	r2, [pc, #196]	; (80173dc <UART_SetConfig+0x350>)
 8017318:	fba2 2303 	umull	r2, r3, r2, r3
 801731c:	095b      	lsrs	r3, r3, #5
 801731e:	011c      	lsls	r4, r3, #4
 8017320:	f7fd fa08 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8017324:	4602      	mov	r2, r0
 8017326:	4613      	mov	r3, r2
 8017328:	009b      	lsls	r3, r3, #2
 801732a:	4413      	add	r3, r2
 801732c:	009a      	lsls	r2, r3, #2
 801732e:	441a      	add	r2, r3
 8017330:	687b      	ldr	r3, [r7, #4]
 8017332:	685b      	ldr	r3, [r3, #4]
 8017334:	009b      	lsls	r3, r3, #2
 8017336:	fbb2 f5f3 	udiv	r5, r2, r3
 801733a:	f7fd f9fb 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 801733e:	4602      	mov	r2, r0
 8017340:	4613      	mov	r3, r2
 8017342:	009b      	lsls	r3, r3, #2
 8017344:	4413      	add	r3, r2
 8017346:	009a      	lsls	r2, r3, #2
 8017348:	441a      	add	r2, r3
 801734a:	687b      	ldr	r3, [r7, #4]
 801734c:	685b      	ldr	r3, [r3, #4]
 801734e:	009b      	lsls	r3, r3, #2
 8017350:	fbb2 f3f3 	udiv	r3, r2, r3
 8017354:	4a21      	ldr	r2, [pc, #132]	; (80173dc <UART_SetConfig+0x350>)
 8017356:	fba2 2303 	umull	r2, r3, r2, r3
 801735a:	095b      	lsrs	r3, r3, #5
 801735c:	2264      	movs	r2, #100	; 0x64
 801735e:	fb02 f303 	mul.w	r3, r2, r3
 8017362:	1aeb      	subs	r3, r5, r3
 8017364:	011b      	lsls	r3, r3, #4
 8017366:	3332      	adds	r3, #50	; 0x32
 8017368:	4a1c      	ldr	r2, [pc, #112]	; (80173dc <UART_SetConfig+0x350>)
 801736a:	fba2 2303 	umull	r2, r3, r2, r3
 801736e:	095b      	lsrs	r3, r3, #5
 8017370:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8017374:	441c      	add	r4, r3
 8017376:	f7fd f9dd 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 801737a:	4602      	mov	r2, r0
 801737c:	4613      	mov	r3, r2
 801737e:	009b      	lsls	r3, r3, #2
 8017380:	4413      	add	r3, r2
 8017382:	009a      	lsls	r2, r3, #2
 8017384:	441a      	add	r2, r3
 8017386:	687b      	ldr	r3, [r7, #4]
 8017388:	685b      	ldr	r3, [r3, #4]
 801738a:	009b      	lsls	r3, r3, #2
 801738c:	fbb2 f5f3 	udiv	r5, r2, r3
 8017390:	f7fd f9d0 	bl	8014734 <HAL_RCC_GetPCLK2Freq>
 8017394:	4602      	mov	r2, r0
 8017396:	4613      	mov	r3, r2
 8017398:	009b      	lsls	r3, r3, #2
 801739a:	4413      	add	r3, r2
 801739c:	009a      	lsls	r2, r3, #2
 801739e:	441a      	add	r2, r3
 80173a0:	687b      	ldr	r3, [r7, #4]
 80173a2:	685b      	ldr	r3, [r3, #4]
 80173a4:	009b      	lsls	r3, r3, #2
 80173a6:	fbb2 f3f3 	udiv	r3, r2, r3
 80173aa:	4a0c      	ldr	r2, [pc, #48]	; (80173dc <UART_SetConfig+0x350>)
 80173ac:	fba2 2303 	umull	r2, r3, r2, r3
 80173b0:	095b      	lsrs	r3, r3, #5
 80173b2:	2264      	movs	r2, #100	; 0x64
 80173b4:	fb02 f303 	mul.w	r3, r2, r3
 80173b8:	1aeb      	subs	r3, r5, r3
 80173ba:	011b      	lsls	r3, r3, #4
 80173bc:	3332      	adds	r3, #50	; 0x32
 80173be:	4a07      	ldr	r2, [pc, #28]	; (80173dc <UART_SetConfig+0x350>)
 80173c0:	fba2 2303 	umull	r2, r3, r2, r3
 80173c4:	095b      	lsrs	r3, r3, #5
 80173c6:	f003 020f 	and.w	r2, r3, #15
 80173ca:	687b      	ldr	r3, [r7, #4]
 80173cc:	681b      	ldr	r3, [r3, #0]
 80173ce:	4422      	add	r2, r4
 80173d0:	609a      	str	r2, [r3, #8]
 80173d2:	e071      	b.n	80174b8 <UART_SetConfig+0x42c>
 80173d4:	40011000 	.word	0x40011000
 80173d8:	40011400 	.word	0x40011400
 80173dc:	51eb851f 	.word	0x51eb851f
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 80173e0:	f7fd f986 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 80173e4:	4602      	mov	r2, r0
 80173e6:	4613      	mov	r3, r2
 80173e8:	009b      	lsls	r3, r3, #2
 80173ea:	4413      	add	r3, r2
 80173ec:	009a      	lsls	r2, r3, #2
 80173ee:	441a      	add	r2, r3
 80173f0:	687b      	ldr	r3, [r7, #4]
 80173f2:	685b      	ldr	r3, [r3, #4]
 80173f4:	009b      	lsls	r3, r3, #2
 80173f6:	fbb2 f3f3 	udiv	r3, r2, r3
 80173fa:	4a31      	ldr	r2, [pc, #196]	; (80174c0 <UART_SetConfig+0x434>)
 80173fc:	fba2 2303 	umull	r2, r3, r2, r3
 8017400:	095b      	lsrs	r3, r3, #5
 8017402:	011c      	lsls	r4, r3, #4
 8017404:	f7fd f974 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017408:	4602      	mov	r2, r0
 801740a:	4613      	mov	r3, r2
 801740c:	009b      	lsls	r3, r3, #2
 801740e:	4413      	add	r3, r2
 8017410:	009a      	lsls	r2, r3, #2
 8017412:	441a      	add	r2, r3
 8017414:	687b      	ldr	r3, [r7, #4]
 8017416:	685b      	ldr	r3, [r3, #4]
 8017418:	009b      	lsls	r3, r3, #2
 801741a:	fbb2 f5f3 	udiv	r5, r2, r3
 801741e:	f7fd f967 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017422:	4602      	mov	r2, r0
 8017424:	4613      	mov	r3, r2
 8017426:	009b      	lsls	r3, r3, #2
 8017428:	4413      	add	r3, r2
 801742a:	009a      	lsls	r2, r3, #2
 801742c:	441a      	add	r2, r3
 801742e:	687b      	ldr	r3, [r7, #4]
 8017430:	685b      	ldr	r3, [r3, #4]
 8017432:	009b      	lsls	r3, r3, #2
 8017434:	fbb2 f3f3 	udiv	r3, r2, r3
 8017438:	4a21      	ldr	r2, [pc, #132]	; (80174c0 <UART_SetConfig+0x434>)
 801743a:	fba2 2303 	umull	r2, r3, r2, r3
 801743e:	095b      	lsrs	r3, r3, #5
 8017440:	2264      	movs	r2, #100	; 0x64
 8017442:	fb02 f303 	mul.w	r3, r2, r3
 8017446:	1aeb      	subs	r3, r5, r3
 8017448:	011b      	lsls	r3, r3, #4
 801744a:	3332      	adds	r3, #50	; 0x32
 801744c:	4a1c      	ldr	r2, [pc, #112]	; (80174c0 <UART_SetConfig+0x434>)
 801744e:	fba2 2303 	umull	r2, r3, r2, r3
 8017452:	095b      	lsrs	r3, r3, #5
 8017454:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8017458:	441c      	add	r4, r3
 801745a:	f7fd f949 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 801745e:	4602      	mov	r2, r0
 8017460:	4613      	mov	r3, r2
 8017462:	009b      	lsls	r3, r3, #2
 8017464:	4413      	add	r3, r2
 8017466:	009a      	lsls	r2, r3, #2
 8017468:	441a      	add	r2, r3
 801746a:	687b      	ldr	r3, [r7, #4]
 801746c:	685b      	ldr	r3, [r3, #4]
 801746e:	009b      	lsls	r3, r3, #2
 8017470:	fbb2 f5f3 	udiv	r5, r2, r3
 8017474:	f7fd f93c 	bl	80146f0 <HAL_RCC_GetPCLK1Freq>
 8017478:	4602      	mov	r2, r0
 801747a:	4613      	mov	r3, r2
 801747c:	009b      	lsls	r3, r3, #2
 801747e:	4413      	add	r3, r2
 8017480:	009a      	lsls	r2, r3, #2
 8017482:	441a      	add	r2, r3
 8017484:	687b      	ldr	r3, [r7, #4]
 8017486:	685b      	ldr	r3, [r3, #4]
 8017488:	009b      	lsls	r3, r3, #2
 801748a:	fbb2 f3f3 	udiv	r3, r2, r3
 801748e:	4a0c      	ldr	r2, [pc, #48]	; (80174c0 <UART_SetConfig+0x434>)
 8017490:	fba2 2303 	umull	r2, r3, r2, r3
 8017494:	095b      	lsrs	r3, r3, #5
 8017496:	2264      	movs	r2, #100	; 0x64
 8017498:	fb02 f303 	mul.w	r3, r2, r3
 801749c:	1aeb      	subs	r3, r5, r3
 801749e:	011b      	lsls	r3, r3, #4
 80174a0:	3332      	adds	r3, #50	; 0x32
 80174a2:	4a07      	ldr	r2, [pc, #28]	; (80174c0 <UART_SetConfig+0x434>)
 80174a4:	fba2 2303 	umull	r2, r3, r2, r3
 80174a8:	095b      	lsrs	r3, r3, #5
 80174aa:	f003 020f 	and.w	r2, r3, #15
 80174ae:	687b      	ldr	r3, [r7, #4]
 80174b0:	681b      	ldr	r3, [r3, #0]
 80174b2:	4422      	add	r2, r4
 80174b4:	609a      	str	r2, [r3, #8]
}
 80174b6:	e7ff      	b.n	80174b8 <UART_SetConfig+0x42c>
 80174b8:	bf00      	nop
 80174ba:	3710      	adds	r7, #16
 80174bc:	46bd      	mov	sp, r7
 80174be:	bdb0      	pop	{r4, r5, r7, pc}
 80174c0:	51eb851f 	.word	0x51eb851f

080174c4 <FMC_NORSRAM_Init>:
  * @param  Device: Pointer to NORSRAM device instance
  * @param  Init: Pointer to NORSRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_InitTypeDef* Init)
{ 
 80174c4:	b480      	push	{r7}
 80174c6:	b085      	sub	sp, #20
 80174c8:	af00      	add	r7, sp, #0
 80174ca:	6078      	str	r0, [r7, #4]
 80174cc:	6039      	str	r1, [r7, #0]
  uint32_t tmpr = 0U;
 80174ce:	2300      	movs	r3, #0
 80174d0:	60fb      	str	r3, [r7, #12]
#if defined (STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
  assert_param(IS_FMC_WRITE_FIFO(Init->WriteFifo));
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */

  /* Get the BTCR register value */
  tmpr = Device->BTCR[Init->NSBank];
 80174d2:	683b      	ldr	r3, [r7, #0]
 80174d4:	681a      	ldr	r2, [r3, #0]
 80174d6:	687b      	ldr	r3, [r7, #4]
 80174d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80174dc:	60fb      	str	r3, [r7, #12]

#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
  /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
           WAITEN, EXTMOD, ASYNCWAIT, CPSIZE, CBURSTRW and CCLKEN bits */
  tmpr &= ((uint32_t)~(FMC_BCR1_MBKEN     | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
 80174de:	68fa      	ldr	r2, [r7, #12]
 80174e0:	4b29      	ldr	r3, [pc, #164]	; (8017588 <FMC_NORSRAM_Init+0xc4>)
 80174e2:	4013      	ands	r3, r2
 80174e4:	60fb      	str	r3, [r7, #12]
                       FMC_BCR1_WREN      | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
                       FMC_BCR1_ASYNCWAIT | FMC_BCR1_CPSIZE   | FMC_BCR1_CBURSTRW | \
                       FMC_BCR1_CCLKEN));
  
  /* Set NORSRAM device control parameters */
  tmpr |= (uint32_t)(Init->DataAddressMux       |\
 80174e6:	683b      	ldr	r3, [r7, #0]
 80174e8:	685a      	ldr	r2, [r3, #4]
                    Init->MemoryType           |\
 80174ea:	683b      	ldr	r3, [r7, #0]
 80174ec:	689b      	ldr	r3, [r3, #8]
  tmpr |= (uint32_t)(Init->DataAddressMux       |\
 80174ee:	431a      	orrs	r2, r3
                    Init->MemoryDataWidth      |\
 80174f0:	683b      	ldr	r3, [r7, #0]
 80174f2:	68db      	ldr	r3, [r3, #12]
                    Init->MemoryType           |\
 80174f4:	431a      	orrs	r2, r3
                    Init->BurstAccessMode      |\
 80174f6:	683b      	ldr	r3, [r7, #0]
 80174f8:	691b      	ldr	r3, [r3, #16]
                    Init->MemoryDataWidth      |\
 80174fa:	431a      	orrs	r2, r3
                    Init->WaitSignalPolarity   |\
 80174fc:	683b      	ldr	r3, [r7, #0]
 80174fe:	695b      	ldr	r3, [r3, #20]
                    Init->BurstAccessMode      |\
 8017500:	431a      	orrs	r2, r3
                    Init->WrapMode             |\
 8017502:	683b      	ldr	r3, [r7, #0]
 8017504:	699b      	ldr	r3, [r3, #24]
                    Init->WaitSignalPolarity   |\
 8017506:	431a      	orrs	r2, r3
                    Init->WaitSignalActive     |\
 8017508:	683b      	ldr	r3, [r7, #0]
 801750a:	69db      	ldr	r3, [r3, #28]
                    Init->WrapMode             |\
 801750c:	431a      	orrs	r2, r3
                    Init->WriteOperation       |\
 801750e:	683b      	ldr	r3, [r7, #0]
 8017510:	6a1b      	ldr	r3, [r3, #32]
                    Init->WaitSignalActive     |\
 8017512:	431a      	orrs	r2, r3
                    Init->WaitSignal           |\
 8017514:	683b      	ldr	r3, [r7, #0]
 8017516:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                    Init->WriteOperation       |\
 8017518:	431a      	orrs	r2, r3
                    Init->ExtendedMode         |\
 801751a:	683b      	ldr	r3, [r7, #0]
 801751c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                    Init->WaitSignal           |\
 801751e:	431a      	orrs	r2, r3
                    Init->AsynchronousWait     |\
 8017520:	683b      	ldr	r3, [r7, #0]
 8017522:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                    Init->ExtendedMode         |\
 8017524:	431a      	orrs	r2, r3
                    Init->PageSize             |\
 8017526:	683b      	ldr	r3, [r7, #0]
 8017528:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
                    Init->AsynchronousWait     |\
 801752a:	431a      	orrs	r2, r3
                    Init->WriteBurst           |\
 801752c:	683b      	ldr	r3, [r7, #0]
 801752e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                    Init->PageSize             |\
 8017530:	431a      	orrs	r2, r3
                    Init->ContinuousClock);
 8017532:	683b      	ldr	r3, [r7, #0]
 8017534:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                    Init->WriteBurst           |\
 8017536:	4313      	orrs	r3, r2
  tmpr |= (uint32_t)(Init->DataAddressMux       |\
 8017538:	68fa      	ldr	r2, [r7, #12]
 801753a:	4313      	orrs	r3, r2
 801753c:	60fb      	str	r3, [r7, #12]
                    Init->ContinuousClock      |\
                    Init->PageSize             |\
                    Init->WriteFifo);
#endif /*  defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) */
                    
  if(Init->MemoryType == FMC_MEMORY_TYPE_NOR)
 801753e:	683b      	ldr	r3, [r7, #0]
 8017540:	689b      	ldr	r3, [r3, #8]
 8017542:	2b08      	cmp	r3, #8
 8017544:	d103      	bne.n	801754e <FMC_NORSRAM_Init+0x8a>
  {
    tmpr |= (uint32_t)FMC_NORSRAM_FLASH_ACCESS_ENABLE;
 8017546:	68fb      	ldr	r3, [r7, #12]
 8017548:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801754c:	60fb      	str	r3, [r7, #12]
  }
  
  Device->BTCR[Init->NSBank] = tmpr;
 801754e:	683b      	ldr	r3, [r7, #0]
 8017550:	681a      	ldr	r2, [r3, #0]
 8017552:	687b      	ldr	r3, [r7, #4]
 8017554:	68f9      	ldr	r1, [r7, #12]
 8017556:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
  if((Init->ContinuousClock == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FMC_NORSRAM_BANK1))
 801755a:	683b      	ldr	r3, [r7, #0]
 801755c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801755e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8017562:	d10a      	bne.n	801757a <FMC_NORSRAM_Init+0xb6>
 8017564:	683b      	ldr	r3, [r7, #0]
 8017566:	681b      	ldr	r3, [r3, #0]
 8017568:	2b00      	cmp	r3, #0
 801756a:	d006      	beq.n	801757a <FMC_NORSRAM_Init+0xb6>
  { 
    Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->ContinuousClock);
 801756c:	687b      	ldr	r3, [r7, #4]
 801756e:	681a      	ldr	r2, [r3, #0]
 8017570:	683b      	ldr	r3, [r7, #0]
 8017572:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8017574:	431a      	orrs	r2, r3
 8017576:	687b      	ldr	r3, [r7, #4]
 8017578:	601a      	str	r2, [r3, #0]
  {
    Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->WriteFifo);              
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */
  
  return HAL_OK;
 801757a:	2300      	movs	r3, #0
}
 801757c:	4618      	mov	r0, r3
 801757e:	3714      	adds	r7, #20
 8017580:	46bd      	mov	sp, r7
 8017582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017586:	4770      	bx	lr
 8017588:	ffe00080 	.word	0xffe00080

0801758c <FMC_NORSRAM_Timing_Init>:
  * @param  Timing: Pointer to NORSRAM Timing structure
  * @param  Bank: NORSRAM bank number  
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 801758c:	b480      	push	{r7}
 801758e:	b087      	sub	sp, #28
 8017590:	af00      	add	r7, sp, #0
 8017592:	60f8      	str	r0, [r7, #12]
 8017594:	60b9      	str	r1, [r7, #8]
 8017596:	607a      	str	r2, [r7, #4]
  uint32_t tmpr = 0U;
 8017598:	2300      	movs	r3, #0
 801759a:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
  assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
  assert_param(IS_FMC_NORSRAM_BANK(Bank));
  
  /* Get the BTCR register value */
  tmpr = Device->BTCR[Bank + 1U];
 801759c:	687b      	ldr	r3, [r7, #4]
 801759e:	1c5a      	adds	r2, r3, #1
 80175a0:	68fb      	ldr	r3, [r7, #12]
 80175a2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80175a6:	617b      	str	r3, [r7, #20]

  /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
  tmpr &= ((uint32_t)~(FMC_BTR1_ADDSET  | FMC_BTR1_ADDHLD | FMC_BTR1_DATAST | \
 80175a8:	697b      	ldr	r3, [r7, #20]
 80175aa:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
 80175ae:	617b      	str	r3, [r7, #20]
                       FMC_BTR1_BUSTURN | FMC_BTR1_CLKDIV | FMC_BTR1_DATLAT | \
                       FMC_BTR1_ACCMOD));
  
  /* Set FMC_NORSRAM device timing parameters */  
  tmpr |= (uint32_t)(Timing->AddressSetupTime                   |\
 80175b0:	68bb      	ldr	r3, [r7, #8]
 80175b2:	681a      	ldr	r2, [r3, #0]
                    ((Timing->AddressHoldTime) << 4U)           |\
 80175b4:	68bb      	ldr	r3, [r7, #8]
 80175b6:	685b      	ldr	r3, [r3, #4]
 80175b8:	011b      	lsls	r3, r3, #4
  tmpr |= (uint32_t)(Timing->AddressSetupTime                   |\
 80175ba:	431a      	orrs	r2, r3
                    ((Timing->DataSetupTime) << 8U)             |\
 80175bc:	68bb      	ldr	r3, [r7, #8]
 80175be:	689b      	ldr	r3, [r3, #8]
 80175c0:	021b      	lsls	r3, r3, #8
                    ((Timing->AddressHoldTime) << 4U)           |\
 80175c2:	431a      	orrs	r2, r3
                    ((Timing->BusTurnAroundDuration) << 16U)    |\
 80175c4:	68bb      	ldr	r3, [r7, #8]
 80175c6:	68db      	ldr	r3, [r3, #12]
 80175c8:	041b      	lsls	r3, r3, #16
                    ((Timing->DataSetupTime) << 8U)             |\
 80175ca:	431a      	orrs	r2, r3
                    (((Timing->CLKDivision) - 1U) << 20U)         |\
 80175cc:	68bb      	ldr	r3, [r7, #8]
 80175ce:	691b      	ldr	r3, [r3, #16]
 80175d0:	3b01      	subs	r3, #1
 80175d2:	051b      	lsls	r3, r3, #20
                    ((Timing->BusTurnAroundDuration) << 16U)    |\
 80175d4:	431a      	orrs	r2, r3
                    (((Timing->DataLatency) - 2U) << 24U)         |\
 80175d6:	68bb      	ldr	r3, [r7, #8]
 80175d8:	695b      	ldr	r3, [r3, #20]
 80175da:	3b02      	subs	r3, #2
 80175dc:	061b      	lsls	r3, r3, #24
                    (((Timing->CLKDivision) - 1U) << 20U)         |\
 80175de:	431a      	orrs	r2, r3
                    (Timing->AccessMode));
 80175e0:	68bb      	ldr	r3, [r7, #8]
 80175e2:	699b      	ldr	r3, [r3, #24]
  tmpr |= (uint32_t)(Timing->AddressSetupTime                   |\
 80175e4:	4313      	orrs	r3, r2
 80175e6:	697a      	ldr	r2, [r7, #20]
 80175e8:	4313      	orrs	r3, r2
 80175ea:	617b      	str	r3, [r7, #20]
  
  Device->BTCR[Bank + 1U] = tmpr;
 80175ec:	687b      	ldr	r3, [r7, #4]
 80175ee:	1c5a      	adds	r2, r3, #1
 80175f0:	68fb      	ldr	r3, [r7, #12]
 80175f2:	6979      	ldr	r1, [r7, #20]
 80175f4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  
  /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
  if(HAL_IS_BIT_SET(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN))
 80175f8:	68fb      	ldr	r3, [r7, #12]
 80175fa:	681b      	ldr	r3, [r3, #0]
 80175fc:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8017600:	2b00      	cmp	r3, #0
 8017602:	d00e      	beq.n	8017622 <FMC_NORSRAM_Timing_Init+0x96>
  {
    tmpr = (uint32_t)(Device->BTCR[FMC_NORSRAM_BANK1 + 1U] & ~(((uint32_t)0x0FU) << 20U)); 
 8017604:	68fb      	ldr	r3, [r7, #12]
 8017606:	685b      	ldr	r3, [r3, #4]
 8017608:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 801760c:	617b      	str	r3, [r7, #20]
    tmpr |= (uint32_t)(((Timing->CLKDivision) - 1U) << 20U);
 801760e:	68bb      	ldr	r3, [r7, #8]
 8017610:	691b      	ldr	r3, [r3, #16]
 8017612:	3b01      	subs	r3, #1
 8017614:	051b      	lsls	r3, r3, #20
 8017616:	697a      	ldr	r2, [r7, #20]
 8017618:	4313      	orrs	r3, r2
 801761a:	617b      	str	r3, [r7, #20]
    Device->BTCR[FMC_NORSRAM_BANK1 + 1U] = tmpr;
 801761c:	68fb      	ldr	r3, [r7, #12]
 801761e:	697a      	ldr	r2, [r7, #20]
 8017620:	605a      	str	r2, [r3, #4]
  }  
  
  return HAL_OK;   
 8017622:	2300      	movs	r3, #0
}
 8017624:	4618      	mov	r0, r3
 8017626:	371c      	adds	r7, #28
 8017628:	46bd      	mov	sp, r7
 801762a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801762e:	4770      	bx	lr

08017630 <FMC_NORSRAM_Extended_Timing_Init>:
  * @param  Timing: Pointer to NORSRAM Timing structure
  * @param  Bank: NORSRAM bank number  
  * @retval HAL status
  */
HAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
{  
 8017630:	b480      	push	{r7}
 8017632:	b087      	sub	sp, #28
 8017634:	af00      	add	r7, sp, #0
 8017636:	60f8      	str	r0, [r7, #12]
 8017638:	60b9      	str	r1, [r7, #8]
 801763a:	607a      	str	r2, [r7, #4]
 801763c:	603b      	str	r3, [r7, #0]
  uint32_t tmpr = 0U;
 801763e:	2300      	movs	r3, #0
 8017640:	617b      	str	r3, [r7, #20]
 
  /* Check the parameters */
  assert_param(IS_FMC_EXTENDED_MODE(ExtendedMode));
  
  /* Set NORSRAM device timing register for write configuration, if extended mode is used */
  if(ExtendedMode == FMC_EXTENDED_MODE_ENABLE)
 8017642:	683b      	ldr	r3, [r7, #0]
 8017644:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8017648:	d122      	bne.n	8017690 <FMC_NORSRAM_Extended_Timing_Init+0x60>
    assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
    assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
    assert_param(IS_FMC_NORSRAM_BANK(Bank));  
    
    /* Get the BWTR register value */
    tmpr = Device->BWTR[Bank];
 801764a:	68fb      	ldr	r3, [r7, #12]
 801764c:	687a      	ldr	r2, [r7, #4]
 801764e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8017652:	617b      	str	r3, [r7, #20]

    /* Clear ADDSET, ADDHLD, DATAST, BUSTURN and ACCMOD bits */
    tmpr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
 8017654:	697a      	ldr	r2, [r7, #20]
 8017656:	4b15      	ldr	r3, [pc, #84]	; (80176ac <FMC_NORSRAM_Extended_Timing_Init+0x7c>)
 8017658:	4013      	ands	r3, r2
 801765a:	617b      	str	r3, [r7, #20]
                         FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
    
    tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
 801765c:	68bb      	ldr	r3, [r7, #8]
 801765e:	681a      	ldr	r2, [r3, #0]
                      ((Timing->AddressHoldTime) << 4U)          |\
 8017660:	68bb      	ldr	r3, [r7, #8]
 8017662:	685b      	ldr	r3, [r3, #4]
 8017664:	011b      	lsls	r3, r3, #4
    tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
 8017666:	431a      	orrs	r2, r3
                      ((Timing->DataSetupTime) << 8U)            |\
 8017668:	68bb      	ldr	r3, [r7, #8]
 801766a:	689b      	ldr	r3, [r3, #8]
 801766c:	021b      	lsls	r3, r3, #8
                      ((Timing->AddressHoldTime) << 4U)          |\
 801766e:	431a      	orrs	r2, r3
                      ((Timing->BusTurnAroundDuration) << 16U)   |\
 8017670:	68bb      	ldr	r3, [r7, #8]
 8017672:	68db      	ldr	r3, [r3, #12]
 8017674:	041b      	lsls	r3, r3, #16
                      ((Timing->DataSetupTime) << 8U)            |\
 8017676:	431a      	orrs	r2, r3
                      (Timing->AccessMode));
 8017678:	68bb      	ldr	r3, [r7, #8]
 801767a:	699b      	ldr	r3, [r3, #24]
                      ((Timing->BusTurnAroundDuration) << 16U)   |\
 801767c:	4313      	orrs	r3, r2
    tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
 801767e:	697a      	ldr	r2, [r7, #20]
 8017680:	4313      	orrs	r3, r2
 8017682:	617b      	str	r3, [r7, #20]

    Device->BWTR[Bank] = tmpr;
 8017684:	68fb      	ldr	r3, [r7, #12]
 8017686:	687a      	ldr	r2, [r7, #4]
 8017688:	6979      	ldr	r1, [r7, #20]
 801768a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801768e:	e005      	b.n	801769c <FMC_NORSRAM_Extended_Timing_Init+0x6c>
  }
  else
  {
    Device->BWTR[Bank] = 0x0FFFFFFFU;
 8017690:	68fb      	ldr	r3, [r7, #12]
 8017692:	687a      	ldr	r2, [r7, #4]
 8017694:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 8017698:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }   
  
  return HAL_OK;  
 801769c:	2300      	movs	r3, #0
}
 801769e:	4618      	mov	r0, r3
 80176a0:	371c      	adds	r7, #28
 80176a2:	46bd      	mov	sp, r7
 80176a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80176a8:	4770      	bx	lr
 80176aa:	bf00      	nop
 80176ac:	cff00000 	.word	0xcff00000

080176b0 <SDIO_Init>:
  * @param  SDIOx: Pointer to SDIO register base
  * @param  Init: SDIO initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 80176b0:	b084      	sub	sp, #16
 80176b2:	b480      	push	{r7}
 80176b4:	b085      	sub	sp, #20
 80176b6:	af00      	add	r7, sp, #0
 80176b8:	6078      	str	r0, [r7, #4]
 80176ba:	f107 001c 	add.w	r0, r7, #28
 80176be:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0U; 
 80176c2:	2300      	movs	r3, #0
 80176c4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
  
  /* Set SDIO configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 80176c6:	69fa      	ldr	r2, [r7, #28]
             Init.ClockBypass         |\
 80176c8:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           |\
 80176ca:	431a      	orrs	r2, r3
             Init.ClockPowerSave      |\
 80176cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
             Init.ClockBypass         |\
 80176ce:	431a      	orrs	r2, r3
             Init.BusWide             |\
 80176d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
             Init.ClockPowerSave      |\
 80176d2:	431a      	orrs	r2, r3
             Init.HardwareFlowControl |\
 80176d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
             Init.BusWide             |\
 80176d6:	431a      	orrs	r2, r3
             Init.ClockDiv
 80176d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
             Init.HardwareFlowControl |\
 80176da:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           |\
 80176dc:	68fa      	ldr	r2, [r7, #12]
 80176de:	4313      	orrs	r3, r2
 80176e0:	60fb      	str	r3, [r7, #12]
             ); 
  
  /* Write to SDIO CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80176e2:	687b      	ldr	r3, [r7, #4]
 80176e4:	685b      	ldr	r3, [r3, #4]
 80176e6:	f423 43fd 	bic.w	r3, r3, #32384	; 0x7e80
 80176ea:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80176ee:	68fa      	ldr	r2, [r7, #12]
 80176f0:	431a      	orrs	r2, r3
 80176f2:	687b      	ldr	r3, [r7, #4]
 80176f4:	605a      	str	r2, [r3, #4]

  return HAL_OK;
 80176f6:	2300      	movs	r3, #0
}
 80176f8:	4618      	mov	r0, r3
 80176fa:	3714      	adds	r7, #20
 80176fc:	46bd      	mov	sp, r7
 80176fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017702:	b004      	add	sp, #16
 8017704:	4770      	bx	lr

08017706 <SDIO_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling) 
  * @param  SDIOx: Pointer to SDIO register base
  * @retval HAL status
  */
uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
{
 8017706:	b480      	push	{r7}
 8017708:	b083      	sub	sp, #12
 801770a:	af00      	add	r7, sp, #0
 801770c:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */ 
  return (SDIOx->FIFO);
 801770e:	687b      	ldr	r3, [r7, #4]
 8017710:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
}
 8017714:	4618      	mov	r0, r3
 8017716:	370c      	adds	r7, #12
 8017718:	46bd      	mov	sp, r7
 801771a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801771e:	4770      	bx	lr

08017720 <SDIO_PowerState_ON>:
  * @brief  Set SDIO Power state to ON. 
  * @param  SDIOx: Pointer to SDIO register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
 8017720:	b480      	push	{r7}
 8017722:	b083      	sub	sp, #12
 8017724:	af00      	add	r7, sp, #0
 8017726:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8017728:	687b      	ldr	r3, [r7, #4]
 801772a:	2203      	movs	r2, #3
 801772c:	601a      	str	r2, [r3, #0]
  
  return HAL_OK; 
 801772e:	2300      	movs	r3, #0
}
 8017730:	4618      	mov	r0, r3
 8017732:	370c      	adds	r7, #12
 8017734:	46bd      	mov	sp, r7
 8017736:	f85d 7b04 	ldr.w	r7, [sp], #4
 801773a:	4770      	bx	lr

0801773c <SDIO_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
 801773c:	b480      	push	{r7}
 801773e:	b083      	sub	sp, #12
 8017740:	af00      	add	r7, sp, #0
 8017742:	6078      	str	r0, [r7, #4]
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8017744:	687b      	ldr	r3, [r7, #4]
 8017746:	681b      	ldr	r3, [r3, #0]
 8017748:	f003 0303 	and.w	r3, r3, #3
}
 801774c:	4618      	mov	r0, r3
 801774e:	370c      	adds	r7, #12
 8017750:	46bd      	mov	sp, r7
 8017752:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017756:	4770      	bx	lr

08017758 <SDIO_SendCommand>:
  * @param  SDIO_CmdInitStruct: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDIO command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 8017758:	b480      	push	{r7}
 801775a:	b085      	sub	sp, #20
 801775c:	af00      	add	r7, sp, #0
 801775e:	6078      	str	r0, [r7, #4]
 8017760:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0U;
 8017762:	2300      	movs	r3, #0
 8017764:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->Response));
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->CPSM));

  /* Set the SDIO Argument value */
  SDIOx->ARG = SDIO_CmdInitStruct->Argument;
 8017766:	683b      	ldr	r3, [r7, #0]
 8017768:	681a      	ldr	r2, [r3, #0]
 801776a:	687b      	ldr	r3, [r7, #4]
 801776c:	609a      	str	r2, [r3, #8]

  /* Set SDIO command parameters */
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 801776e:	683b      	ldr	r3, [r7, #0]
 8017770:	685a      	ldr	r2, [r3, #4]
                       SDIO_CmdInitStruct->Response         |\
 8017772:	683b      	ldr	r3, [r7, #0]
 8017774:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 8017776:	431a      	orrs	r2, r3
                       SDIO_CmdInitStruct->WaitForInterrupt |\
 8017778:	683b      	ldr	r3, [r7, #0]
 801777a:	68db      	ldr	r3, [r3, #12]
                       SDIO_CmdInitStruct->Response         |\
 801777c:	431a      	orrs	r2, r3
                       SDIO_CmdInitStruct->CPSM);
 801777e:	683b      	ldr	r3, [r7, #0]
 8017780:	691b      	ldr	r3, [r3, #16]
                       SDIO_CmdInitStruct->WaitForInterrupt |\
 8017782:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(SDIO_CmdInitStruct->CmdIndex         |\
 8017784:	68fa      	ldr	r2, [r7, #12]
 8017786:	4313      	orrs	r3, r2
 8017788:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDIO CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801778a:	687b      	ldr	r3, [r7, #4]
 801778c:	68db      	ldr	r3, [r3, #12]
 801778e:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8017792:	f023 030f 	bic.w	r3, r3, #15
 8017796:	68fa      	ldr	r2, [r7, #12]
 8017798:	431a      	orrs	r2, r3
 801779a:	687b      	ldr	r3, [r7, #4]
 801779c:	60da      	str	r2, [r3, #12]
  
  return HAL_OK;  
 801779e:	2300      	movs	r3, #0
}
 80177a0:	4618      	mov	r0, r3
 80177a2:	3714      	adds	r7, #20
 80177a4:	46bd      	mov	sp, r7
 80177a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177aa:	4770      	bx	lr

080177ac <SDIO_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDIOx: Pointer to SDIO register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
 80177ac:	b480      	push	{r7}
 80177ae:	b083      	sub	sp, #12
 80177b0:	af00      	add	r7, sp, #0
 80177b2:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDIOx->RESPCMD);
 80177b4:	687b      	ldr	r3, [r7, #4]
 80177b6:	691b      	ldr	r3, [r3, #16]
 80177b8:	b2db      	uxtb	r3, r3
}
 80177ba:	4618      	mov	r0, r3
 80177bc:	370c      	adds	r7, #12
 80177be:	46bd      	mov	sp, r7
 80177c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177c4:	4770      	bx	lr
	...

080177c8 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 80177c8:	b480      	push	{r7}
 80177ca:	b085      	sub	sp, #20
 80177cc:	af00      	add	r7, sp, #0
 80177ce:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmp = 0U;
 80177d0:	2300      	movs	r3, #0
 80177d2:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  /* Get the response */
  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 80177d4:	687a      	ldr	r2, [r7, #4]
 80177d6:	4b05      	ldr	r3, [pc, #20]	; (80177ec <SDIO_GetResponse+0x24>)
 80177d8:	4413      	add	r3, r2
 80177da:	60fb      	str	r3, [r7, #12]
  
  return (*(__IO uint32_t *) tmp);
 80177dc:	68fb      	ldr	r3, [r7, #12]
 80177de:	681b      	ldr	r3, [r3, #0]
}  
 80177e0:	4618      	mov	r0, r3
 80177e2:	3714      	adds	r7, #20
 80177e4:	46bd      	mov	sp, r7
 80177e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80177ea:	4770      	bx	lr
 80177ec:	40012c14 	.word	0x40012c14

080177f0 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_DataConfig(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 80177f0:	b480      	push	{r7}
 80177f2:	b085      	sub	sp, #20
 80177f4:	af00      	add	r7, sp, #0
 80177f6:	6078      	str	r0, [r7, #4]
 80177f8:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0U;
 80177fa:	2300      	movs	r3, #0
 80177fc:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->DPSM));

  /* Set the SDIO Data Timeout value */
  SDIOx->DTIMER = SDIO_DataInitStruct->DataTimeOut;
 80177fe:	683b      	ldr	r3, [r7, #0]
 8017800:	681a      	ldr	r2, [r3, #0]
 8017802:	687b      	ldr	r3, [r7, #4]
 8017804:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the SDIO DataLength value */
  SDIOx->DLEN = SDIO_DataInitStruct->DataLength;
 8017806:	683b      	ldr	r3, [r7, #0]
 8017808:	685a      	ldr	r2, [r3, #4]
 801780a:	687b      	ldr	r3, [r7, #4]
 801780c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Set the SDIO data configuration parameters */
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 801780e:	683b      	ldr	r3, [r7, #0]
 8017810:	689a      	ldr	r2, [r3, #8]
                       SDIO_DataInitStruct->TransferDir   |\
 8017812:	683b      	ldr	r3, [r7, #0]
 8017814:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 8017816:	431a      	orrs	r2, r3
                       SDIO_DataInitStruct->TransferMode  |\
 8017818:	683b      	ldr	r3, [r7, #0]
 801781a:	691b      	ldr	r3, [r3, #16]
                       SDIO_DataInitStruct->TransferDir   |\
 801781c:	431a      	orrs	r2, r3
                       SDIO_DataInitStruct->DPSM);
 801781e:	683b      	ldr	r3, [r7, #0]
 8017820:	695b      	ldr	r3, [r3, #20]
                       SDIO_DataInitStruct->TransferMode  |\
 8017822:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(SDIO_DataInitStruct->DataBlockSize |\
 8017824:	68fa      	ldr	r2, [r7, #12]
 8017826:	4313      	orrs	r3, r2
 8017828:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDIO DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 801782a:	687b      	ldr	r3, [r7, #4]
 801782c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801782e:	f023 02f7 	bic.w	r2, r3, #247	; 0xf7
 8017832:	68fb      	ldr	r3, [r7, #12]
 8017834:	431a      	orrs	r2, r3
 8017836:	687b      	ldr	r3, [r7, #4]
 8017838:	62da      	str	r2, [r3, #44]	; 0x2c

  return HAL_OK;
 801783a:	2300      	movs	r3, #0

}
 801783c:	4618      	mov	r0, r3
 801783e:	3714      	adds	r7, #20
 8017840:	46bd      	mov	sp, r7
 8017842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017846:	4770      	bx	lr

08017848 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8017848:	b084      	sub	sp, #16
 801784a:	b580      	push	{r7, lr}
 801784c:	b082      	sub	sp, #8
 801784e:	af00      	add	r7, sp, #0
 8017850:	6078      	str	r0, [r7, #4]
 8017852:	f107 0014 	add.w	r0, r7, #20
 8017856:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 801785a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801785c:	2b01      	cmp	r3, #1
 801785e:	d120      	bne.n	80178a2 <USB_CoreInit+0x5a>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8017860:	687b      	ldr	r3, [r7, #4]
 8017862:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8017864:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8017868:	687b      	ldr	r3, [r7, #4]
 801786a:	639a      	str	r2, [r3, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 801786c:	687b      	ldr	r3, [r7, #4]
 801786e:	68db      	ldr	r3, [r3, #12]
 8017870:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8017874:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8017878:	687a      	ldr	r2, [r7, #4]
 801787a:	60d3      	str	r3, [r2, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 801787c:	687b      	ldr	r3, [r7, #4]
 801787e:	68db      	ldr	r3, [r3, #12]
 8017880:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8017884:	687b      	ldr	r3, [r7, #4]
 8017886:	60da      	str	r2, [r3, #12]
    if(cfg.use_external_vbus == 1U)
 8017888:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801788a:	2b01      	cmp	r3, #1
 801788c:	d105      	bne.n	801789a <USB_CoreInit+0x52>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 801788e:	687b      	ldr	r3, [r7, #4]
 8017890:	68db      	ldr	r3, [r3, #12]
 8017892:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 8017896:	687b      	ldr	r3, [r7, #4]
 8017898:	60da      	str	r2, [r3, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 801789a:	6878      	ldr	r0, [r7, #4]
 801789c:	f001 f93a 	bl	8018b14 <USB_CoreReset>
 80178a0:	e00c      	b.n	80178bc <USB_CoreInit+0x74>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 80178a2:	687b      	ldr	r3, [r7, #4]
 80178a4:	68db      	ldr	r3, [r3, #12]
 80178a6:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80178aa:	687b      	ldr	r3, [r7, #4]
 80178ac:	60da      	str	r2, [r3, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 80178ae:	6878      	ldr	r0, [r7, #4]
 80178b0:	f001 f930 	bl	8018b14 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 80178b4:	687b      	ldr	r3, [r7, #4]
 80178b6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80178ba:	639a      	str	r2, [r3, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 80178bc:	6a3b      	ldr	r3, [r7, #32]
 80178be:	2b01      	cmp	r3, #1
 80178c0:	d10b      	bne.n	80178da <USB_CoreInit+0x92>
  {
    USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
 80178c2:	687b      	ldr	r3, [r7, #4]
 80178c4:	689b      	ldr	r3, [r3, #8]
 80178c6:	f043 020c 	orr.w	r2, r3, #12
 80178ca:	687b      	ldr	r3, [r7, #4]
 80178cc:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 80178ce:	687b      	ldr	r3, [r7, #4]
 80178d0:	689b      	ldr	r3, [r3, #8]
 80178d2:	f043 0220 	orr.w	r2, r3, #32
 80178d6:	687b      	ldr	r3, [r7, #4]
 80178d8:	609a      	str	r2, [r3, #8]
  }  

  return HAL_OK;
 80178da:	2300      	movs	r3, #0
}
 80178dc:	4618      	mov	r0, r3
 80178de:	3708      	adds	r7, #8
 80178e0:	46bd      	mov	sp, r7
 80178e2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80178e6:	b004      	add	sp, #16
 80178e8:	4770      	bx	lr

080178ea <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 80178ea:	b480      	push	{r7}
 80178ec:	b083      	sub	sp, #12
 80178ee:	af00      	add	r7, sp, #0
 80178f0:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80178f2:	687b      	ldr	r3, [r7, #4]
 80178f4:	689b      	ldr	r3, [r3, #8]
 80178f6:	f043 0201 	orr.w	r2, r3, #1
 80178fa:	687b      	ldr	r3, [r7, #4]
 80178fc:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80178fe:	2300      	movs	r3, #0
}
 8017900:	4618      	mov	r0, r3
 8017902:	370c      	adds	r7, #12
 8017904:	46bd      	mov	sp, r7
 8017906:	f85d 7b04 	ldr.w	r7, [sp], #4
 801790a:	4770      	bx	lr

0801790c <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 801790c:	b480      	push	{r7}
 801790e:	b083      	sub	sp, #12
 8017910:	af00      	add	r7, sp, #0
 8017912:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8017914:	687b      	ldr	r3, [r7, #4]
 8017916:	689b      	ldr	r3, [r3, #8]
 8017918:	f023 0201 	bic.w	r2, r3, #1
 801791c:	687b      	ldr	r3, [r7, #4]
 801791e:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8017920:	2300      	movs	r3, #0
}
 8017922:	4618      	mov	r0, r3
 8017924:	370c      	adds	r7, #12
 8017926:	46bd      	mov	sp, r7
 8017928:	f85d 7b04 	ldr.w	r7, [sp], #4
 801792c:	4770      	bx	lr

0801792e <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 801792e:	b580      	push	{r7, lr}
 8017930:	b082      	sub	sp, #8
 8017932:	af00      	add	r7, sp, #0
 8017934:	6078      	str	r0, [r7, #4]
 8017936:	460b      	mov	r3, r1
 8017938:	70fb      	strb	r3, [r7, #3]
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 801793a:	687b      	ldr	r3, [r7, #4]
 801793c:	68db      	ldr	r3, [r3, #12]
 801793e:	f023 42c0 	bic.w	r2, r3, #1610612736	; 0x60000000
 8017942:	687b      	ldr	r3, [r7, #4]
 8017944:	60da      	str	r2, [r3, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8017946:	78fb      	ldrb	r3, [r7, #3]
 8017948:	2b01      	cmp	r3, #1
 801794a:	d106      	bne.n	801795a <USB_SetCurrentMode+0x2c>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 801794c:	687b      	ldr	r3, [r7, #4]
 801794e:	68db      	ldr	r3, [r3, #12]
 8017950:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 8017954:	687b      	ldr	r3, [r7, #4]
 8017956:	60da      	str	r2, [r3, #12]
 8017958:	e008      	b.n	801796c <USB_SetCurrentMode+0x3e>
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 801795a:	78fb      	ldrb	r3, [r7, #3]
 801795c:	2b00      	cmp	r3, #0
 801795e:	d105      	bne.n	801796c <USB_SetCurrentMode+0x3e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8017960:	687b      	ldr	r3, [r7, #4]
 8017962:	68db      	ldr	r3, [r3, #12]
 8017964:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8017968:	687b      	ldr	r3, [r7, #4]
 801796a:	60da      	str	r2, [r3, #12]
  }
  HAL_Delay(50U);
 801796c:	2032      	movs	r0, #50	; 0x32
 801796e:	f7f9 fde7 	bl	8011540 <HAL_Delay>
  
  return HAL_OK;
 8017972:	2300      	movs	r3, #0
}
 8017974:	4618      	mov	r0, r3
 8017976:	3708      	adds	r7, #8
 8017978:	46bd      	mov	sp, r7
 801797a:	bd80      	pop	{r7, pc}

0801797c <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 801797c:	b084      	sub	sp, #16
 801797e:	b580      	push	{r7, lr}
 8017980:	b084      	sub	sp, #16
 8017982:	af00      	add	r7, sp, #0
 8017984:	6078      	str	r0, [r7, #4]
 8017986:	f107 001c 	add.w	r0, r7, #28
 801798a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t i = 0U;
 801798e:	2300      	movs	r3, #0
 8017990:	60fb      	str	r3, [r7, #12]
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8017992:	687b      	ldr	r3, [r7, #4]
 8017994:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8017996:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 801799a:	687b      	ldr	r3, [r7, #4]
 801799c:	639a      	str	r2, [r3, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0U)
 801799e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80179a0:	2b00      	cmp	r3, #0
 80179a2:	d105      	bne.n	80179b0 <USB_DevInit+0x34>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80179a4:	687b      	ldr	r3, [r7, #4]
 80179a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80179a8:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 80179ac:	687b      	ldr	r3, [r7, #4]
 80179ae:	639a      	str	r2, [r3, #56]	; 0x38
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 80179b0:	687b      	ldr	r3, [r7, #4]
 80179b2:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 80179b6:	461a      	mov	r2, r3
 80179b8:	2300      	movs	r3, #0
 80179ba:	6013      	str	r3, [r2, #0]

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80179bc:	687b      	ldr	r3, [r7, #4]
 80179be:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80179c2:	4619      	mov	r1, r3
 80179c4:	687b      	ldr	r3, [r7, #4]
 80179c6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80179ca:	461a      	mov	r2, r3
 80179cc:	680b      	ldr	r3, [r1, #0]
 80179ce:	6013      	str	r3, [r2, #0]
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 80179d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80179d2:	2b01      	cmp	r3, #1
 80179d4:	d10c      	bne.n	80179f0 <USB_DevInit+0x74>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 80179d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80179d8:	2b00      	cmp	r3, #0
 80179da:	d104      	bne.n	80179e6 <USB_DevInit+0x6a>
    {      
      /* Set High speed phy */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
 80179dc:	2100      	movs	r1, #0
 80179de:	6878      	ldr	r0, [r7, #4]
 80179e0:	f000 f944 	bl	8017c6c <USB_SetDevSpeed>
 80179e4:	e008      	b.n	80179f8 <USB_DevInit+0x7c>
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 80179e6:	2101      	movs	r1, #1
 80179e8:	6878      	ldr	r0, [r7, #4]
 80179ea:	f000 f93f 	bl	8017c6c <USB_SetDevSpeed>
 80179ee:	e003      	b.n	80179f8 <USB_DevInit+0x7c>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 80179f0:	2103      	movs	r1, #3
 80179f2:	6878      	ldr	r0, [r7, #4]
 80179f4:	f000 f93a 	bl	8017c6c <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 80179f8:	2110      	movs	r1, #16
 80179fa:	6878      	ldr	r0, [r7, #4]
 80179fc:	f000 f8ee 	bl	8017bdc <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 8017a00:	6878      	ldr	r0, [r7, #4]
 8017a02:	f000 f911 	bl	8017c28 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8017a06:	687b      	ldr	r3, [r7, #4]
 8017a08:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017a0c:	461a      	mov	r2, r3
 8017a0e:	2300      	movs	r3, #0
 8017a10:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8017a12:	687b      	ldr	r3, [r7, #4]
 8017a14:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017a18:	461a      	mov	r2, r3
 8017a1a:	2300      	movs	r3, #0
 8017a1c:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8017a1e:	687b      	ldr	r3, [r7, #4]
 8017a20:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017a24:	461a      	mov	r2, r3
 8017a26:	f04f 33ff 	mov.w	r3, #4294967295
 8017a2a:	6193      	str	r3, [r2, #24]
  USBx_DEVICE->DAINTMSK = 0U;
 8017a2c:	687b      	ldr	r3, [r7, #4]
 8017a2e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017a32:	461a      	mov	r2, r3
 8017a34:	2300      	movs	r3, #0
 8017a36:	61d3      	str	r3, [r2, #28]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8017a38:	2300      	movs	r3, #0
 8017a3a:	60fb      	str	r3, [r7, #12]
 8017a3c:	e034      	b.n	8017aa8 <USB_DevInit+0x12c>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8017a3e:	68fb      	ldr	r3, [r7, #12]
 8017a40:	015a      	lsls	r2, r3, #5
 8017a42:	687b      	ldr	r3, [r7, #4]
 8017a44:	4413      	add	r3, r2
 8017a46:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017a4a:	681b      	ldr	r3, [r3, #0]
 8017a4c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8017a50:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8017a54:	d10a      	bne.n	8017a6c <USB_DevInit+0xf0>
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 8017a56:	68fb      	ldr	r3, [r7, #12]
 8017a58:	015a      	lsls	r2, r3, #5
 8017a5a:	687b      	ldr	r3, [r7, #4]
 8017a5c:	4413      	add	r3, r2
 8017a5e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017a62:	461a      	mov	r2, r3
 8017a64:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8017a68:	6013      	str	r3, [r2, #0]
 8017a6a:	e008      	b.n	8017a7e <USB_DevInit+0x102>
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8017a6c:	68fb      	ldr	r3, [r7, #12]
 8017a6e:	015a      	lsls	r2, r3, #5
 8017a70:	687b      	ldr	r3, [r7, #4]
 8017a72:	4413      	add	r3, r2
 8017a74:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017a78:	461a      	mov	r2, r3
 8017a7a:	2300      	movs	r3, #0
 8017a7c:	6013      	str	r3, [r2, #0]
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8017a7e:	68fb      	ldr	r3, [r7, #12]
 8017a80:	015a      	lsls	r2, r3, #5
 8017a82:	687b      	ldr	r3, [r7, #4]
 8017a84:	4413      	add	r3, r2
 8017a86:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017a8a:	461a      	mov	r2, r3
 8017a8c:	2300      	movs	r3, #0
 8017a8e:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 8017a90:	68fb      	ldr	r3, [r7, #12]
 8017a92:	015a      	lsls	r2, r3, #5
 8017a94:	687b      	ldr	r3, [r7, #4]
 8017a96:	4413      	add	r3, r2
 8017a98:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017a9c:	461a      	mov	r2, r3
 8017a9e:	23ff      	movs	r3, #255	; 0xff
 8017aa0:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8017aa2:	68fb      	ldr	r3, [r7, #12]
 8017aa4:	3301      	adds	r3, #1
 8017aa6:	60fb      	str	r3, [r7, #12]
 8017aa8:	69fb      	ldr	r3, [r7, #28]
 8017aaa:	68fa      	ldr	r2, [r7, #12]
 8017aac:	429a      	cmp	r2, r3
 8017aae:	d3c6      	bcc.n	8017a3e <USB_DevInit+0xc2>
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8017ab0:	2300      	movs	r3, #0
 8017ab2:	60fb      	str	r3, [r7, #12]
 8017ab4:	e034      	b.n	8017b20 <USB_DevInit+0x1a4>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8017ab6:	68fb      	ldr	r3, [r7, #12]
 8017ab8:	015a      	lsls	r2, r3, #5
 8017aba:	687b      	ldr	r3, [r7, #4]
 8017abc:	4413      	add	r3, r2
 8017abe:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017ac2:	681b      	ldr	r3, [r3, #0]
 8017ac4:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8017ac8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8017acc:	d10a      	bne.n	8017ae4 <USB_DevInit+0x168>
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8017ace:	68fb      	ldr	r3, [r7, #12]
 8017ad0:	015a      	lsls	r2, r3, #5
 8017ad2:	687b      	ldr	r3, [r7, #4]
 8017ad4:	4413      	add	r3, r2
 8017ad6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017ada:	461a      	mov	r2, r3
 8017adc:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8017ae0:	6013      	str	r3, [r2, #0]
 8017ae2:	e008      	b.n	8017af6 <USB_DevInit+0x17a>
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8017ae4:	68fb      	ldr	r3, [r7, #12]
 8017ae6:	015a      	lsls	r2, r3, #5
 8017ae8:	687b      	ldr	r3, [r7, #4]
 8017aea:	4413      	add	r3, r2
 8017aec:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017af0:	461a      	mov	r2, r3
 8017af2:	2300      	movs	r3, #0
 8017af4:	6013      	str	r3, [r2, #0]
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8017af6:	68fb      	ldr	r3, [r7, #12]
 8017af8:	015a      	lsls	r2, r3, #5
 8017afa:	687b      	ldr	r3, [r7, #4]
 8017afc:	4413      	add	r3, r2
 8017afe:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017b02:	461a      	mov	r2, r3
 8017b04:	2300      	movs	r3, #0
 8017b06:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8017b08:	68fb      	ldr	r3, [r7, #12]
 8017b0a:	015a      	lsls	r2, r3, #5
 8017b0c:	687b      	ldr	r3, [r7, #4]
 8017b0e:	4413      	add	r3, r2
 8017b10:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017b14:	461a      	mov	r2, r3
 8017b16:	23ff      	movs	r3, #255	; 0xff
 8017b18:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8017b1a:	68fb      	ldr	r3, [r7, #12]
 8017b1c:	3301      	adds	r3, #1
 8017b1e:	60fb      	str	r3, [r7, #12]
 8017b20:	69fb      	ldr	r3, [r7, #28]
 8017b22:	68fa      	ldr	r2, [r7, #12]
 8017b24:	429a      	cmp	r2, r3
 8017b26:	d3c6      	bcc.n	8017ab6 <USB_DevInit+0x13a>
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8017b28:	687b      	ldr	r3, [r7, #4]
 8017b2a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017b2e:	691b      	ldr	r3, [r3, #16]
 8017b30:	687a      	ldr	r2, [r7, #4]
 8017b32:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8017b36:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8017b3a:	6113      	str	r3, [r2, #16]
  
  if (cfg.dma_enable == 1U)
 8017b3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017b3e:	2b01      	cmp	r3, #1
 8017b40:	d116      	bne.n	8017b70 <USB_DevInit+0x1f4>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 8017b42:	687b      	ldr	r3, [r7, #4]
 8017b44:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017b48:	461a      	mov	r2, r3
 8017b4a:	4b22      	ldr	r3, [pc, #136]	; (8017bd4 <USB_DevInit+0x258>)
 8017b4c:	6313      	str	r3, [r2, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 8017b4e:	687b      	ldr	r3, [r7, #4]
 8017b50:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017b54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8017b56:	687a      	ldr	r2, [r7, #4]
 8017b58:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8017b5c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8017b60:	f043 0303 	orr.w	r3, r3, #3
 8017b64:	6313      	str	r3, [r2, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 8017b66:	687b      	ldr	r3, [r7, #4]
 8017b68:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017b6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8017b6e:	60fb      	str	r3, [r7, #12]
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8017b70:	687b      	ldr	r3, [r7, #4]
 8017b72:	2200      	movs	r2, #0
 8017b74:	619a      	str	r2, [r3, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8017b76:	687b      	ldr	r3, [r7, #4]
 8017b78:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
 8017b7c:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 8017b7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017b80:	2b00      	cmp	r3, #0
 8017b82:	d105      	bne.n	8017b90 <USB_DevInit+0x214>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 8017b84:	687b      	ldr	r3, [r7, #4]
 8017b86:	699b      	ldr	r3, [r3, #24]
 8017b88:	f043 0210 	orr.w	r2, r3, #16
 8017b8c:	687b      	ldr	r3, [r7, #4]
 8017b8e:	619a      	str	r2, [r3, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 8017b90:	687b      	ldr	r3, [r7, #4]
 8017b92:	699a      	ldr	r2, [r3, #24]
 8017b94:	4b10      	ldr	r3, [pc, #64]	; (8017bd8 <USB_DevInit+0x25c>)
 8017b96:	4313      	orrs	r3, r2
 8017b98:	687a      	ldr	r2, [r7, #4]
 8017b9a:	6193      	str	r3, [r2, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 8017b9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017b9e:	2b00      	cmp	r3, #0
 8017ba0:	d005      	beq.n	8017bae <USB_DevInit+0x232>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8017ba2:	687b      	ldr	r3, [r7, #4]
 8017ba4:	699b      	ldr	r3, [r3, #24]
 8017ba6:	f043 0208 	orr.w	r2, r3, #8
 8017baa:	687b      	ldr	r3, [r7, #4]
 8017bac:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 8017bae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8017bb0:	2b01      	cmp	r3, #1
 8017bb2:	d107      	bne.n	8017bc4 <USB_DevInit+0x248>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 8017bb4:	687b      	ldr	r3, [r7, #4]
 8017bb6:	699b      	ldr	r3, [r3, #24]
 8017bb8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8017bbc:	f043 0304 	orr.w	r3, r3, #4
 8017bc0:	687a      	ldr	r2, [r7, #4]
 8017bc2:	6193      	str	r3, [r2, #24]
  }
  
  return HAL_OK;
 8017bc4:	2300      	movs	r3, #0
}
 8017bc6:	4618      	mov	r0, r3
 8017bc8:	3710      	adds	r7, #16
 8017bca:	46bd      	mov	sp, r7
 8017bcc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8017bd0:	b004      	add	sp, #16
 8017bd2:	4770      	bx	lr
 8017bd4:	00800100 	.word	0x00800100
 8017bd8:	803c3800 	.word	0x803c3800

08017bdc <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
 8017bdc:	b480      	push	{r7}
 8017bde:	b085      	sub	sp, #20
 8017be0:	af00      	add	r7, sp, #0
 8017be2:	6078      	str	r0, [r7, #4]
 8017be4:	6039      	str	r1, [r7, #0]
  uint32_t count = 0U;
 8017be6:	2300      	movs	r3, #0
 8017be8:	60fb      	str	r3, [r7, #12]
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 8017bea:	683b      	ldr	r3, [r7, #0]
 8017bec:	019b      	lsls	r3, r3, #6
 8017bee:	f043 0220 	orr.w	r2, r3, #32
 8017bf2:	687b      	ldr	r3, [r7, #4]
 8017bf4:	611a      	str	r2, [r3, #16]
 
  do
  {
    if (++count > 200000U)
 8017bf6:	68fb      	ldr	r3, [r7, #12]
 8017bf8:	3301      	adds	r3, #1
 8017bfa:	60fb      	str	r3, [r7, #12]
 8017bfc:	68fb      	ldr	r3, [r7, #12]
 8017bfe:	4a09      	ldr	r2, [pc, #36]	; (8017c24 <USB_FlushTxFifo+0x48>)
 8017c00:	4293      	cmp	r3, r2
 8017c02:	d901      	bls.n	8017c08 <USB_FlushTxFifo+0x2c>
    {
      return HAL_TIMEOUT;
 8017c04:	2303      	movs	r3, #3
 8017c06:	e006      	b.n	8017c16 <USB_FlushTxFifo+0x3a>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8017c08:	687b      	ldr	r3, [r7, #4]
 8017c0a:	691b      	ldr	r3, [r3, #16]
 8017c0c:	f003 0320 	and.w	r3, r3, #32
 8017c10:	2b20      	cmp	r3, #32
 8017c12:	d0f0      	beq.n	8017bf6 <USB_FlushTxFifo+0x1a>
  
  return HAL_OK;
 8017c14:	2300      	movs	r3, #0
}
 8017c16:	4618      	mov	r0, r3
 8017c18:	3714      	adds	r7, #20
 8017c1a:	46bd      	mov	sp, r7
 8017c1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c20:	4770      	bx	lr
 8017c22:	bf00      	nop
 8017c24:	00030d40 	.word	0x00030d40

08017c28 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo : Flush Rx FIFO
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8017c28:	b480      	push	{r7}
 8017c2a:	b085      	sub	sp, #20
 8017c2c:	af00      	add	r7, sp, #0
 8017c2e:	6078      	str	r0, [r7, #4]
  uint32_t count = 0U;
 8017c30:	2300      	movs	r3, #0
 8017c32:	60fb      	str	r3, [r7, #12]
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8017c34:	687b      	ldr	r3, [r7, #4]
 8017c36:	2210      	movs	r2, #16
 8017c38:	611a      	str	r2, [r3, #16]
  
  do
  {
    if (++count > 200000U)
 8017c3a:	68fb      	ldr	r3, [r7, #12]
 8017c3c:	3301      	adds	r3, #1
 8017c3e:	60fb      	str	r3, [r7, #12]
 8017c40:	68fb      	ldr	r3, [r7, #12]
 8017c42:	4a09      	ldr	r2, [pc, #36]	; (8017c68 <USB_FlushRxFifo+0x40>)
 8017c44:	4293      	cmp	r3, r2
 8017c46:	d901      	bls.n	8017c4c <USB_FlushRxFifo+0x24>
    {
      return HAL_TIMEOUT;
 8017c48:	2303      	movs	r3, #3
 8017c4a:	e006      	b.n	8017c5a <USB_FlushRxFifo+0x32>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8017c4c:	687b      	ldr	r3, [r7, #4]
 8017c4e:	691b      	ldr	r3, [r3, #16]
 8017c50:	f003 0310 	and.w	r3, r3, #16
 8017c54:	2b10      	cmp	r3, #16
 8017c56:	d0f0      	beq.n	8017c3a <USB_FlushRxFifo+0x12>
  
  return HAL_OK;
 8017c58:	2300      	movs	r3, #0
}
 8017c5a:	4618      	mov	r0, r3
 8017c5c:	3714      	adds	r7, #20
 8017c5e:	46bd      	mov	sp, r7
 8017c60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c64:	4770      	bx	lr
 8017c66:	bf00      	nop
 8017c68:	00030d40 	.word	0x00030d40

08017c6c <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
 8017c6c:	b480      	push	{r7}
 8017c6e:	b083      	sub	sp, #12
 8017c70:	af00      	add	r7, sp, #0
 8017c72:	6078      	str	r0, [r7, #4]
 8017c74:	460b      	mov	r3, r1
 8017c76:	70fb      	strb	r3, [r7, #3]
  USBx_DEVICE->DCFG |= speed;
 8017c78:	687b      	ldr	r3, [r7, #4]
 8017c7a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017c7e:	681a      	ldr	r2, [r3, #0]
 8017c80:	78fb      	ldrb	r3, [r7, #3]
 8017c82:	6879      	ldr	r1, [r7, #4]
 8017c84:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017c88:	4313      	orrs	r3, r2
 8017c8a:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 8017c8c:	2300      	movs	r3, #0
}
 8017c8e:	4618      	mov	r0, r3
 8017c90:	370c      	adds	r7, #12
 8017c92:	46bd      	mov	sp, r7
 8017c94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017c98:	4770      	bx	lr

08017c9a <USB_GetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH: High speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 8017c9a:	b480      	push	{r7}
 8017c9c:	b085      	sub	sp, #20
 8017c9e:	af00      	add	r7, sp, #0
 8017ca0:	6078      	str	r0, [r7, #4]
  uint8_t speed = 0U;
 8017ca2:	2300      	movs	r3, #0
 8017ca4:	73fb      	strb	r3, [r7, #15]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8017ca6:	687b      	ldr	r3, [r7, #4]
 8017ca8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017cac:	689b      	ldr	r3, [r3, #8]
 8017cae:	f003 0306 	and.w	r3, r3, #6
 8017cb2:	2b00      	cmp	r3, #0
 8017cb4:	d102      	bne.n	8017cbc <USB_GetDevSpeed+0x22>
  {
    speed = USB_OTG_SPEED_HIGH;
 8017cb6:	2300      	movs	r3, #0
 8017cb8:	73fb      	strb	r3, [r7, #15]
 8017cba:	e01c      	b.n	8017cf6 <USB_GetDevSpeed+0x5c>
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8017cbc:	687b      	ldr	r3, [r7, #4]
 8017cbe:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017cc2:	689b      	ldr	r3, [r3, #8]
 8017cc4:	f003 0306 	and.w	r3, r3, #6
 8017cc8:	2b02      	cmp	r3, #2
 8017cca:	d007      	beq.n	8017cdc <USB_GetDevSpeed+0x42>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8017ccc:	687b      	ldr	r3, [r7, #4]
 8017cce:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017cd2:	689b      	ldr	r3, [r3, #8]
 8017cd4:	f003 0306 	and.w	r3, r3, #6
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 8017cd8:	2b06      	cmp	r3, #6
 8017cda:	d102      	bne.n	8017ce2 <USB_GetDevSpeed+0x48>
  {
    speed = USB_OTG_SPEED_FULL;
 8017cdc:	2303      	movs	r3, #3
 8017cde:	73fb      	strb	r3, [r7, #15]
 8017ce0:	e009      	b.n	8017cf6 <USB_GetDevSpeed+0x5c>
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8017ce2:	687b      	ldr	r3, [r7, #4]
 8017ce4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017ce8:	689b      	ldr	r3, [r3, #8]
 8017cea:	f003 0306 	and.w	r3, r3, #6
 8017cee:	2b04      	cmp	r3, #4
 8017cf0:	d101      	bne.n	8017cf6 <USB_GetDevSpeed+0x5c>
  {
    speed = USB_OTG_SPEED_LOW;
 8017cf2:	2302      	movs	r3, #2
 8017cf4:	73fb      	strb	r3, [r7, #15]
  }
  
  return speed;
 8017cf6:	7bfb      	ldrb	r3, [r7, #15]
}
 8017cf8:	4618      	mov	r0, r3
 8017cfa:	3714      	adds	r7, #20
 8017cfc:	46bd      	mov	sp, r7
 8017cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017d02:	4770      	bx	lr

08017d04 <USB_ActivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8017d04:	b480      	push	{r7}
 8017d06:	b083      	sub	sp, #12
 8017d08:	af00      	add	r7, sp, #0
 8017d0a:	6078      	str	r0, [r7, #4]
 8017d0c:	6039      	str	r1, [r7, #0]
  if (ep->is_in == 1U)
 8017d0e:	683b      	ldr	r3, [r7, #0]
 8017d10:	785b      	ldrb	r3, [r3, #1]
 8017d12:	2b01      	cmp	r3, #1
 8017d14:	d13c      	bne.n	8017d90 <USB_ActivateEndpoint+0x8c>
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8017d16:	687b      	ldr	r3, [r7, #4]
 8017d18:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017d1c:	69da      	ldr	r2, [r3, #28]
 8017d1e:	683b      	ldr	r3, [r7, #0]
 8017d20:	781b      	ldrb	r3, [r3, #0]
 8017d22:	4619      	mov	r1, r3
 8017d24:	2301      	movs	r3, #1
 8017d26:	408b      	lsls	r3, r1
 8017d28:	b29b      	uxth	r3, r3
 8017d2a:	6879      	ldr	r1, [r7, #4]
 8017d2c:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017d30:	4313      	orrs	r3, r2
 8017d32:	61cb      	str	r3, [r1, #28]
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8017d34:	683b      	ldr	r3, [r7, #0]
 8017d36:	781b      	ldrb	r3, [r3, #0]
 8017d38:	015a      	lsls	r2, r3, #5
 8017d3a:	687b      	ldr	r3, [r7, #4]
 8017d3c:	4413      	add	r3, r2
 8017d3e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017d42:	681b      	ldr	r3, [r3, #0]
 8017d44:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8017d48:	2b00      	cmp	r3, #0
 8017d4a:	d159      	bne.n	8017e00 <USB_ActivateEndpoint+0xfc>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8017d4c:	683b      	ldr	r3, [r7, #0]
 8017d4e:	781b      	ldrb	r3, [r3, #0]
 8017d50:	015a      	lsls	r2, r3, #5
 8017d52:	687b      	ldr	r3, [r7, #4]
 8017d54:	4413      	add	r3, r2
 8017d56:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017d5a:	681a      	ldr	r2, [r3, #0]
 8017d5c:	683b      	ldr	r3, [r7, #0]
 8017d5e:	689b      	ldr	r3, [r3, #8]
 8017d60:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8017d64:	6839      	ldr	r1, [r7, #0]
 8017d66:	78c9      	ldrb	r1, [r1, #3]
 8017d68:	0489      	lsls	r1, r1, #18
 8017d6a:	430b      	orrs	r3, r1
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
 8017d6c:	6839      	ldr	r1, [r7, #0]
 8017d6e:	7809      	ldrb	r1, [r1, #0]
 8017d70:	0589      	lsls	r1, r1, #22
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8017d72:	430b      	orrs	r3, r1
 8017d74:	4313      	orrs	r3, r2
 8017d76:	683a      	ldr	r2, [r7, #0]
 8017d78:	7812      	ldrb	r2, [r2, #0]
 8017d7a:	0151      	lsls	r1, r2, #5
 8017d7c:	687a      	ldr	r2, [r7, #4]
 8017d7e:	440a      	add	r2, r1
 8017d80:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017d84:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8017d88:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8017d8c:	6013      	str	r3, [r2, #0]
 8017d8e:	e037      	b.n	8017e00 <USB_ActivateEndpoint+0xfc>
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 8017d90:	687b      	ldr	r3, [r7, #4]
 8017d92:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017d96:	69da      	ldr	r2, [r3, #28]
 8017d98:	683b      	ldr	r3, [r7, #0]
 8017d9a:	781b      	ldrb	r3, [r3, #0]
 8017d9c:	4619      	mov	r1, r3
 8017d9e:	2301      	movs	r3, #1
 8017da0:	408b      	lsls	r3, r1
 8017da2:	041b      	lsls	r3, r3, #16
 8017da4:	6879      	ldr	r1, [r7, #4]
 8017da6:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017daa:	4313      	orrs	r3, r2
 8017dac:	61cb      	str	r3, [r1, #28]
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8017dae:	683b      	ldr	r3, [r7, #0]
 8017db0:	781b      	ldrb	r3, [r3, #0]
 8017db2:	015a      	lsls	r2, r3, #5
 8017db4:	687b      	ldr	r3, [r7, #4]
 8017db6:	4413      	add	r3, r2
 8017db8:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017dbc:	681b      	ldr	r3, [r3, #0]
 8017dbe:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8017dc2:	2b00      	cmp	r3, #0
 8017dc4:	d11c      	bne.n	8017e00 <USB_ActivateEndpoint+0xfc>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 8017dc6:	683b      	ldr	r3, [r7, #0]
 8017dc8:	781b      	ldrb	r3, [r3, #0]
 8017dca:	015a      	lsls	r2, r3, #5
 8017dcc:	687b      	ldr	r3, [r7, #4]
 8017dce:	4413      	add	r3, r2
 8017dd0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017dd4:	681a      	ldr	r2, [r3, #0]
 8017dd6:	683b      	ldr	r3, [r7, #0]
 8017dd8:	689b      	ldr	r3, [r3, #8]
 8017dda:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8017dde:	6839      	ldr	r1, [r7, #0]
 8017de0:	78c9      	ldrb	r1, [r1, #3]
 8017de2:	0489      	lsls	r1, r1, #18
 8017de4:	430b      	orrs	r3, r1
 8017de6:	4313      	orrs	r3, r2
 8017de8:	683a      	ldr	r2, [r7, #0]
 8017dea:	7812      	ldrb	r2, [r2, #0]
 8017dec:	0151      	lsls	r1, r2, #5
 8017dee:	687a      	ldr	r2, [r7, #4]
 8017df0:	440a      	add	r2, r1
 8017df2:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8017df6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8017dfa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8017dfe:	6013      	str	r3, [r2, #0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
 8017e00:	2300      	movs	r3, #0
}
 8017e02:	4618      	mov	r0, r3
 8017e04:	370c      	adds	r7, #12
 8017e06:	46bd      	mov	sp, r7
 8017e08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017e0c:	4770      	bx	lr

08017e0e <USB_DeactivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8017e0e:	b480      	push	{r7}
 8017e10:	b083      	sub	sp, #12
 8017e12:	af00      	add	r7, sp, #0
 8017e14:	6078      	str	r0, [r7, #4]
 8017e16:	6039      	str	r1, [r7, #0]
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8017e18:	683b      	ldr	r3, [r7, #0]
 8017e1a:	785b      	ldrb	r3, [r3, #1]
 8017e1c:	2b01      	cmp	r3, #1
 8017e1e:	d132      	bne.n	8017e86 <USB_DeactivateEndpoint+0x78>
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 8017e20:	687b      	ldr	r3, [r7, #4]
 8017e22:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017e26:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8017e28:	683b      	ldr	r3, [r7, #0]
 8017e2a:	781b      	ldrb	r3, [r3, #0]
 8017e2c:	4619      	mov	r1, r3
 8017e2e:	2301      	movs	r3, #1
 8017e30:	408b      	lsls	r3, r1
 8017e32:	b29b      	uxth	r3, r3
 8017e34:	43db      	mvns	r3, r3
 8017e36:	6879      	ldr	r1, [r7, #4]
 8017e38:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017e3c:	4013      	ands	r3, r2
 8017e3e:	63cb      	str	r3, [r1, #60]	; 0x3c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 8017e40:	687b      	ldr	r3, [r7, #4]
 8017e42:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017e46:	69da      	ldr	r2, [r3, #28]
 8017e48:	683b      	ldr	r3, [r7, #0]
 8017e4a:	781b      	ldrb	r3, [r3, #0]
 8017e4c:	4619      	mov	r1, r3
 8017e4e:	2301      	movs	r3, #1
 8017e50:	408b      	lsls	r3, r1
 8017e52:	b29b      	uxth	r3, r3
 8017e54:	43db      	mvns	r3, r3
 8017e56:	6879      	ldr	r1, [r7, #4]
 8017e58:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017e5c:	4013      	ands	r3, r2
 8017e5e:	61cb      	str	r3, [r1, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 8017e60:	683b      	ldr	r3, [r7, #0]
 8017e62:	781b      	ldrb	r3, [r3, #0]
 8017e64:	015a      	lsls	r2, r3, #5
 8017e66:	687b      	ldr	r3, [r7, #4]
 8017e68:	4413      	add	r3, r2
 8017e6a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017e6e:	681b      	ldr	r3, [r3, #0]
 8017e70:	683a      	ldr	r2, [r7, #0]
 8017e72:	7812      	ldrb	r2, [r2, #0]
 8017e74:	0151      	lsls	r1, r2, #5
 8017e76:	687a      	ldr	r2, [r7, #4]
 8017e78:	440a      	add	r2, r1
 8017e7a:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017e7e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8017e82:	6013      	str	r3, [r2, #0]
 8017e84:	e031      	b.n	8017eea <USB_DeactivateEndpoint+0xdc>
  }
  else
  {
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
 8017e86:	687b      	ldr	r3, [r7, #4]
 8017e88:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017e8c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8017e8e:	683b      	ldr	r3, [r7, #0]
 8017e90:	781b      	ldrb	r3, [r3, #0]
 8017e92:	4619      	mov	r1, r3
 8017e94:	2301      	movs	r3, #1
 8017e96:	408b      	lsls	r3, r1
 8017e98:	041b      	lsls	r3, r3, #16
 8017e9a:	43db      	mvns	r3, r3
 8017e9c:	6879      	ldr	r1, [r7, #4]
 8017e9e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017ea2:	4013      	ands	r3, r2
 8017ea4:	63cb      	str	r3, [r1, #60]	; 0x3c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));     
 8017ea6:	687b      	ldr	r3, [r7, #4]
 8017ea8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8017eac:	69da      	ldr	r2, [r3, #28]
 8017eae:	683b      	ldr	r3, [r7, #0]
 8017eb0:	781b      	ldrb	r3, [r3, #0]
 8017eb2:	4619      	mov	r1, r3
 8017eb4:	2301      	movs	r3, #1
 8017eb6:	408b      	lsls	r3, r1
 8017eb8:	041b      	lsls	r3, r3, #16
 8017eba:	43db      	mvns	r3, r3
 8017ebc:	6879      	ldr	r1, [r7, #4]
 8017ebe:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8017ec2:	4013      	ands	r3, r2
 8017ec4:	61cb      	str	r3, [r1, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 8017ec6:	683b      	ldr	r3, [r7, #0]
 8017ec8:	781b      	ldrb	r3, [r3, #0]
 8017eca:	015a      	lsls	r2, r3, #5
 8017ecc:	687b      	ldr	r3, [r7, #4]
 8017ece:	4413      	add	r3, r2
 8017ed0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8017ed4:	681b      	ldr	r3, [r3, #0]
 8017ed6:	683a      	ldr	r2, [r7, #0]
 8017ed8:	7812      	ldrb	r2, [r2, #0]
 8017eda:	0151      	lsls	r1, r2, #5
 8017edc:	687a      	ldr	r2, [r7, #4]
 8017ede:	440a      	add	r2, r1
 8017ee0:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8017ee4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8017ee8:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 8017eea:	2300      	movs	r3, #0
}
 8017eec:	4618      	mov	r0, r3
 8017eee:	370c      	adds	r7, #12
 8017ef0:	46bd      	mov	sp, r7
 8017ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017ef6:	4770      	bx	lr

08017ef8 <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8017ef8:	b580      	push	{r7, lr}
 8017efa:	b088      	sub	sp, #32
 8017efc:	af02      	add	r7, sp, #8
 8017efe:	60f8      	str	r0, [r7, #12]
 8017f00:	60b9      	str	r1, [r7, #8]
 8017f02:	4613      	mov	r3, r2
 8017f04:	71fb      	strb	r3, [r7, #7]
  uint16_t pktcnt = 0U;
 8017f06:	2300      	movs	r3, #0
 8017f08:	82fb      	strh	r3, [r7, #22]
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8017f0a:	68bb      	ldr	r3, [r7, #8]
 8017f0c:	785b      	ldrb	r3, [r3, #1]
 8017f0e:	2b01      	cmp	r3, #1
 8017f10:	f040 8139 	bne.w	8018186 <USB_EPStartXfer+0x28e>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8017f14:	68bb      	ldr	r3, [r7, #8]
 8017f16:	695b      	ldr	r3, [r3, #20]
 8017f18:	2b00      	cmp	r3, #0
 8017f1a:	d138      	bne.n	8017f8e <USB_EPStartXfer+0x96>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8017f1c:	68bb      	ldr	r3, [r7, #8]
 8017f1e:	781b      	ldrb	r3, [r3, #0]
 8017f20:	015a      	lsls	r2, r3, #5
 8017f22:	68fb      	ldr	r3, [r7, #12]
 8017f24:	4413      	add	r3, r2
 8017f26:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017f2a:	691b      	ldr	r3, [r3, #16]
 8017f2c:	68ba      	ldr	r2, [r7, #8]
 8017f2e:	7812      	ldrb	r2, [r2, #0]
 8017f30:	0151      	lsls	r1, r2, #5
 8017f32:	68fa      	ldr	r2, [r7, #12]
 8017f34:	440a      	add	r2, r1
 8017f36:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017f3a:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8017f3e:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8017f42:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8017f44:	68bb      	ldr	r3, [r7, #8]
 8017f46:	781b      	ldrb	r3, [r3, #0]
 8017f48:	015a      	lsls	r2, r3, #5
 8017f4a:	68fb      	ldr	r3, [r7, #12]
 8017f4c:	4413      	add	r3, r2
 8017f4e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017f52:	691b      	ldr	r3, [r3, #16]
 8017f54:	68ba      	ldr	r2, [r7, #8]
 8017f56:	7812      	ldrb	r2, [r2, #0]
 8017f58:	0151      	lsls	r1, r2, #5
 8017f5a:	68fa      	ldr	r2, [r7, #12]
 8017f5c:	440a      	add	r2, r1
 8017f5e:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017f62:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8017f66:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8017f68:	68bb      	ldr	r3, [r7, #8]
 8017f6a:	781b      	ldrb	r3, [r3, #0]
 8017f6c:	015a      	lsls	r2, r3, #5
 8017f6e:	68fb      	ldr	r3, [r7, #12]
 8017f70:	4413      	add	r3, r2
 8017f72:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017f76:	691b      	ldr	r3, [r3, #16]
 8017f78:	68ba      	ldr	r2, [r7, #8]
 8017f7a:	7812      	ldrb	r2, [r2, #0]
 8017f7c:	0151      	lsls	r1, r2, #5
 8017f7e:	68fa      	ldr	r2, [r7, #12]
 8017f80:	440a      	add	r2, r1
 8017f82:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017f86:	0cdb      	lsrs	r3, r3, #19
 8017f88:	04db      	lsls	r3, r3, #19
 8017f8a:	6113      	str	r3, [r2, #16]
 8017f8c:	e080      	b.n	8018090 <USB_EPStartXfer+0x198>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8017f8e:	68bb      	ldr	r3, [r7, #8]
 8017f90:	781b      	ldrb	r3, [r3, #0]
 8017f92:	015a      	lsls	r2, r3, #5
 8017f94:	68fb      	ldr	r3, [r7, #12]
 8017f96:	4413      	add	r3, r2
 8017f98:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017f9c:	691b      	ldr	r3, [r3, #16]
 8017f9e:	68ba      	ldr	r2, [r7, #8]
 8017fa0:	7812      	ldrb	r2, [r2, #0]
 8017fa2:	0151      	lsls	r1, r2, #5
 8017fa4:	68fa      	ldr	r2, [r7, #12]
 8017fa6:	440a      	add	r2, r1
 8017fa8:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017fac:	0cdb      	lsrs	r3, r3, #19
 8017fae:	04db      	lsls	r3, r3, #19
 8017fb0:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8017fb2:	68bb      	ldr	r3, [r7, #8]
 8017fb4:	781b      	ldrb	r3, [r3, #0]
 8017fb6:	015a      	lsls	r2, r3, #5
 8017fb8:	68fb      	ldr	r3, [r7, #12]
 8017fba:	4413      	add	r3, r2
 8017fbc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017fc0:	691b      	ldr	r3, [r3, #16]
 8017fc2:	68ba      	ldr	r2, [r7, #8]
 8017fc4:	7812      	ldrb	r2, [r2, #0]
 8017fc6:	0151      	lsls	r1, r2, #5
 8017fc8:	68fa      	ldr	r2, [r7, #12]
 8017fca:	440a      	add	r2, r1
 8017fcc:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8017fd0:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8017fd4:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8017fd8:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8017fda:	68bb      	ldr	r3, [r7, #8]
 8017fdc:	781b      	ldrb	r3, [r3, #0]
 8017fde:	015a      	lsls	r2, r3, #5
 8017fe0:	68fb      	ldr	r3, [r7, #12]
 8017fe2:	4413      	add	r3, r2
 8017fe4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8017fe8:	691a      	ldr	r2, [r3, #16]
 8017fea:	68bb      	ldr	r3, [r7, #8]
 8017fec:	6959      	ldr	r1, [r3, #20]
 8017fee:	68bb      	ldr	r3, [r7, #8]
 8017ff0:	689b      	ldr	r3, [r3, #8]
 8017ff2:	440b      	add	r3, r1
 8017ff4:	1e59      	subs	r1, r3, #1
 8017ff6:	68bb      	ldr	r3, [r7, #8]
 8017ff8:	689b      	ldr	r3, [r3, #8]
 8017ffa:	fbb1 f3f3 	udiv	r3, r1, r3
 8017ffe:	04d9      	lsls	r1, r3, #19
 8018000:	4b8a      	ldr	r3, [pc, #552]	; (801822c <USB_EPStartXfer+0x334>)
 8018002:	400b      	ands	r3, r1
 8018004:	68b9      	ldr	r1, [r7, #8]
 8018006:	7809      	ldrb	r1, [r1, #0]
 8018008:	0148      	lsls	r0, r1, #5
 801800a:	68f9      	ldr	r1, [r7, #12]
 801800c:	4401      	add	r1, r0
 801800e:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 8018012:	4313      	orrs	r3, r2
 8018014:	610b      	str	r3, [r1, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8018016:	68bb      	ldr	r3, [r7, #8]
 8018018:	781b      	ldrb	r3, [r3, #0]
 801801a:	015a      	lsls	r2, r3, #5
 801801c:	68fb      	ldr	r3, [r7, #12]
 801801e:	4413      	add	r3, r2
 8018020:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018024:	691a      	ldr	r2, [r3, #16]
 8018026:	68bb      	ldr	r3, [r7, #8]
 8018028:	695b      	ldr	r3, [r3, #20]
 801802a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 801802e:	68b9      	ldr	r1, [r7, #8]
 8018030:	7809      	ldrb	r1, [r1, #0]
 8018032:	0148      	lsls	r0, r1, #5
 8018034:	68f9      	ldr	r1, [r7, #12]
 8018036:	4401      	add	r1, r0
 8018038:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 801803c:	4313      	orrs	r3, r2
 801803e:	610b      	str	r3, [r1, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 8018040:	68bb      	ldr	r3, [r7, #8]
 8018042:	78db      	ldrb	r3, [r3, #3]
 8018044:	2b01      	cmp	r3, #1
 8018046:	d123      	bne.n	8018090 <USB_EPStartXfer+0x198>
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 8018048:	68bb      	ldr	r3, [r7, #8]
 801804a:	781b      	ldrb	r3, [r3, #0]
 801804c:	015a      	lsls	r2, r3, #5
 801804e:	68fb      	ldr	r3, [r7, #12]
 8018050:	4413      	add	r3, r2
 8018052:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018056:	691b      	ldr	r3, [r3, #16]
 8018058:	68ba      	ldr	r2, [r7, #8]
 801805a:	7812      	ldrb	r2, [r2, #0]
 801805c:	0151      	lsls	r1, r2, #5
 801805e:	68fa      	ldr	r2, [r7, #12]
 8018060:	440a      	add	r2, r1
 8018062:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018066:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 801806a:	6113      	str	r3, [r2, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 801806c:	68bb      	ldr	r3, [r7, #8]
 801806e:	781b      	ldrb	r3, [r3, #0]
 8018070:	015a      	lsls	r2, r3, #5
 8018072:	68fb      	ldr	r3, [r7, #12]
 8018074:	4413      	add	r3, r2
 8018076:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 801807a:	691b      	ldr	r3, [r3, #16]
 801807c:	68ba      	ldr	r2, [r7, #8]
 801807e:	7812      	ldrb	r2, [r2, #0]
 8018080:	0151      	lsls	r1, r2, #5
 8018082:	68fa      	ldr	r2, [r7, #12]
 8018084:	440a      	add	r2, r1
 8018086:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 801808a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 801808e:	6113      	str	r3, [r2, #16]
      }       
    }

    if (dma == 1U)
 8018090:	79fb      	ldrb	r3, [r7, #7]
 8018092:	2b01      	cmp	r3, #1
 8018094:	d10b      	bne.n	80180ae <USB_EPStartXfer+0x1b6>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8018096:	68bb      	ldr	r3, [r7, #8]
 8018098:	781b      	ldrb	r3, [r3, #0]
 801809a:	015a      	lsls	r2, r3, #5
 801809c:	68fb      	ldr	r3, [r7, #12]
 801809e:	4413      	add	r3, r2
 80180a0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80180a4:	461a      	mov	r2, r3
 80180a6:	68bb      	ldr	r3, [r7, #8]
 80180a8:	691b      	ldr	r3, [r3, #16]
 80180aa:	6153      	str	r3, [r2, #20]
 80180ac:	e015      	b.n	80180da <USB_EPStartXfer+0x1e2>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 80180ae:	68bb      	ldr	r3, [r7, #8]
 80180b0:	78db      	ldrb	r3, [r3, #3]
 80180b2:	2b01      	cmp	r3, #1
 80180b4:	d011      	beq.n	80180da <USB_EPStartXfer+0x1e2>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 80180b6:	68bb      	ldr	r3, [r7, #8]
 80180b8:	695b      	ldr	r3, [r3, #20]
 80180ba:	2b00      	cmp	r3, #0
 80180bc:	d00d      	beq.n	80180da <USB_EPStartXfer+0x1e2>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 80180be:	68fb      	ldr	r3, [r7, #12]
 80180c0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80180c4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80180c6:	68bb      	ldr	r3, [r7, #8]
 80180c8:	781b      	ldrb	r3, [r3, #0]
 80180ca:	4619      	mov	r1, r3
 80180cc:	2301      	movs	r3, #1
 80180ce:	408b      	lsls	r3, r1
 80180d0:	68f9      	ldr	r1, [r7, #12]
 80180d2:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80180d6:	4313      	orrs	r3, r2
 80180d8:	634b      	str	r3, [r1, #52]	; 0x34
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 80180da:	68bb      	ldr	r3, [r7, #8]
 80180dc:	78db      	ldrb	r3, [r3, #3]
 80180de:	2b01      	cmp	r3, #1
 80180e0:	d12c      	bne.n	801813c <USB_EPStartXfer+0x244>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 80180e2:	68fb      	ldr	r3, [r7, #12]
 80180e4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80180e8:	689b      	ldr	r3, [r3, #8]
 80180ea:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80180ee:	2b00      	cmp	r3, #0
 80180f0:	d112      	bne.n	8018118 <USB_EPStartXfer+0x220>
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80180f2:	68bb      	ldr	r3, [r7, #8]
 80180f4:	781b      	ldrb	r3, [r3, #0]
 80180f6:	015a      	lsls	r2, r3, #5
 80180f8:	68fb      	ldr	r3, [r7, #12]
 80180fa:	4413      	add	r3, r2
 80180fc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018100:	681b      	ldr	r3, [r3, #0]
 8018102:	68ba      	ldr	r2, [r7, #8]
 8018104:	7812      	ldrb	r2, [r2, #0]
 8018106:	0151      	lsls	r1, r2, #5
 8018108:	68fa      	ldr	r2, [r7, #12]
 801810a:	440a      	add	r2, r1
 801810c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018110:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8018114:	6013      	str	r3, [r2, #0]
 8018116:	e011      	b.n	801813c <USB_EPStartXfer+0x244>
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8018118:	68bb      	ldr	r3, [r7, #8]
 801811a:	781b      	ldrb	r3, [r3, #0]
 801811c:	015a      	lsls	r2, r3, #5
 801811e:	68fb      	ldr	r3, [r7, #12]
 8018120:	4413      	add	r3, r2
 8018122:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018126:	681b      	ldr	r3, [r3, #0]
 8018128:	68ba      	ldr	r2, [r7, #8]
 801812a:	7812      	ldrb	r2, [r2, #0]
 801812c:	0151      	lsls	r1, r2, #5
 801812e:	68fa      	ldr	r2, [r7, #12]
 8018130:	440a      	add	r2, r1
 8018132:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018136:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801813a:	6013      	str	r3, [r2, #0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801813c:	68bb      	ldr	r3, [r7, #8]
 801813e:	781b      	ldrb	r3, [r3, #0]
 8018140:	015a      	lsls	r2, r3, #5
 8018142:	68fb      	ldr	r3, [r7, #12]
 8018144:	4413      	add	r3, r2
 8018146:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 801814a:	681b      	ldr	r3, [r3, #0]
 801814c:	68ba      	ldr	r2, [r7, #8]
 801814e:	7812      	ldrb	r2, [r2, #0]
 8018150:	0151      	lsls	r1, r2, #5
 8018152:	68fa      	ldr	r2, [r7, #12]
 8018154:	440a      	add	r2, r1
 8018156:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 801815a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 801815e:	6013      	str	r3, [r2, #0]
    
    if (ep->type == EP_TYPE_ISOC)
 8018160:	68bb      	ldr	r3, [r7, #8]
 8018162:	78db      	ldrb	r3, [r3, #3]
 8018164:	2b01      	cmp	r3, #1
 8018166:	f040 80ed 	bne.w	8018344 <USB_EPStartXfer+0x44c>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 801816a:	68bb      	ldr	r3, [r7, #8]
 801816c:	68d9      	ldr	r1, [r3, #12]
 801816e:	68bb      	ldr	r3, [r7, #8]
 8018170:	781a      	ldrb	r2, [r3, #0]
 8018172:	68bb      	ldr	r3, [r7, #8]
 8018174:	695b      	ldr	r3, [r3, #20]
 8018176:	b298      	uxth	r0, r3
 8018178:	79fb      	ldrb	r3, [r7, #7]
 801817a:	9300      	str	r3, [sp, #0]
 801817c:	4603      	mov	r3, r0
 801817e:	68f8      	ldr	r0, [r7, #12]
 8018180:	f000 fa38 	bl	80185f4 <USB_WritePacket>
 8018184:	e0de      	b.n	8018344 <USB_EPStartXfer+0x44c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8018186:	68bb      	ldr	r3, [r7, #8]
 8018188:	781b      	ldrb	r3, [r3, #0]
 801818a:	015a      	lsls	r2, r3, #5
 801818c:	68fb      	ldr	r3, [r7, #12]
 801818e:	4413      	add	r3, r2
 8018190:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018194:	691b      	ldr	r3, [r3, #16]
 8018196:	68ba      	ldr	r2, [r7, #8]
 8018198:	7812      	ldrb	r2, [r2, #0]
 801819a:	0151      	lsls	r1, r2, #5
 801819c:	68fa      	ldr	r2, [r7, #12]
 801819e:	440a      	add	r2, r1
 80181a0:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80181a4:	0cdb      	lsrs	r3, r3, #19
 80181a6:	04db      	lsls	r3, r3, #19
 80181a8:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 80181aa:	68bb      	ldr	r3, [r7, #8]
 80181ac:	781b      	ldrb	r3, [r3, #0]
 80181ae:	015a      	lsls	r2, r3, #5
 80181b0:	68fb      	ldr	r3, [r7, #12]
 80181b2:	4413      	add	r3, r2
 80181b4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80181b8:	691b      	ldr	r3, [r3, #16]
 80181ba:	68ba      	ldr	r2, [r7, #8]
 80181bc:	7812      	ldrb	r2, [r2, #0]
 80181be:	0151      	lsls	r1, r2, #5
 80181c0:	68fa      	ldr	r2, [r7, #12]
 80181c2:	440a      	add	r2, r1
 80181c4:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80181c8:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80181cc:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80181d0:	6113      	str	r3, [r2, #16]

    if (ep->xfer_len == 0U)
 80181d2:	68bb      	ldr	r3, [r7, #8]
 80181d4:	695b      	ldr	r3, [r3, #20]
 80181d6:	2b00      	cmp	r3, #0
 80181d8:	d12a      	bne.n	8018230 <USB_EPStartXfer+0x338>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80181da:	68bb      	ldr	r3, [r7, #8]
 80181dc:	781b      	ldrb	r3, [r3, #0]
 80181de:	015a      	lsls	r2, r3, #5
 80181e0:	68fb      	ldr	r3, [r7, #12]
 80181e2:	4413      	add	r3, r2
 80181e4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80181e8:	691a      	ldr	r2, [r3, #16]
 80181ea:	68bb      	ldr	r3, [r7, #8]
 80181ec:	689b      	ldr	r3, [r3, #8]
 80181ee:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80181f2:	68b9      	ldr	r1, [r7, #8]
 80181f4:	7809      	ldrb	r1, [r1, #0]
 80181f6:	0148      	lsls	r0, r1, #5
 80181f8:	68f9      	ldr	r1, [r7, #12]
 80181fa:	4401      	add	r1, r0
 80181fc:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 8018200:	4313      	orrs	r3, r2
 8018202:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8018204:	68bb      	ldr	r3, [r7, #8]
 8018206:	781b      	ldrb	r3, [r3, #0]
 8018208:	015a      	lsls	r2, r3, #5
 801820a:	68fb      	ldr	r3, [r7, #12]
 801820c:	4413      	add	r3, r2
 801820e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018212:	691b      	ldr	r3, [r3, #16]
 8018214:	68ba      	ldr	r2, [r7, #8]
 8018216:	7812      	ldrb	r2, [r2, #0]
 8018218:	0151      	lsls	r1, r2, #5
 801821a:	68fa      	ldr	r2, [r7, #12]
 801821c:	440a      	add	r2, r1
 801821e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018222:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8018226:	6113      	str	r3, [r2, #16]
 8018228:	e03b      	b.n	80182a2 <USB_EPStartXfer+0x3aa>
 801822a:	bf00      	nop
 801822c:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8018230:	68bb      	ldr	r3, [r7, #8]
 8018232:	695a      	ldr	r2, [r3, #20]
 8018234:	68bb      	ldr	r3, [r7, #8]
 8018236:	689b      	ldr	r3, [r3, #8]
 8018238:	4413      	add	r3, r2
 801823a:	1e5a      	subs	r2, r3, #1
 801823c:	68bb      	ldr	r3, [r7, #8]
 801823e:	689b      	ldr	r3, [r3, #8]
 8018240:	fbb2 f3f3 	udiv	r3, r2, r3
 8018244:	82fb      	strh	r3, [r7, #22]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8018246:	68bb      	ldr	r3, [r7, #8]
 8018248:	781b      	ldrb	r3, [r3, #0]
 801824a:	015a      	lsls	r2, r3, #5
 801824c:	68fb      	ldr	r3, [r7, #12]
 801824e:	4413      	add	r3, r2
 8018250:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018254:	691a      	ldr	r2, [r3, #16]
 8018256:	8afb      	ldrh	r3, [r7, #22]
 8018258:	04db      	lsls	r3, r3, #19
 801825a:	4619      	mov	r1, r3
 801825c:	4b3c      	ldr	r3, [pc, #240]	; (8018350 <USB_EPStartXfer+0x458>)
 801825e:	400b      	ands	r3, r1
 8018260:	68b9      	ldr	r1, [r7, #8]
 8018262:	7809      	ldrb	r1, [r1, #0]
 8018264:	0148      	lsls	r0, r1, #5
 8018266:	68f9      	ldr	r1, [r7, #12]
 8018268:	4401      	add	r1, r0
 801826a:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 801826e:	4313      	orrs	r3, r2
 8018270:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 8018272:	68bb      	ldr	r3, [r7, #8]
 8018274:	781b      	ldrb	r3, [r3, #0]
 8018276:	015a      	lsls	r2, r3, #5
 8018278:	68fb      	ldr	r3, [r7, #12]
 801827a:	4413      	add	r3, r2
 801827c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018280:	691a      	ldr	r2, [r3, #16]
 8018282:	68bb      	ldr	r3, [r7, #8]
 8018284:	689b      	ldr	r3, [r3, #8]
 8018286:	8af9      	ldrh	r1, [r7, #22]
 8018288:	fb01 f303 	mul.w	r3, r1, r3
 801828c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8018290:	68b9      	ldr	r1, [r7, #8]
 8018292:	7809      	ldrb	r1, [r1, #0]
 8018294:	0148      	lsls	r0, r1, #5
 8018296:	68f9      	ldr	r1, [r7, #12]
 8018298:	4401      	add	r1, r0
 801829a:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 801829e:	4313      	orrs	r3, r2
 80182a0:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 80182a2:	79fb      	ldrb	r3, [r7, #7]
 80182a4:	2b01      	cmp	r3, #1
 80182a6:	d10a      	bne.n	80182be <USB_EPStartXfer+0x3c6>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 80182a8:	68bb      	ldr	r3, [r7, #8]
 80182aa:	68d9      	ldr	r1, [r3, #12]
 80182ac:	68bb      	ldr	r3, [r7, #8]
 80182ae:	781b      	ldrb	r3, [r3, #0]
 80182b0:	015a      	lsls	r2, r3, #5
 80182b2:	68fb      	ldr	r3, [r7, #12]
 80182b4:	4413      	add	r3, r2
 80182b6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80182ba:	460a      	mov	r2, r1
 80182bc:	615a      	str	r2, [r3, #20]
    }
    
    if (ep->type == EP_TYPE_ISOC)
 80182be:	68bb      	ldr	r3, [r7, #8]
 80182c0:	78db      	ldrb	r3, [r3, #3]
 80182c2:	2b01      	cmp	r3, #1
 80182c4:	d12c      	bne.n	8018320 <USB_EPStartXfer+0x428>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 80182c6:	68fb      	ldr	r3, [r7, #12]
 80182c8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80182cc:	689b      	ldr	r3, [r3, #8]
 80182ce:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80182d2:	2b00      	cmp	r3, #0
 80182d4:	d112      	bne.n	80182fc <USB_EPStartXfer+0x404>
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80182d6:	68bb      	ldr	r3, [r7, #8]
 80182d8:	781b      	ldrb	r3, [r3, #0]
 80182da:	015a      	lsls	r2, r3, #5
 80182dc:	68fb      	ldr	r3, [r7, #12]
 80182de:	4413      	add	r3, r2
 80182e0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80182e4:	681b      	ldr	r3, [r3, #0]
 80182e6:	68ba      	ldr	r2, [r7, #8]
 80182e8:	7812      	ldrb	r2, [r2, #0]
 80182ea:	0151      	lsls	r1, r2, #5
 80182ec:	68fa      	ldr	r2, [r7, #12]
 80182ee:	440a      	add	r2, r1
 80182f0:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80182f4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80182f8:	6013      	str	r3, [r2, #0]
 80182fa:	e011      	b.n	8018320 <USB_EPStartXfer+0x428>
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 80182fc:	68bb      	ldr	r3, [r7, #8]
 80182fe:	781b      	ldrb	r3, [r3, #0]
 8018300:	015a      	lsls	r2, r3, #5
 8018302:	68fb      	ldr	r3, [r7, #12]
 8018304:	4413      	add	r3, r2
 8018306:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801830a:	681b      	ldr	r3, [r3, #0]
 801830c:	68ba      	ldr	r2, [r7, #8]
 801830e:	7812      	ldrb	r2, [r2, #0]
 8018310:	0151      	lsls	r1, r2, #5
 8018312:	68fa      	ldr	r2, [r7, #12]
 8018314:	440a      	add	r2, r1
 8018316:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 801831a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 801831e:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8018320:	68bb      	ldr	r3, [r7, #8]
 8018322:	781b      	ldrb	r3, [r3, #0]
 8018324:	015a      	lsls	r2, r3, #5
 8018326:	68fb      	ldr	r3, [r7, #12]
 8018328:	4413      	add	r3, r2
 801832a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801832e:	681b      	ldr	r3, [r3, #0]
 8018330:	68ba      	ldr	r2, [r7, #8]
 8018332:	7812      	ldrb	r2, [r2, #0]
 8018334:	0151      	lsls	r1, r2, #5
 8018336:	68fa      	ldr	r2, [r7, #12]
 8018338:	440a      	add	r2, r1
 801833a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 801833e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8018342:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 8018344:	2300      	movs	r3, #0
}
 8018346:	4618      	mov	r0, r3
 8018348:	3718      	adds	r7, #24
 801834a:	46bd      	mov	sp, r7
 801834c:	bd80      	pop	{r7, pc}
 801834e:	bf00      	nop
 8018350:	1ff80000 	.word	0x1ff80000

08018354 <USB_EP0StartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8018354:	b480      	push	{r7}
 8018356:	b085      	sub	sp, #20
 8018358:	af00      	add	r7, sp, #0
 801835a:	60f8      	str	r0, [r7, #12]
 801835c:	60b9      	str	r1, [r7, #8]
 801835e:	4613      	mov	r3, r2
 8018360:	71fb      	strb	r3, [r7, #7]
  /* IN endpoint */
  if (ep->is_in == 1U)
 8018362:	68bb      	ldr	r3, [r7, #8]
 8018364:	785b      	ldrb	r3, [r3, #1]
 8018366:	2b01      	cmp	r3, #1
 8018368:	f040 80c8 	bne.w	80184fc <USB_EP0StartXfer+0x1a8>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 801836c:	68bb      	ldr	r3, [r7, #8]
 801836e:	695b      	ldr	r3, [r3, #20]
 8018370:	2b00      	cmp	r3, #0
 8018372:	d138      	bne.n	80183e6 <USB_EP0StartXfer+0x92>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8018374:	68bb      	ldr	r3, [r7, #8]
 8018376:	781b      	ldrb	r3, [r3, #0]
 8018378:	015a      	lsls	r2, r3, #5
 801837a:	68fb      	ldr	r3, [r7, #12]
 801837c:	4413      	add	r3, r2
 801837e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018382:	691b      	ldr	r3, [r3, #16]
 8018384:	68ba      	ldr	r2, [r7, #8]
 8018386:	7812      	ldrb	r2, [r2, #0]
 8018388:	0151      	lsls	r1, r2, #5
 801838a:	68fa      	ldr	r2, [r7, #12]
 801838c:	440a      	add	r2, r1
 801838e:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018392:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8018396:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 801839a:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 801839c:	68bb      	ldr	r3, [r7, #8]
 801839e:	781b      	ldrb	r3, [r3, #0]
 80183a0:	015a      	lsls	r2, r3, #5
 80183a2:	68fb      	ldr	r3, [r7, #12]
 80183a4:	4413      	add	r3, r2
 80183a6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80183aa:	691b      	ldr	r3, [r3, #16]
 80183ac:	68ba      	ldr	r2, [r7, #8]
 80183ae:	7812      	ldrb	r2, [r2, #0]
 80183b0:	0151      	lsls	r1, r2, #5
 80183b2:	68fa      	ldr	r2, [r7, #12]
 80183b4:	440a      	add	r2, r1
 80183b6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80183ba:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80183be:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 80183c0:	68bb      	ldr	r3, [r7, #8]
 80183c2:	781b      	ldrb	r3, [r3, #0]
 80183c4:	015a      	lsls	r2, r3, #5
 80183c6:	68fb      	ldr	r3, [r7, #12]
 80183c8:	4413      	add	r3, r2
 80183ca:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80183ce:	691b      	ldr	r3, [r3, #16]
 80183d0:	68ba      	ldr	r2, [r7, #8]
 80183d2:	7812      	ldrb	r2, [r2, #0]
 80183d4:	0151      	lsls	r1, r2, #5
 80183d6:	68fa      	ldr	r2, [r7, #12]
 80183d8:	440a      	add	r2, r1
 80183da:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80183de:	0cdb      	lsrs	r3, r3, #19
 80183e0:	04db      	lsls	r3, r3, #19
 80183e2:	6113      	str	r3, [r2, #16]
 80183e4:	e056      	b.n	8018494 <USB_EP0StartXfer+0x140>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80183e6:	68bb      	ldr	r3, [r7, #8]
 80183e8:	781b      	ldrb	r3, [r3, #0]
 80183ea:	015a      	lsls	r2, r3, #5
 80183ec:	68fb      	ldr	r3, [r7, #12]
 80183ee:	4413      	add	r3, r2
 80183f0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80183f4:	691b      	ldr	r3, [r3, #16]
 80183f6:	68ba      	ldr	r2, [r7, #8]
 80183f8:	7812      	ldrb	r2, [r2, #0]
 80183fa:	0151      	lsls	r1, r2, #5
 80183fc:	68fa      	ldr	r2, [r7, #12]
 80183fe:	440a      	add	r2, r1
 8018400:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018404:	0cdb      	lsrs	r3, r3, #19
 8018406:	04db      	lsls	r3, r3, #19
 8018408:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 801840a:	68bb      	ldr	r3, [r7, #8]
 801840c:	781b      	ldrb	r3, [r3, #0]
 801840e:	015a      	lsls	r2, r3, #5
 8018410:	68fb      	ldr	r3, [r7, #12]
 8018412:	4413      	add	r3, r2
 8018414:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018418:	691b      	ldr	r3, [r3, #16]
 801841a:	68ba      	ldr	r2, [r7, #8]
 801841c:	7812      	ldrb	r2, [r2, #0]
 801841e:	0151      	lsls	r1, r2, #5
 8018420:	68fa      	ldr	r2, [r7, #12]
 8018422:	440a      	add	r2, r1
 8018424:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018428:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 801842c:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8018430:	6113      	str	r3, [r2, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 8018432:	68bb      	ldr	r3, [r7, #8]
 8018434:	695a      	ldr	r2, [r3, #20]
 8018436:	68bb      	ldr	r3, [r7, #8]
 8018438:	689b      	ldr	r3, [r3, #8]
 801843a:	429a      	cmp	r2, r3
 801843c:	d903      	bls.n	8018446 <USB_EP0StartXfer+0xf2>
      {
        ep->xfer_len = ep->maxpacket;
 801843e:	68bb      	ldr	r3, [r7, #8]
 8018440:	689a      	ldr	r2, [r3, #8]
 8018442:	68bb      	ldr	r3, [r7, #8]
 8018444:	615a      	str	r2, [r3, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8018446:	68bb      	ldr	r3, [r7, #8]
 8018448:	781b      	ldrb	r3, [r3, #0]
 801844a:	015a      	lsls	r2, r3, #5
 801844c:	68fb      	ldr	r3, [r7, #12]
 801844e:	4413      	add	r3, r2
 8018450:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018454:	691b      	ldr	r3, [r3, #16]
 8018456:	68ba      	ldr	r2, [r7, #8]
 8018458:	7812      	ldrb	r2, [r2, #0]
 801845a:	0151      	lsls	r1, r2, #5
 801845c:	68fa      	ldr	r2, [r7, #12]
 801845e:	440a      	add	r2, r1
 8018460:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018464:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8018468:	6113      	str	r3, [r2, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 801846a:	68bb      	ldr	r3, [r7, #8]
 801846c:	781b      	ldrb	r3, [r3, #0]
 801846e:	015a      	lsls	r2, r3, #5
 8018470:	68fb      	ldr	r3, [r7, #12]
 8018472:	4413      	add	r3, r2
 8018474:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018478:	691a      	ldr	r2, [r3, #16]
 801847a:	68bb      	ldr	r3, [r7, #8]
 801847c:	695b      	ldr	r3, [r3, #20]
 801847e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8018482:	68b9      	ldr	r1, [r7, #8]
 8018484:	7809      	ldrb	r1, [r1, #0]
 8018486:	0148      	lsls	r0, r1, #5
 8018488:	68f9      	ldr	r1, [r7, #12]
 801848a:	4401      	add	r1, r0
 801848c:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 8018490:	4313      	orrs	r3, r2
 8018492:	610b      	str	r3, [r1, #16]
    
    }
    
    if (dma == 1)
 8018494:	79fb      	ldrb	r3, [r7, #7]
 8018496:	2b01      	cmp	r3, #1
 8018498:	d10b      	bne.n	80184b2 <USB_EP0StartXfer+0x15e>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 801849a:	68bb      	ldr	r3, [r7, #8]
 801849c:	781b      	ldrb	r3, [r3, #0]
 801849e:	015a      	lsls	r2, r3, #5
 80184a0:	68fb      	ldr	r3, [r7, #12]
 80184a2:	4413      	add	r3, r2
 80184a4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80184a8:	461a      	mov	r2, r3
 80184aa:	68bb      	ldr	r3, [r7, #8]
 80184ac:	691b      	ldr	r3, [r3, #16]
 80184ae:	6153      	str	r3, [r2, #20]
 80184b0:	e011      	b.n	80184d6 <USB_EP0StartXfer+0x182>
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 80184b2:	68bb      	ldr	r3, [r7, #8]
 80184b4:	695b      	ldr	r3, [r3, #20]
 80184b6:	2b00      	cmp	r3, #0
 80184b8:	d00d      	beq.n	80184d6 <USB_EP0StartXfer+0x182>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 80184ba:	68fb      	ldr	r3, [r7, #12]
 80184bc:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80184c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80184c2:	68bb      	ldr	r3, [r7, #8]
 80184c4:	781b      	ldrb	r3, [r3, #0]
 80184c6:	4619      	mov	r1, r3
 80184c8:	2301      	movs	r3, #1
 80184ca:	408b      	lsls	r3, r1
 80184cc:	68f9      	ldr	r1, [r7, #12]
 80184ce:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80184d2:	4313      	orrs	r3, r2
 80184d4:	634b      	str	r3, [r1, #52]	; 0x34
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 80184d6:	68bb      	ldr	r3, [r7, #8]
 80184d8:	781b      	ldrb	r3, [r3, #0]
 80184da:	015a      	lsls	r2, r3, #5
 80184dc:	68fb      	ldr	r3, [r7, #12]
 80184de:	4413      	add	r3, r2
 80184e0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80184e4:	681b      	ldr	r3, [r3, #0]
 80184e6:	68ba      	ldr	r2, [r7, #8]
 80184e8:	7812      	ldrb	r2, [r2, #0]
 80184ea:	0151      	lsls	r1, r2, #5
 80184ec:	68fa      	ldr	r2, [r7, #12]
 80184ee:	440a      	add	r2, r1
 80184f0:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80184f4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80184f8:	6013      	str	r3, [r2, #0]
 80184fa:	e074      	b.n	80185e6 <USB_EP0StartXfer+0x292>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 80184fc:	68bb      	ldr	r3, [r7, #8]
 80184fe:	781b      	ldrb	r3, [r3, #0]
 8018500:	015a      	lsls	r2, r3, #5
 8018502:	68fb      	ldr	r3, [r7, #12]
 8018504:	4413      	add	r3, r2
 8018506:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801850a:	691b      	ldr	r3, [r3, #16]
 801850c:	68ba      	ldr	r2, [r7, #8]
 801850e:	7812      	ldrb	r2, [r2, #0]
 8018510:	0151      	lsls	r1, r2, #5
 8018512:	68fa      	ldr	r2, [r7, #12]
 8018514:	440a      	add	r2, r1
 8018516:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 801851a:	0cdb      	lsrs	r3, r3, #19
 801851c:	04db      	lsls	r3, r3, #19
 801851e:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8018520:	68bb      	ldr	r3, [r7, #8]
 8018522:	781b      	ldrb	r3, [r3, #0]
 8018524:	015a      	lsls	r2, r3, #5
 8018526:	68fb      	ldr	r3, [r7, #12]
 8018528:	4413      	add	r3, r2
 801852a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801852e:	691b      	ldr	r3, [r3, #16]
 8018530:	68ba      	ldr	r2, [r7, #8]
 8018532:	7812      	ldrb	r2, [r2, #0]
 8018534:	0151      	lsls	r1, r2, #5
 8018536:	68fa      	ldr	r2, [r7, #12]
 8018538:	440a      	add	r2, r1
 801853a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 801853e:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 8018542:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8018546:	6113      	str	r3, [r2, #16]
      
    if (ep->xfer_len > 0U)
 8018548:	68bb      	ldr	r3, [r7, #8]
 801854a:	695b      	ldr	r3, [r3, #20]
 801854c:	2b00      	cmp	r3, #0
 801854e:	d003      	beq.n	8018558 <USB_EP0StartXfer+0x204>
    {
      ep->xfer_len = ep->maxpacket;
 8018550:	68bb      	ldr	r3, [r7, #8]
 8018552:	689a      	ldr	r2, [r3, #8]
 8018554:	68bb      	ldr	r3, [r7, #8]
 8018556:	615a      	str	r2, [r3, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8018558:	68bb      	ldr	r3, [r7, #8]
 801855a:	781b      	ldrb	r3, [r3, #0]
 801855c:	015a      	lsls	r2, r3, #5
 801855e:	68fb      	ldr	r3, [r7, #12]
 8018560:	4413      	add	r3, r2
 8018562:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018566:	691b      	ldr	r3, [r3, #16]
 8018568:	68ba      	ldr	r2, [r7, #8]
 801856a:	7812      	ldrb	r2, [r2, #0]
 801856c:	0151      	lsls	r1, r2, #5
 801856e:	68fa      	ldr	r2, [r7, #12]
 8018570:	440a      	add	r2, r1
 8018572:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018576:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 801857a:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 801857c:	68bb      	ldr	r3, [r7, #8]
 801857e:	781b      	ldrb	r3, [r3, #0]
 8018580:	015a      	lsls	r2, r3, #5
 8018582:	68fb      	ldr	r3, [r7, #12]
 8018584:	4413      	add	r3, r2
 8018586:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801858a:	691a      	ldr	r2, [r3, #16]
 801858c:	68bb      	ldr	r3, [r7, #8]
 801858e:	689b      	ldr	r3, [r3, #8]
 8018590:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8018594:	68b9      	ldr	r1, [r7, #8]
 8018596:	7809      	ldrb	r1, [r1, #0]
 8018598:	0148      	lsls	r0, r1, #5
 801859a:	68f9      	ldr	r1, [r7, #12]
 801859c:	4401      	add	r1, r0
 801859e:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 80185a2:	4313      	orrs	r3, r2
 80185a4:	610b      	str	r3, [r1, #16]
    

    if (dma == 1U)
 80185a6:	79fb      	ldrb	r3, [r7, #7]
 80185a8:	2b01      	cmp	r3, #1
 80185aa:	d10a      	bne.n	80185c2 <USB_EP0StartXfer+0x26e>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80185ac:	68bb      	ldr	r3, [r7, #8]
 80185ae:	68d9      	ldr	r1, [r3, #12]
 80185b0:	68bb      	ldr	r3, [r7, #8]
 80185b2:	781b      	ldrb	r3, [r3, #0]
 80185b4:	015a      	lsls	r2, r3, #5
 80185b6:	68fb      	ldr	r3, [r7, #12]
 80185b8:	4413      	add	r3, r2
 80185ba:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80185be:	460a      	mov	r2, r1
 80185c0:	615a      	str	r2, [r3, #20]
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 80185c2:	68bb      	ldr	r3, [r7, #8]
 80185c4:	781b      	ldrb	r3, [r3, #0]
 80185c6:	015a      	lsls	r2, r3, #5
 80185c8:	68fb      	ldr	r3, [r7, #12]
 80185ca:	4413      	add	r3, r2
 80185cc:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80185d0:	681b      	ldr	r3, [r3, #0]
 80185d2:	68ba      	ldr	r2, [r7, #8]
 80185d4:	7812      	ldrb	r2, [r2, #0]
 80185d6:	0151      	lsls	r1, r2, #5
 80185d8:	68fa      	ldr	r2, [r7, #12]
 80185da:	440a      	add	r2, r1
 80185dc:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80185e0:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80185e4:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 80185e6:	2300      	movs	r3, #0
}
 80185e8:	4618      	mov	r0, r3
 80185ea:	3714      	adds	r7, #20
 80185ec:	46bd      	mov	sp, r7
 80185ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80185f2:	4770      	bx	lr

080185f4 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 80185f4:	b480      	push	{r7}
 80185f6:	b087      	sub	sp, #28
 80185f8:	af00      	add	r7, sp, #0
 80185fa:	60f8      	str	r0, [r7, #12]
 80185fc:	60b9      	str	r1, [r7, #8]
 80185fe:	4611      	mov	r1, r2
 8018600:	461a      	mov	r2, r3
 8018602:	460b      	mov	r3, r1
 8018604:	71fb      	strb	r3, [r7, #7]
 8018606:	4613      	mov	r3, r2
 8018608:	80bb      	strh	r3, [r7, #4]
  uint32_t count32b = 0U , i = 0U;
 801860a:	2300      	movs	r3, #0
 801860c:	613b      	str	r3, [r7, #16]
 801860e:	2300      	movs	r3, #0
 8018610:	617b      	str	r3, [r7, #20]
  
  if (dma == 0U)
 8018612:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018616:	2b00      	cmp	r3, #0
 8018618:	d11a      	bne.n	8018650 <USB_WritePacket+0x5c>
  {
    count32b =  (len + 3U) / 4U;
 801861a:	88bb      	ldrh	r3, [r7, #4]
 801861c:	3303      	adds	r3, #3
 801861e:	089b      	lsrs	r3, r3, #2
 8018620:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++, src += 4U)
 8018622:	2300      	movs	r3, #0
 8018624:	617b      	str	r3, [r7, #20]
 8018626:	e00f      	b.n	8018648 <USB_WritePacket+0x54>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8018628:	79fb      	ldrb	r3, [r7, #7]
 801862a:	031a      	lsls	r2, r3, #12
 801862c:	68fb      	ldr	r3, [r7, #12]
 801862e:	4413      	add	r3, r2
 8018630:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8018634:	461a      	mov	r2, r3
 8018636:	68bb      	ldr	r3, [r7, #8]
 8018638:	681b      	ldr	r3, [r3, #0]
 801863a:	6013      	str	r3, [r2, #0]
    for (i = 0U; i < count32b; i++, src += 4U)
 801863c:	697b      	ldr	r3, [r7, #20]
 801863e:	3301      	adds	r3, #1
 8018640:	617b      	str	r3, [r7, #20]
 8018642:	68bb      	ldr	r3, [r7, #8]
 8018644:	3304      	adds	r3, #4
 8018646:	60bb      	str	r3, [r7, #8]
 8018648:	697a      	ldr	r2, [r7, #20]
 801864a:	693b      	ldr	r3, [r7, #16]
 801864c:	429a      	cmp	r2, r3
 801864e:	d3eb      	bcc.n	8018628 <USB_WritePacket+0x34>
    }
  }
  return HAL_OK;
 8018650:	2300      	movs	r3, #0
}
 8018652:	4618      	mov	r0, r3
 8018654:	371c      	adds	r7, #28
 8018656:	46bd      	mov	sp, r7
 8018658:	f85d 7b04 	ldr.w	r7, [sp], #4
 801865c:	4770      	bx	lr

0801865e <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 801865e:	b480      	push	{r7}
 8018660:	b087      	sub	sp, #28
 8018662:	af00      	add	r7, sp, #0
 8018664:	60f8      	str	r0, [r7, #12]
 8018666:	60b9      	str	r1, [r7, #8]
 8018668:	4613      	mov	r3, r2
 801866a:	80fb      	strh	r3, [r7, #6]
  uint32_t i=0U;
 801866c:	2300      	movs	r3, #0
 801866e:	617b      	str	r3, [r7, #20]
  uint32_t count32b = (len + 3U) / 4U;
 8018670:	88fb      	ldrh	r3, [r7, #6]
 8018672:	3303      	adds	r3, #3
 8018674:	089b      	lsrs	r3, r3, #2
 8018676:	613b      	str	r3, [r7, #16]
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 8018678:	2300      	movs	r3, #0
 801867a:	617b      	str	r3, [r7, #20]
 801867c:	e00b      	b.n	8018696 <USB_ReadPacket+0x38>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 801867e:	68fb      	ldr	r3, [r7, #12]
 8018680:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8018684:	681a      	ldr	r2, [r3, #0]
 8018686:	68bb      	ldr	r3, [r7, #8]
 8018688:	601a      	str	r2, [r3, #0]
  for ( i = 0U; i < count32b; i++, dest += 4U )
 801868a:	697b      	ldr	r3, [r7, #20]
 801868c:	3301      	adds	r3, #1
 801868e:	617b      	str	r3, [r7, #20]
 8018690:	68bb      	ldr	r3, [r7, #8]
 8018692:	3304      	adds	r3, #4
 8018694:	60bb      	str	r3, [r7, #8]
 8018696:	697a      	ldr	r2, [r7, #20]
 8018698:	693b      	ldr	r3, [r7, #16]
 801869a:	429a      	cmp	r2, r3
 801869c:	d3ef      	bcc.n	801867e <USB_ReadPacket+0x20>
    
  }
  return ((void *)dest);
 801869e:	68bb      	ldr	r3, [r7, #8]
}
 80186a0:	4618      	mov	r0, r3
 80186a2:	371c      	adds	r7, #28
 80186a4:	46bd      	mov	sp, r7
 80186a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80186aa:	4770      	bx	lr

080186ac <USB_EPSetStall>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 80186ac:	b480      	push	{r7}
 80186ae:	b083      	sub	sp, #12
 80186b0:	af00      	add	r7, sp, #0
 80186b2:	6078      	str	r0, [r7, #4]
 80186b4:	6039      	str	r1, [r7, #0]
  if (ep->is_in == 1U)
 80186b6:	683b      	ldr	r3, [r7, #0]
 80186b8:	785b      	ldrb	r3, [r3, #1]
 80186ba:	2b01      	cmp	r3, #1
 80186bc:	d12e      	bne.n	801871c <USB_EPSetStall+0x70>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 80186be:	683b      	ldr	r3, [r7, #0]
 80186c0:	781b      	ldrb	r3, [r3, #0]
 80186c2:	015a      	lsls	r2, r3, #5
 80186c4:	687b      	ldr	r3, [r7, #4]
 80186c6:	4413      	add	r3, r2
 80186c8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80186cc:	681b      	ldr	r3, [r3, #0]
 80186ce:	2b00      	cmp	r3, #0
 80186d0:	db11      	blt.n	80186f6 <USB_EPSetStall+0x4a>
    {
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 80186d2:	683b      	ldr	r3, [r7, #0]
 80186d4:	781b      	ldrb	r3, [r3, #0]
 80186d6:	015a      	lsls	r2, r3, #5
 80186d8:	687b      	ldr	r3, [r7, #4]
 80186da:	4413      	add	r3, r2
 80186dc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80186e0:	681b      	ldr	r3, [r3, #0]
 80186e2:	683a      	ldr	r2, [r7, #0]
 80186e4:	7812      	ldrb	r2, [r2, #0]
 80186e6:	0151      	lsls	r1, r2, #5
 80186e8:	687a      	ldr	r2, [r7, #4]
 80186ea:	440a      	add	r2, r1
 80186ec:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80186f0:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80186f4:	6013      	str	r3, [r2, #0]
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 80186f6:	683b      	ldr	r3, [r7, #0]
 80186f8:	781b      	ldrb	r3, [r3, #0]
 80186fa:	015a      	lsls	r2, r3, #5
 80186fc:	687b      	ldr	r3, [r7, #4]
 80186fe:	4413      	add	r3, r2
 8018700:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018704:	681b      	ldr	r3, [r3, #0]
 8018706:	683a      	ldr	r2, [r7, #0]
 8018708:	7812      	ldrb	r2, [r2, #0]
 801870a:	0151      	lsls	r1, r2, #5
 801870c:	687a      	ldr	r2, [r7, #4]
 801870e:	440a      	add	r2, r1
 8018710:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018714:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8018718:	6013      	str	r3, [r2, #0]
 801871a:	e02d      	b.n	8018778 <USB_EPSetStall+0xcc>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 801871c:	683b      	ldr	r3, [r7, #0]
 801871e:	781b      	ldrb	r3, [r3, #0]
 8018720:	015a      	lsls	r2, r3, #5
 8018722:	687b      	ldr	r3, [r7, #4]
 8018724:	4413      	add	r3, r2
 8018726:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801872a:	681b      	ldr	r3, [r3, #0]
 801872c:	2b00      	cmp	r3, #0
 801872e:	db11      	blt.n	8018754 <USB_EPSetStall+0xa8>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8018730:	683b      	ldr	r3, [r7, #0]
 8018732:	781b      	ldrb	r3, [r3, #0]
 8018734:	015a      	lsls	r2, r3, #5
 8018736:	687b      	ldr	r3, [r7, #4]
 8018738:	4413      	add	r3, r2
 801873a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801873e:	681b      	ldr	r3, [r3, #0]
 8018740:	683a      	ldr	r2, [r7, #0]
 8018742:	7812      	ldrb	r2, [r2, #0]
 8018744:	0151      	lsls	r1, r2, #5
 8018746:	687a      	ldr	r2, [r7, #4]
 8018748:	440a      	add	r2, r1
 801874a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 801874e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8018752:	6013      	str	r3, [r2, #0]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8018754:	683b      	ldr	r3, [r7, #0]
 8018756:	781b      	ldrb	r3, [r3, #0]
 8018758:	015a      	lsls	r2, r3, #5
 801875a:	687b      	ldr	r3, [r7, #4]
 801875c:	4413      	add	r3, r2
 801875e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018762:	681b      	ldr	r3, [r3, #0]
 8018764:	683a      	ldr	r2, [r7, #0]
 8018766:	7812      	ldrb	r2, [r2, #0]
 8018768:	0151      	lsls	r1, r2, #5
 801876a:	687a      	ldr	r2, [r7, #4]
 801876c:	440a      	add	r2, r1
 801876e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018772:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8018776:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 8018778:	2300      	movs	r3, #0
}
 801877a:	4618      	mov	r0, r3
 801877c:	370c      	adds	r7, #12
 801877e:	46bd      	mov	sp, r7
 8018780:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018784:	4770      	bx	lr

08018786 <USB_EPClearStall>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8018786:	b480      	push	{r7}
 8018788:	b083      	sub	sp, #12
 801878a:	af00      	add	r7, sp, #0
 801878c:	6078      	str	r0, [r7, #4]
 801878e:	6039      	str	r1, [r7, #0]
  if (ep->is_in == 1U)
 8018790:	683b      	ldr	r3, [r7, #0]
 8018792:	785b      	ldrb	r3, [r3, #1]
 8018794:	2b01      	cmp	r3, #1
 8018796:	d12c      	bne.n	80187f2 <USB_EPClearStall+0x6c>
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8018798:	683b      	ldr	r3, [r7, #0]
 801879a:	781b      	ldrb	r3, [r3, #0]
 801879c:	015a      	lsls	r2, r3, #5
 801879e:	687b      	ldr	r3, [r7, #4]
 80187a0:	4413      	add	r3, r2
 80187a2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80187a6:	681b      	ldr	r3, [r3, #0]
 80187a8:	683a      	ldr	r2, [r7, #0]
 80187aa:	7812      	ldrb	r2, [r2, #0]
 80187ac:	0151      	lsls	r1, r2, #5
 80187ae:	687a      	ldr	r2, [r7, #4]
 80187b0:	440a      	add	r2, r1
 80187b2:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80187b6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80187ba:	6013      	str	r3, [r2, #0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 80187bc:	683b      	ldr	r3, [r7, #0]
 80187be:	78db      	ldrb	r3, [r3, #3]
 80187c0:	2b03      	cmp	r3, #3
 80187c2:	d003      	beq.n	80187cc <USB_EPClearStall+0x46>
 80187c4:	683b      	ldr	r3, [r7, #0]
 80187c6:	78db      	ldrb	r3, [r3, #3]
 80187c8:	2b02      	cmp	r3, #2
 80187ca:	d13e      	bne.n	801884a <USB_EPClearStall+0xc4>
    {
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80187cc:	683b      	ldr	r3, [r7, #0]
 80187ce:	781b      	ldrb	r3, [r3, #0]
 80187d0:	015a      	lsls	r2, r3, #5
 80187d2:	687b      	ldr	r3, [r7, #4]
 80187d4:	4413      	add	r3, r2
 80187d6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80187da:	681b      	ldr	r3, [r3, #0]
 80187dc:	683a      	ldr	r2, [r7, #0]
 80187de:	7812      	ldrb	r2, [r2, #0]
 80187e0:	0151      	lsls	r1, r2, #5
 80187e2:	687a      	ldr	r2, [r7, #4]
 80187e4:	440a      	add	r2, r1
 80187e6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80187ea:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80187ee:	6013      	str	r3, [r2, #0]
 80187f0:	e02b      	b.n	801884a <USB_EPClearStall+0xc4>
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 80187f2:	683b      	ldr	r3, [r7, #0]
 80187f4:	781b      	ldrb	r3, [r3, #0]
 80187f6:	015a      	lsls	r2, r3, #5
 80187f8:	687b      	ldr	r3, [r7, #4]
 80187fa:	4413      	add	r3, r2
 80187fc:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018800:	681b      	ldr	r3, [r3, #0]
 8018802:	683a      	ldr	r2, [r7, #0]
 8018804:	7812      	ldrb	r2, [r2, #0]
 8018806:	0151      	lsls	r1, r2, #5
 8018808:	687a      	ldr	r2, [r7, #4]
 801880a:	440a      	add	r2, r1
 801880c:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018810:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8018814:	6013      	str	r3, [r2, #0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8018816:	683b      	ldr	r3, [r7, #0]
 8018818:	78db      	ldrb	r3, [r3, #3]
 801881a:	2b03      	cmp	r3, #3
 801881c:	d003      	beq.n	8018826 <USB_EPClearStall+0xa0>
 801881e:	683b      	ldr	r3, [r7, #0]
 8018820:	78db      	ldrb	r3, [r3, #3]
 8018822:	2b02      	cmp	r3, #2
 8018824:	d111      	bne.n	801884a <USB_EPClearStall+0xc4>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8018826:	683b      	ldr	r3, [r7, #0]
 8018828:	781b      	ldrb	r3, [r3, #0]
 801882a:	015a      	lsls	r2, r3, #5
 801882c:	687b      	ldr	r3, [r7, #4]
 801882e:	4413      	add	r3, r2
 8018830:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018834:	681b      	ldr	r3, [r3, #0]
 8018836:	683a      	ldr	r2, [r7, #0]
 8018838:	7812      	ldrb	r2, [r2, #0]
 801883a:	0151      	lsls	r1, r2, #5
 801883c:	687a      	ldr	r2, [r7, #4]
 801883e:	440a      	add	r2, r1
 8018840:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018844:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8018848:	6013      	str	r3, [r2, #0]
    }    
  }
  return HAL_OK;
 801884a:	2300      	movs	r3, #0
}
 801884c:	4618      	mov	r0, r3
 801884e:	370c      	adds	r7, #12
 8018850:	46bd      	mov	sp, r7
 8018852:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018856:	4770      	bx	lr

08018858 <USB_SetDevAddress>:
  * @param  address : new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 8018858:	b480      	push	{r7}
 801885a:	b083      	sub	sp, #12
 801885c:	af00      	add	r7, sp, #0
 801885e:	6078      	str	r0, [r7, #4]
 8018860:	460b      	mov	r3, r1
 8018862:	70fb      	strb	r3, [r7, #3]
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 8018864:	687b      	ldr	r3, [r7, #4]
 8018866:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 801886a:	681b      	ldr	r3, [r3, #0]
 801886c:	687a      	ldr	r2, [r7, #4]
 801886e:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8018872:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8018876:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 8018878:	687b      	ldr	r3, [r7, #4]
 801887a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 801887e:	681a      	ldr	r2, [r3, #0]
 8018880:	78fb      	ldrb	r3, [r7, #3]
 8018882:	011b      	lsls	r3, r3, #4
 8018884:	f403 63fe 	and.w	r3, r3, #2032	; 0x7f0
 8018888:	6879      	ldr	r1, [r7, #4]
 801888a:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 801888e:	4313      	orrs	r3, r2
 8018890:	600b      	str	r3, [r1, #0]
  
  return HAL_OK;  
 8018892:	2300      	movs	r3, #0
}
 8018894:	4618      	mov	r0, r3
 8018896:	370c      	adds	r7, #12
 8018898:	46bd      	mov	sp, r7
 801889a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801889e:	4770      	bx	lr

080188a0 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 80188a0:	b580      	push	{r7, lr}
 80188a2:	b082      	sub	sp, #8
 80188a4:	af00      	add	r7, sp, #0
 80188a6:	6078      	str	r0, [r7, #4]
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 80188a8:	687b      	ldr	r3, [r7, #4]
 80188aa:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80188ae:	685b      	ldr	r3, [r3, #4]
 80188b0:	687a      	ldr	r2, [r7, #4]
 80188b2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80188b6:	f023 0302 	bic.w	r3, r3, #2
 80188ba:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 80188bc:	2003      	movs	r0, #3
 80188be:	f7f8 fe3f 	bl	8011540 <HAL_Delay>
  
  return HAL_OK;  
 80188c2:	2300      	movs	r3, #0
}
 80188c4:	4618      	mov	r0, r3
 80188c6:	3708      	adds	r7, #8
 80188c8:	46bd      	mov	sp, r7
 80188ca:	bd80      	pop	{r7, pc}

080188cc <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 80188cc:	b580      	push	{r7, lr}
 80188ce:	b082      	sub	sp, #8
 80188d0:	af00      	add	r7, sp, #0
 80188d2:	6078      	str	r0, [r7, #4]
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 80188d4:	687b      	ldr	r3, [r7, #4]
 80188d6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80188da:	685b      	ldr	r3, [r3, #4]
 80188dc:	687a      	ldr	r2, [r7, #4]
 80188de:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80188e2:	f043 0302 	orr.w	r3, r3, #2
 80188e6:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 80188e8:	2003      	movs	r0, #3
 80188ea:	f7f8 fe29 	bl	8011540 <HAL_Delay>
  
  return HAL_OK;  
 80188ee:	2300      	movs	r3, #0
}
 80188f0:	4618      	mov	r0, r3
 80188f2:	3708      	adds	r7, #8
 80188f4:	46bd      	mov	sp, r7
 80188f6:	bd80      	pop	{r7, pc}

080188f8 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx : Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
 80188f8:	b480      	push	{r7}
 80188fa:	b085      	sub	sp, #20
 80188fc:	af00      	add	r7, sp, #0
 80188fe:	6078      	str	r0, [r7, #4]
  uint32_t v = 0U;
 8018900:	2300      	movs	r3, #0
 8018902:	60fb      	str	r3, [r7, #12]
  
  v = USBx->GINTSTS;
 8018904:	687b      	ldr	r3, [r7, #4]
 8018906:	695b      	ldr	r3, [r3, #20]
 8018908:	60fb      	str	r3, [r7, #12]
  v &= USBx->GINTMSK;
 801890a:	687b      	ldr	r3, [r7, #4]
 801890c:	699b      	ldr	r3, [r3, #24]
 801890e:	68fa      	ldr	r2, [r7, #12]
 8018910:	4013      	ands	r3, r2
 8018912:	60fb      	str	r3, [r7, #12]
  return v;  
 8018914:	68fb      	ldr	r3, [r7, #12]
}
 8018916:	4618      	mov	r0, r3
 8018918:	3714      	adds	r7, #20
 801891a:	46bd      	mov	sp, r7
 801891c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018920:	4770      	bx	lr

08018922 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx : Selected device
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
 8018922:	b480      	push	{r7}
 8018924:	b085      	sub	sp, #20
 8018926:	af00      	add	r7, sp, #0
 8018928:	6078      	str	r0, [r7, #4]
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 801892a:	687b      	ldr	r3, [r7, #4]
 801892c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8018930:	699b      	ldr	r3, [r3, #24]
 8018932:	60fb      	str	r3, [r7, #12]
  v &= USBx_DEVICE->DAINTMSK;
 8018934:	687b      	ldr	r3, [r7, #4]
 8018936:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 801893a:	69db      	ldr	r3, [r3, #28]
 801893c:	68fa      	ldr	r2, [r7, #12]
 801893e:	4013      	ands	r3, r2
 8018940:	60fb      	str	r3, [r7, #12]
  return ((v & 0xffff0000U) >> 16U);
 8018942:	68fb      	ldr	r3, [r7, #12]
 8018944:	0c1b      	lsrs	r3, r3, #16
}
 8018946:	4618      	mov	r0, r3
 8018948:	3714      	adds	r7, #20
 801894a:	46bd      	mov	sp, r7
 801894c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018950:	4770      	bx	lr

08018952 <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx : Selected device
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
 8018952:	b480      	push	{r7}
 8018954:	b085      	sub	sp, #20
 8018956:	af00      	add	r7, sp, #0
 8018958:	6078      	str	r0, [r7, #4]
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 801895a:	687b      	ldr	r3, [r7, #4]
 801895c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8018960:	699b      	ldr	r3, [r3, #24]
 8018962:	60fb      	str	r3, [r7, #12]
  v &= USBx_DEVICE->DAINTMSK;
 8018964:	687b      	ldr	r3, [r7, #4]
 8018966:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 801896a:	69db      	ldr	r3, [r3, #28]
 801896c:	68fa      	ldr	r2, [r7, #12]
 801896e:	4013      	ands	r3, r2
 8018970:	60fb      	str	r3, [r7, #12]
  return ((v & 0xFFFFU));
 8018972:	68fb      	ldr	r3, [r7, #12]
 8018974:	b29b      	uxth	r3, r3
}
 8018976:	4618      	mov	r0, r3
 8018978:	3714      	adds	r7, #20
 801897a:	46bd      	mov	sp, r7
 801897c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018980:	4770      	bx	lr

08018982 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum : endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8018982:	b480      	push	{r7}
 8018984:	b085      	sub	sp, #20
 8018986:	af00      	add	r7, sp, #0
 8018988:	6078      	str	r0, [r7, #4]
 801898a:	460b      	mov	r3, r1
 801898c:	70fb      	strb	r3, [r7, #3]
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 801898e:	78fb      	ldrb	r3, [r7, #3]
 8018990:	015a      	lsls	r2, r3, #5
 8018992:	687b      	ldr	r3, [r7, #4]
 8018994:	4413      	add	r3, r2
 8018996:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 801899a:	689b      	ldr	r3, [r3, #8]
 801899c:	60fb      	str	r3, [r7, #12]
  v &= USBx_DEVICE->DOEPMSK;
 801899e:	687b      	ldr	r3, [r7, #4]
 80189a0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80189a4:	695b      	ldr	r3, [r3, #20]
 80189a6:	68fa      	ldr	r2, [r7, #12]
 80189a8:	4013      	ands	r3, r2
 80189aa:	60fb      	str	r3, [r7, #12]
  return v;
 80189ac:	68fb      	ldr	r3, [r7, #12]
}
 80189ae:	4618      	mov	r0, r3
 80189b0:	3714      	adds	r7, #20
 80189b2:	46bd      	mov	sp, r7
 80189b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80189b8:	4770      	bx	lr

080189ba <USB_ReadDevInEPInterrupt>:
  * @param  epnum : endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 80189ba:	b480      	push	{r7}
 80189bc:	b087      	sub	sp, #28
 80189be:	af00      	add	r7, sp, #0
 80189c0:	6078      	str	r0, [r7, #4]
 80189c2:	460b      	mov	r3, r1
 80189c4:	70fb      	strb	r3, [r7, #3]
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 80189c6:	687b      	ldr	r3, [r7, #4]
 80189c8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80189cc:	691b      	ldr	r3, [r3, #16]
 80189ce:	617b      	str	r3, [r7, #20]
  emp = USBx_DEVICE->DIEPEMPMSK;
 80189d0:	687b      	ldr	r3, [r7, #4]
 80189d2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80189d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80189d8:	613b      	str	r3, [r7, #16]
  msk |= ((emp >> epnum) & 0x1U) << 7U;
 80189da:	78fb      	ldrb	r3, [r7, #3]
 80189dc:	693a      	ldr	r2, [r7, #16]
 80189de:	fa22 f303 	lsr.w	r3, r2, r3
 80189e2:	01db      	lsls	r3, r3, #7
 80189e4:	b2db      	uxtb	r3, r3
 80189e6:	697a      	ldr	r2, [r7, #20]
 80189e8:	4313      	orrs	r3, r2
 80189ea:	617b      	str	r3, [r7, #20]
  v = USBx_INEP(epnum)->DIEPINT & msk;
 80189ec:	78fb      	ldrb	r3, [r7, #3]
 80189ee:	015a      	lsls	r2, r3, #5
 80189f0:	687b      	ldr	r3, [r7, #4]
 80189f2:	4413      	add	r3, r2
 80189f4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80189f8:	689b      	ldr	r3, [r3, #8]
 80189fa:	697a      	ldr	r2, [r7, #20]
 80189fc:	4013      	ands	r3, r2
 80189fe:	60fb      	str	r3, [r7, #12]
  return v;
 8018a00:	68fb      	ldr	r3, [r7, #12]
}
 8018a02:	4618      	mov	r0, r3
 8018a04:	371c      	adds	r7, #28
 8018a06:	46bd      	mov	sp, r7
 8018a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a0c:	4770      	bx	lr

08018a0e <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
 8018a0e:	b480      	push	{r7}
 8018a10:	b083      	sub	sp, #12
 8018a12:	af00      	add	r7, sp, #0
 8018a14:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS ) & 0x1U);
 8018a16:	687b      	ldr	r3, [r7, #4]
 8018a18:	695b      	ldr	r3, [r3, #20]
 8018a1a:	f003 0301 	and.w	r3, r3, #1
}
 8018a1e:	4618      	mov	r0, r3
 8018a20:	370c      	adds	r7, #12
 8018a22:	46bd      	mov	sp, r7
 8018a24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a28:	4770      	bx	lr

08018a2a <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
 8018a2a:	b480      	push	{r7}
 8018a2c:	b083      	sub	sp, #12
 8018a2e:	af00      	add	r7, sp, #0
 8018a30:	6078      	str	r0, [r7, #4]
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8018a32:	687b      	ldr	r3, [r7, #4]
 8018a34:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018a38:	681b      	ldr	r3, [r3, #0]
 8018a3a:	687a      	ldr	r2, [r7, #4]
 8018a3c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018a40:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8018a44:	f023 0307 	bic.w	r3, r3, #7
 8018a48:	6013      	str	r3, [r2, #0]
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8018a4a:	687b      	ldr	r3, [r7, #4]
 8018a4c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8018a50:	689b      	ldr	r3, [r3, #8]
 8018a52:	f003 0306 	and.w	r3, r3, #6
 8018a56:	2b04      	cmp	r3, #4
 8018a58:	d109      	bne.n	8018a6e <USB_ActivateSetup+0x44>
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
 8018a5a:	687b      	ldr	r3, [r7, #4]
 8018a5c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8018a60:	681b      	ldr	r3, [r3, #0]
 8018a62:	687a      	ldr	r2, [r7, #4]
 8018a64:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8018a68:	f043 0303 	orr.w	r3, r3, #3
 8018a6c:	6013      	str	r3, [r2, #0]
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8018a6e:	687b      	ldr	r3, [r7, #4]
 8018a70:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8018a74:	685b      	ldr	r3, [r3, #4]
 8018a76:	687a      	ldr	r2, [r7, #4]
 8018a78:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8018a7c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8018a80:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8018a82:	2300      	movs	r3, #0
}
 8018a84:	4618      	mov	r0, r3
 8018a86:	370c      	adds	r7, #12
 8018a88:	46bd      	mov	sp, r7
 8018a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018a8e:	4770      	bx	lr

08018a90 <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8018a90:	b480      	push	{r7}
 8018a92:	b085      	sub	sp, #20
 8018a94:	af00      	add	r7, sp, #0
 8018a96:	60f8      	str	r0, [r7, #12]
 8018a98:	460b      	mov	r3, r1
 8018a9a:	607a      	str	r2, [r7, #4]
 8018a9c:	72fb      	strb	r3, [r7, #11]
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8018a9e:	68fb      	ldr	r3, [r7, #12]
 8018aa0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018aa4:	461a      	mov	r2, r3
 8018aa6:	2300      	movs	r3, #0
 8018aa8:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 8018aaa:	68fb      	ldr	r3, [r7, #12]
 8018aac:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018ab0:	691b      	ldr	r3, [r3, #16]
 8018ab2:	68fa      	ldr	r2, [r7, #12]
 8018ab4:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018ab8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8018abc:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8018abe:	68fb      	ldr	r3, [r7, #12]
 8018ac0:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018ac4:	691b      	ldr	r3, [r3, #16]
 8018ac6:	68fa      	ldr	r2, [r7, #12]
 8018ac8:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018acc:	f043 0318 	orr.w	r3, r3, #24
 8018ad0:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8018ad2:	68fb      	ldr	r3, [r7, #12]
 8018ad4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018ad8:	691b      	ldr	r3, [r3, #16]
 8018ada:	68fa      	ldr	r2, [r7, #12]
 8018adc:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8018ae0:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8018ae4:	6113      	str	r3, [r2, #16]
  
  if (dma == 1U)
 8018ae6:	7afb      	ldrb	r3, [r7, #11]
 8018ae8:	2b01      	cmp	r3, #1
 8018aea:	d10c      	bne.n	8018b06 <USB_EP0_OutStart+0x76>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8018aec:	68fb      	ldr	r3, [r7, #12]
 8018aee:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018af2:	461a      	mov	r2, r3
 8018af4:	687b      	ldr	r3, [r7, #4]
 8018af6:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 8018af8:	68fb      	ldr	r3, [r7, #12]
 8018afa:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8018afe:	461a      	mov	r2, r3
 8018b00:	f04f 2380 	mov.w	r3, #2147516416	; 0x80008000
 8018b04:	6013      	str	r3, [r2, #0]
  }
  
  return HAL_OK;  
 8018b06:	2300      	movs	r3, #0
}
 8018b08:	4618      	mov	r0, r3
 8018b0a:	3714      	adds	r7, #20
 8018b0c:	46bd      	mov	sp, r7
 8018b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018b12:	4770      	bx	lr

08018b14 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8018b14:	b480      	push	{r7}
 8018b16:	b085      	sub	sp, #20
 8018b18:	af00      	add	r7, sp, #0
 8018b1a:	6078      	str	r0, [r7, #4]
  uint32_t count = 0U;
 8018b1c:	2300      	movs	r3, #0
 8018b1e:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8018b20:	68fb      	ldr	r3, [r7, #12]
 8018b22:	3301      	adds	r3, #1
 8018b24:	60fb      	str	r3, [r7, #12]
 8018b26:	68fb      	ldr	r3, [r7, #12]
 8018b28:	4a13      	ldr	r2, [pc, #76]	; (8018b78 <USB_CoreReset+0x64>)
 8018b2a:	4293      	cmp	r3, r2
 8018b2c:	d901      	bls.n	8018b32 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8018b2e:	2303      	movs	r3, #3
 8018b30:	e01b      	b.n	8018b6a <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8018b32:	687b      	ldr	r3, [r7, #4]
 8018b34:	691b      	ldr	r3, [r3, #16]
 8018b36:	2b00      	cmp	r3, #0
 8018b38:	daf2      	bge.n	8018b20 <USB_CoreReset+0xc>
  
  /* Core Soft Reset */
  count = 0U;
 8018b3a:	2300      	movs	r3, #0
 8018b3c:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8018b3e:	687b      	ldr	r3, [r7, #4]
 8018b40:	691b      	ldr	r3, [r3, #16]
 8018b42:	f043 0201 	orr.w	r2, r3, #1
 8018b46:	687b      	ldr	r3, [r7, #4]
 8018b48:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8018b4a:	68fb      	ldr	r3, [r7, #12]
 8018b4c:	3301      	adds	r3, #1
 8018b4e:	60fb      	str	r3, [r7, #12]
 8018b50:	68fb      	ldr	r3, [r7, #12]
 8018b52:	4a09      	ldr	r2, [pc, #36]	; (8018b78 <USB_CoreReset+0x64>)
 8018b54:	4293      	cmp	r3, r2
 8018b56:	d901      	bls.n	8018b5c <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8018b58:	2303      	movs	r3, #3
 8018b5a:	e006      	b.n	8018b6a <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8018b5c:	687b      	ldr	r3, [r7, #4]
 8018b5e:	691b      	ldr	r3, [r3, #16]
 8018b60:	f003 0301 	and.w	r3, r3, #1
 8018b64:	2b01      	cmp	r3, #1
 8018b66:	d0f0      	beq.n	8018b4a <USB_CoreReset+0x36>
  
  return HAL_OK;
 8018b68:	2300      	movs	r3, #0
}
 8018b6a:	4618      	mov	r0, r3
 8018b6c:	3714      	adds	r7, #20
 8018b6e:	46bd      	mov	sp, r7
 8018b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018b74:	4770      	bx	lr
 8018b76:	bf00      	nop
 8018b78:	00030d40 	.word	0x00030d40

08018b7c <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8018b7c:	b580      	push	{r7, lr}
 8018b7e:	b084      	sub	sp, #16
 8018b80:	af00      	add	r7, sp, #0
 8018b82:	60f8      	str	r0, [r7, #12]
 8018b84:	60b9      	str	r1, [r7, #8]
 8018b86:	4613      	mov	r3, r2
 8018b88:	71fb      	strb	r3, [r7, #7]
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8018b8a:	68fb      	ldr	r3, [r7, #12]
 8018b8c:	2b00      	cmp	r3, #0
 8018b8e:	d101      	bne.n	8018b94 <USBD_Init+0x18>
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 8018b90:	2302      	movs	r3, #2
 8018b92:	e01a      	b.n	8018bca <USBD_Init+0x4e>
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8018b94:	68fb      	ldr	r3, [r7, #12]
 8018b96:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018b9a:	2b00      	cmp	r3, #0
 8018b9c:	d003      	beq.n	8018ba6 <USBD_Init+0x2a>
  {
    pdev->pClass = NULL;
 8018b9e:	68fb      	ldr	r3, [r7, #12]
 8018ba0:	2200      	movs	r2, #0
 8018ba2:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8018ba6:	68bb      	ldr	r3, [r7, #8]
 8018ba8:	2b00      	cmp	r3, #0
 8018baa:	d003      	beq.n	8018bb4 <USBD_Init+0x38>
  {
    pdev->pDesc = pdesc;
 8018bac:	68fb      	ldr	r3, [r7, #12]
 8018bae:	68ba      	ldr	r2, [r7, #8]
 8018bb0:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8018bb4:	68fb      	ldr	r3, [r7, #12]
 8018bb6:	2201      	movs	r2, #1
 8018bb8:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  pdev->id = id;
 8018bbc:	68fb      	ldr	r3, [r7, #12]
 8018bbe:	79fa      	ldrb	r2, [r7, #7]
 8018bc0:	701a      	strb	r2, [r3, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8018bc2:	68f8      	ldr	r0, [r7, #12]
 8018bc4:	f7f8 f9b2 	bl	8010f2c <USBD_LL_Init>
  
  return USBD_OK; 
 8018bc8:	2300      	movs	r3, #0
}
 8018bca:	4618      	mov	r0, r3
 8018bcc:	3710      	adds	r7, #16
 8018bce:	46bd      	mov	sp, r7
 8018bd0:	bd80      	pop	{r7, pc}

08018bd2 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8018bd2:	b480      	push	{r7}
 8018bd4:	b085      	sub	sp, #20
 8018bd6:	af00      	add	r7, sp, #0
 8018bd8:	6078      	str	r0, [r7, #4]
 8018bda:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef   status = USBD_OK;
 8018bdc:	2300      	movs	r3, #0
 8018bde:	73fb      	strb	r3, [r7, #15]
  if(pclass != 0)
 8018be0:	683b      	ldr	r3, [r7, #0]
 8018be2:	2b00      	cmp	r3, #0
 8018be4:	d006      	beq.n	8018bf4 <USBD_RegisterClass+0x22>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8018be6:	687b      	ldr	r3, [r7, #4]
 8018be8:	683a      	ldr	r2, [r7, #0]
 8018bea:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    status = USBD_OK;
 8018bee:	2300      	movs	r3, #0
 8018bf0:	73fb      	strb	r3, [r7, #15]
 8018bf2:	e001      	b.n	8018bf8 <USBD_RegisterClass+0x26>
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8018bf4:	2302      	movs	r3, #2
 8018bf6:	73fb      	strb	r3, [r7, #15]
  }
  
  return status;
 8018bf8:	7bfb      	ldrb	r3, [r7, #15]
}
 8018bfa:	4618      	mov	r0, r3
 8018bfc:	3714      	adds	r7, #20
 8018bfe:	46bd      	mov	sp, r7
 8018c00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018c04:	4770      	bx	lr

08018c06 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8018c06:	b580      	push	{r7, lr}
 8018c08:	b082      	sub	sp, #8
 8018c0a:	af00      	add	r7, sp, #0
 8018c0c:	6078      	str	r0, [r7, #4]
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8018c0e:	6878      	ldr	r0, [r7, #4]
 8018c10:	f7f8 f9dc 	bl	8010fcc <USBD_LL_Start>
  
  return USBD_OK;  
 8018c14:	2300      	movs	r3, #0
}
 8018c16:	4618      	mov	r0, r3
 8018c18:	3708      	adds	r7, #8
 8018c1a:	46bd      	mov	sp, r7
 8018c1c:	bd80      	pop	{r7, pc}

08018c1e <USBD_RunTestMode>:
*         Launch test mode process
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_RunTestMode (USBD_HandleTypeDef  *pdev) 
{
 8018c1e:	b480      	push	{r7}
 8018c20:	b083      	sub	sp, #12
 8018c22:	af00      	add	r7, sp, #0
 8018c24:	6078      	str	r0, [r7, #4]
  return USBD_OK;
 8018c26:	2300      	movs	r3, #0
}
 8018c28:	4618      	mov	r0, r3
 8018c2a:	370c      	adds	r7, #12
 8018c2c:	46bd      	mov	sp, r7
 8018c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018c32:	4770      	bx	lr

08018c34 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8018c34:	b580      	push	{r7, lr}
 8018c36:	b084      	sub	sp, #16
 8018c38:	af00      	add	r7, sp, #0
 8018c3a:	6078      	str	r0, [r7, #4]
 8018c3c:	460b      	mov	r3, r1
 8018c3e:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8018c40:	2302      	movs	r3, #2
 8018c42:	73fb      	strb	r3, [r7, #15]
  
  if(pdev->pClass != NULL)
 8018c44:	687b      	ldr	r3, [r7, #4]
 8018c46:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018c4a:	2b00      	cmp	r3, #0
 8018c4c:	d00c      	beq.n	8018c68 <USBD_SetClassConfig+0x34>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8018c4e:	687b      	ldr	r3, [r7, #4]
 8018c50:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018c54:	681b      	ldr	r3, [r3, #0]
 8018c56:	78fa      	ldrb	r2, [r7, #3]
 8018c58:	4611      	mov	r1, r2
 8018c5a:	6878      	ldr	r0, [r7, #4]
 8018c5c:	4798      	blx	r3
 8018c5e:	4603      	mov	r3, r0
 8018c60:	2b00      	cmp	r3, #0
 8018c62:	d101      	bne.n	8018c68 <USBD_SetClassConfig+0x34>
    {
      ret = USBD_OK;
 8018c64:	2300      	movs	r3, #0
 8018c66:	73fb      	strb	r3, [r7, #15]
    }
  }
  return ret; 
 8018c68:	7bfb      	ldrb	r3, [r7, #15]
}
 8018c6a:	4618      	mov	r0, r3
 8018c6c:	3710      	adds	r7, #16
 8018c6e:	46bd      	mov	sp, r7
 8018c70:	bd80      	pop	{r7, pc}

08018c72 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8018c72:	b580      	push	{r7, lr}
 8018c74:	b082      	sub	sp, #8
 8018c76:	af00      	add	r7, sp, #0
 8018c78:	6078      	str	r0, [r7, #4]
 8018c7a:	460b      	mov	r3, r1
 8018c7c:	70fb      	strb	r3, [r7, #3]
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8018c7e:	687b      	ldr	r3, [r7, #4]
 8018c80:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018c84:	685b      	ldr	r3, [r3, #4]
 8018c86:	78fa      	ldrb	r2, [r7, #3]
 8018c88:	4611      	mov	r1, r2
 8018c8a:	6878      	ldr	r0, [r7, #4]
 8018c8c:	4798      	blx	r3
  return USBD_OK;
 8018c8e:	2300      	movs	r3, #0
}
 8018c90:	4618      	mov	r0, r3
 8018c92:	3708      	adds	r7, #8
 8018c94:	46bd      	mov	sp, r7
 8018c96:	bd80      	pop	{r7, pc}

08018c98 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8018c98:	b580      	push	{r7, lr}
 8018c9a:	b082      	sub	sp, #8
 8018c9c:	af00      	add	r7, sp, #0
 8018c9e:	6078      	str	r0, [r7, #4]
 8018ca0:	6039      	str	r1, [r7, #0]

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8018ca2:	687b      	ldr	r3, [r7, #4]
 8018ca4:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8018ca8:	6839      	ldr	r1, [r7, #0]
 8018caa:	4618      	mov	r0, r3
 8018cac:	f000 fd99 	bl	80197e2 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8018cb0:	687b      	ldr	r3, [r7, #4]
 8018cb2:	2201      	movs	r2, #1
 8018cb4:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8018cb8:	687b      	ldr	r3, [r7, #4]
 8018cba:	f8b3 320e 	ldrh.w	r3, [r3, #526]	; 0x20e
 8018cbe:	461a      	mov	r2, r3
 8018cc0:	687b      	ldr	r3, [r7, #4]
 8018cc2:	f8c3 21f8 	str.w	r2, [r3, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 8018cc6:	687b      	ldr	r3, [r7, #4]
 8018cc8:	f893 3208 	ldrb.w	r3, [r3, #520]	; 0x208
 8018ccc:	f003 031f 	and.w	r3, r3, #31
 8018cd0:	2b01      	cmp	r3, #1
 8018cd2:	d00b      	beq.n	8018cec <USBD_LL_SetupStage+0x54>
 8018cd4:	2b02      	cmp	r3, #2
 8018cd6:	d011      	beq.n	8018cfc <USBD_LL_SetupStage+0x64>
 8018cd8:	2b00      	cmp	r3, #0
 8018cda:	d117      	bne.n	8018d0c <USBD_LL_SetupStage+0x74>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 8018cdc:	687b      	ldr	r3, [r7, #4]
 8018cde:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8018ce2:	4619      	mov	r1, r3
 8018ce4:	6878      	ldr	r0, [r7, #4]
 8018ce6:	f000 f9c7 	bl	8019078 <USBD_StdDevReq>
    break;
 8018cea:	e01a      	b.n	8018d22 <USBD_LL_SetupStage+0x8a>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 8018cec:	687b      	ldr	r3, [r7, #4]
 8018cee:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8018cf2:	4619      	mov	r1, r3
 8018cf4:	6878      	ldr	r0, [r7, #4]
 8018cf6:	f000 fa0f 	bl	8019118 <USBD_StdItfReq>
    break;
 8018cfa:	e012      	b.n	8018d22 <USBD_LL_SetupStage+0x8a>
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 8018cfc:	687b      	ldr	r3, [r7, #4]
 8018cfe:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8018d02:	4619      	mov	r1, r3
 8018d04:	6878      	ldr	r0, [r7, #4]
 8018d06:	f000 fa3a 	bl	801917e <USBD_StdEPReq>
    break;
 8018d0a:	e00a      	b.n	8018d22 <USBD_LL_SetupStage+0x8a>
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8018d0c:	687b      	ldr	r3, [r7, #4]
 8018d0e:	f893 3208 	ldrb.w	r3, [r3, #520]	; 0x208
 8018d12:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8018d16:	b2db      	uxtb	r3, r3
 8018d18:	4619      	mov	r1, r3
 8018d1a:	6878      	ldr	r0, [r7, #4]
 8018d1c:	f7f8 f9a5 	bl	801106a <USBD_LL_StallEP>
    break;
 8018d20:	bf00      	nop
  }  
  return USBD_OK;  
 8018d22:	2300      	movs	r3, #0
}
 8018d24:	4618      	mov	r0, r3
 8018d26:	3708      	adds	r7, #8
 8018d28:	46bd      	mov	sp, r7
 8018d2a:	bd80      	pop	{r7, pc}

08018d2c <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8018d2c:	b580      	push	{r7, lr}
 8018d2e:	b086      	sub	sp, #24
 8018d30:	af00      	add	r7, sp, #0
 8018d32:	60f8      	str	r0, [r7, #12]
 8018d34:	460b      	mov	r3, r1
 8018d36:	607a      	str	r2, [r7, #4]
 8018d38:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8018d3a:	7afb      	ldrb	r3, [r7, #11]
 8018d3c:	2b00      	cmp	r3, #0
 8018d3e:	d138      	bne.n	8018db2 <USBD_LL_DataOutStage+0x86>
  {
    pep = &pdev->ep_out[0];
 8018d40:	68fb      	ldr	r3, [r7, #12]
 8018d42:	f503 7382 	add.w	r3, r3, #260	; 0x104
 8018d46:	617b      	str	r3, [r7, #20]
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8018d48:	68fb      	ldr	r3, [r7, #12]
 8018d4a:	f8d3 31f4 	ldr.w	r3, [r3, #500]	; 0x1f4
 8018d4e:	2b03      	cmp	r3, #3
 8018d50:	d142      	bne.n	8018dd8 <USBD_LL_DataOutStage+0xac>
    {
      if(pep->rem_length > pep->maxpacket)
 8018d52:	697b      	ldr	r3, [r7, #20]
 8018d54:	689a      	ldr	r2, [r3, #8]
 8018d56:	697b      	ldr	r3, [r7, #20]
 8018d58:	68db      	ldr	r3, [r3, #12]
 8018d5a:	429a      	cmp	r2, r3
 8018d5c:	d914      	bls.n	8018d88 <USBD_LL_DataOutStage+0x5c>
      {
        pep->rem_length -=  pep->maxpacket;
 8018d5e:	697b      	ldr	r3, [r7, #20]
 8018d60:	689a      	ldr	r2, [r3, #8]
 8018d62:	697b      	ldr	r3, [r7, #20]
 8018d64:	68db      	ldr	r3, [r3, #12]
 8018d66:	1ad2      	subs	r2, r2, r3
 8018d68:	697b      	ldr	r3, [r7, #20]
 8018d6a:	609a      	str	r2, [r3, #8]
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 8018d6c:	697b      	ldr	r3, [r7, #20]
 8018d6e:	68da      	ldr	r2, [r3, #12]
 8018d70:	697b      	ldr	r3, [r7, #20]
 8018d72:	689b      	ldr	r3, [r3, #8]
 8018d74:	4293      	cmp	r3, r2
 8018d76:	bf28      	it	cs
 8018d78:	4613      	movcs	r3, r2
        USBD_CtlContinueRx (pdev, 
 8018d7a:	b29b      	uxth	r3, r3
 8018d7c:	461a      	mov	r2, r3
 8018d7e:	6879      	ldr	r1, [r7, #4]
 8018d80:	68f8      	ldr	r0, [r7, #12]
 8018d82:	f000 fe05 	bl	8019990 <USBD_CtlContinueRx>
 8018d86:	e027      	b.n	8018dd8 <USBD_LL_DataOutStage+0xac>
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8018d88:	68fb      	ldr	r3, [r7, #12]
 8018d8a:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018d8e:	691b      	ldr	r3, [r3, #16]
 8018d90:	2b00      	cmp	r3, #0
 8018d92:	d00a      	beq.n	8018daa <USBD_LL_DataOutStage+0x7e>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 8018d94:	68fb      	ldr	r3, [r7, #12]
 8018d96:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8018d9a:	2b03      	cmp	r3, #3
 8018d9c:	d105      	bne.n	8018daa <USBD_LL_DataOutStage+0x7e>
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8018d9e:	68fb      	ldr	r3, [r7, #12]
 8018da0:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018da4:	691b      	ldr	r3, [r3, #16]
 8018da6:	68f8      	ldr	r0, [r7, #12]
 8018da8:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8018daa:	68f8      	ldr	r0, [r7, #12]
 8018dac:	f000 fe02 	bl	80199b4 <USBD_CtlSendStatus>
 8018db0:	e012      	b.n	8018dd8 <USBD_LL_DataOutStage+0xac>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8018db2:	68fb      	ldr	r3, [r7, #12]
 8018db4:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018db8:	699b      	ldr	r3, [r3, #24]
 8018dba:	2b00      	cmp	r3, #0
 8018dbc:	d00c      	beq.n	8018dd8 <USBD_LL_DataOutStage+0xac>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
 8018dbe:	68fb      	ldr	r3, [r7, #12]
 8018dc0:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
  else if((pdev->pClass->DataOut != NULL)&&
 8018dc4:	2b03      	cmp	r3, #3
 8018dc6:	d107      	bne.n	8018dd8 <USBD_LL_DataOutStage+0xac>
  {
    pdev->pClass->DataOut(pdev, epnum); 
 8018dc8:	68fb      	ldr	r3, [r7, #12]
 8018dca:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018dce:	699b      	ldr	r3, [r3, #24]
 8018dd0:	7afa      	ldrb	r2, [r7, #11]
 8018dd2:	4611      	mov	r1, r2
 8018dd4:	68f8      	ldr	r0, [r7, #12]
 8018dd6:	4798      	blx	r3
  }  
  return USBD_OK;
 8018dd8:	2300      	movs	r3, #0
}
 8018dda:	4618      	mov	r0, r3
 8018ddc:	3718      	adds	r7, #24
 8018dde:	46bd      	mov	sp, r7
 8018de0:	bd80      	pop	{r7, pc}

08018de2 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8018de2:	b580      	push	{r7, lr}
 8018de4:	b086      	sub	sp, #24
 8018de6:	af00      	add	r7, sp, #0
 8018de8:	60f8      	str	r0, [r7, #12]
 8018dea:	460b      	mov	r3, r1
 8018dec:	607a      	str	r2, [r7, #4]
 8018dee:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8018df0:	7afb      	ldrb	r3, [r7, #11]
 8018df2:	2b00      	cmp	r3, #0
 8018df4:	d16c      	bne.n	8018ed0 <USBD_LL_DataInStage+0xee>
  {
    pep = &pdev->ep_in[0];
 8018df6:	68fb      	ldr	r3, [r7, #12]
 8018df8:	3314      	adds	r3, #20
 8018dfa:	617b      	str	r3, [r7, #20]
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8018dfc:	68fb      	ldr	r3, [r7, #12]
 8018dfe:	f8d3 31f4 	ldr.w	r3, [r3, #500]	; 0x1f4
 8018e02:	2b02      	cmp	r3, #2
 8018e04:	d157      	bne.n	8018eb6 <USBD_LL_DataInStage+0xd4>
    {
      if(pep->rem_length > pep->maxpacket)
 8018e06:	697b      	ldr	r3, [r7, #20]
 8018e08:	689a      	ldr	r2, [r3, #8]
 8018e0a:	697b      	ldr	r3, [r7, #20]
 8018e0c:	68db      	ldr	r3, [r3, #12]
 8018e0e:	429a      	cmp	r2, r3
 8018e10:	d915      	bls.n	8018e3e <USBD_LL_DataInStage+0x5c>
      {
        pep->rem_length -=  pep->maxpacket;
 8018e12:	697b      	ldr	r3, [r7, #20]
 8018e14:	689a      	ldr	r2, [r3, #8]
 8018e16:	697b      	ldr	r3, [r7, #20]
 8018e18:	68db      	ldr	r3, [r3, #12]
 8018e1a:	1ad2      	subs	r2, r2, r3
 8018e1c:	697b      	ldr	r3, [r7, #20]
 8018e1e:	609a      	str	r2, [r3, #8]
        
        USBD_CtlContinueSendData (pdev, 
                                  pdata, 
                                  pep->rem_length);
 8018e20:	697b      	ldr	r3, [r7, #20]
 8018e22:	689b      	ldr	r3, [r3, #8]
        USBD_CtlContinueSendData (pdev, 
 8018e24:	b29b      	uxth	r3, r3
 8018e26:	461a      	mov	r2, r3
 8018e28:	6879      	ldr	r1, [r7, #4]
 8018e2a:	68f8      	ldr	r0, [r7, #12]
 8018e2c:	f000 fd9e 	bl	801996c <USBD_CtlContinueSendData>
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8018e30:	2300      	movs	r3, #0
 8018e32:	2200      	movs	r2, #0
 8018e34:	2100      	movs	r1, #0
 8018e36:	68f8      	ldr	r0, [r7, #12]
 8018e38:	f7f8 f993 	bl	8011162 <USBD_LL_PrepareReceive>
 8018e3c:	e03b      	b.n	8018eb6 <USBD_LL_DataInStage+0xd4>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 8018e3e:	697b      	ldr	r3, [r7, #20]
 8018e40:	685b      	ldr	r3, [r3, #4]
 8018e42:	697a      	ldr	r2, [r7, #20]
 8018e44:	68d2      	ldr	r2, [r2, #12]
 8018e46:	fbb3 f1f2 	udiv	r1, r3, r2
 8018e4a:	fb02 f201 	mul.w	r2, r2, r1
 8018e4e:	1a9b      	subs	r3, r3, r2
 8018e50:	2b00      	cmp	r3, #0
 8018e52:	d11c      	bne.n	8018e8e <USBD_LL_DataInStage+0xac>
           (pep->total_length >= pep->maxpacket) &&
 8018e54:	697b      	ldr	r3, [r7, #20]
 8018e56:	685a      	ldr	r2, [r3, #4]
 8018e58:	697b      	ldr	r3, [r7, #20]
 8018e5a:	68db      	ldr	r3, [r3, #12]
        if((pep->total_length % pep->maxpacket == 0) &&
 8018e5c:	429a      	cmp	r2, r3
 8018e5e:	d316      	bcc.n	8018e8e <USBD_LL_DataInStage+0xac>
             (pep->total_length < pdev->ep0_data_len ))
 8018e60:	697b      	ldr	r3, [r7, #20]
 8018e62:	685a      	ldr	r2, [r3, #4]
 8018e64:	68fb      	ldr	r3, [r7, #12]
 8018e66:	f8d3 31f8 	ldr.w	r3, [r3, #504]	; 0x1f8
           (pep->total_length >= pep->maxpacket) &&
 8018e6a:	429a      	cmp	r2, r3
 8018e6c:	d20f      	bcs.n	8018e8e <USBD_LL_DataInStage+0xac>
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8018e6e:	2200      	movs	r2, #0
 8018e70:	2100      	movs	r1, #0
 8018e72:	68f8      	ldr	r0, [r7, #12]
 8018e74:	f000 fd7a 	bl	801996c <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8018e78:	68fb      	ldr	r3, [r7, #12]
 8018e7a:	2200      	movs	r2, #0
 8018e7c:	f8c3 21f8 	str.w	r2, [r3, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8018e80:	2300      	movs	r3, #0
 8018e82:	2200      	movs	r2, #0
 8018e84:	2100      	movs	r1, #0
 8018e86:	68f8      	ldr	r0, [r7, #12]
 8018e88:	f7f8 f96b 	bl	8011162 <USBD_LL_PrepareReceive>
 8018e8c:	e013      	b.n	8018eb6 <USBD_LL_DataInStage+0xd4>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8018e8e:	68fb      	ldr	r3, [r7, #12]
 8018e90:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018e94:	68db      	ldr	r3, [r3, #12]
 8018e96:	2b00      	cmp	r3, #0
 8018e98:	d00a      	beq.n	8018eb0 <USBD_LL_DataInStage+0xce>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
 8018e9a:	68fb      	ldr	r3, [r7, #12]
 8018e9c:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8018ea0:	2b03      	cmp	r3, #3
 8018ea2:	d105      	bne.n	8018eb0 <USBD_LL_DataInStage+0xce>
          {
            pdev->pClass->EP0_TxSent(pdev); 
 8018ea4:	68fb      	ldr	r3, [r7, #12]
 8018ea6:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018eaa:	68db      	ldr	r3, [r3, #12]
 8018eac:	68f8      	ldr	r0, [r7, #12]
 8018eae:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 8018eb0:	68f8      	ldr	r0, [r7, #12]
 8018eb2:	f000 fd92 	bl	80199da <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8018eb6:	68fb      	ldr	r3, [r7, #12]
 8018eb8:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8018ebc:	2b01      	cmp	r3, #1
 8018ebe:	d11a      	bne.n	8018ef6 <USBD_LL_DataInStage+0x114>
    {
      USBD_RunTestMode(pdev); 
 8018ec0:	68f8      	ldr	r0, [r7, #12]
 8018ec2:	f7ff feac 	bl	8018c1e <USBD_RunTestMode>
      pdev->dev_test_mode = 0;
 8018ec6:	68fb      	ldr	r3, [r7, #12]
 8018ec8:	2200      	movs	r2, #0
 8018eca:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
 8018ece:	e012      	b.n	8018ef6 <USBD_LL_DataInStage+0x114>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 8018ed0:	68fb      	ldr	r3, [r7, #12]
 8018ed2:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018ed6:	695b      	ldr	r3, [r3, #20]
 8018ed8:	2b00      	cmp	r3, #0
 8018eda:	d00c      	beq.n	8018ef6 <USBD_LL_DataInStage+0x114>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
 8018edc:	68fb      	ldr	r3, [r7, #12]
 8018ede:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
  else if((pdev->pClass->DataIn != NULL)&& 
 8018ee2:	2b03      	cmp	r3, #3
 8018ee4:	d107      	bne.n	8018ef6 <USBD_LL_DataInStage+0x114>
  {
    pdev->pClass->DataIn(pdev, epnum); 
 8018ee6:	68fb      	ldr	r3, [r7, #12]
 8018ee8:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018eec:	695b      	ldr	r3, [r3, #20]
 8018eee:	7afa      	ldrb	r2, [r7, #11]
 8018ef0:	4611      	mov	r1, r2
 8018ef2:	68f8      	ldr	r0, [r7, #12]
 8018ef4:	4798      	blx	r3
  }  
  return USBD_OK;
 8018ef6:	2300      	movs	r3, #0
}
 8018ef8:	4618      	mov	r0, r3
 8018efa:	3718      	adds	r7, #24
 8018efc:	46bd      	mov	sp, r7
 8018efe:	bd80      	pop	{r7, pc}

08018f00 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8018f00:	b580      	push	{r7, lr}
 8018f02:	b082      	sub	sp, #8
 8018f04:	af00      	add	r7, sp, #0
 8018f06:	6078      	str	r0, [r7, #4]
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8018f08:	2340      	movs	r3, #64	; 0x40
 8018f0a:	2200      	movs	r2, #0
 8018f0c:	2100      	movs	r1, #0
 8018f0e:	6878      	ldr	r0, [r7, #4]
 8018f10:	f7f8 f86b 	bl	8010fea <USBD_LL_OpenEP>
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8018f14:	687b      	ldr	r3, [r7, #4]
 8018f16:	2240      	movs	r2, #64	; 0x40
 8018f18:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8018f1c:	2340      	movs	r3, #64	; 0x40
 8018f1e:	2200      	movs	r2, #0
 8018f20:	2180      	movs	r1, #128	; 0x80
 8018f22:	6878      	ldr	r0, [r7, #4]
 8018f24:	f7f8 f861 	bl	8010fea <USBD_LL_OpenEP>
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8018f28:	687b      	ldr	r3, [r7, #4]
 8018f2a:	2240      	movs	r2, #64	; 0x40
 8018f2c:	621a      	str	r2, [r3, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8018f2e:	687b      	ldr	r3, [r7, #4]
 8018f30:	2201      	movs	r2, #1
 8018f32:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8018f36:	687b      	ldr	r3, [r7, #4]
 8018f38:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8018f3c:	2b00      	cmp	r3, #0
 8018f3e:	d009      	beq.n	8018f54 <USBD_LL_Reset+0x54>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8018f40:	687b      	ldr	r3, [r7, #4]
 8018f42:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018f46:	685b      	ldr	r3, [r3, #4]
 8018f48:	687a      	ldr	r2, [r7, #4]
 8018f4a:	6852      	ldr	r2, [r2, #4]
 8018f4c:	b2d2      	uxtb	r2, r2
 8018f4e:	4611      	mov	r1, r2
 8018f50:	6878      	ldr	r0, [r7, #4]
 8018f52:	4798      	blx	r3
 
  
  return USBD_OK;
 8018f54:	2300      	movs	r3, #0
}
 8018f56:	4618      	mov	r0, r3
 8018f58:	3708      	adds	r7, #8
 8018f5a:	46bd      	mov	sp, r7
 8018f5c:	bd80      	pop	{r7, pc}

08018f5e <USBD_LL_SetSpeed>:
*         Handle Reset event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
 8018f5e:	b480      	push	{r7}
 8018f60:	b083      	sub	sp, #12
 8018f62:	af00      	add	r7, sp, #0
 8018f64:	6078      	str	r0, [r7, #4]
 8018f66:	460b      	mov	r3, r1
 8018f68:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 8018f6a:	687b      	ldr	r3, [r7, #4]
 8018f6c:	78fa      	ldrb	r2, [r7, #3]
 8018f6e:	741a      	strb	r2, [r3, #16]
  return USBD_OK;
 8018f70:	2300      	movs	r3, #0
}
 8018f72:	4618      	mov	r0, r3
 8018f74:	370c      	adds	r7, #12
 8018f76:	46bd      	mov	sp, r7
 8018f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018f7c:	4770      	bx	lr

08018f7e <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
 8018f7e:	b480      	push	{r7}
 8018f80:	b083      	sub	sp, #12
 8018f82:	af00      	add	r7, sp, #0
 8018f84:	6078      	str	r0, [r7, #4]
  pdev->dev_old_state =  pdev->dev_state;
 8018f86:	687b      	ldr	r3, [r7, #4]
 8018f88:	f893 21fc 	ldrb.w	r2, [r3, #508]	; 0x1fc
 8018f8c:	687b      	ldr	r3, [r7, #4]
 8018f8e:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8018f92:	687b      	ldr	r3, [r7, #4]
 8018f94:	2204      	movs	r2, #4
 8018f96:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  return USBD_OK;
 8018f9a:	2300      	movs	r3, #0
}
 8018f9c:	4618      	mov	r0, r3
 8018f9e:	370c      	adds	r7, #12
 8018fa0:	46bd      	mov	sp, r7
 8018fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018fa6:	4770      	bx	lr

08018fa8 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 8018fa8:	b480      	push	{r7}
 8018faa:	b083      	sub	sp, #12
 8018fac:	af00      	add	r7, sp, #0
 8018fae:	6078      	str	r0, [r7, #4]
  pdev->dev_state = pdev->dev_old_state;  
 8018fb0:	687b      	ldr	r3, [r7, #4]
 8018fb2:	f893 21fd 	ldrb.w	r2, [r3, #509]	; 0x1fd
 8018fb6:	687b      	ldr	r3, [r7, #4]
 8018fb8:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  return USBD_OK;
 8018fbc:	2300      	movs	r3, #0
}
 8018fbe:	4618      	mov	r0, r3
 8018fc0:	370c      	adds	r7, #12
 8018fc2:	46bd      	mov	sp, r7
 8018fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018fc8:	4770      	bx	lr

08018fca <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8018fca:	b580      	push	{r7, lr}
 8018fcc:	b082      	sub	sp, #8
 8018fce:	af00      	add	r7, sp, #0
 8018fd0:	6078      	str	r0, [r7, #4]
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8018fd2:	687b      	ldr	r3, [r7, #4]
 8018fd4:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8018fd8:	2b03      	cmp	r3, #3
 8018fda:	d10b      	bne.n	8018ff4 <USBD_LL_SOF+0x2a>
  {
    if(pdev->pClass->SOF != NULL)
 8018fdc:	687b      	ldr	r3, [r7, #4]
 8018fde:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018fe2:	69db      	ldr	r3, [r3, #28]
 8018fe4:	2b00      	cmp	r3, #0
 8018fe6:	d005      	beq.n	8018ff4 <USBD_LL_SOF+0x2a>
    {
      pdev->pClass->SOF(pdev);
 8018fe8:	687b      	ldr	r3, [r7, #4]
 8018fea:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8018fee:	69db      	ldr	r3, [r3, #28]
 8018ff0:	6878      	ldr	r0, [r7, #4]
 8018ff2:	4798      	blx	r3
    }
  }
  return USBD_OK;
 8018ff4:	2300      	movs	r3, #0
}
 8018ff6:	4618      	mov	r0, r3
 8018ff8:	3708      	adds	r7, #8
 8018ffa:	46bd      	mov	sp, r7
 8018ffc:	bd80      	pop	{r7, pc}

08018ffe <USBD_LL_IsoINIncomplete>:
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 8018ffe:	b480      	push	{r7}
 8019000:	b083      	sub	sp, #12
 8019002:	af00      	add	r7, sp, #0
 8019004:	6078      	str	r0, [r7, #4]
 8019006:	460b      	mov	r3, r1
 8019008:	70fb      	strb	r3, [r7, #3]
  return USBD_OK;
 801900a:	2300      	movs	r3, #0
}
 801900c:	4618      	mov	r0, r3
 801900e:	370c      	adds	r7, #12
 8019010:	46bd      	mov	sp, r7
 8019012:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019016:	4770      	bx	lr

08019018 <USBD_LL_IsoOUTIncomplete>:
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 8019018:	b480      	push	{r7}
 801901a:	b083      	sub	sp, #12
 801901c:	af00      	add	r7, sp, #0
 801901e:	6078      	str	r0, [r7, #4]
 8019020:	460b      	mov	r3, r1
 8019022:	70fb      	strb	r3, [r7, #3]
  return USBD_OK;
 8019024:	2300      	movs	r3, #0
}
 8019026:	4618      	mov	r0, r3
 8019028:	370c      	adds	r7, #12
 801902a:	46bd      	mov	sp, r7
 801902c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019030:	4770      	bx	lr

08019032 <USBD_LL_DevConnected>:
*         Handle device connection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
 8019032:	b480      	push	{r7}
 8019034:	b083      	sub	sp, #12
 8019036:	af00      	add	r7, sp, #0
 8019038:	6078      	str	r0, [r7, #4]
  return USBD_OK;
 801903a:	2300      	movs	r3, #0
}
 801903c:	4618      	mov	r0, r3
 801903e:	370c      	adds	r7, #12
 8019040:	46bd      	mov	sp, r7
 8019042:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019046:	4770      	bx	lr

08019048 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 8019048:	b580      	push	{r7, lr}
 801904a:	b082      	sub	sp, #8
 801904c:	af00      	add	r7, sp, #0
 801904e:	6078      	str	r0, [r7, #4]
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8019050:	687b      	ldr	r3, [r7, #4]
 8019052:	2201      	movs	r2, #1
 8019054:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8019058:	687b      	ldr	r3, [r7, #4]
 801905a:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 801905e:	685b      	ldr	r3, [r3, #4]
 8019060:	687a      	ldr	r2, [r7, #4]
 8019062:	6852      	ldr	r2, [r2, #4]
 8019064:	b2d2      	uxtb	r2, r2
 8019066:	4611      	mov	r1, r2
 8019068:	6878      	ldr	r0, [r7, #4]
 801906a:	4798      	blx	r3
   
  return USBD_OK;
 801906c:	2300      	movs	r3, #0
}
 801906e:	4618      	mov	r0, r3
 8019070:	3708      	adds	r7, #8
 8019072:	46bd      	mov	sp, r7
 8019074:	bd80      	pop	{r7, pc}
	...

08019078 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8019078:	b580      	push	{r7, lr}
 801907a:	b084      	sub	sp, #16
 801907c:	af00      	add	r7, sp, #0
 801907e:	6078      	str	r0, [r7, #4]
 8019080:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;  
 8019082:	2300      	movs	r3, #0
 8019084:	73fb      	strb	r3, [r7, #15]
  
  switch (req->bRequest) 
 8019086:	683b      	ldr	r3, [r7, #0]
 8019088:	785b      	ldrb	r3, [r3, #1]
 801908a:	2b09      	cmp	r3, #9
 801908c:	d839      	bhi.n	8019102 <USBD_StdDevReq+0x8a>
 801908e:	a201      	add	r2, pc, #4	; (adr r2, 8019094 <USBD_StdDevReq+0x1c>)
 8019090:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019094:	080190e5 	.word	0x080190e5
 8019098:	080190f9 	.word	0x080190f9
 801909c:	08019103 	.word	0x08019103
 80190a0:	080190ef 	.word	0x080190ef
 80190a4:	08019103 	.word	0x08019103
 80190a8:	080190c7 	.word	0x080190c7
 80190ac:	080190bd 	.word	0x080190bd
 80190b0:	08019103 	.word	0x08019103
 80190b4:	080190db 	.word	0x080190db
 80190b8:	080190d1 	.word	0x080190d1
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
 80190bc:	6839      	ldr	r1, [r7, #0]
 80190be:	6878      	ldr	r0, [r7, #4]
 80190c0:	f000 f936 	bl	8019330 <USBD_GetDescriptor>
    break;
 80190c4:	e022      	b.n	801910c <USBD_StdDevReq+0x94>
    
  case USB_REQ_SET_ADDRESS:                      
    USBD_SetAddress(pdev, req);
 80190c6:	6839      	ldr	r1, [r7, #0]
 80190c8:	6878      	ldr	r0, [r7, #4]
 80190ca:	f000 fa25 	bl	8019518 <USBD_SetAddress>
    break;
 80190ce:	e01d      	b.n	801910c <USBD_StdDevReq+0x94>
    
  case USB_REQ_SET_CONFIGURATION:                    
    USBD_SetConfig (pdev , req);
 80190d0:	6839      	ldr	r1, [r7, #0]
 80190d2:	6878      	ldr	r0, [r7, #4]
 80190d4:	f000 fa5e 	bl	8019594 <USBD_SetConfig>
    break;
 80190d8:	e018      	b.n	801910c <USBD_StdDevReq+0x94>
    
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
 80190da:	6839      	ldr	r1, [r7, #0]
 80190dc:	6878      	ldr	r0, [r7, #4]
 80190de:	f000 fae1 	bl	80196a4 <USBD_GetConfig>
    break;
 80190e2:	e013      	b.n	801910c <USBD_StdDevReq+0x94>
    
  case USB_REQ_GET_STATUS:                                  
    USBD_GetStatus (pdev , req);
 80190e4:	6839      	ldr	r1, [r7, #0]
 80190e6:	6878      	ldr	r0, [r7, #4]
 80190e8:	f000 fb0e 	bl	8019708 <USBD_GetStatus>
    break;
 80190ec:	e00e      	b.n	801910c <USBD_StdDevReq+0x94>
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
 80190ee:	6839      	ldr	r1, [r7, #0]
 80190f0:	6878      	ldr	r0, [r7, #4]
 80190f2:	f000 fb33 	bl	801975c <USBD_SetFeature>
    break;
 80190f6:	e009      	b.n	801910c <USBD_StdDevReq+0x94>
    
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
 80190f8:	6839      	ldr	r1, [r7, #0]
 80190fa:	6878      	ldr	r0, [r7, #4]
 80190fc:	f000 fb49 	bl	8019792 <USBD_ClrFeature>
    break;
 8019100:	e004      	b.n	801910c <USBD_StdDevReq+0x94>
    
  default:  
    USBD_CtlError(pdev , req);
 8019102:	6839      	ldr	r1, [r7, #0]
 8019104:	6878      	ldr	r0, [r7, #4]
 8019106:	f000 fba9 	bl	801985c <USBD_CtlError>
    break;
 801910a:	bf00      	nop
  }
  
  return ret;
 801910c:	7bfb      	ldrb	r3, [r7, #15]
}
 801910e:	4618      	mov	r0, r3
 8019110:	3710      	adds	r7, #16
 8019112:	46bd      	mov	sp, r7
 8019114:	bd80      	pop	{r7, pc}
 8019116:	bf00      	nop

08019118 <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8019118:	b580      	push	{r7, lr}
 801911a:	b084      	sub	sp, #16
 801911c:	af00      	add	r7, sp, #0
 801911e:	6078      	str	r0, [r7, #4]
 8019120:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK; 
 8019122:	2300      	movs	r3, #0
 8019124:	73fb      	strb	r3, [r7, #15]
  
  switch (pdev->dev_state) 
 8019126:	687b      	ldr	r3, [r7, #4]
 8019128:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 801912c:	2b03      	cmp	r3, #3
 801912e:	d11b      	bne.n	8019168 <USBD_StdItfReq+0x50>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 8019130:	683b      	ldr	r3, [r7, #0]
 8019132:	889b      	ldrh	r3, [r3, #4]
 8019134:	b2db      	uxtb	r3, r3
 8019136:	2b01      	cmp	r3, #1
 8019138:	d811      	bhi.n	801915e <USBD_StdItfReq+0x46>
    {
      pdev->pClass->Setup (pdev, req); 
 801913a:	687b      	ldr	r3, [r7, #4]
 801913c:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8019140:	689b      	ldr	r3, [r3, #8]
 8019142:	6839      	ldr	r1, [r7, #0]
 8019144:	6878      	ldr	r0, [r7, #4]
 8019146:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 8019148:	683b      	ldr	r3, [r7, #0]
 801914a:	88db      	ldrh	r3, [r3, #6]
 801914c:	2b00      	cmp	r3, #0
 801914e:	d110      	bne.n	8019172 <USBD_StdItfReq+0x5a>
 8019150:	7bfb      	ldrb	r3, [r7, #15]
 8019152:	2b00      	cmp	r3, #0
 8019154:	d10d      	bne.n	8019172 <USBD_StdItfReq+0x5a>
      {
         USBD_CtlSendStatus(pdev);
 8019156:	6878      	ldr	r0, [r7, #4]
 8019158:	f000 fc2c 	bl	80199b4 <USBD_CtlSendStatus>
    } 
    else 
    {                                               
       USBD_CtlError(pdev , req);
    }
    break;
 801915c:	e009      	b.n	8019172 <USBD_StdItfReq+0x5a>
       USBD_CtlError(pdev , req);
 801915e:	6839      	ldr	r1, [r7, #0]
 8019160:	6878      	ldr	r0, [r7, #4]
 8019162:	f000 fb7b 	bl	801985c <USBD_CtlError>
    break;
 8019166:	e004      	b.n	8019172 <USBD_StdItfReq+0x5a>
    
  default:
     USBD_CtlError(pdev , req);
 8019168:	6839      	ldr	r1, [r7, #0]
 801916a:	6878      	ldr	r0, [r7, #4]
 801916c:	f000 fb76 	bl	801985c <USBD_CtlError>
    break;
 8019170:	e000      	b.n	8019174 <USBD_StdItfReq+0x5c>
    break;
 8019172:	bf00      	nop
  }
  return USBD_OK;
 8019174:	2300      	movs	r3, #0
}
 8019176:	4618      	mov	r0, r3
 8019178:	3710      	adds	r7, #16
 801917a:	46bd      	mov	sp, r7
 801917c:	bd80      	pop	{r7, pc}

0801917e <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 801917e:	b580      	push	{r7, lr}
 8019180:	b084      	sub	sp, #16
 8019182:	af00      	add	r7, sp, #0
 8019184:	6078      	str	r0, [r7, #4]
 8019186:	6039      	str	r1, [r7, #0]
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
 8019188:	2300      	movs	r3, #0
 801918a:	73fb      	strb	r3, [r7, #15]
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 801918c:	683b      	ldr	r3, [r7, #0]
 801918e:	889b      	ldrh	r3, [r3, #4]
 8019190:	73bb      	strb	r3, [r7, #14]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8019192:	683b      	ldr	r3, [r7, #0]
 8019194:	781b      	ldrb	r3, [r3, #0]
 8019196:	f003 0360 	and.w	r3, r3, #96	; 0x60
 801919a:	2b20      	cmp	r3, #32
 801919c:	d108      	bne.n	80191b0 <USBD_StdEPReq+0x32>
  {
    pdev->pClass->Setup (pdev, req);
 801919e:	687b      	ldr	r3, [r7, #4]
 80191a0:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80191a4:	689b      	ldr	r3, [r3, #8]
 80191a6:	6839      	ldr	r1, [r7, #0]
 80191a8:	6878      	ldr	r0, [r7, #4]
 80191aa:	4798      	blx	r3
    
    return USBD_OK;
 80191ac:	2300      	movs	r3, #0
 80191ae:	e0ba      	b.n	8019326 <USBD_StdEPReq+0x1a8>
  }
  
  switch (req->bRequest) 
 80191b0:	683b      	ldr	r3, [r7, #0]
 80191b2:	785b      	ldrb	r3, [r3, #1]
 80191b4:	2b01      	cmp	r3, #1
 80191b6:	d039      	beq.n	801922c <USBD_StdEPReq+0xae>
 80191b8:	2b03      	cmp	r3, #3
 80191ba:	d002      	beq.n	80191c2 <USBD_StdEPReq+0x44>
 80191bc:	2b00      	cmp	r3, #0
 80191be:	d06b      	beq.n	8019298 <USBD_StdEPReq+0x11a>
      break;
    }
    break;
    
  default:
    break;
 80191c0:	e0b0      	b.n	8019324 <USBD_StdEPReq+0x1a6>
    switch (pdev->dev_state) 
 80191c2:	687b      	ldr	r3, [r7, #4]
 80191c4:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80191c8:	2b02      	cmp	r3, #2
 80191ca:	d002      	beq.n	80191d2 <USBD_StdEPReq+0x54>
 80191cc:	2b03      	cmp	r3, #3
 80191ce:	d00c      	beq.n	80191ea <USBD_StdEPReq+0x6c>
 80191d0:	e025      	b.n	801921e <USBD_StdEPReq+0xa0>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80191d2:	7bbb      	ldrb	r3, [r7, #14]
 80191d4:	2b00      	cmp	r3, #0
 80191d6:	d027      	beq.n	8019228 <USBD_StdEPReq+0xaa>
 80191d8:	7bbb      	ldrb	r3, [r7, #14]
 80191da:	2b80      	cmp	r3, #128	; 0x80
 80191dc:	d024      	beq.n	8019228 <USBD_StdEPReq+0xaa>
        USBD_LL_StallEP(pdev , ep_addr);
 80191de:	7bbb      	ldrb	r3, [r7, #14]
 80191e0:	4619      	mov	r1, r3
 80191e2:	6878      	ldr	r0, [r7, #4]
 80191e4:	f7f7 ff41 	bl	801106a <USBD_LL_StallEP>
      break;	
 80191e8:	e01e      	b.n	8019228 <USBD_StdEPReq+0xaa>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80191ea:	683b      	ldr	r3, [r7, #0]
 80191ec:	885b      	ldrh	r3, [r3, #2]
 80191ee:	2b00      	cmp	r3, #0
 80191f0:	d10a      	bne.n	8019208 <USBD_StdEPReq+0x8a>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80191f2:	7bbb      	ldrb	r3, [r7, #14]
 80191f4:	2b00      	cmp	r3, #0
 80191f6:	d007      	beq.n	8019208 <USBD_StdEPReq+0x8a>
 80191f8:	7bbb      	ldrb	r3, [r7, #14]
 80191fa:	2b80      	cmp	r3, #128	; 0x80
 80191fc:	d004      	beq.n	8019208 <USBD_StdEPReq+0x8a>
          USBD_LL_StallEP(pdev , ep_addr);
 80191fe:	7bbb      	ldrb	r3, [r7, #14]
 8019200:	4619      	mov	r1, r3
 8019202:	6878      	ldr	r0, [r7, #4]
 8019204:	f7f7 ff31 	bl	801106a <USBD_LL_StallEP>
      pdev->pClass->Setup (pdev, req);   
 8019208:	687b      	ldr	r3, [r7, #4]
 801920a:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 801920e:	689b      	ldr	r3, [r3, #8]
 8019210:	6839      	ldr	r1, [r7, #0]
 8019212:	6878      	ldr	r0, [r7, #4]
 8019214:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 8019216:	6878      	ldr	r0, [r7, #4]
 8019218:	f000 fbcc 	bl	80199b4 <USBD_CtlSendStatus>
      break;
 801921c:	e005      	b.n	801922a <USBD_StdEPReq+0xac>
      USBD_CtlError(pdev , req);
 801921e:	6839      	ldr	r1, [r7, #0]
 8019220:	6878      	ldr	r0, [r7, #4]
 8019222:	f000 fb1b 	bl	801985c <USBD_CtlError>
      break;    
 8019226:	e000      	b.n	801922a <USBD_StdEPReq+0xac>
      break;	
 8019228:	bf00      	nop
    break;
 801922a:	e07b      	b.n	8019324 <USBD_StdEPReq+0x1a6>
    switch (pdev->dev_state) 
 801922c:	687b      	ldr	r3, [r7, #4]
 801922e:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8019232:	2b02      	cmp	r3, #2
 8019234:	d002      	beq.n	801923c <USBD_StdEPReq+0xbe>
 8019236:	2b03      	cmp	r3, #3
 8019238:	d00c      	beq.n	8019254 <USBD_StdEPReq+0xd6>
 801923a:	e024      	b.n	8019286 <USBD_StdEPReq+0x108>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 801923c:	7bbb      	ldrb	r3, [r7, #14]
 801923e:	2b00      	cmp	r3, #0
 8019240:	d026      	beq.n	8019290 <USBD_StdEPReq+0x112>
 8019242:	7bbb      	ldrb	r3, [r7, #14]
 8019244:	2b80      	cmp	r3, #128	; 0x80
 8019246:	d023      	beq.n	8019290 <USBD_StdEPReq+0x112>
        USBD_LL_StallEP(pdev , ep_addr);
 8019248:	7bbb      	ldrb	r3, [r7, #14]
 801924a:	4619      	mov	r1, r3
 801924c:	6878      	ldr	r0, [r7, #4]
 801924e:	f7f7 ff0c 	bl	801106a <USBD_LL_StallEP>
      break;	
 8019252:	e01d      	b.n	8019290 <USBD_StdEPReq+0x112>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8019254:	683b      	ldr	r3, [r7, #0]
 8019256:	885b      	ldrh	r3, [r3, #2]
 8019258:	2b00      	cmp	r3, #0
 801925a:	d11b      	bne.n	8019294 <USBD_StdEPReq+0x116>
        if ((ep_addr & 0x7F) != 0x00) 
 801925c:	7bbb      	ldrb	r3, [r7, #14]
 801925e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8019262:	2b00      	cmp	r3, #0
 8019264:	d00b      	beq.n	801927e <USBD_StdEPReq+0x100>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8019266:	7bbb      	ldrb	r3, [r7, #14]
 8019268:	4619      	mov	r1, r3
 801926a:	6878      	ldr	r0, [r7, #4]
 801926c:	f7f7 ff10 	bl	8011090 <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 8019270:	687b      	ldr	r3, [r7, #4]
 8019272:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8019276:	689b      	ldr	r3, [r3, #8]
 8019278:	6839      	ldr	r1, [r7, #0]
 801927a:	6878      	ldr	r0, [r7, #4]
 801927c:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 801927e:	6878      	ldr	r0, [r7, #4]
 8019280:	f000 fb98 	bl	80199b4 <USBD_CtlSendStatus>
      break;
 8019284:	e006      	b.n	8019294 <USBD_StdEPReq+0x116>
      USBD_CtlError(pdev , req);
 8019286:	6839      	ldr	r1, [r7, #0]
 8019288:	6878      	ldr	r0, [r7, #4]
 801928a:	f000 fae7 	bl	801985c <USBD_CtlError>
      break;    
 801928e:	e002      	b.n	8019296 <USBD_StdEPReq+0x118>
      break;	
 8019290:	bf00      	nop
 8019292:	e047      	b.n	8019324 <USBD_StdEPReq+0x1a6>
      break;
 8019294:	bf00      	nop
    break;
 8019296:	e045      	b.n	8019324 <USBD_StdEPReq+0x1a6>
    switch (pdev->dev_state) 
 8019298:	687b      	ldr	r3, [r7, #4]
 801929a:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 801929e:	2b02      	cmp	r3, #2
 80192a0:	d002      	beq.n	80192a8 <USBD_StdEPReq+0x12a>
 80192a2:	2b03      	cmp	r3, #3
 80192a4:	d00b      	beq.n	80192be <USBD_StdEPReq+0x140>
 80192a6:	e036      	b.n	8019316 <USBD_StdEPReq+0x198>
      if ((ep_addr & 0x7F) != 0x00) 
 80192a8:	7bbb      	ldrb	r3, [r7, #14]
 80192aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80192ae:	2b00      	cmp	r3, #0
 80192b0:	d036      	beq.n	8019320 <USBD_StdEPReq+0x1a2>
        USBD_LL_StallEP(pdev , ep_addr);
 80192b2:	7bbb      	ldrb	r3, [r7, #14]
 80192b4:	4619      	mov	r1, r3
 80192b6:	6878      	ldr	r0, [r7, #4]
 80192b8:	f7f7 fed7 	bl	801106a <USBD_LL_StallEP>
      break;	
 80192bc:	e030      	b.n	8019320 <USBD_StdEPReq+0x1a2>
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80192be:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80192c2:	2b00      	cmp	r3, #0
 80192c4:	da08      	bge.n	80192d8 <USBD_StdEPReq+0x15a>
 80192c6:	7bbb      	ldrb	r3, [r7, #14]
 80192c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80192cc:	3301      	adds	r3, #1
 80192ce:	011b      	lsls	r3, r3, #4
 80192d0:	687a      	ldr	r2, [r7, #4]
 80192d2:	4413      	add	r3, r2
 80192d4:	3304      	adds	r3, #4
 80192d6:	e007      	b.n	80192e8 <USBD_StdEPReq+0x16a>
                                         &pdev->ep_out[ep_addr & 0x7F];
 80192d8:	7bbb      	ldrb	r3, [r7, #14]
 80192da:	f003 037f 	and.w	r3, r3, #127	; 0x7f
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80192de:	3310      	adds	r3, #16
 80192e0:	011b      	lsls	r3, r3, #4
 80192e2:	687a      	ldr	r2, [r7, #4]
 80192e4:	4413      	add	r3, r2
 80192e6:	3304      	adds	r3, #4
 80192e8:	60bb      	str	r3, [r7, #8]
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80192ea:	7bbb      	ldrb	r3, [r7, #14]
 80192ec:	4619      	mov	r1, r3
 80192ee:	6878      	ldr	r0, [r7, #4]
 80192f0:	f7f7 fee1 	bl	80110b6 <USBD_LL_IsStallEP>
 80192f4:	4603      	mov	r3, r0
 80192f6:	2b00      	cmp	r3, #0
 80192f8:	d003      	beq.n	8019302 <USBD_StdEPReq+0x184>
        pep->status = 0x0001;     
 80192fa:	68bb      	ldr	r3, [r7, #8]
 80192fc:	2201      	movs	r2, #1
 80192fe:	601a      	str	r2, [r3, #0]
 8019300:	e002      	b.n	8019308 <USBD_StdEPReq+0x18a>
        pep->status = 0x0000;  
 8019302:	68bb      	ldr	r3, [r7, #8]
 8019304:	2200      	movs	r2, #0
 8019306:	601a      	str	r2, [r3, #0]
                        (uint8_t *)&pep->status,
 8019308:	68bb      	ldr	r3, [r7, #8]
      USBD_CtlSendData (pdev,
 801930a:	2202      	movs	r2, #2
 801930c:	4619      	mov	r1, r3
 801930e:	6878      	ldr	r0, [r7, #4]
 8019310:	f000 fb10 	bl	8019934 <USBD_CtlSendData>
      break;
 8019314:	e005      	b.n	8019322 <USBD_StdEPReq+0x1a4>
      USBD_CtlError(pdev , req);
 8019316:	6839      	ldr	r1, [r7, #0]
 8019318:	6878      	ldr	r0, [r7, #4]
 801931a:	f000 fa9f 	bl	801985c <USBD_CtlError>
      break;
 801931e:	e000      	b.n	8019322 <USBD_StdEPReq+0x1a4>
      break;	
 8019320:	bf00      	nop
    break;
 8019322:	bf00      	nop
  }
  return ret;
 8019324:	7bfb      	ldrb	r3, [r7, #15]
}
 8019326:	4618      	mov	r0, r3
 8019328:	3710      	adds	r7, #16
 801932a:	46bd      	mov	sp, r7
 801932c:	bd80      	pop	{r7, pc}
	...

08019330 <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
 8019330:	b580      	push	{r7, lr}
 8019332:	b084      	sub	sp, #16
 8019334:	af00      	add	r7, sp, #0
 8019336:	6078      	str	r0, [r7, #4]
 8019338:	6039      	str	r1, [r7, #0]
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 801933a:	683b      	ldr	r3, [r7, #0]
 801933c:	885b      	ldrh	r3, [r3, #2]
 801933e:	0a1b      	lsrs	r3, r3, #8
 8019340:	b29b      	uxth	r3, r3
 8019342:	3b01      	subs	r3, #1
 8019344:	2b06      	cmp	r3, #6
 8019346:	f200 80c9 	bhi.w	80194dc <USBD_GetDescriptor+0x1ac>
 801934a:	a201      	add	r2, pc, #4	; (adr r2, 8019350 <USBD_GetDescriptor+0x20>)
 801934c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8019350:	0801936d 	.word	0x0801936d
 8019354:	08019385 	.word	0x08019385
 8019358:	080193c5 	.word	0x080193c5
 801935c:	080194dd 	.word	0x080194dd
 8019360:	080194dd 	.word	0x080194dd
 8019364:	08019489 	.word	0x08019489
 8019368:	080194af 	.word	0x080194af
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 801936c:	687b      	ldr	r3, [r7, #4]
 801936e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8019372:	681b      	ldr	r3, [r3, #0]
 8019374:	687a      	ldr	r2, [r7, #4]
 8019376:	7c12      	ldrb	r2, [r2, #16]
 8019378:	f107 010a 	add.w	r1, r7, #10
 801937c:	4610      	mov	r0, r2
 801937e:	4798      	blx	r3
 8019380:	60f8      	str	r0, [r7, #12]
    break;
 8019382:	e0b0      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8019384:	687b      	ldr	r3, [r7, #4]
 8019386:	7c1b      	ldrb	r3, [r3, #16]
 8019388:	2b00      	cmp	r3, #0
 801938a:	d10d      	bne.n	80193a8 <USBD_GetDescriptor+0x78>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 801938c:	687b      	ldr	r3, [r7, #4]
 801938e:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8019392:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8019394:	f107 020a 	add.w	r2, r7, #10
 8019398:	4610      	mov	r0, r2
 801939a:	4798      	blx	r3
 801939c:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801939e:	68fb      	ldr	r3, [r7, #12]
 80193a0:	3301      	adds	r3, #1
 80193a2:	2202      	movs	r2, #2
 80193a4:	701a      	strb	r2, [r3, #0]
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
 80193a6:	e09e      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80193a8:	687b      	ldr	r3, [r7, #4]
 80193aa:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80193ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80193b0:	f107 020a 	add.w	r2, r7, #10
 80193b4:	4610      	mov	r0, r2
 80193b6:	4798      	blx	r3
 80193b8:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80193ba:	68fb      	ldr	r3, [r7, #12]
 80193bc:	3301      	adds	r3, #1
 80193be:	2202      	movs	r2, #2
 80193c0:	701a      	strb	r2, [r3, #0]
    break;
 80193c2:	e090      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80193c4:	683b      	ldr	r3, [r7, #0]
 80193c6:	885b      	ldrh	r3, [r3, #2]
 80193c8:	b2db      	uxtb	r3, r3
 80193ca:	2b05      	cmp	r3, #5
 80193cc:	d856      	bhi.n	801947c <USBD_GetDescriptor+0x14c>
 80193ce:	a201      	add	r2, pc, #4	; (adr r2, 80193d4 <USBD_GetDescriptor+0xa4>)
 80193d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80193d4:	080193ed 	.word	0x080193ed
 80193d8:	08019405 	.word	0x08019405
 80193dc:	0801941d 	.word	0x0801941d
 80193e0:	08019435 	.word	0x08019435
 80193e4:	0801944d 	.word	0x0801944d
 80193e8:	08019465 	.word	0x08019465
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80193ec:	687b      	ldr	r3, [r7, #4]
 80193ee:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 80193f2:	685b      	ldr	r3, [r3, #4]
 80193f4:	687a      	ldr	r2, [r7, #4]
 80193f6:	7c12      	ldrb	r2, [r2, #16]
 80193f8:	f107 010a 	add.w	r1, r7, #10
 80193fc:	4610      	mov	r0, r2
 80193fe:	4798      	blx	r3
 8019400:	60f8      	str	r0, [r7, #12]
      break;
 8019402:	e040      	b.n	8019486 <USBD_GetDescriptor+0x156>
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8019404:	687b      	ldr	r3, [r7, #4]
 8019406:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 801940a:	689b      	ldr	r3, [r3, #8]
 801940c:	687a      	ldr	r2, [r7, #4]
 801940e:	7c12      	ldrb	r2, [r2, #16]
 8019410:	f107 010a 	add.w	r1, r7, #10
 8019414:	4610      	mov	r0, r2
 8019416:	4798      	blx	r3
 8019418:	60f8      	str	r0, [r7, #12]
      break;
 801941a:	e034      	b.n	8019486 <USBD_GetDescriptor+0x156>
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 801941c:	687b      	ldr	r3, [r7, #4]
 801941e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8019422:	68db      	ldr	r3, [r3, #12]
 8019424:	687a      	ldr	r2, [r7, #4]
 8019426:	7c12      	ldrb	r2, [r2, #16]
 8019428:	f107 010a 	add.w	r1, r7, #10
 801942c:	4610      	mov	r0, r2
 801942e:	4798      	blx	r3
 8019430:	60f8      	str	r0, [r7, #12]
      break;
 8019432:	e028      	b.n	8019486 <USBD_GetDescriptor+0x156>
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8019434:	687b      	ldr	r3, [r7, #4]
 8019436:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 801943a:	691b      	ldr	r3, [r3, #16]
 801943c:	687a      	ldr	r2, [r7, #4]
 801943e:	7c12      	ldrb	r2, [r2, #16]
 8019440:	f107 010a 	add.w	r1, r7, #10
 8019444:	4610      	mov	r0, r2
 8019446:	4798      	blx	r3
 8019448:	60f8      	str	r0, [r7, #12]
      break;
 801944a:	e01c      	b.n	8019486 <USBD_GetDescriptor+0x156>
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 801944c:	687b      	ldr	r3, [r7, #4]
 801944e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 8019452:	695b      	ldr	r3, [r3, #20]
 8019454:	687a      	ldr	r2, [r7, #4]
 8019456:	7c12      	ldrb	r2, [r2, #16]
 8019458:	f107 010a 	add.w	r1, r7, #10
 801945c:	4610      	mov	r0, r2
 801945e:	4798      	blx	r3
 8019460:	60f8      	str	r0, [r7, #12]
      break;
 8019462:	e010      	b.n	8019486 <USBD_GetDescriptor+0x156>
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8019464:	687b      	ldr	r3, [r7, #4]
 8019466:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 801946a:	699b      	ldr	r3, [r3, #24]
 801946c:	687a      	ldr	r2, [r7, #4]
 801946e:	7c12      	ldrb	r2, [r2, #16]
 8019470:	f107 010a 	add.w	r1, r7, #10
 8019474:	4610      	mov	r0, r2
 8019476:	4798      	blx	r3
 8019478:	60f8      	str	r0, [r7, #12]
      break;
 801947a:	e004      	b.n	8019486 <USBD_GetDescriptor+0x156>
    default:
#if (USBD_SUPPORT_USER_STRING == 1)
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
      break;
#else      
       USBD_CtlError(pdev , req);
 801947c:	6839      	ldr	r1, [r7, #0]
 801947e:	6878      	ldr	r0, [r7, #4]
 8019480:	f000 f9ec 	bl	801985c <USBD_CtlError>
      return;
 8019484:	e044      	b.n	8019510 <USBD_GetDescriptor+0x1e0>
#endif   
    }
    break;
 8019486:	e02e      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8019488:	687b      	ldr	r3, [r7, #4]
 801948a:	7c1b      	ldrb	r3, [r3, #16]
 801948c:	2b00      	cmp	r3, #0
 801948e:	d109      	bne.n	80194a4 <USBD_GetDescriptor+0x174>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8019490:	687b      	ldr	r3, [r7, #4]
 8019492:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8019496:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8019498:	f107 020a 	add.w	r2, r7, #10
 801949c:	4610      	mov	r0, r2
 801949e:	4798      	blx	r3
 80194a0:	60f8      	str	r0, [r7, #12]
      break;
 80194a2:	e020      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
    }
    else
    {
      USBD_CtlError(pdev , req);
 80194a4:	6839      	ldr	r1, [r7, #0]
 80194a6:	6878      	ldr	r0, [r7, #4]
 80194a8:	f000 f9d8 	bl	801985c <USBD_CtlError>
      return;
 80194ac:	e030      	b.n	8019510 <USBD_GetDescriptor+0x1e0>
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80194ae:	687b      	ldr	r3, [r7, #4]
 80194b0:	7c1b      	ldrb	r3, [r3, #16]
 80194b2:	2b00      	cmp	r3, #0
 80194b4:	d10d      	bne.n	80194d2 <USBD_GetDescriptor+0x1a2>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 80194b6:	687b      	ldr	r3, [r7, #4]
 80194b8:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80194bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80194be:	f107 020a 	add.w	r2, r7, #10
 80194c2:	4610      	mov	r0, r2
 80194c4:	4798      	blx	r3
 80194c6:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80194c8:	68fb      	ldr	r3, [r7, #12]
 80194ca:	3301      	adds	r3, #1
 80194cc:	2207      	movs	r2, #7
 80194ce:	701a      	strb	r2, [r3, #0]
      break; 
 80194d0:	e009      	b.n	80194e6 <USBD_GetDescriptor+0x1b6>
    }
    else
    {
      USBD_CtlError(pdev , req);
 80194d2:	6839      	ldr	r1, [r7, #0]
 80194d4:	6878      	ldr	r0, [r7, #4]
 80194d6:	f000 f9c1 	bl	801985c <USBD_CtlError>
      return;
 80194da:	e019      	b.n	8019510 <USBD_GetDescriptor+0x1e0>
    }

  default: 
     USBD_CtlError(pdev , req);
 80194dc:	6839      	ldr	r1, [r7, #0]
 80194de:	6878      	ldr	r0, [r7, #4]
 80194e0:	f000 f9bc 	bl	801985c <USBD_CtlError>
    return;
 80194e4:	e014      	b.n	8019510 <USBD_GetDescriptor+0x1e0>
  }
  
  if((len != 0)&& (req->wLength != 0))
 80194e6:	897b      	ldrh	r3, [r7, #10]
 80194e8:	2b00      	cmp	r3, #0
 80194ea:	d011      	beq.n	8019510 <USBD_GetDescriptor+0x1e0>
 80194ec:	683b      	ldr	r3, [r7, #0]
 80194ee:	88db      	ldrh	r3, [r3, #6]
 80194f0:	2b00      	cmp	r3, #0
 80194f2:	d00d      	beq.n	8019510 <USBD_GetDescriptor+0x1e0>
  {
    
    len = MIN(len , req->wLength);
 80194f4:	683b      	ldr	r3, [r7, #0]
 80194f6:	88da      	ldrh	r2, [r3, #6]
 80194f8:	897b      	ldrh	r3, [r7, #10]
 80194fa:	4293      	cmp	r3, r2
 80194fc:	bf28      	it	cs
 80194fe:	4613      	movcs	r3, r2
 8019500:	b29b      	uxth	r3, r3
 8019502:	817b      	strh	r3, [r7, #10]
    
    USBD_CtlSendData (pdev, 
 8019504:	897b      	ldrh	r3, [r7, #10]
 8019506:	461a      	mov	r2, r3
 8019508:	68f9      	ldr	r1, [r7, #12]
 801950a:	6878      	ldr	r0, [r7, #4]
 801950c:	f000 fa12 	bl	8019934 <USBD_CtlSendData>
                      pbuf,
                      len);
  }
  
}
 8019510:	3710      	adds	r7, #16
 8019512:	46bd      	mov	sp, r7
 8019514:	bd80      	pop	{r7, pc}
 8019516:	bf00      	nop

08019518 <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 8019518:	b580      	push	{r7, lr}
 801951a:	b084      	sub	sp, #16
 801951c:	af00      	add	r7, sp, #0
 801951e:	6078      	str	r0, [r7, #4]
 8019520:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8019522:	683b      	ldr	r3, [r7, #0]
 8019524:	889b      	ldrh	r3, [r3, #4]
 8019526:	2b00      	cmp	r3, #0
 8019528:	d12c      	bne.n	8019584 <USBD_SetAddress+0x6c>
 801952a:	683b      	ldr	r3, [r7, #0]
 801952c:	88db      	ldrh	r3, [r3, #6]
 801952e:	2b00      	cmp	r3, #0
 8019530:	d128      	bne.n	8019584 <USBD_SetAddress+0x6c>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8019532:	683b      	ldr	r3, [r7, #0]
 8019534:	885b      	ldrh	r3, [r3, #2]
 8019536:	b2db      	uxtb	r3, r3
 8019538:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801953c:	73fb      	strb	r3, [r7, #15]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 801953e:	687b      	ldr	r3, [r7, #4]
 8019540:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8019544:	2b03      	cmp	r3, #3
 8019546:	d104      	bne.n	8019552 <USBD_SetAddress+0x3a>
    {
      USBD_CtlError(pdev , req);
 8019548:	6839      	ldr	r1, [r7, #0]
 801954a:	6878      	ldr	r0, [r7, #4]
 801954c:	f000 f986 	bl	801985c <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8019550:	e01c      	b.n	801958c <USBD_SetAddress+0x74>
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 8019552:	687b      	ldr	r3, [r7, #4]
 8019554:	7bfa      	ldrb	r2, [r7, #15]
 8019556:	f883 21fe 	strb.w	r2, [r3, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 801955a:	7bfb      	ldrb	r3, [r7, #15]
 801955c:	4619      	mov	r1, r3
 801955e:	6878      	ldr	r0, [r7, #4]
 8019560:	f7f7 fdd5 	bl	801110e <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8019564:	6878      	ldr	r0, [r7, #4]
 8019566:	f000 fa25 	bl	80199b4 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 801956a:	7bfb      	ldrb	r3, [r7, #15]
 801956c:	2b00      	cmp	r3, #0
 801956e:	d004      	beq.n	801957a <USBD_SetAddress+0x62>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8019570:	687b      	ldr	r3, [r7, #4]
 8019572:	2202      	movs	r2, #2
 8019574:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8019578:	e008      	b.n	801958c <USBD_SetAddress+0x74>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 801957a:	687b      	ldr	r3, [r7, #4]
 801957c:	2201      	movs	r2, #1
 801957e:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8019582:	e003      	b.n	801958c <USBD_SetAddress+0x74>
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
 8019584:	6839      	ldr	r1, [r7, #0]
 8019586:	6878      	ldr	r0, [r7, #4]
 8019588:	f000 f968 	bl	801985c <USBD_CtlError>
  } 
}
 801958c:	bf00      	nop
 801958e:	3710      	adds	r7, #16
 8019590:	46bd      	mov	sp, r7
 8019592:	bd80      	pop	{r7, pc}

08019594 <USBD_SetConfig>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 8019594:	b580      	push	{r7, lr}
 8019596:	b082      	sub	sp, #8
 8019598:	af00      	add	r7, sp, #0
 801959a:	6078      	str	r0, [r7, #4]
 801959c:	6039      	str	r1, [r7, #0]
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 801959e:	683b      	ldr	r3, [r7, #0]
 80195a0:	885b      	ldrh	r3, [r3, #2]
 80195a2:	b2da      	uxtb	r2, r3
 80195a4:	4b3e      	ldr	r3, [pc, #248]	; (80196a0 <USBD_SetConfig+0x10c>)
 80195a6:	701a      	strb	r2, [r3, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 80195a8:	4b3d      	ldr	r3, [pc, #244]	; (80196a0 <USBD_SetConfig+0x10c>)
 80195aa:	781b      	ldrb	r3, [r3, #0]
 80195ac:	2b01      	cmp	r3, #1
 80195ae:	d904      	bls.n	80195ba <USBD_SetConfig+0x26>
  {            
     USBD_CtlError(pdev , req);                              
 80195b0:	6839      	ldr	r1, [r7, #0]
 80195b2:	6878      	ldr	r0, [r7, #4]
 80195b4:	f000 f952 	bl	801985c <USBD_CtlError>
 80195b8:	e06f      	b.n	801969a <USBD_SetConfig+0x106>
  } 
  else 
  {
    switch (pdev->dev_state) 
 80195ba:	687b      	ldr	r3, [r7, #4]
 80195bc:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80195c0:	2b02      	cmp	r3, #2
 80195c2:	d002      	beq.n	80195ca <USBD_SetConfig+0x36>
 80195c4:	2b03      	cmp	r3, #3
 80195c6:	d023      	beq.n	8019610 <USBD_SetConfig+0x7c>
 80195c8:	e062      	b.n	8019690 <USBD_SetConfig+0xfc>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 80195ca:	4b35      	ldr	r3, [pc, #212]	; (80196a0 <USBD_SetConfig+0x10c>)
 80195cc:	781b      	ldrb	r3, [r3, #0]
 80195ce:	2b00      	cmp	r3, #0
 80195d0:	d01a      	beq.n	8019608 <USBD_SetConfig+0x74>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 80195d2:	4b33      	ldr	r3, [pc, #204]	; (80196a0 <USBD_SetConfig+0x10c>)
 80195d4:	781b      	ldrb	r3, [r3, #0]
 80195d6:	461a      	mov	r2, r3
 80195d8:	687b      	ldr	r3, [r7, #4]
 80195da:	605a      	str	r2, [r3, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 80195dc:	687b      	ldr	r3, [r7, #4]
 80195de:	2203      	movs	r2, #3
 80195e0:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 80195e4:	4b2e      	ldr	r3, [pc, #184]	; (80196a0 <USBD_SetConfig+0x10c>)
 80195e6:	781b      	ldrb	r3, [r3, #0]
 80195e8:	4619      	mov	r1, r3
 80195ea:	6878      	ldr	r0, [r7, #4]
 80195ec:	f7ff fb22 	bl	8018c34 <USBD_SetClassConfig>
 80195f0:	4603      	mov	r3, r0
 80195f2:	2b02      	cmp	r3, #2
 80195f4:	d104      	bne.n	8019600 <USBD_SetConfig+0x6c>
        {
          USBD_CtlError(pdev , req);  
 80195f6:	6839      	ldr	r1, [r7, #0]
 80195f8:	6878      	ldr	r0, [r7, #4]
 80195fa:	f000 f92f 	bl	801985c <USBD_CtlError>
          return;
 80195fe:	e04c      	b.n	801969a <USBD_SetConfig+0x106>
        }
        USBD_CtlSendStatus(pdev);
 8019600:	6878      	ldr	r0, [r7, #4]
 8019602:	f000 f9d7 	bl	80199b4 <USBD_CtlSendStatus>
      }
      else 
      {
         USBD_CtlSendStatus(pdev);
      }
      break;
 8019606:	e048      	b.n	801969a <USBD_SetConfig+0x106>
         USBD_CtlSendStatus(pdev);
 8019608:	6878      	ldr	r0, [r7, #4]
 801960a:	f000 f9d3 	bl	80199b4 <USBD_CtlSendStatus>
      break;
 801960e:	e044      	b.n	801969a <USBD_SetConfig+0x106>
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 8019610:	4b23      	ldr	r3, [pc, #140]	; (80196a0 <USBD_SetConfig+0x10c>)
 8019612:	781b      	ldrb	r3, [r3, #0]
 8019614:	2b00      	cmp	r3, #0
 8019616:	d112      	bne.n	801963e <USBD_SetConfig+0xaa>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8019618:	687b      	ldr	r3, [r7, #4]
 801961a:	2202      	movs	r2, #2
 801961c:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8019620:	4b1f      	ldr	r3, [pc, #124]	; (80196a0 <USBD_SetConfig+0x10c>)
 8019622:	781b      	ldrb	r3, [r3, #0]
 8019624:	461a      	mov	r2, r3
 8019626:	687b      	ldr	r3, [r7, #4]
 8019628:	605a      	str	r2, [r3, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 801962a:	4b1d      	ldr	r3, [pc, #116]	; (80196a0 <USBD_SetConfig+0x10c>)
 801962c:	781b      	ldrb	r3, [r3, #0]
 801962e:	4619      	mov	r1, r3
 8019630:	6878      	ldr	r0, [r7, #4]
 8019632:	f7ff fb1e 	bl	8018c72 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 8019636:	6878      	ldr	r0, [r7, #4]
 8019638:	f000 f9bc 	bl	80199b4 <USBD_CtlSendStatus>
      }
      else
      {
        USBD_CtlSendStatus(pdev);
      }
      break;
 801963c:	e02d      	b.n	801969a <USBD_SetConfig+0x106>
      else  if (cfgidx != pdev->dev_config) 
 801963e:	4b18      	ldr	r3, [pc, #96]	; (80196a0 <USBD_SetConfig+0x10c>)
 8019640:	781b      	ldrb	r3, [r3, #0]
 8019642:	461a      	mov	r2, r3
 8019644:	687b      	ldr	r3, [r7, #4]
 8019646:	685b      	ldr	r3, [r3, #4]
 8019648:	429a      	cmp	r2, r3
 801964a:	d01d      	beq.n	8019688 <USBD_SetConfig+0xf4>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 801964c:	687b      	ldr	r3, [r7, #4]
 801964e:	685b      	ldr	r3, [r3, #4]
 8019650:	b2db      	uxtb	r3, r3
 8019652:	4619      	mov	r1, r3
 8019654:	6878      	ldr	r0, [r7, #4]
 8019656:	f7ff fb0c 	bl	8018c72 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 801965a:	4b11      	ldr	r3, [pc, #68]	; (80196a0 <USBD_SetConfig+0x10c>)
 801965c:	781b      	ldrb	r3, [r3, #0]
 801965e:	461a      	mov	r2, r3
 8019660:	687b      	ldr	r3, [r7, #4]
 8019662:	605a      	str	r2, [r3, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8019664:	4b0e      	ldr	r3, [pc, #56]	; (80196a0 <USBD_SetConfig+0x10c>)
 8019666:	781b      	ldrb	r3, [r3, #0]
 8019668:	4619      	mov	r1, r3
 801966a:	6878      	ldr	r0, [r7, #4]
 801966c:	f7ff fae2 	bl	8018c34 <USBD_SetClassConfig>
 8019670:	4603      	mov	r3, r0
 8019672:	2b02      	cmp	r3, #2
 8019674:	d104      	bne.n	8019680 <USBD_SetConfig+0xec>
          USBD_CtlError(pdev , req);  
 8019676:	6839      	ldr	r1, [r7, #0]
 8019678:	6878      	ldr	r0, [r7, #4]
 801967a:	f000 f8ef 	bl	801985c <USBD_CtlError>
          return;
 801967e:	e00c      	b.n	801969a <USBD_SetConfig+0x106>
        USBD_CtlSendStatus(pdev);
 8019680:	6878      	ldr	r0, [r7, #4]
 8019682:	f000 f997 	bl	80199b4 <USBD_CtlSendStatus>
      break;
 8019686:	e008      	b.n	801969a <USBD_SetConfig+0x106>
        USBD_CtlSendStatus(pdev);
 8019688:	6878      	ldr	r0, [r7, #4]
 801968a:	f000 f993 	bl	80199b4 <USBD_CtlSendStatus>
      break;
 801968e:	e004      	b.n	801969a <USBD_SetConfig+0x106>
      
    default:					
       USBD_CtlError(pdev , req);                     
 8019690:	6839      	ldr	r1, [r7, #0]
 8019692:	6878      	ldr	r0, [r7, #4]
 8019694:	f000 f8e2 	bl	801985c <USBD_CtlError>
      break;
 8019698:	bf00      	nop
    }
  }
}
 801969a:	3708      	adds	r7, #8
 801969c:	46bd      	mov	sp, r7
 801969e:	bd80      	pop	{r7, pc}
 80196a0:	20000490 	.word	0x20000490

080196a4 <USBD_GetConfig>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 80196a4:	b580      	push	{r7, lr}
 80196a6:	b082      	sub	sp, #8
 80196a8:	af00      	add	r7, sp, #0
 80196aa:	6078      	str	r0, [r7, #4]
 80196ac:	6039      	str	r1, [r7, #0]

  if (req->wLength != 1) 
 80196ae:	683b      	ldr	r3, [r7, #0]
 80196b0:	88db      	ldrh	r3, [r3, #6]
 80196b2:	2b01      	cmp	r3, #1
 80196b4:	d004      	beq.n	80196c0 <USBD_GetConfig+0x1c>
  {                   
     USBD_CtlError(pdev , req);
 80196b6:	6839      	ldr	r1, [r7, #0]
 80196b8:	6878      	ldr	r0, [r7, #4]
 80196ba:	f000 f8cf 	bl	801985c <USBD_CtlError>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
 80196be:	e01f      	b.n	8019700 <USBD_GetConfig+0x5c>
    switch (pdev->dev_state )  
 80196c0:	687b      	ldr	r3, [r7, #4]
 80196c2:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80196c6:	2b02      	cmp	r3, #2
 80196c8:	d002      	beq.n	80196d0 <USBD_GetConfig+0x2c>
 80196ca:	2b03      	cmp	r3, #3
 80196cc:	d00b      	beq.n	80196e6 <USBD_GetConfig+0x42>
 80196ce:	e012      	b.n	80196f6 <USBD_GetConfig+0x52>
      pdev->dev_default_config = 0;
 80196d0:	687b      	ldr	r3, [r7, #4]
 80196d2:	2200      	movs	r2, #0
 80196d4:	609a      	str	r2, [r3, #8]
                        (uint8_t *)&pdev->dev_default_config,
 80196d6:	687b      	ldr	r3, [r7, #4]
 80196d8:	3308      	adds	r3, #8
      USBD_CtlSendData (pdev, 
 80196da:	2201      	movs	r2, #1
 80196dc:	4619      	mov	r1, r3
 80196de:	6878      	ldr	r0, [r7, #4]
 80196e0:	f000 f928 	bl	8019934 <USBD_CtlSendData>
      break;
 80196e4:	e00c      	b.n	8019700 <USBD_GetConfig+0x5c>
                        (uint8_t *)&pdev->dev_config,
 80196e6:	687b      	ldr	r3, [r7, #4]
 80196e8:	3304      	adds	r3, #4
      USBD_CtlSendData (pdev, 
 80196ea:	2201      	movs	r2, #1
 80196ec:	4619      	mov	r1, r3
 80196ee:	6878      	ldr	r0, [r7, #4]
 80196f0:	f000 f920 	bl	8019934 <USBD_CtlSendData>
      break;
 80196f4:	e004      	b.n	8019700 <USBD_GetConfig+0x5c>
       USBD_CtlError(pdev , req);
 80196f6:	6839      	ldr	r1, [r7, #0]
 80196f8:	6878      	ldr	r0, [r7, #4]
 80196fa:	f000 f8af 	bl	801985c <USBD_CtlError>
      break;
 80196fe:	bf00      	nop
}
 8019700:	bf00      	nop
 8019702:	3708      	adds	r7, #8
 8019704:	46bd      	mov	sp, r7
 8019706:	bd80      	pop	{r7, pc}

08019708 <USBD_GetStatus>:
* @param  req: usb request
* @retval status
*/
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
 8019708:	b580      	push	{r7, lr}
 801970a:	b082      	sub	sp, #8
 801970c:	af00      	add	r7, sp, #0
 801970e:	6078      	str	r0, [r7, #4]
 8019710:	6039      	str	r1, [r7, #0]
  
    
  switch (pdev->dev_state) 
 8019712:	687b      	ldr	r3, [r7, #4]
 8019714:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 8019718:	3b02      	subs	r3, #2
 801971a:	2b01      	cmp	r3, #1
 801971c:	d815      	bhi.n	801974a <USBD_GetStatus+0x42>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 801971e:	687b      	ldr	r3, [r7, #4]
 8019720:	2201      	movs	r2, #1
 8019722:	60da      	str	r2, [r3, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 8019724:	687b      	ldr	r3, [r7, #4]
 8019726:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 801972a:	2b00      	cmp	r3, #0
 801972c:	d005      	beq.n	801973a <USBD_GetStatus+0x32>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 801972e:	687b      	ldr	r3, [r7, #4]
 8019730:	68db      	ldr	r3, [r3, #12]
 8019732:	f043 0202 	orr.w	r2, r3, #2
 8019736:	687b      	ldr	r3, [r7, #4]
 8019738:	60da      	str	r2, [r3, #12]
    }
    
    USBD_CtlSendData (pdev, 
                      (uint8_t *)& pdev->dev_config_status,
 801973a:	687b      	ldr	r3, [r7, #4]
 801973c:	330c      	adds	r3, #12
    USBD_CtlSendData (pdev, 
 801973e:	2202      	movs	r2, #2
 8019740:	4619      	mov	r1, r3
 8019742:	6878      	ldr	r0, [r7, #4]
 8019744:	f000 f8f6 	bl	8019934 <USBD_CtlSendData>
                      2);
    break;
 8019748:	e004      	b.n	8019754 <USBD_GetStatus+0x4c>
    
  default :
    USBD_CtlError(pdev , req);                        
 801974a:	6839      	ldr	r1, [r7, #0]
 801974c:	6878      	ldr	r0, [r7, #4]
 801974e:	f000 f885 	bl	801985c <USBD_CtlError>
    break;
 8019752:	bf00      	nop
  }
}
 8019754:	bf00      	nop
 8019756:	3708      	adds	r7, #8
 8019758:	46bd      	mov	sp, r7
 801975a:	bd80      	pop	{r7, pc}

0801975c <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 801975c:	b580      	push	{r7, lr}
 801975e:	b082      	sub	sp, #8
 8019760:	af00      	add	r7, sp, #0
 8019762:	6078      	str	r0, [r7, #4]
 8019764:	6039      	str	r1, [r7, #0]

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8019766:	683b      	ldr	r3, [r7, #0]
 8019768:	885b      	ldrh	r3, [r3, #2]
 801976a:	2b01      	cmp	r3, #1
 801976c:	d10d      	bne.n	801978a <USBD_SetFeature+0x2e>
  {
    pdev->dev_remote_wakeup = 1;  
 801976e:	687b      	ldr	r3, [r7, #4]
 8019770:	2201      	movs	r2, #1
 8019772:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 8019776:	687b      	ldr	r3, [r7, #4]
 8019778:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 801977c:	689b      	ldr	r3, [r3, #8]
 801977e:	6839      	ldr	r1, [r7, #0]
 8019780:	6878      	ldr	r0, [r7, #4]
 8019782:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 8019784:	6878      	ldr	r0, [r7, #4]
 8019786:	f000 f915 	bl	80199b4 <USBD_CtlSendStatus>
  }

}
 801978a:	bf00      	nop
 801978c:	3708      	adds	r7, #8
 801978e:	46bd      	mov	sp, r7
 8019790:	bd80      	pop	{r7, pc}

08019792 <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
 8019792:	b580      	push	{r7, lr}
 8019794:	b082      	sub	sp, #8
 8019796:	af00      	add	r7, sp, #0
 8019798:	6078      	str	r0, [r7, #4]
 801979a:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 801979c:	687b      	ldr	r3, [r7, #4]
 801979e:	f893 31fc 	ldrb.w	r3, [r3, #508]	; 0x1fc
 80197a2:	3b02      	subs	r3, #2
 80197a4:	2b01      	cmp	r3, #1
 80197a6:	d812      	bhi.n	80197ce <USBD_ClrFeature+0x3c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80197a8:	683b      	ldr	r3, [r7, #0]
 80197aa:	885b      	ldrh	r3, [r3, #2]
 80197ac:	2b01      	cmp	r3, #1
 80197ae:	d113      	bne.n	80197d8 <USBD_ClrFeature+0x46>
    {
      pdev->dev_remote_wakeup = 0; 
 80197b0:	687b      	ldr	r3, [r7, #4]
 80197b2:	2200      	movs	r2, #0
 80197b4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80197b8:	687b      	ldr	r3, [r7, #4]
 80197ba:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 80197be:	689b      	ldr	r3, [r3, #8]
 80197c0:	6839      	ldr	r1, [r7, #0]
 80197c2:	6878      	ldr	r0, [r7, #4]
 80197c4:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80197c6:	6878      	ldr	r0, [r7, #4]
 80197c8:	f000 f8f4 	bl	80199b4 <USBD_CtlSendStatus>
    }
    break;
 80197cc:	e004      	b.n	80197d8 <USBD_ClrFeature+0x46>
    
  default :
     USBD_CtlError(pdev , req);
 80197ce:	6839      	ldr	r1, [r7, #0]
 80197d0:	6878      	ldr	r0, [r7, #4]
 80197d2:	f000 f843 	bl	801985c <USBD_CtlError>
    break;
 80197d6:	e000      	b.n	80197da <USBD_ClrFeature+0x48>
    break;
 80197d8:	bf00      	nop
  }
}
 80197da:	bf00      	nop
 80197dc:	3708      	adds	r7, #8
 80197de:	46bd      	mov	sp, r7
 80197e0:	bd80      	pop	{r7, pc}

080197e2 <USBD_ParseSetupRequest>:
* @param  req: usb request
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 80197e2:	b480      	push	{r7}
 80197e4:	b083      	sub	sp, #12
 80197e6:	af00      	add	r7, sp, #0
 80197e8:	6078      	str	r0, [r7, #4]
 80197ea:	6039      	str	r1, [r7, #0]
  req->bmRequest     = *(uint8_t *)  (pdata);
 80197ec:	683b      	ldr	r3, [r7, #0]
 80197ee:	781a      	ldrb	r2, [r3, #0]
 80197f0:	687b      	ldr	r3, [r7, #4]
 80197f2:	701a      	strb	r2, [r3, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 80197f4:	683b      	ldr	r3, [r7, #0]
 80197f6:	785a      	ldrb	r2, [r3, #1]
 80197f8:	687b      	ldr	r3, [r7, #4]
 80197fa:	705a      	strb	r2, [r3, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 80197fc:	683b      	ldr	r3, [r7, #0]
 80197fe:	3302      	adds	r3, #2
 8019800:	781b      	ldrb	r3, [r3, #0]
 8019802:	b29a      	uxth	r2, r3
 8019804:	683b      	ldr	r3, [r7, #0]
 8019806:	3303      	adds	r3, #3
 8019808:	781b      	ldrb	r3, [r3, #0]
 801980a:	b29b      	uxth	r3, r3
 801980c:	021b      	lsls	r3, r3, #8
 801980e:	b29b      	uxth	r3, r3
 8019810:	4413      	add	r3, r2
 8019812:	b29a      	uxth	r2, r3
 8019814:	687b      	ldr	r3, [r7, #4]
 8019816:	805a      	strh	r2, [r3, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8019818:	683b      	ldr	r3, [r7, #0]
 801981a:	3304      	adds	r3, #4
 801981c:	781b      	ldrb	r3, [r3, #0]
 801981e:	b29a      	uxth	r2, r3
 8019820:	683b      	ldr	r3, [r7, #0]
 8019822:	3305      	adds	r3, #5
 8019824:	781b      	ldrb	r3, [r3, #0]
 8019826:	b29b      	uxth	r3, r3
 8019828:	021b      	lsls	r3, r3, #8
 801982a:	b29b      	uxth	r3, r3
 801982c:	4413      	add	r3, r2
 801982e:	b29a      	uxth	r2, r3
 8019830:	687b      	ldr	r3, [r7, #4]
 8019832:	809a      	strh	r2, [r3, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8019834:	683b      	ldr	r3, [r7, #0]
 8019836:	3306      	adds	r3, #6
 8019838:	781b      	ldrb	r3, [r3, #0]
 801983a:	b29a      	uxth	r2, r3
 801983c:	683b      	ldr	r3, [r7, #0]
 801983e:	3307      	adds	r3, #7
 8019840:	781b      	ldrb	r3, [r3, #0]
 8019842:	b29b      	uxth	r3, r3
 8019844:	021b      	lsls	r3, r3, #8
 8019846:	b29b      	uxth	r3, r3
 8019848:	4413      	add	r3, r2
 801984a:	b29a      	uxth	r2, r3
 801984c:	687b      	ldr	r3, [r7, #4]
 801984e:	80da      	strh	r2, [r3, #6]

}
 8019850:	bf00      	nop
 8019852:	370c      	adds	r7, #12
 8019854:	46bd      	mov	sp, r7
 8019856:	f85d 7b04 	ldr.w	r7, [sp], #4
 801985a:	4770      	bx	lr

0801985c <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 801985c:	b580      	push	{r7, lr}
 801985e:	b082      	sub	sp, #8
 8019860:	af00      	add	r7, sp, #0
 8019862:	6078      	str	r0, [r7, #4]
 8019864:	6039      	str	r1, [r7, #0]
  USBD_LL_StallEP(pdev , 0x80);
 8019866:	2180      	movs	r1, #128	; 0x80
 8019868:	6878      	ldr	r0, [r7, #4]
 801986a:	f7f7 fbfe 	bl	801106a <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 801986e:	2100      	movs	r1, #0
 8019870:	6878      	ldr	r0, [r7, #4]
 8019872:	f7f7 fbfa 	bl	801106a <USBD_LL_StallEP>
}
 8019876:	bf00      	nop
 8019878:	3708      	adds	r7, #8
 801987a:	46bd      	mov	sp, r7
 801987c:	bd80      	pop	{r7, pc}

0801987e <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 801987e:	b580      	push	{r7, lr}
 8019880:	b086      	sub	sp, #24
 8019882:	af00      	add	r7, sp, #0
 8019884:	60f8      	str	r0, [r7, #12]
 8019886:	60b9      	str	r1, [r7, #8]
 8019888:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0;
 801988a:	2300      	movs	r3, #0
 801988c:	75fb      	strb	r3, [r7, #23]
  
  if (desc != NULL) 
 801988e:	68fb      	ldr	r3, [r7, #12]
 8019890:	2b00      	cmp	r3, #0
 8019892:	d033      	beq.n	80198fc <USBD_GetString+0x7e>
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8019894:	68f8      	ldr	r0, [r7, #12]
 8019896:	f000 f835 	bl	8019904 <USBD_GetLen>
 801989a:	4603      	mov	r3, r0
 801989c:	3301      	adds	r3, #1
 801989e:	b29b      	uxth	r3, r3
 80198a0:	005b      	lsls	r3, r3, #1
 80198a2:	b29a      	uxth	r2, r3
 80198a4:	687b      	ldr	r3, [r7, #4]
 80198a6:	801a      	strh	r2, [r3, #0]
    unicode[idx++] = *len;
 80198a8:	687b      	ldr	r3, [r7, #4]
 80198aa:	881a      	ldrh	r2, [r3, #0]
 80198ac:	7dfb      	ldrb	r3, [r7, #23]
 80198ae:	1c59      	adds	r1, r3, #1
 80198b0:	75f9      	strb	r1, [r7, #23]
 80198b2:	4619      	mov	r1, r3
 80198b4:	68bb      	ldr	r3, [r7, #8]
 80198b6:	440b      	add	r3, r1
 80198b8:	b2d2      	uxtb	r2, r2
 80198ba:	701a      	strb	r2, [r3, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80198bc:	7dfb      	ldrb	r3, [r7, #23]
 80198be:	1c5a      	adds	r2, r3, #1
 80198c0:	75fa      	strb	r2, [r7, #23]
 80198c2:	461a      	mov	r2, r3
 80198c4:	68bb      	ldr	r3, [r7, #8]
 80198c6:	4413      	add	r3, r2
 80198c8:	2203      	movs	r2, #3
 80198ca:	701a      	strb	r2, [r3, #0]
    
    while (*desc != '\0') 
 80198cc:	e012      	b.n	80198f4 <USBD_GetString+0x76>
    {
      unicode[idx++] = *desc++;
 80198ce:	68fb      	ldr	r3, [r7, #12]
 80198d0:	1c5a      	adds	r2, r3, #1
 80198d2:	60fa      	str	r2, [r7, #12]
 80198d4:	7dfa      	ldrb	r2, [r7, #23]
 80198d6:	1c51      	adds	r1, r2, #1
 80198d8:	75f9      	strb	r1, [r7, #23]
 80198da:	4611      	mov	r1, r2
 80198dc:	68ba      	ldr	r2, [r7, #8]
 80198de:	440a      	add	r2, r1
 80198e0:	781b      	ldrb	r3, [r3, #0]
 80198e2:	7013      	strb	r3, [r2, #0]
      unicode[idx++] =  0x00;
 80198e4:	7dfb      	ldrb	r3, [r7, #23]
 80198e6:	1c5a      	adds	r2, r3, #1
 80198e8:	75fa      	strb	r2, [r7, #23]
 80198ea:	461a      	mov	r2, r3
 80198ec:	68bb      	ldr	r3, [r7, #8]
 80198ee:	4413      	add	r3, r2
 80198f0:	2200      	movs	r2, #0
 80198f2:	701a      	strb	r2, [r3, #0]
    while (*desc != '\0') 
 80198f4:	68fb      	ldr	r3, [r7, #12]
 80198f6:	781b      	ldrb	r3, [r3, #0]
 80198f8:	2b00      	cmp	r3, #0
 80198fa:	d1e8      	bne.n	80198ce <USBD_GetString+0x50>
    }
  } 
}
 80198fc:	bf00      	nop
 80198fe:	3718      	adds	r7, #24
 8019900:	46bd      	mov	sp, r7
 8019902:	bd80      	pop	{r7, pc}

08019904 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 8019904:	b480      	push	{r7}
 8019906:	b085      	sub	sp, #20
 8019908:	af00      	add	r7, sp, #0
 801990a:	6078      	str	r0, [r7, #4]
    uint8_t  len = 0;
 801990c:	2300      	movs	r3, #0
 801990e:	73fb      	strb	r3, [r7, #15]

    while (*buf != '\0') 
 8019910:	e005      	b.n	801991e <USBD_GetLen+0x1a>
    {
        len++;
 8019912:	7bfb      	ldrb	r3, [r7, #15]
 8019914:	3301      	adds	r3, #1
 8019916:	73fb      	strb	r3, [r7, #15]
        buf++;
 8019918:	687b      	ldr	r3, [r7, #4]
 801991a:	3301      	adds	r3, #1
 801991c:	607b      	str	r3, [r7, #4]
    while (*buf != '\0') 
 801991e:	687b      	ldr	r3, [r7, #4]
 8019920:	781b      	ldrb	r3, [r3, #0]
 8019922:	2b00      	cmp	r3, #0
 8019924:	d1f5      	bne.n	8019912 <USBD_GetLen+0xe>
    }

    return len;
 8019926:	7bfb      	ldrb	r3, [r7, #15]
}
 8019928:	4618      	mov	r0, r3
 801992a:	3714      	adds	r7, #20
 801992c:	46bd      	mov	sp, r7
 801992e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019932:	4770      	bx	lr

08019934 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8019934:	b580      	push	{r7, lr}
 8019936:	b084      	sub	sp, #16
 8019938:	af00      	add	r7, sp, #0
 801993a:	60f8      	str	r0, [r7, #12]
 801993c:	60b9      	str	r1, [r7, #8]
 801993e:	4613      	mov	r3, r2
 8019940:	80fb      	strh	r3, [r7, #6]
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8019942:	68fb      	ldr	r3, [r7, #12]
 8019944:	2202      	movs	r2, #2
 8019946:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 801994a:	88fa      	ldrh	r2, [r7, #6]
 801994c:	68fb      	ldr	r3, [r7, #12]
 801994e:	619a      	str	r2, [r3, #24]
  pdev->ep_in[0].rem_length   = len;
 8019950:	88fa      	ldrh	r2, [r7, #6]
 8019952:	68fb      	ldr	r3, [r7, #12]
 8019954:	61da      	str	r2, [r3, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8019956:	88fb      	ldrh	r3, [r7, #6]
 8019958:	68ba      	ldr	r2, [r7, #8]
 801995a:	2100      	movs	r1, #0
 801995c:	68f8      	ldr	r0, [r7, #12]
 801995e:	f7f7 fbe9 	bl	8011134 <USBD_LL_Transmit>
  
  return USBD_OK;
 8019962:	2300      	movs	r3, #0
}
 8019964:	4618      	mov	r0, r3
 8019966:	3710      	adds	r7, #16
 8019968:	46bd      	mov	sp, r7
 801996a:	bd80      	pop	{r7, pc}

0801996c <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 801996c:	b580      	push	{r7, lr}
 801996e:	b084      	sub	sp, #16
 8019970:	af00      	add	r7, sp, #0
 8019972:	60f8      	str	r0, [r7, #12]
 8019974:	60b9      	str	r1, [r7, #8]
 8019976:	4613      	mov	r3, r2
 8019978:	80fb      	strh	r3, [r7, #6]
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 801997a:	88fb      	ldrh	r3, [r7, #6]
 801997c:	68ba      	ldr	r2, [r7, #8]
 801997e:	2100      	movs	r1, #0
 8019980:	68f8      	ldr	r0, [r7, #12]
 8019982:	f7f7 fbd7 	bl	8011134 <USBD_LL_Transmit>
  
  return USBD_OK;
 8019986:	2300      	movs	r3, #0
}
 8019988:	4618      	mov	r0, r3
 801998a:	3710      	adds	r7, #16
 801998c:	46bd      	mov	sp, r7
 801998e:	bd80      	pop	{r7, pc}

08019990 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8019990:	b580      	push	{r7, lr}
 8019992:	b084      	sub	sp, #16
 8019994:	af00      	add	r7, sp, #0
 8019996:	60f8      	str	r0, [r7, #12]
 8019998:	60b9      	str	r1, [r7, #8]
 801999a:	4613      	mov	r3, r2
 801999c:	80fb      	strh	r3, [r7, #6]

  USBD_LL_PrepareReceive (pdev,
 801999e:	88fb      	ldrh	r3, [r7, #6]
 80199a0:	68ba      	ldr	r2, [r7, #8]
 80199a2:	2100      	movs	r1, #0
 80199a4:	68f8      	ldr	r0, [r7, #12]
 80199a6:	f7f7 fbdc 	bl	8011162 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
 80199aa:	2300      	movs	r3, #0
}
 80199ac:	4618      	mov	r0, r3
 80199ae:	3710      	adds	r7, #16
 80199b0:	46bd      	mov	sp, r7
 80199b2:	bd80      	pop	{r7, pc}

080199b4 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 80199b4:	b580      	push	{r7, lr}
 80199b6:	b082      	sub	sp, #8
 80199b8:	af00      	add	r7, sp, #0
 80199ba:	6078      	str	r0, [r7, #4]

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80199bc:	687b      	ldr	r3, [r7, #4]
 80199be:	2204      	movs	r2, #4
 80199c0:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 80199c4:	2300      	movs	r3, #0
 80199c6:	2200      	movs	r2, #0
 80199c8:	2100      	movs	r1, #0
 80199ca:	6878      	ldr	r0, [r7, #4]
 80199cc:	f7f7 fbb2 	bl	8011134 <USBD_LL_Transmit>
  
  return USBD_OK;
 80199d0:	2300      	movs	r3, #0
}
 80199d2:	4618      	mov	r0, r3
 80199d4:	3708      	adds	r7, #8
 80199d6:	46bd      	mov	sp, r7
 80199d8:	bd80      	pop	{r7, pc}

080199da <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 80199da:	b580      	push	{r7, lr}
 80199dc:	b082      	sub	sp, #8
 80199de:	af00      	add	r7, sp, #0
 80199e0:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 80199e2:	687b      	ldr	r3, [r7, #4]
 80199e4:	2205      	movs	r2, #5
 80199e6:	f8c3 21f4 	str.w	r2, [r3, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 80199ea:	2300      	movs	r3, #0
 80199ec:	2200      	movs	r2, #0
 80199ee:	2100      	movs	r1, #0
 80199f0:	6878      	ldr	r0, [r7, #4]
 80199f2:	f7f7 fbb6 	bl	8011162 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
 80199f6:	2300      	movs	r3, #0
}
 80199f8:	4618      	mov	r0, r3
 80199fa:	3708      	adds	r7, #8
 80199fc:	46bd      	mov	sp, r7
 80199fe:	bd80      	pop	{r7, pc}

08019a00 <USBD_MSC_Init>:
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_Init (USBD_HandleTypeDef *pdev, 
                            uint8_t cfgidx)
{
 8019a00:	b580      	push	{r7, lr}
 8019a02:	b084      	sub	sp, #16
 8019a04:	af00      	add	r7, sp, #0
 8019a06:	6078      	str	r0, [r7, #4]
 8019a08:	460b      	mov	r3, r1
 8019a0a:	70fb      	strb	r3, [r7, #3]
  int16_t ret = 0;
 8019a0c:	2300      	movs	r3, #0
 8019a0e:	81fb      	strh	r3, [r7, #14]
   
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8019a10:	687b      	ldr	r3, [r7, #4]
 8019a12:	7c1b      	ldrb	r3, [r3, #16]
 8019a14:	2b00      	cmp	r3, #0
 8019a16:	d10e      	bne.n	8019a36 <USBD_MSC_Init+0x36>
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8019a18:	f44f 7300 	mov.w	r3, #512	; 0x200
 8019a1c:	2202      	movs	r2, #2
 8019a1e:	2101      	movs	r1, #1
 8019a20:	6878      	ldr	r0, [r7, #4]
 8019a22:	f7f7 fae2 	bl	8010fea <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_HS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8019a26:	f44f 7300 	mov.w	r3, #512	; 0x200
 8019a2a:	2202      	movs	r2, #2
 8019a2c:	2181      	movs	r1, #129	; 0x81
 8019a2e:	6878      	ldr	r0, [r7, #4]
 8019a30:	f7f7 fadb 	bl	8010fea <USBD_LL_OpenEP>
 8019a34:	e00b      	b.n	8019a4e <USBD_MSC_Init+0x4e>
                   MSC_MAX_HS_PACKET);  
  }
  else
  {
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8019a36:	2340      	movs	r3, #64	; 0x40
 8019a38:	2202      	movs	r2, #2
 8019a3a:	2101      	movs	r1, #1
 8019a3c:	6878      	ldr	r0, [r7, #4]
 8019a3e:	f7f7 fad4 	bl	8010fea <USBD_LL_OpenEP>
                   MSC_EPOUT_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);
    
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8019a42:	2340      	movs	r3, #64	; 0x40
 8019a44:	2202      	movs	r2, #2
 8019a46:	2181      	movs	r1, #129	; 0x81
 8019a48:	6878      	ldr	r0, [r7, #4]
 8019a4a:	f7f7 face 	bl	8010fea <USBD_LL_OpenEP>
                   MSC_EPIN_ADDR,
                   USBD_EP_TYPE_BULK,
                   MSC_MAX_FS_PACKET);  
  }
  pdev->pClassData = USBD_malloc(sizeof (USBD_MSC_BOT_HandleTypeDef));
 8019a4e:	f244 006c 	movw	r0, #16492	; 0x406c
 8019a52:	f001 fa89 	bl	801af68 <malloc>
 8019a56:	4603      	mov	r3, r0
 8019a58:	461a      	mov	r2, r3
 8019a5a:	687b      	ldr	r3, [r7, #4]
 8019a5c:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 8019a60:	687b      	ldr	r3, [r7, #4]
 8019a62:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019a66:	2b00      	cmp	r3, #0
 8019a68:	d102      	bne.n	8019a70 <USBD_MSC_Init+0x70>
  {
    ret = 1; 
 8019a6a:	2301      	movs	r3, #1
 8019a6c:	81fb      	strh	r3, [r7, #14]
 8019a6e:	e004      	b.n	8019a7a <USBD_MSC_Init+0x7a>
  }
  else
  {
    /* Init the BOT  layer */
    MSC_BOT_Init(pdev); 
 8019a70:	6878      	ldr	r0, [r7, #4]
 8019a72:	f000 f958 	bl	8019d26 <MSC_BOT_Init>
    ret = 0;
 8019a76:	2300      	movs	r3, #0
 8019a78:	81fb      	strh	r3, [r7, #14]
  }
  
  return ret;
 8019a7a:	89fb      	ldrh	r3, [r7, #14]
 8019a7c:	b2db      	uxtb	r3, r3
}
 8019a7e:	4618      	mov	r0, r3
 8019a80:	3710      	adds	r7, #16
 8019a82:	46bd      	mov	sp, r7
 8019a84:	bd80      	pop	{r7, pc}

08019a86 <USBD_MSC_DeInit>:
  * @param  cfgidx: configuration index
  * @retval status
  */
uint8_t  USBD_MSC_DeInit (USBD_HandleTypeDef *pdev, 
                              uint8_t cfgidx)
{
 8019a86:	b580      	push	{r7, lr}
 8019a88:	b082      	sub	sp, #8
 8019a8a:	af00      	add	r7, sp, #0
 8019a8c:	6078      	str	r0, [r7, #4]
 8019a8e:	460b      	mov	r3, r1
 8019a90:	70fb      	strb	r3, [r7, #3]
  /* Close MSC EPs */
  USBD_LL_CloseEP(pdev,
 8019a92:	2101      	movs	r1, #1
 8019a94:	6878      	ldr	r0, [r7, #4]
 8019a96:	f7f7 fac2 	bl	801101e <USBD_LL_CloseEP>
                  MSC_EPOUT_ADDR);
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 8019a9a:	2181      	movs	r1, #129	; 0x81
 8019a9c:	6878      	ldr	r0, [r7, #4]
 8019a9e:	f7f7 fabe 	bl	801101e <USBD_LL_CloseEP>
                  MSC_EPIN_ADDR);
  
  
    /* De-Init the BOT layer */
  MSC_BOT_DeInit(pdev);
 8019aa2:	6878      	ldr	r0, [r7, #4]
 8019aa4:	f000 f98f 	bl	8019dc6 <MSC_BOT_DeInit>
  
  /* Free MSC Class Resources */
  if(pdev->pClassData != NULL)
 8019aa8:	687b      	ldr	r3, [r7, #4]
 8019aaa:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019aae:	2b00      	cmp	r3, #0
 8019ab0:	d009      	beq.n	8019ac6 <USBD_MSC_DeInit+0x40>
  {
    USBD_free(pdev->pClassData);
 8019ab2:	687b      	ldr	r3, [r7, #4]
 8019ab4:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019ab8:	4618      	mov	r0, r3
 8019aba:	f001 fa5d 	bl	801af78 <free>
    pdev->pClassData  = NULL; 
 8019abe:	687b      	ldr	r3, [r7, #4]
 8019ac0:	2200      	movs	r2, #0
 8019ac2:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
  }
  return 0;
 8019ac6:	2300      	movs	r3, #0
}
 8019ac8:	4618      	mov	r0, r3
 8019aca:	3708      	adds	r7, #8
 8019acc:	46bd      	mov	sp, r7
 8019ace:	bd80      	pop	{r7, pc}

08019ad0 <USBD_MSC_Setup>:
* @param  pdev: device instance
* @param  req: USB request
* @retval status
*/
uint8_t  USBD_MSC_Setup (USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8019ad0:	b580      	push	{r7, lr}
 8019ad2:	b084      	sub	sp, #16
 8019ad4:	af00      	add	r7, sp, #0
 8019ad6:	6078      	str	r0, [r7, #4]
 8019ad8:	6039      	str	r1, [r7, #0]
  USBD_MSC_BOT_HandleTypeDef     *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;
 8019ada:	687b      	ldr	r3, [r7, #4]
 8019adc:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019ae0:	60fb      	str	r3, [r7, #12]
  
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8019ae2:	683b      	ldr	r3, [r7, #0]
 8019ae4:	781b      	ldrb	r3, [r3, #0]
 8019ae6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8019aea:	2b00      	cmp	r3, #0
 8019aec:	d04a      	beq.n	8019b84 <USBD_MSC_Setup+0xb4>
 8019aee:	2b20      	cmp	r3, #32
 8019af0:	d000      	beq.n	8019af4 <USBD_MSC_Setup+0x24>
      
    }  
    break;
   
  default:
    break;
 8019af2:	e0a0      	b.n	8019c36 <USBD_MSC_Setup+0x166>
    switch (req->bRequest)
 8019af4:	683b      	ldr	r3, [r7, #0]
 8019af6:	785b      	ldrb	r3, [r3, #1]
 8019af8:	2bfe      	cmp	r3, #254	; 0xfe
 8019afa:	d002      	beq.n	8019b02 <USBD_MSC_Setup+0x32>
 8019afc:	2bff      	cmp	r3, #255	; 0xff
 8019afe:	d023      	beq.n	8019b48 <USBD_MSC_Setup+0x78>
 8019b00:	e039      	b.n	8019b76 <USBD_MSC_Setup+0xa6>
      if((req->wValue  == 0) && 
 8019b02:	683b      	ldr	r3, [r7, #0]
 8019b04:	885b      	ldrh	r3, [r3, #2]
 8019b06:	2b00      	cmp	r3, #0
 8019b08:	d118      	bne.n	8019b3c <USBD_MSC_Setup+0x6c>
         (req->wLength == 1) &&
 8019b0a:	683b      	ldr	r3, [r7, #0]
 8019b0c:	88db      	ldrh	r3, [r3, #6]
      if((req->wValue  == 0) && 
 8019b0e:	2b01      	cmp	r3, #1
 8019b10:	d114      	bne.n	8019b3c <USBD_MSC_Setup+0x6c>
         ((req->bmRequest & 0x80) == 0x80))
 8019b12:	683b      	ldr	r3, [r7, #0]
 8019b14:	781b      	ldrb	r3, [r3, #0]
 8019b16:	b25b      	sxtb	r3, r3
         (req->wLength == 1) &&
 8019b18:	2b00      	cmp	r3, #0
 8019b1a:	da0f      	bge.n	8019b3c <USBD_MSC_Setup+0x6c>
        hmsc->max_lun = ((USBD_StorageTypeDef *)pdev->pUserData)->GetMaxLun();
 8019b1c:	687b      	ldr	r3, [r7, #4]
 8019b1e:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8019b22:	699b      	ldr	r3, [r3, #24]
 8019b24:	4798      	blx	r3
 8019b26:	4603      	mov	r3, r0
 8019b28:	461a      	mov	r2, r3
 8019b2a:	68fb      	ldr	r3, [r7, #12]
 8019b2c:	601a      	str	r2, [r3, #0]
                          (uint8_t *)&hmsc->max_lun,
 8019b2e:	68fb      	ldr	r3, [r7, #12]
        USBD_CtlSendData (pdev,
 8019b30:	2201      	movs	r2, #1
 8019b32:	4619      	mov	r1, r3
 8019b34:	6878      	ldr	r0, [r7, #4]
 8019b36:	f7ff fefd 	bl	8019934 <USBD_CtlSendData>
      break;
 8019b3a:	e022      	b.n	8019b82 <USBD_MSC_Setup+0xb2>
         USBD_CtlError(pdev , req);
 8019b3c:	6839      	ldr	r1, [r7, #0]
 8019b3e:	6878      	ldr	r0, [r7, #4]
 8019b40:	f7ff fe8c 	bl	801985c <USBD_CtlError>
         return USBD_FAIL; 
 8019b44:	2302      	movs	r3, #2
 8019b46:	e077      	b.n	8019c38 <USBD_MSC_Setup+0x168>
      if((req->wValue  == 0) && 
 8019b48:	683b      	ldr	r3, [r7, #0]
 8019b4a:	885b      	ldrh	r3, [r3, #2]
 8019b4c:	2b00      	cmp	r3, #0
 8019b4e:	d10c      	bne.n	8019b6a <USBD_MSC_Setup+0x9a>
         (req->wLength == 0) &&
 8019b50:	683b      	ldr	r3, [r7, #0]
 8019b52:	88db      	ldrh	r3, [r3, #6]
      if((req->wValue  == 0) && 
 8019b54:	2b00      	cmp	r3, #0
 8019b56:	d108      	bne.n	8019b6a <USBD_MSC_Setup+0x9a>
        ((req->bmRequest & 0x80) != 0x80))
 8019b58:	683b      	ldr	r3, [r7, #0]
 8019b5a:	781b      	ldrb	r3, [r3, #0]
 8019b5c:	b25b      	sxtb	r3, r3
         (req->wLength == 0) &&
 8019b5e:	2b00      	cmp	r3, #0
 8019b60:	db03      	blt.n	8019b6a <USBD_MSC_Setup+0x9a>
         MSC_BOT_Reset(pdev);
 8019b62:	6878      	ldr	r0, [r7, #4]
 8019b64:	f000 f914 	bl	8019d90 <MSC_BOT_Reset>
      break;
 8019b68:	e00b      	b.n	8019b82 <USBD_MSC_Setup+0xb2>
         USBD_CtlError(pdev , req);
 8019b6a:	6839      	ldr	r1, [r7, #0]
 8019b6c:	6878      	ldr	r0, [r7, #4]
 8019b6e:	f7ff fe75 	bl	801985c <USBD_CtlError>
         return USBD_FAIL; 
 8019b72:	2302      	movs	r3, #2
 8019b74:	e060      	b.n	8019c38 <USBD_MSC_Setup+0x168>
       USBD_CtlError(pdev , req);
 8019b76:	6839      	ldr	r1, [r7, #0]
 8019b78:	6878      	ldr	r0, [r7, #4]
 8019b7a:	f7ff fe6f 	bl	801985c <USBD_CtlError>
       return USBD_FAIL; 
 8019b7e:	2302      	movs	r3, #2
 8019b80:	e05a      	b.n	8019c38 <USBD_MSC_Setup+0x168>
    break;
 8019b82:	e058      	b.n	8019c36 <USBD_MSC_Setup+0x166>
    switch (req->bRequest)
 8019b84:	683b      	ldr	r3, [r7, #0]
 8019b86:	785b      	ldrb	r3, [r3, #1]
 8019b88:	2b0a      	cmp	r3, #10
 8019b8a:	d004      	beq.n	8019b96 <USBD_MSC_Setup+0xc6>
 8019b8c:	2b0b      	cmp	r3, #11
 8019b8e:	d00a      	beq.n	8019ba6 <USBD_MSC_Setup+0xd6>
 8019b90:	2b01      	cmp	r3, #1
 8019b92:	d00f      	beq.n	8019bb4 <USBD_MSC_Setup+0xe4>
    break;
 8019b94:	e04e      	b.n	8019c34 <USBD_MSC_Setup+0x164>
                        (uint8_t *)&hmsc->interface,
 8019b96:	68fb      	ldr	r3, [r7, #12]
 8019b98:	3304      	adds	r3, #4
      USBD_CtlSendData (pdev,
 8019b9a:	2201      	movs	r2, #1
 8019b9c:	4619      	mov	r1, r3
 8019b9e:	6878      	ldr	r0, [r7, #4]
 8019ba0:	f7ff fec8 	bl	8019934 <USBD_CtlSendData>
      break;
 8019ba4:	e046      	b.n	8019c34 <USBD_MSC_Setup+0x164>
      hmsc->interface = (uint8_t)(req->wValue);
 8019ba6:	683b      	ldr	r3, [r7, #0]
 8019ba8:	885b      	ldrh	r3, [r3, #2]
 8019baa:	b2db      	uxtb	r3, r3
 8019bac:	461a      	mov	r2, r3
 8019bae:	68fb      	ldr	r3, [r7, #12]
 8019bb0:	605a      	str	r2, [r3, #4]
      break;
 8019bb2:	e03f      	b.n	8019c34 <USBD_MSC_Setup+0x164>
      USBD_LL_FlushEP(pdev, (uint8_t)req->wIndex);
 8019bb4:	683b      	ldr	r3, [r7, #0]
 8019bb6:	889b      	ldrh	r3, [r3, #4]
 8019bb8:	b2db      	uxtb	r3, r3
 8019bba:	4619      	mov	r1, r3
 8019bbc:	6878      	ldr	r0, [r7, #4]
 8019bbe:	f7f7 fa41 	bl	8011044 <USBD_LL_FlushEP>
      USBD_LL_CloseEP (pdev , (uint8_t)req->wIndex);
 8019bc2:	683b      	ldr	r3, [r7, #0]
 8019bc4:	889b      	ldrh	r3, [r3, #4]
 8019bc6:	b2db      	uxtb	r3, r3
 8019bc8:	4619      	mov	r1, r3
 8019bca:	6878      	ldr	r0, [r7, #4]
 8019bcc:	f7f7 fa27 	bl	801101e <USBD_LL_CloseEP>
      if((((uint8_t)req->wIndex) & 0x80) == 0x80)
 8019bd0:	683b      	ldr	r3, [r7, #0]
 8019bd2:	889b      	ldrh	r3, [r3, #4]
 8019bd4:	b25b      	sxtb	r3, r3
 8019bd6:	2b00      	cmp	r3, #0
 8019bd8:	da12      	bge.n	8019c00 <USBD_MSC_Setup+0x130>
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8019bda:	687b      	ldr	r3, [r7, #4]
 8019bdc:	7c1b      	ldrb	r3, [r3, #16]
 8019bde:	2b00      	cmp	r3, #0
 8019be0:	d107      	bne.n	8019bf2 <USBD_MSC_Setup+0x122>
          USBD_LL_OpenEP(pdev,
 8019be2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8019be6:	2202      	movs	r2, #2
 8019be8:	2181      	movs	r1, #129	; 0x81
 8019bea:	6878      	ldr	r0, [r7, #4]
 8019bec:	f7f7 f9fd 	bl	8010fea <USBD_LL_OpenEP>
 8019bf0:	e018      	b.n	8019c24 <USBD_MSC_Setup+0x154>
          USBD_LL_OpenEP(pdev,
 8019bf2:	2340      	movs	r3, #64	; 0x40
 8019bf4:	2202      	movs	r2, #2
 8019bf6:	2181      	movs	r1, #129	; 0x81
 8019bf8:	6878      	ldr	r0, [r7, #4]
 8019bfa:	f7f7 f9f6 	bl	8010fea <USBD_LL_OpenEP>
 8019bfe:	e011      	b.n	8019c24 <USBD_MSC_Setup+0x154>
        if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8019c00:	687b      	ldr	r3, [r7, #4]
 8019c02:	7c1b      	ldrb	r3, [r3, #16]
 8019c04:	2b00      	cmp	r3, #0
 8019c06:	d107      	bne.n	8019c18 <USBD_MSC_Setup+0x148>
          USBD_LL_OpenEP(pdev,
 8019c08:	f44f 7300 	mov.w	r3, #512	; 0x200
 8019c0c:	2202      	movs	r2, #2
 8019c0e:	2101      	movs	r1, #1
 8019c10:	6878      	ldr	r0, [r7, #4]
 8019c12:	f7f7 f9ea 	bl	8010fea <USBD_LL_OpenEP>
 8019c16:	e005      	b.n	8019c24 <USBD_MSC_Setup+0x154>
          USBD_LL_OpenEP(pdev,
 8019c18:	2340      	movs	r3, #64	; 0x40
 8019c1a:	2202      	movs	r2, #2
 8019c1c:	2101      	movs	r1, #1
 8019c1e:	6878      	ldr	r0, [r7, #4]
 8019c20:	f7f7 f9e3 	bl	8010fea <USBD_LL_OpenEP>
      MSC_BOT_CplClrFeature(pdev, (uint8_t)req->wIndex);
 8019c24:	683b      	ldr	r3, [r7, #0]
 8019c26:	889b      	ldrh	r3, [r3, #4]
 8019c28:	b2db      	uxtb	r3, r3
 8019c2a:	4619      	mov	r1, r3
 8019c2c:	6878      	ldr	r0, [r7, #4]
 8019c2e:	f000 fa6c 	bl	801a10a <MSC_BOT_CplClrFeature>
      break;
 8019c32:	bf00      	nop
    break;
 8019c34:	bf00      	nop
  }
  return 0;
 8019c36:	2300      	movs	r3, #0
}
 8019c38:	4618      	mov	r0, r3
 8019c3a:	3710      	adds	r7, #16
 8019c3c:	46bd      	mov	sp, r7
 8019c3e:	bd80      	pop	{r7, pc}

08019c40 <USBD_MSC_DataIn>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
 8019c40:	b580      	push	{r7, lr}
 8019c42:	b082      	sub	sp, #8
 8019c44:	af00      	add	r7, sp, #0
 8019c46:	6078      	str	r0, [r7, #4]
 8019c48:	460b      	mov	r3, r1
 8019c4a:	70fb      	strb	r3, [r7, #3]
  MSC_BOT_DataIn(pdev , epnum);
 8019c4c:	78fb      	ldrb	r3, [r7, #3]
 8019c4e:	4619      	mov	r1, r3
 8019c50:	6878      	ldr	r0, [r7, #4]
 8019c52:	f000 f8c9 	bl	8019de8 <MSC_BOT_DataIn>
  return 0;
 8019c56:	2300      	movs	r3, #0
}
 8019c58:	4618      	mov	r0, r3
 8019c5a:	3708      	adds	r7, #8
 8019c5c:	46bd      	mov	sp, r7
 8019c5e:	bd80      	pop	{r7, pc}

08019c60 <USBD_MSC_DataOut>:
* @param  epnum: endpoint index
* @retval status
*/
uint8_t  USBD_MSC_DataOut (USBD_HandleTypeDef *pdev, 
                               uint8_t epnum)
{
 8019c60:	b580      	push	{r7, lr}
 8019c62:	b082      	sub	sp, #8
 8019c64:	af00      	add	r7, sp, #0
 8019c66:	6078      	str	r0, [r7, #4]
 8019c68:	460b      	mov	r3, r1
 8019c6a:	70fb      	strb	r3, [r7, #3]
  MSC_BOT_DataOut(pdev , epnum);
 8019c6c:	78fb      	ldrb	r3, [r7, #3]
 8019c6e:	4619      	mov	r1, r3
 8019c70:	6878      	ldr	r0, [r7, #4]
 8019c72:	f000 f8ed 	bl	8019e50 <MSC_BOT_DataOut>
  return 0;
 8019c76:	2300      	movs	r3, #0
}
 8019c78:	4618      	mov	r0, r3
 8019c7a:	3708      	adds	r7, #8
 8019c7c:	46bd      	mov	sp, r7
 8019c7e:	bd80      	pop	{r7, pc}

08019c80 <USBD_MSC_GetHSCfgDesc>:
*         return configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetHSCfgDesc (uint16_t *length)
{
 8019c80:	b480      	push	{r7}
 8019c82:	b083      	sub	sp, #12
 8019c84:	af00      	add	r7, sp, #0
 8019c86:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_MSC_CfgHSDesc);
 8019c88:	687b      	ldr	r3, [r7, #4]
 8019c8a:	2220      	movs	r2, #32
 8019c8c:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_CfgHSDesc;
 8019c8e:	4b03      	ldr	r3, [pc, #12]	; (8019c9c <USBD_MSC_GetHSCfgDesc+0x1c>)
}
 8019c90:	4618      	mov	r0, r3
 8019c92:	370c      	adds	r7, #12
 8019c94:	46bd      	mov	sp, r7
 8019c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019c9a:	4770      	bx	lr
 8019c9c:	20000394 	.word	0x20000394

08019ca0 <USBD_MSC_GetFSCfgDesc>:
*         return configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetFSCfgDesc (uint16_t *length)
{
 8019ca0:	b480      	push	{r7}
 8019ca2:	b083      	sub	sp, #12
 8019ca4:	af00      	add	r7, sp, #0
 8019ca6:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_MSC_CfgFSDesc);
 8019ca8:	687b      	ldr	r3, [r7, #4]
 8019caa:	2220      	movs	r2, #32
 8019cac:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_CfgFSDesc;
 8019cae:	4b03      	ldr	r3, [pc, #12]	; (8019cbc <USBD_MSC_GetFSCfgDesc+0x1c>)
}
 8019cb0:	4618      	mov	r0, r3
 8019cb2:	370c      	adds	r7, #12
 8019cb4:	46bd      	mov	sp, r7
 8019cb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019cba:	4770      	bx	lr
 8019cbc:	200003b4 	.word	0x200003b4

08019cc0 <USBD_MSC_GetOtherSpeedCfgDesc>:
*         return other speed configuration descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetOtherSpeedCfgDesc (uint16_t *length)
{
 8019cc0:	b480      	push	{r7}
 8019cc2:	b083      	sub	sp, #12
 8019cc4:	af00      	add	r7, sp, #0
 8019cc6:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_MSC_OtherSpeedCfgDesc);
 8019cc8:	687b      	ldr	r3, [r7, #4]
 8019cca:	2220      	movs	r2, #32
 8019ccc:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_OtherSpeedCfgDesc;
 8019cce:	4b03      	ldr	r3, [pc, #12]	; (8019cdc <USBD_MSC_GetOtherSpeedCfgDesc+0x1c>)
}
 8019cd0:	4618      	mov	r0, r3
 8019cd2:	370c      	adds	r7, #12
 8019cd4:	46bd      	mov	sp, r7
 8019cd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019cda:	4770      	bx	lr
 8019cdc:	200003d4 	.word	0x200003d4

08019ce0 <USBD_MSC_GetDeviceQualifierDescriptor>:
*         return Device Qualifier descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MSC_GetDeviceQualifierDescriptor (uint16_t *length)
{
 8019ce0:	b480      	push	{r7}
 8019ce2:	b083      	sub	sp, #12
 8019ce4:	af00      	add	r7, sp, #0
 8019ce6:	6078      	str	r0, [r7, #4]
  *length = sizeof (USBD_MSC_DeviceQualifierDesc);
 8019ce8:	687b      	ldr	r3, [r7, #4]
 8019cea:	220a      	movs	r2, #10
 8019cec:	801a      	strh	r2, [r3, #0]
  return USBD_MSC_DeviceQualifierDesc;
 8019cee:	4b03      	ldr	r3, [pc, #12]	; (8019cfc <USBD_MSC_GetDeviceQualifierDescriptor+0x1c>)
}
 8019cf0:	4618      	mov	r0, r3
 8019cf2:	370c      	adds	r7, #12
 8019cf4:	46bd      	mov	sp, r7
 8019cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019cfa:	4770      	bx	lr
 8019cfc:	200003f4 	.word	0x200003f4

08019d00 <USBD_MSC_RegisterStorage>:
* @param  fops: storage callback
* @retval status
*/
uint8_t  USBD_MSC_RegisterStorage  (USBD_HandleTypeDef   *pdev, 
                                    USBD_StorageTypeDef *fops)
{
 8019d00:	b480      	push	{r7}
 8019d02:	b083      	sub	sp, #12
 8019d04:	af00      	add	r7, sp, #0
 8019d06:	6078      	str	r0, [r7, #4]
 8019d08:	6039      	str	r1, [r7, #0]
  if(fops != NULL)
 8019d0a:	683b      	ldr	r3, [r7, #0]
 8019d0c:	2b00      	cmp	r3, #0
 8019d0e:	d003      	beq.n	8019d18 <USBD_MSC_RegisterStorage+0x18>
  {
    pdev->pUserData= fops;
 8019d10:	687b      	ldr	r3, [r7, #4]
 8019d12:	683a      	ldr	r2, [r7, #0]
 8019d14:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
  }
  return 0;
 8019d18:	2300      	movs	r3, #0
}
 8019d1a:	4618      	mov	r0, r3
 8019d1c:	370c      	adds	r7, #12
 8019d1e:	46bd      	mov	sp, r7
 8019d20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019d24:	4770      	bx	lr

08019d26 <MSC_BOT_Init>:
*         Initialize the BOT Process
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_Init (USBD_HandleTypeDef  *pdev)
{
 8019d26:	b580      	push	{r7, lr}
 8019d28:	b084      	sub	sp, #16
 8019d2a:	af00      	add	r7, sp, #0
 8019d2c:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8019d2e:	687b      	ldr	r3, [r7, #4]
 8019d30:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019d34:	60fb      	str	r3, [r7, #12]
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8019d36:	68fb      	ldr	r3, [r7, #12]
 8019d38:	2200      	movs	r2, #0
 8019d3a:	721a      	strb	r2, [r3, #8]
  hmsc->bot_status = USBD_BOT_STATUS_NORMAL;
 8019d3c:	68fb      	ldr	r3, [r7, #12]
 8019d3e:	2200      	movs	r2, #0
 8019d40:	725a      	strb	r2, [r3, #9]
  
  hmsc->scsi_sense_tail = 0;
 8019d42:	68fb      	ldr	r3, [r7, #12]
 8019d44:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019d48:	335d      	adds	r3, #93	; 0x5d
 8019d4a:	2200      	movs	r2, #0
 8019d4c:	701a      	strb	r2, [r3, #0]
  hmsc->scsi_sense_head = 0;
 8019d4e:	68fb      	ldr	r3, [r7, #12]
 8019d50:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019d54:	335c      	adds	r3, #92	; 0x5c
 8019d56:	2200      	movs	r2, #0
 8019d58:	701a      	strb	r2, [r3, #0]
  
  ((USBD_StorageTypeDef *)pdev->pUserData)->Init(0);
 8019d5a:	687b      	ldr	r3, [r7, #4]
 8019d5c:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 8019d60:	681b      	ldr	r3, [r3, #0]
 8019d62:	2000      	movs	r0, #0
 8019d64:	4798      	blx	r3
  
  USBD_LL_FlushEP(pdev, MSC_EPOUT_ADDR);
 8019d66:	2101      	movs	r1, #1
 8019d68:	6878      	ldr	r0, [r7, #4]
 8019d6a:	f7f7 f96b 	bl	8011044 <USBD_LL_FlushEP>
  USBD_LL_FlushEP(pdev, MSC_EPIN_ADDR);
 8019d6e:	2181      	movs	r1, #129	; 0x81
 8019d70:	6878      	ldr	r0, [r7, #4]
 8019d72:	f7f7 f967 	bl	8011044 <USBD_LL_FlushEP>
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
                          MSC_EPOUT_ADDR,
                          (uint8_t *)&hmsc->cbw,
 8019d76:	68fb      	ldr	r3, [r7, #12]
 8019d78:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 8019d7c:	320c      	adds	r2, #12
  USBD_LL_PrepareReceive (pdev,
 8019d7e:	231f      	movs	r3, #31
 8019d80:	2101      	movs	r1, #1
 8019d82:	6878      	ldr	r0, [r7, #4]
 8019d84:	f7f7 f9ed 	bl	8011162 <USBD_LL_PrepareReceive>
                          USBD_BOT_CBW_LENGTH);    
}
 8019d88:	bf00      	nop
 8019d8a:	3710      	adds	r7, #16
 8019d8c:	46bd      	mov	sp, r7
 8019d8e:	bd80      	pop	{r7, pc}

08019d90 <MSC_BOT_Reset>:
*         Reset the BOT Machine
* @param  pdev: device instance
* @retval  None
*/
void MSC_BOT_Reset (USBD_HandleTypeDef  *pdev)
{
 8019d90:	b580      	push	{r7, lr}
 8019d92:	b084      	sub	sp, #16
 8019d94:	af00      	add	r7, sp, #0
 8019d96:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8019d98:	687b      	ldr	r3, [r7, #4]
 8019d9a:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019d9e:	60fb      	str	r3, [r7, #12]
    
  hmsc->bot_state  = USBD_BOT_IDLE;
 8019da0:	68fb      	ldr	r3, [r7, #12]
 8019da2:	2200      	movs	r2, #0
 8019da4:	721a      	strb	r2, [r3, #8]
  hmsc->bot_status = USBD_BOT_STATUS_RECOVERY;  
 8019da6:	68fb      	ldr	r3, [r7, #12]
 8019da8:	2201      	movs	r2, #1
 8019daa:	725a      	strb	r2, [r3, #9]
  
  /* Prapare EP to Receive First BOT Cmd */
  USBD_LL_PrepareReceive (pdev,
                          MSC_EPOUT_ADDR,
                          (uint8_t *)&hmsc->cbw,
 8019dac:	68fb      	ldr	r3, [r7, #12]
 8019dae:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 8019db2:	320c      	adds	r2, #12
  USBD_LL_PrepareReceive (pdev,
 8019db4:	231f      	movs	r3, #31
 8019db6:	2101      	movs	r1, #1
 8019db8:	6878      	ldr	r0, [r7, #4]
 8019dba:	f7f7 f9d2 	bl	8011162 <USBD_LL_PrepareReceive>
                          USBD_BOT_CBW_LENGTH);   
}
 8019dbe:	bf00      	nop
 8019dc0:	3710      	adds	r7, #16
 8019dc2:	46bd      	mov	sp, r7
 8019dc4:	bd80      	pop	{r7, pc}

08019dc6 <MSC_BOT_DeInit>:
*         Deinitialize the BOT Machine
* @param  pdev: device instance
* @retval None
*/
void MSC_BOT_DeInit (USBD_HandleTypeDef  *pdev)
{
 8019dc6:	b480      	push	{r7}
 8019dc8:	b085      	sub	sp, #20
 8019dca:	af00      	add	r7, sp, #0
 8019dcc:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8019dce:	687b      	ldr	r3, [r7, #4]
 8019dd0:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019dd4:	60fb      	str	r3, [r7, #12]
  hmsc->bot_state  = USBD_BOT_IDLE;
 8019dd6:	68fb      	ldr	r3, [r7, #12]
 8019dd8:	2200      	movs	r2, #0
 8019dda:	721a      	strb	r2, [r3, #8]
}
 8019ddc:	bf00      	nop
 8019dde:	3714      	adds	r7, #20
 8019de0:	46bd      	mov	sp, r7
 8019de2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019de6:	4770      	bx	lr

08019de8 <MSC_BOT_DataIn>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataIn (USBD_HandleTypeDef  *pdev, 
                     uint8_t epnum)
{
 8019de8:	b580      	push	{r7, lr}
 8019dea:	b084      	sub	sp, #16
 8019dec:	af00      	add	r7, sp, #0
 8019dee:	6078      	str	r0, [r7, #4]
 8019df0:	460b      	mov	r3, r1
 8019df2:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8019df4:	687b      	ldr	r3, [r7, #4]
 8019df6:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019dfa:	60fb      	str	r3, [r7, #12]
  
  switch (hmsc->bot_state)
 8019dfc:	68fb      	ldr	r3, [r7, #12]
 8019dfe:	7a1b      	ldrb	r3, [r3, #8]
 8019e00:	2b02      	cmp	r3, #2
 8019e02:	d004      	beq.n	8019e0e <MSC_BOT_DataIn+0x26>
 8019e04:	2b02      	cmp	r3, #2
 8019e06:	db1c      	blt.n	8019e42 <MSC_BOT_DataIn+0x5a>
 8019e08:	2b04      	cmp	r3, #4
 8019e0a:	dc1a      	bgt.n	8019e42 <MSC_BOT_DataIn+0x5a>
 8019e0c:	e014      	b.n	8019e38 <MSC_BOT_DataIn+0x50>
  {
  case USBD_BOT_DATA_IN:
    if(SCSI_ProcessCmd(pdev,
 8019e0e:	68fb      	ldr	r3, [r7, #12]
 8019e10:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019e14:	3319      	adds	r3, #25
 8019e16:	7819      	ldrb	r1, [r3, #0]
 8019e18:	68fb      	ldr	r3, [r7, #12]
 8019e1a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019e1e:	331b      	adds	r3, #27
 8019e20:	461a      	mov	r2, r3
 8019e22:	6878      	ldr	r0, [r7, #4]
 8019e24:	f000 f998 	bl	801a158 <SCSI_ProcessCmd>
 8019e28:	4603      	mov	r3, r0
 8019e2a:	2b00      	cmp	r3, #0
 8019e2c:	da0b      	bge.n	8019e46 <MSC_BOT_DataIn+0x5e>
                        hmsc->cbw.bLUN,
                        &hmsc->cbw.CB[0]) < 0)
    {
      MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8019e2e:	2101      	movs	r1, #1
 8019e30:	6878      	ldr	r0, [r7, #4]
 8019e32:	f000 f905 	bl	801a040 <MSC_BOT_SendCSW>
    }
    break;
 8019e36:	e006      	b.n	8019e46 <MSC_BOT_DataIn+0x5e>
    
  case USBD_BOT_SEND_DATA:
  case USBD_BOT_LAST_DATA_IN:
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 8019e38:	2100      	movs	r1, #0
 8019e3a:	6878      	ldr	r0, [r7, #4]
 8019e3c:	f000 f900 	bl	801a040 <MSC_BOT_SendCSW>
    
    break;
 8019e40:	e002      	b.n	8019e48 <MSC_BOT_DataIn+0x60>
    
  default:
    break;
 8019e42:	bf00      	nop
 8019e44:	e000      	b.n	8019e48 <MSC_BOT_DataIn+0x60>
    break;
 8019e46:	bf00      	nop
  }
}
 8019e48:	bf00      	nop
 8019e4a:	3710      	adds	r7, #16
 8019e4c:	46bd      	mov	sp, r7
 8019e4e:	bd80      	pop	{r7, pc}

08019e50 <MSC_BOT_DataOut>:
* @param  epnum: endpoint index
* @retval None
*/
void MSC_BOT_DataOut (USBD_HandleTypeDef  *pdev, 
                      uint8_t epnum)
{
 8019e50:	b580      	push	{r7, lr}
 8019e52:	b084      	sub	sp, #16
 8019e54:	af00      	add	r7, sp, #0
 8019e56:	6078      	str	r0, [r7, #4]
 8019e58:	460b      	mov	r3, r1
 8019e5a:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;
 8019e5c:	687b      	ldr	r3, [r7, #4]
 8019e5e:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019e62:	60fb      	str	r3, [r7, #12]
  
  switch (hmsc->bot_state)
 8019e64:	68fb      	ldr	r3, [r7, #12]
 8019e66:	7a1b      	ldrb	r3, [r3, #8]
 8019e68:	2b00      	cmp	r3, #0
 8019e6a:	d002      	beq.n	8019e72 <MSC_BOT_DataOut+0x22>
 8019e6c:	2b01      	cmp	r3, #1
 8019e6e:	d004      	beq.n	8019e7a <MSC_BOT_DataOut+0x2a>
    }

    break;
    
  default:
    break;
 8019e70:	e018      	b.n	8019ea4 <MSC_BOT_DataOut+0x54>
    MSC_BOT_CBW_Decode(pdev);
 8019e72:	6878      	ldr	r0, [r7, #4]
 8019e74:	f000 f81a 	bl	8019eac <MSC_BOT_CBW_Decode>
    break;
 8019e78:	e014      	b.n	8019ea4 <MSC_BOT_DataOut+0x54>
    if(SCSI_ProcessCmd(pdev,
 8019e7a:	68fb      	ldr	r3, [r7, #12]
 8019e7c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019e80:	3319      	adds	r3, #25
 8019e82:	7819      	ldrb	r1, [r3, #0]
 8019e84:	68fb      	ldr	r3, [r7, #12]
 8019e86:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019e8a:	331b      	adds	r3, #27
 8019e8c:	461a      	mov	r2, r3
 8019e8e:	6878      	ldr	r0, [r7, #4]
 8019e90:	f000 f962 	bl	801a158 <SCSI_ProcessCmd>
 8019e94:	4603      	mov	r3, r0
 8019e96:	2b00      	cmp	r3, #0
 8019e98:	da03      	bge.n	8019ea2 <MSC_BOT_DataOut+0x52>
      MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 8019e9a:	2101      	movs	r1, #1
 8019e9c:	6878      	ldr	r0, [r7, #4]
 8019e9e:	f000 f8cf 	bl	801a040 <MSC_BOT_SendCSW>
    break;
 8019ea2:	bf00      	nop
  }
}
 8019ea4:	bf00      	nop
 8019ea6:	3710      	adds	r7, #16
 8019ea8:	46bd      	mov	sp, r7
 8019eaa:	bd80      	pop	{r7, pc}

08019eac <MSC_BOT_CBW_Decode>:
*         Decode the CBW command and set the BOT state machine accordingly  
* @param  pdev: device instance
* @retval None
*/
static void  MSC_BOT_CBW_Decode (USBD_HandleTypeDef  *pdev)
{
 8019eac:	b580      	push	{r7, lr}
 8019eae:	b084      	sub	sp, #16
 8019eb0:	af00      	add	r7, sp, #0
 8019eb2:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 8019eb4:	687b      	ldr	r3, [r7, #4]
 8019eb6:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019eba:	60fb      	str	r3, [r7, #12]
  
  hmsc->csw.dTag = hmsc->cbw.dTag;
 8019ebc:	68fb      	ldr	r3, [r7, #12]
 8019ebe:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ec2:	3310      	adds	r3, #16
 8019ec4:	681a      	ldr	r2, [r3, #0]
 8019ec6:	68fb      	ldr	r3, [r7, #12]
 8019ec8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ecc:	3330      	adds	r3, #48	; 0x30
 8019ece:	601a      	str	r2, [r3, #0]
  hmsc->csw.dDataResidue = hmsc->cbw.dDataLength;
 8019ed0:	68fb      	ldr	r3, [r7, #12]
 8019ed2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ed6:	3314      	adds	r3, #20
 8019ed8:	681a      	ldr	r2, [r3, #0]
 8019eda:	68fb      	ldr	r3, [r7, #12]
 8019edc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ee0:	3334      	adds	r3, #52	; 0x34
 8019ee2:	601a      	str	r2, [r3, #0]
  
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 8019ee4:	2101      	movs	r1, #1
 8019ee6:	6878      	ldr	r0, [r7, #4]
 8019ee8:	f7f7 f952 	bl	8011190 <USBD_LL_GetRxDataSize>
 8019eec:	4603      	mov	r3, r0
 8019eee:	2b1f      	cmp	r3, #31
 8019ef0:	d11c      	bne.n	8019f2c <MSC_BOT_CBW_Decode+0x80>
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE)||
 8019ef2:	68fb      	ldr	r3, [r7, #12]
 8019ef4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ef8:	330c      	adds	r3, #12
 8019efa:	681b      	ldr	r3, [r3, #0]
  if ((USBD_LL_GetRxDataSize (pdev ,MSC_EPOUT_ADDR) != USBD_BOT_CBW_LENGTH) ||
 8019efc:	4a35      	ldr	r2, [pc, #212]	; (8019fd4 <MSC_BOT_CBW_Decode+0x128>)
 8019efe:	4293      	cmp	r3, r2
 8019f00:	d114      	bne.n	8019f2c <MSC_BOT_CBW_Decode+0x80>
        (hmsc->cbw.bLUN > 1) || 
 8019f02:	68fb      	ldr	r3, [r7, #12]
 8019f04:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f08:	3319      	adds	r3, #25
 8019f0a:	781b      	ldrb	r3, [r3, #0]
      (hmsc->cbw.dSignature != USBD_BOT_CBW_SIGNATURE)||
 8019f0c:	2b01      	cmp	r3, #1
 8019f0e:	d80d      	bhi.n	8019f2c <MSC_BOT_CBW_Decode+0x80>
          (hmsc->cbw.bCBLength < 1) || 
 8019f10:	68fb      	ldr	r3, [r7, #12]
 8019f12:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f16:	331a      	adds	r3, #26
 8019f18:	781b      	ldrb	r3, [r3, #0]
        (hmsc->cbw.bLUN > 1) || 
 8019f1a:	2b00      	cmp	r3, #0
 8019f1c:	d006      	beq.n	8019f2c <MSC_BOT_CBW_Decode+0x80>
            (hmsc->cbw.bCBLength > 16))
 8019f1e:	68fb      	ldr	r3, [r7, #12]
 8019f20:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f24:	331a      	adds	r3, #26
 8019f26:	781b      	ldrb	r3, [r3, #0]
          (hmsc->cbw.bCBLength < 1) || 
 8019f28:	2b10      	cmp	r3, #16
 8019f2a:	d910      	bls.n	8019f4e <MSC_BOT_CBW_Decode+0xa2>
  {
    
    SCSI_SenseCode(pdev,
 8019f2c:	68fb      	ldr	r3, [r7, #12]
 8019f2e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f32:	3319      	adds	r3, #25
 8019f34:	7819      	ldrb	r1, [r3, #0]
 8019f36:	2320      	movs	r3, #32
 8019f38:	2205      	movs	r2, #5
 8019f3a:	6878      	ldr	r0, [r7, #4]
 8019f3c:	f000 fc7a 	bl	801a834 <SCSI_SenseCode>
                   hmsc->cbw.bLUN, 
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    
    hmsc->bot_status = USBD_BOT_STATUS_ERROR;   
 8019f40:	68fb      	ldr	r3, [r7, #12]
 8019f42:	2202      	movs	r2, #2
 8019f44:	725a      	strb	r2, [r3, #9]
    MSC_BOT_Abort(pdev);
 8019f46:	6878      	ldr	r0, [r7, #4]
 8019f48:	f000 f8ac 	bl	801a0a4 <MSC_BOT_Abort>
        MSC_BOT_SendCSW (pdev,
                         USBD_CSW_CMD_PASSED);
      }
    }
  }
}
 8019f4c:	e03e      	b.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
    if(SCSI_ProcessCmd(pdev,
 8019f4e:	68fb      	ldr	r3, [r7, #12]
 8019f50:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f54:	3319      	adds	r3, #25
 8019f56:	7819      	ldrb	r1, [r3, #0]
 8019f58:	68fb      	ldr	r3, [r7, #12]
 8019f5a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019f5e:	331b      	adds	r3, #27
 8019f60:	461a      	mov	r2, r3
 8019f62:	6878      	ldr	r0, [r7, #4]
 8019f64:	f000 f8f8 	bl	801a158 <SCSI_ProcessCmd>
 8019f68:	4603      	mov	r3, r0
 8019f6a:	2b00      	cmp	r3, #0
 8019f6c:	da0c      	bge.n	8019f88 <MSC_BOT_CBW_Decode+0xdc>
      if(hmsc->bot_state == USBD_BOT_NO_DATA)
 8019f6e:	68fb      	ldr	r3, [r7, #12]
 8019f70:	7a1b      	ldrb	r3, [r3, #8]
 8019f72:	2b05      	cmp	r3, #5
 8019f74:	d104      	bne.n	8019f80 <MSC_BOT_CBW_Decode+0xd4>
       MSC_BOT_SendCSW (pdev,
 8019f76:	2101      	movs	r1, #1
 8019f78:	6878      	ldr	r0, [r7, #4]
 8019f7a:	f000 f861 	bl	801a040 <MSC_BOT_SendCSW>
}
 8019f7e:	e025      	b.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
        MSC_BOT_Abort(pdev);
 8019f80:	6878      	ldr	r0, [r7, #4]
 8019f82:	f000 f88f 	bl	801a0a4 <MSC_BOT_Abort>
}
 8019f86:	e021      	b.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) && 
 8019f88:	68fb      	ldr	r3, [r7, #12]
 8019f8a:	7a1b      	ldrb	r3, [r3, #8]
 8019f8c:	2b02      	cmp	r3, #2
 8019f8e:	d01d      	beq.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
 8019f90:	68fb      	ldr	r3, [r7, #12]
 8019f92:	7a1b      	ldrb	r3, [r3, #8]
    else if ((hmsc->bot_state != USBD_BOT_DATA_IN) && 
 8019f94:	2b01      	cmp	r3, #1
 8019f96:	d019      	beq.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
             (hmsc->bot_state != USBD_BOT_LAST_DATA_IN)) 
 8019f98:	68fb      	ldr	r3, [r7, #12]
 8019f9a:	7a1b      	ldrb	r3, [r3, #8]
             (hmsc->bot_state != USBD_BOT_DATA_OUT) &&
 8019f9c:	2b03      	cmp	r3, #3
 8019f9e:	d015      	beq.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
      if (hmsc->bot_data_length > 0)
 8019fa0:	68fb      	ldr	r3, [r7, #12]
 8019fa2:	895b      	ldrh	r3, [r3, #10]
 8019fa4:	2b00      	cmp	r3, #0
 8019fa6:	d009      	beq.n	8019fbc <MSC_BOT_CBW_Decode+0x110>
                         hmsc->bot_data, 
 8019fa8:	68fb      	ldr	r3, [r7, #12]
 8019faa:	f103 010c 	add.w	r1, r3, #12
        MSC_BOT_SendData(pdev,
 8019fae:	68fb      	ldr	r3, [r7, #12]
 8019fb0:	895b      	ldrh	r3, [r3, #10]
 8019fb2:	461a      	mov	r2, r3
 8019fb4:	6878      	ldr	r0, [r7, #4]
 8019fb6:	f000 f80f 	bl	8019fd8 <MSC_BOT_SendData>
}
 8019fba:	e007      	b.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
      else if (hmsc->bot_data_length == 0) 
 8019fbc:	68fb      	ldr	r3, [r7, #12]
 8019fbe:	895b      	ldrh	r3, [r3, #10]
 8019fc0:	2b00      	cmp	r3, #0
 8019fc2:	d103      	bne.n	8019fcc <MSC_BOT_CBW_Decode+0x120>
        MSC_BOT_SendCSW (pdev,
 8019fc4:	2100      	movs	r1, #0
 8019fc6:	6878      	ldr	r0, [r7, #4]
 8019fc8:	f000 f83a 	bl	801a040 <MSC_BOT_SendCSW>
}
 8019fcc:	bf00      	nop
 8019fce:	3710      	adds	r7, #16
 8019fd0:	46bd      	mov	sp, r7
 8019fd2:	bd80      	pop	{r7, pc}
 8019fd4:	43425355 	.word	0x43425355

08019fd8 <MSC_BOT_SendData>:
* @retval None
*/
static void  MSC_BOT_SendData(USBD_HandleTypeDef  *pdev,
                              uint8_t* buf, 
                              uint16_t len)
{
 8019fd8:	b580      	push	{r7, lr}
 8019fda:	b086      	sub	sp, #24
 8019fdc:	af00      	add	r7, sp, #0
 8019fde:	60f8      	str	r0, [r7, #12]
 8019fe0:	60b9      	str	r1, [r7, #8]
 8019fe2:	4613      	mov	r3, r2
 8019fe4:	80fb      	strh	r3, [r7, #6]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 8019fe6:	68fb      	ldr	r3, [r7, #12]
 8019fe8:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 8019fec:	617b      	str	r3, [r7, #20]
  
  len = MIN (hmsc->cbw.dDataLength, len);
 8019fee:	88fa      	ldrh	r2, [r7, #6]
 8019ff0:	697b      	ldr	r3, [r7, #20]
 8019ff2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 8019ff6:	3314      	adds	r3, #20
 8019ff8:	681b      	ldr	r3, [r3, #0]
 8019ffa:	4293      	cmp	r3, r2
 8019ffc:	bf28      	it	cs
 8019ffe:	4613      	movcs	r3, r2
 801a000:	80fb      	strh	r3, [r7, #6]
  hmsc->csw.dDataResidue -= len;
 801a002:	697b      	ldr	r3, [r7, #20]
 801a004:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a008:	3334      	adds	r3, #52	; 0x34
 801a00a:	681a      	ldr	r2, [r3, #0]
 801a00c:	88fb      	ldrh	r3, [r7, #6]
 801a00e:	1ad2      	subs	r2, r2, r3
 801a010:	697b      	ldr	r3, [r7, #20]
 801a012:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a016:	3334      	adds	r3, #52	; 0x34
 801a018:	601a      	str	r2, [r3, #0]
  hmsc->csw.bStatus = USBD_CSW_CMD_PASSED;
 801a01a:	697b      	ldr	r3, [r7, #20]
 801a01c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a020:	3338      	adds	r3, #56	; 0x38
 801a022:	2200      	movs	r2, #0
 801a024:	701a      	strb	r2, [r3, #0]
  hmsc->bot_state = USBD_BOT_SEND_DATA;
 801a026:	697b      	ldr	r3, [r7, #20]
 801a028:	2204      	movs	r2, #4
 801a02a:	721a      	strb	r2, [r3, #8]
  
  USBD_LL_Transmit (pdev, MSC_EPIN_ADDR, buf, len);  
 801a02c:	88fb      	ldrh	r3, [r7, #6]
 801a02e:	68ba      	ldr	r2, [r7, #8]
 801a030:	2181      	movs	r1, #129	; 0x81
 801a032:	68f8      	ldr	r0, [r7, #12]
 801a034:	f7f7 f87e 	bl	8011134 <USBD_LL_Transmit>
}
 801a038:	bf00      	nop
 801a03a:	3718      	adds	r7, #24
 801a03c:	46bd      	mov	sp, r7
 801a03e:	bd80      	pop	{r7, pc}

0801a040 <MSC_BOT_SendCSW>:
* @param  status : CSW status
* @retval None
*/
void  MSC_BOT_SendCSW (USBD_HandleTypeDef  *pdev,
                              uint8_t CSW_Status)
{
 801a040:	b580      	push	{r7, lr}
 801a042:	b084      	sub	sp, #16
 801a044:	af00      	add	r7, sp, #0
 801a046:	6078      	str	r0, [r7, #4]
 801a048:	460b      	mov	r3, r1
 801a04a:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a04c:	687b      	ldr	r3, [r7, #4]
 801a04e:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a052:	60fb      	str	r3, [r7, #12]
  
  hmsc->csw.dSignature = USBD_BOT_CSW_SIGNATURE;
 801a054:	68fb      	ldr	r3, [r7, #12]
 801a056:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a05a:	332c      	adds	r3, #44	; 0x2c
 801a05c:	4a10      	ldr	r2, [pc, #64]	; (801a0a0 <MSC_BOT_SendCSW+0x60>)
 801a05e:	601a      	str	r2, [r3, #0]
  hmsc->csw.bStatus = CSW_Status;
 801a060:	68fb      	ldr	r3, [r7, #12]
 801a062:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a066:	3338      	adds	r3, #56	; 0x38
 801a068:	78fa      	ldrb	r2, [r7, #3]
 801a06a:	701a      	strb	r2, [r3, #0]
  hmsc->bot_state = USBD_BOT_IDLE;
 801a06c:	68fb      	ldr	r3, [r7, #12]
 801a06e:	2200      	movs	r2, #0
 801a070:	721a      	strb	r2, [r3, #8]
  
  USBD_LL_Transmit (pdev, 
             MSC_EPIN_ADDR, 
             (uint8_t *)&hmsc->csw, 
 801a072:	68fb      	ldr	r3, [r7, #12]
 801a074:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 801a078:	322c      	adds	r2, #44	; 0x2c
  USBD_LL_Transmit (pdev, 
 801a07a:	230d      	movs	r3, #13
 801a07c:	2181      	movs	r1, #129	; 0x81
 801a07e:	6878      	ldr	r0, [r7, #4]
 801a080:	f7f7 f858 	bl	8011134 <USBD_LL_Transmit>
             USBD_BOT_CSW_LENGTH);
  
  /* Prepare EP to Receive next Cmd */
  USBD_LL_PrepareReceive (pdev,
                    MSC_EPOUT_ADDR,
                    (uint8_t *)&hmsc->cbw, 
 801a084:	68fb      	ldr	r3, [r7, #12]
 801a086:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 801a08a:	320c      	adds	r2, #12
  USBD_LL_PrepareReceive (pdev,
 801a08c:	231f      	movs	r3, #31
 801a08e:	2101      	movs	r1, #1
 801a090:	6878      	ldr	r0, [r7, #4]
 801a092:	f7f7 f866 	bl	8011162 <USBD_LL_PrepareReceive>
                    USBD_BOT_CBW_LENGTH);  
  
}
 801a096:	bf00      	nop
 801a098:	3710      	adds	r7, #16
 801a09a:	46bd      	mov	sp, r7
 801a09c:	bd80      	pop	{r7, pc}
 801a09e:	bf00      	nop
 801a0a0:	53425355 	.word	0x53425355

0801a0a4 <MSC_BOT_Abort>:
* @param  pdev: device instance
* @retval status
*/

static void  MSC_BOT_Abort (USBD_HandleTypeDef  *pdev)
{
 801a0a4:	b580      	push	{r7, lr}
 801a0a6:	b084      	sub	sp, #16
 801a0a8:	af00      	add	r7, sp, #0
 801a0aa:	6078      	str	r0, [r7, #4]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a0ac:	687b      	ldr	r3, [r7, #4]
 801a0ae:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a0b2:	60fb      	str	r3, [r7, #12]
  
  if ((hmsc->cbw.bmFlags == 0) && 
 801a0b4:	68fb      	ldr	r3, [r7, #12]
 801a0b6:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a0ba:	3318      	adds	r3, #24
 801a0bc:	781b      	ldrb	r3, [r3, #0]
 801a0be:	2b00      	cmp	r3, #0
 801a0c0:	d10e      	bne.n	801a0e0 <MSC_BOT_Abort+0x3c>
      (hmsc->cbw.dDataLength != 0) &&
 801a0c2:	68fb      	ldr	r3, [r7, #12]
 801a0c4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a0c8:	3314      	adds	r3, #20
 801a0ca:	681b      	ldr	r3, [r3, #0]
  if ((hmsc->cbw.bmFlags == 0) && 
 801a0cc:	2b00      	cmp	r3, #0
 801a0ce:	d007      	beq.n	801a0e0 <MSC_BOT_Abort+0x3c>
      (hmsc->bot_status == USBD_BOT_STATUS_NORMAL) )
 801a0d0:	68fb      	ldr	r3, [r7, #12]
 801a0d2:	7a5b      	ldrb	r3, [r3, #9]
      (hmsc->cbw.dDataLength != 0) &&
 801a0d4:	2b00      	cmp	r3, #0
 801a0d6:	d103      	bne.n	801a0e0 <MSC_BOT_Abort+0x3c>
  {
    USBD_LL_StallEP(pdev, MSC_EPOUT_ADDR );
 801a0d8:	2101      	movs	r1, #1
 801a0da:	6878      	ldr	r0, [r7, #4]
 801a0dc:	f7f6 ffc5 	bl	801106a <USBD_LL_StallEP>
  }
  USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 801a0e0:	2181      	movs	r1, #129	; 0x81
 801a0e2:	6878      	ldr	r0, [r7, #4]
 801a0e4:	f7f6 ffc1 	bl	801106a <USBD_LL_StallEP>
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR)
 801a0e8:	68fb      	ldr	r3, [r7, #12]
 801a0ea:	7a5b      	ldrb	r3, [r3, #9]
 801a0ec:	2b02      	cmp	r3, #2
 801a0ee:	d108      	bne.n	801a102 <MSC_BOT_Abort+0x5e>
  {
    USBD_LL_PrepareReceive (pdev,
                      MSC_EPOUT_ADDR,
                      (uint8_t *)&hmsc->cbw, 
 801a0f0:	68fb      	ldr	r3, [r7, #12]
 801a0f2:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 801a0f6:	320c      	adds	r2, #12
    USBD_LL_PrepareReceive (pdev,
 801a0f8:	231f      	movs	r3, #31
 801a0fa:	2101      	movs	r1, #1
 801a0fc:	6878      	ldr	r0, [r7, #4]
 801a0fe:	f7f7 f830 	bl	8011162 <USBD_LL_PrepareReceive>
                      USBD_BOT_CBW_LENGTH);    
  }
}
 801a102:	bf00      	nop
 801a104:	3710      	adds	r7, #16
 801a106:	46bd      	mov	sp, r7
 801a108:	bd80      	pop	{r7, pc}

0801a10a <MSC_BOT_CplClrFeature>:
* @param  epnum: endpoint index
* @retval None
*/

void  MSC_BOT_CplClrFeature (USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
 801a10a:	b580      	push	{r7, lr}
 801a10c:	b084      	sub	sp, #16
 801a10e:	af00      	add	r7, sp, #0
 801a110:	6078      	str	r0, [r7, #4]
 801a112:	460b      	mov	r3, r1
 801a114:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a116:	687b      	ldr	r3, [r7, #4]
 801a118:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a11c:	60fb      	str	r3, [r7, #12]
  
  if(hmsc->bot_status == USBD_BOT_STATUS_ERROR )/* Bad CBW Signature */
 801a11e:	68fb      	ldr	r3, [r7, #12]
 801a120:	7a5b      	ldrb	r3, [r3, #9]
 801a122:	2b02      	cmp	r3, #2
 801a124:	d107      	bne.n	801a136 <MSC_BOT_CplClrFeature+0x2c>
  {
    USBD_LL_StallEP(pdev, MSC_EPIN_ADDR);
 801a126:	2181      	movs	r1, #129	; 0x81
 801a128:	6878      	ldr	r0, [r7, #4]
 801a12a:	f7f6 ff9e 	bl	801106a <USBD_LL_StallEP>
    hmsc->bot_status = USBD_BOT_STATUS_NORMAL;    
 801a12e:	68fb      	ldr	r3, [r7, #12]
 801a130:	2200      	movs	r2, #0
 801a132:	725a      	strb	r2, [r3, #9]
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
  }
  
}
 801a134:	e00b      	b.n	801a14e <MSC_BOT_CplClrFeature+0x44>
  else if(((epnum & 0x80) == 0x80) && ( hmsc->bot_status != USBD_BOT_STATUS_RECOVERY))
 801a136:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801a13a:	2b00      	cmp	r3, #0
 801a13c:	da07      	bge.n	801a14e <MSC_BOT_CplClrFeature+0x44>
 801a13e:	68fb      	ldr	r3, [r7, #12]
 801a140:	7a5b      	ldrb	r3, [r3, #9]
 801a142:	2b01      	cmp	r3, #1
 801a144:	d003      	beq.n	801a14e <MSC_BOT_CplClrFeature+0x44>
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED);
 801a146:	2101      	movs	r1, #1
 801a148:	6878      	ldr	r0, [r7, #4]
 801a14a:	f7ff ff79 	bl	801a040 <MSC_BOT_SendCSW>
}
 801a14e:	bf00      	nop
 801a150:	3710      	adds	r7, #16
 801a152:	46bd      	mov	sp, r7
 801a154:	bd80      	pop	{r7, pc}
	...

0801a158 <SCSI_ProcessCmd>:
* @retval status
*/
int8_t SCSI_ProcessCmd(USBD_HandleTypeDef  *pdev,
                           uint8_t lun, 
                           uint8_t *params)
{
 801a158:	b580      	push	{r7, lr}
 801a15a:	b084      	sub	sp, #16
 801a15c:	af00      	add	r7, sp, #0
 801a15e:	60f8      	str	r0, [r7, #12]
 801a160:	460b      	mov	r3, r1
 801a162:	607a      	str	r2, [r7, #4]
 801a164:	72fb      	strb	r3, [r7, #11]
  
  switch (params[0])
 801a166:	687b      	ldr	r3, [r7, #4]
 801a168:	781b      	ldrb	r3, [r3, #0]
 801a16a:	2b5a      	cmp	r3, #90	; 0x5a
 801a16c:	f200 811a 	bhi.w	801a3a4 <SCSI_ProcessCmd+0x24c>
 801a170:	a201      	add	r2, pc, #4	; (adr r2, 801a178 <SCSI_ProcessCmd+0x20>)
 801a172:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a176:	bf00      	nop
 801a178:	0801a2e5 	.word	0x0801a2e5
 801a17c:	0801a3a5 	.word	0x0801a3a5
 801a180:	0801a3a5 	.word	0x0801a3a5
 801a184:	0801a2f5 	.word	0x0801a2f5
 801a188:	0801a3a5 	.word	0x0801a3a5
 801a18c:	0801a3a5 	.word	0x0801a3a5
 801a190:	0801a3a5 	.word	0x0801a3a5
 801a194:	0801a3a5 	.word	0x0801a3a5
 801a198:	0801a3a5 	.word	0x0801a3a5
 801a19c:	0801a3a5 	.word	0x0801a3a5
 801a1a0:	0801a3a5 	.word	0x0801a3a5
 801a1a4:	0801a3a5 	.word	0x0801a3a5
 801a1a8:	0801a3a5 	.word	0x0801a3a5
 801a1ac:	0801a3a5 	.word	0x0801a3a5
 801a1b0:	0801a3a5 	.word	0x0801a3a5
 801a1b4:	0801a3a5 	.word	0x0801a3a5
 801a1b8:	0801a3a5 	.word	0x0801a3a5
 801a1bc:	0801a3a5 	.word	0x0801a3a5
 801a1c0:	0801a305 	.word	0x0801a305
 801a1c4:	0801a3a5 	.word	0x0801a3a5
 801a1c8:	0801a3a5 	.word	0x0801a3a5
 801a1cc:	0801a3a5 	.word	0x0801a3a5
 801a1d0:	0801a3a5 	.word	0x0801a3a5
 801a1d4:	0801a3a5 	.word	0x0801a3a5
 801a1d8:	0801a3a5 	.word	0x0801a3a5
 801a1dc:	0801a3a5 	.word	0x0801a3a5
 801a1e0:	0801a335 	.word	0x0801a335
 801a1e4:	0801a315 	.word	0x0801a315
 801a1e8:	0801a3a5 	.word	0x0801a3a5
 801a1ec:	0801a3a5 	.word	0x0801a3a5
 801a1f0:	0801a325 	.word	0x0801a325
 801a1f4:	0801a3a5 	.word	0x0801a3a5
 801a1f8:	0801a3a5 	.word	0x0801a3a5
 801a1fc:	0801a3a5 	.word	0x0801a3a5
 801a200:	0801a3a5 	.word	0x0801a3a5
 801a204:	0801a355 	.word	0x0801a355
 801a208:	0801a3a5 	.word	0x0801a3a5
 801a20c:	0801a365 	.word	0x0801a365
 801a210:	0801a3a5 	.word	0x0801a3a5
 801a214:	0801a3a5 	.word	0x0801a3a5
 801a218:	0801a375 	.word	0x0801a375
 801a21c:	0801a3a5 	.word	0x0801a3a5
 801a220:	0801a385 	.word	0x0801a385
 801a224:	0801a3a5 	.word	0x0801a3a5
 801a228:	0801a3a5 	.word	0x0801a3a5
 801a22c:	0801a3a5 	.word	0x0801a3a5
 801a230:	0801a3a5 	.word	0x0801a3a5
 801a234:	0801a395 	.word	0x0801a395
 801a238:	0801a3a5 	.word	0x0801a3a5
 801a23c:	0801a3a5 	.word	0x0801a3a5
 801a240:	0801a3a5 	.word	0x0801a3a5
 801a244:	0801a3a5 	.word	0x0801a3a5
 801a248:	0801a3a5 	.word	0x0801a3a5
 801a24c:	0801a3a5 	.word	0x0801a3a5
 801a250:	0801a3a5 	.word	0x0801a3a5
 801a254:	0801a3a5 	.word	0x0801a3a5
 801a258:	0801a3a5 	.word	0x0801a3a5
 801a25c:	0801a3a5 	.word	0x0801a3a5
 801a260:	0801a3a5 	.word	0x0801a3a5
 801a264:	0801a3a5 	.word	0x0801a3a5
 801a268:	0801a3a5 	.word	0x0801a3a5
 801a26c:	0801a3a5 	.word	0x0801a3a5
 801a270:	0801a3a5 	.word	0x0801a3a5
 801a274:	0801a3a5 	.word	0x0801a3a5
 801a278:	0801a3a5 	.word	0x0801a3a5
 801a27c:	0801a3a5 	.word	0x0801a3a5
 801a280:	0801a3a5 	.word	0x0801a3a5
 801a284:	0801a3a5 	.word	0x0801a3a5
 801a288:	0801a3a5 	.word	0x0801a3a5
 801a28c:	0801a3a5 	.word	0x0801a3a5
 801a290:	0801a3a5 	.word	0x0801a3a5
 801a294:	0801a3a5 	.word	0x0801a3a5
 801a298:	0801a3a5 	.word	0x0801a3a5
 801a29c:	0801a3a5 	.word	0x0801a3a5
 801a2a0:	0801a3a5 	.word	0x0801a3a5
 801a2a4:	0801a3a5 	.word	0x0801a3a5
 801a2a8:	0801a3a5 	.word	0x0801a3a5
 801a2ac:	0801a3a5 	.word	0x0801a3a5
 801a2b0:	0801a3a5 	.word	0x0801a3a5
 801a2b4:	0801a3a5 	.word	0x0801a3a5
 801a2b8:	0801a3a5 	.word	0x0801a3a5
 801a2bc:	0801a3a5 	.word	0x0801a3a5
 801a2c0:	0801a3a5 	.word	0x0801a3a5
 801a2c4:	0801a3a5 	.word	0x0801a3a5
 801a2c8:	0801a3a5 	.word	0x0801a3a5
 801a2cc:	0801a3a5 	.word	0x0801a3a5
 801a2d0:	0801a3a5 	.word	0x0801a3a5
 801a2d4:	0801a3a5 	.word	0x0801a3a5
 801a2d8:	0801a3a5 	.word	0x0801a3a5
 801a2dc:	0801a3a5 	.word	0x0801a3a5
 801a2e0:	0801a345 	.word	0x0801a345
  {
  case SCSI_TEST_UNIT_READY:
    return SCSI_TestUnitReady(pdev, lun, params);
 801a2e4:	7afb      	ldrb	r3, [r7, #11]
 801a2e6:	687a      	ldr	r2, [r7, #4]
 801a2e8:	4619      	mov	r1, r3
 801a2ea:	68f8      	ldr	r0, [r7, #12]
 801a2ec:	f000 f866 	bl	801a3bc <SCSI_TestUnitReady>
 801a2f0:	4603      	mov	r3, r0
 801a2f2:	e05f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_REQUEST_SENSE:
    return SCSI_RequestSense (pdev, lun, params);
 801a2f4:	7afb      	ldrb	r3, [r7, #11]
 801a2f6:	687a      	ldr	r2, [r7, #4]
 801a2f8:	4619      	mov	r1, r3
 801a2fa:	68f8      	ldr	r0, [r7, #12]
 801a2fc:	f000 fa1a 	bl	801a734 <SCSI_RequestSense>
 801a300:	4603      	mov	r3, r0
 801a302:	e057      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
  case SCSI_INQUIRY:
    return SCSI_Inquiry(pdev, lun, params);
 801a304:	7afb      	ldrb	r3, [r7, #11]
 801a306:	687a      	ldr	r2, [r7, #4]
 801a308:	4619      	mov	r1, r3
 801a30a:	68f8      	ldr	r0, [r7, #12]
 801a30c:	f000 f894 	bl	801a438 <SCSI_Inquiry>
 801a310:	4603      	mov	r3, r0
 801a312:	e04f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_START_STOP_UNIT:
    return SCSI_StartStopUnit(pdev, lun, params);
 801a314:	7afb      	ldrb	r3, [r7, #11]
 801a316:	687a      	ldr	r2, [r7, #4]
 801a318:	4619      	mov	r1, r3
 801a31a:	68f8      	ldr	r0, [r7, #12]
 801a31c:	f000 fad4 	bl	801a8c8 <SCSI_StartStopUnit>
 801a320:	4603      	mov	r3, r0
 801a322:	e047      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_ALLOW_MEDIUM_REMOVAL:
    return SCSI_StartStopUnit(pdev, lun, params);
 801a324:	7afb      	ldrb	r3, [r7, #11]
 801a326:	687a      	ldr	r2, [r7, #4]
 801a328:	4619      	mov	r1, r3
 801a32a:	68f8      	ldr	r0, [r7, #12]
 801a32c:	f000 facc 	bl	801a8c8 <SCSI_StartStopUnit>
 801a330:	4603      	mov	r3, r0
 801a332:	e03f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_MODE_SENSE6:
    return SCSI_ModeSense6 (pdev, lun, params);
 801a334:	7afb      	ldrb	r3, [r7, #11]
 801a336:	687a      	ldr	r2, [r7, #4]
 801a338:	4619      	mov	r1, r3
 801a33a:	68f8      	ldr	r0, [r7, #12]
 801a33c:	f000 f9aa 	bl	801a694 <SCSI_ModeSense6>
 801a340:	4603      	mov	r3, r0
 801a342:	e037      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_MODE_SENSE10:
    return SCSI_ModeSense10 (pdev, lun, params);
 801a344:	7afb      	ldrb	r3, [r7, #11]
 801a346:	687a      	ldr	r2, [r7, #4]
 801a348:	4619      	mov	r1, r3
 801a34a:	68f8      	ldr	r0, [r7, #12]
 801a34c:	f000 f9ca 	bl	801a6e4 <SCSI_ModeSense10>
 801a350:	4603      	mov	r3, r0
 801a352:	e02f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_READ_FORMAT_CAPACITIES:
    return SCSI_ReadFormatCapacity(pdev, lun, params);
 801a354:	7afb      	ldrb	r3, [r7, #11]
 801a356:	687a      	ldr	r2, [r7, #4]
 801a358:	4619      	mov	r1, r3
 801a35a:	68f8      	ldr	r0, [r7, #12]
 801a35c:	f000 f936 	bl	801a5cc <SCSI_ReadFormatCapacity>
 801a360:	4603      	mov	r3, r0
 801a362:	e027      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_READ_CAPACITY10:
    return SCSI_ReadCapacity10(pdev, lun, params);
 801a364:	7afb      	ldrb	r3, [r7, #11]
 801a366:	687a      	ldr	r2, [r7, #4]
 801a368:	4619      	mov	r1, r3
 801a36a:	68f8      	ldr	r0, [r7, #12]
 801a36c:	f000 f8b4 	bl	801a4d8 <SCSI_ReadCapacity10>
 801a370:	4603      	mov	r3, r0
 801a372:	e01f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_READ10:
    return SCSI_Read10(pdev, lun, params); 
 801a374:	7afb      	ldrb	r3, [r7, #11]
 801a376:	687a      	ldr	r2, [r7, #4]
 801a378:	4619      	mov	r1, r3
 801a37a:	68f8      	ldr	r0, [r7, #12]
 801a37c:	f000 fab9 	bl	801a8f2 <SCSI_Read10>
 801a380:	4603      	mov	r3, r0
 801a382:	e017      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_WRITE10:
    return SCSI_Write10(pdev, lun, params);
 801a384:	7afb      	ldrb	r3, [r7, #11]
 801a386:	687a      	ldr	r2, [r7, #4]
 801a388:	4619      	mov	r1, r3
 801a38a:	68f8      	ldr	r0, [r7, #12]
 801a38c:	f000 fb70 	bl	801aa70 <SCSI_Write10>
 801a390:	4603      	mov	r3, r0
 801a392:	e00f      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  case SCSI_VERIFY10:
    return SCSI_Verify10(pdev, lun, params);
 801a394:	7afb      	ldrb	r3, [r7, #11]
 801a396:	687a      	ldr	r2, [r7, #4]
 801a398:	4619      	mov	r1, r3
 801a39a:	68f8      	ldr	r0, [r7, #12]
 801a39c:	f000 fc4a 	bl	801ac34 <SCSI_Verify10>
 801a3a0:	4603      	mov	r3, r0
 801a3a2:	e007      	b.n	801a3b4 <SCSI_ProcessCmd+0x25c>
    
  default:
    SCSI_SenseCode(pdev, 
 801a3a4:	7af9      	ldrb	r1, [r7, #11]
 801a3a6:	2320      	movs	r3, #32
 801a3a8:	2205      	movs	r2, #5
 801a3aa:	68f8      	ldr	r0, [r7, #12]
 801a3ac:	f000 fa42 	bl	801a834 <SCSI_SenseCode>
                   lun,
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);    
    return -1;
 801a3b0:	f04f 33ff 	mov.w	r3, #4294967295
  }
}
 801a3b4:	4618      	mov	r0, r3
 801a3b6:	3710      	adds	r7, #16
 801a3b8:	46bd      	mov	sp, r7
 801a3ba:	bd80      	pop	{r7, pc}

0801a3bc <SCSI_TestUnitReady>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_TestUnitReady(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a3bc:	b580      	push	{r7, lr}
 801a3be:	b086      	sub	sp, #24
 801a3c0:	af00      	add	r7, sp, #0
 801a3c2:	60f8      	str	r0, [r7, #12]
 801a3c4:	460b      	mov	r3, r1
 801a3c6:	607a      	str	r2, [r7, #4]
 801a3c8:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;  
 801a3ca:	68fb      	ldr	r3, [r7, #12]
 801a3cc:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a3d0:	617b      	str	r3, [r7, #20]
    
  /* case 9 : Hi > D0 */
  if (hmsc->cbw.dDataLength != 0)
 801a3d2:	697b      	ldr	r3, [r7, #20]
 801a3d4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a3d8:	3314      	adds	r3, #20
 801a3da:	681b      	ldr	r3, [r3, #0]
 801a3dc:	2b00      	cmp	r3, #0
 801a3de:	d00c      	beq.n	801a3fa <SCSI_TestUnitReady+0x3e>
  {
    SCSI_SenseCode(pdev,
 801a3e0:	697b      	ldr	r3, [r7, #20]
 801a3e2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a3e6:	3319      	adds	r3, #25
 801a3e8:	7819      	ldrb	r1, [r3, #0]
 801a3ea:	2320      	movs	r3, #32
 801a3ec:	2205      	movs	r2, #5
 801a3ee:	68f8      	ldr	r0, [r7, #12]
 801a3f0:	f000 fa20 	bl	801a834 <SCSI_SenseCode>
                   hmsc->cbw.bLUN, 
                   ILLEGAL_REQUEST, 
                   INVALID_CDB);
    return -1;
 801a3f4:	f04f 33ff 	mov.w	r3, #4294967295
 801a3f8:	e019      	b.n	801a42e <SCSI_TestUnitReady+0x72>
  }  
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 801a3fa:	68fb      	ldr	r3, [r7, #12]
 801a3fc:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801a400:	689b      	ldr	r3, [r3, #8]
 801a402:	7afa      	ldrb	r2, [r7, #11]
 801a404:	4610      	mov	r0, r2
 801a406:	4798      	blx	r3
 801a408:	4603      	mov	r3, r0
 801a40a:	2b00      	cmp	r3, #0
 801a40c:	d00b      	beq.n	801a426 <SCSI_TestUnitReady+0x6a>
  {
    SCSI_SenseCode(pdev,
 801a40e:	7af9      	ldrb	r1, [r7, #11]
 801a410:	233a      	movs	r3, #58	; 0x3a
 801a412:	2202      	movs	r2, #2
 801a414:	68f8      	ldr	r0, [r7, #12]
 801a416:	f000 fa0d 	bl	801a834 <SCSI_SenseCode>
                   lun,
                   NOT_READY, 
                   MEDIUM_NOT_PRESENT);
    
    hmsc->bot_state = USBD_BOT_NO_DATA;
 801a41a:	697b      	ldr	r3, [r7, #20]
 801a41c:	2205      	movs	r2, #5
 801a41e:	721a      	strb	r2, [r3, #8]
    return -1;
 801a420:	f04f 33ff 	mov.w	r3, #4294967295
 801a424:	e003      	b.n	801a42e <SCSI_TestUnitReady+0x72>
  } 
  hmsc->bot_data_length = 0;
 801a426:	697b      	ldr	r3, [r7, #20]
 801a428:	2200      	movs	r2, #0
 801a42a:	815a      	strh	r2, [r3, #10]
  return 0;
 801a42c:	2300      	movs	r3, #0
}
 801a42e:	4618      	mov	r0, r3
 801a430:	3718      	adds	r7, #24
 801a432:	46bd      	mov	sp, r7
 801a434:	bd80      	pop	{r7, pc}
	...

0801a438 <SCSI_Inquiry>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t  SCSI_Inquiry(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a438:	b480      	push	{r7}
 801a43a:	b089      	sub	sp, #36	; 0x24
 801a43c:	af00      	add	r7, sp, #0
 801a43e:	60f8      	str	r0, [r7, #12]
 801a440:	460b      	mov	r3, r1
 801a442:	607a      	str	r2, [r7, #4]
 801a444:	72fb      	strb	r3, [r7, #11]
  uint8_t* pPage;
  uint16_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a446:	68fb      	ldr	r3, [r7, #12]
 801a448:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a44c:	617b      	str	r3, [r7, #20]
  
  if (params[1] & 0x01)/*Evpd is set*/
 801a44e:	687b      	ldr	r3, [r7, #4]
 801a450:	3301      	adds	r3, #1
 801a452:	781b      	ldrb	r3, [r3, #0]
 801a454:	f003 0301 	and.w	r3, r3, #1
 801a458:	2b00      	cmp	r3, #0
 801a45a:	d004      	beq.n	801a466 <SCSI_Inquiry+0x2e>
  {
    pPage = (uint8_t *)MSC_Page00_Inquiry_Data;
 801a45c:	4b1d      	ldr	r3, [pc, #116]	; (801a4d4 <SCSI_Inquiry+0x9c>)
 801a45e:	61fb      	str	r3, [r7, #28]
    len = LENGTH_INQUIRY_PAGE00;
 801a460:	2307      	movs	r3, #7
 801a462:	837b      	strh	r3, [r7, #26]
 801a464:	e01b      	b.n	801a49e <SCSI_Inquiry+0x66>
  }
  else
  {
    
    pPage = (uint8_t *)&((USBD_StorageTypeDef *)pdev->pUserData)->pInquiry[lun * STANDARD_INQUIRY_DATA_LEN];
 801a466:	68fb      	ldr	r3, [r7, #12]
 801a468:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801a46c:	69d9      	ldr	r1, [r3, #28]
 801a46e:	7afa      	ldrb	r2, [r7, #11]
 801a470:	4613      	mov	r3, r2
 801a472:	00db      	lsls	r3, r3, #3
 801a474:	4413      	add	r3, r2
 801a476:	009b      	lsls	r3, r3, #2
 801a478:	440b      	add	r3, r1
 801a47a:	61fb      	str	r3, [r7, #28]
    len = pPage[4] + 5;
 801a47c:	69fb      	ldr	r3, [r7, #28]
 801a47e:	3304      	adds	r3, #4
 801a480:	781b      	ldrb	r3, [r3, #0]
 801a482:	b29b      	uxth	r3, r3
 801a484:	3305      	adds	r3, #5
 801a486:	837b      	strh	r3, [r7, #26]
    
    if (params[4] <= len)
 801a488:	687b      	ldr	r3, [r7, #4]
 801a48a:	3304      	adds	r3, #4
 801a48c:	781b      	ldrb	r3, [r3, #0]
 801a48e:	b29b      	uxth	r3, r3
 801a490:	8b7a      	ldrh	r2, [r7, #26]
 801a492:	429a      	cmp	r2, r3
 801a494:	d303      	bcc.n	801a49e <SCSI_Inquiry+0x66>
    {
      len = params[4];
 801a496:	687b      	ldr	r3, [r7, #4]
 801a498:	3304      	adds	r3, #4
 801a49a:	781b      	ldrb	r3, [r3, #0]
 801a49c:	837b      	strh	r3, [r7, #26]
    }
  }
  hmsc->bot_data_length = len;
 801a49e:	697b      	ldr	r3, [r7, #20]
 801a4a0:	8b7a      	ldrh	r2, [r7, #26]
 801a4a2:	815a      	strh	r2, [r3, #10]
  
  while (len) 
 801a4a4:	e00b      	b.n	801a4be <SCSI_Inquiry+0x86>
  {
    len--;
 801a4a6:	8b7b      	ldrh	r3, [r7, #26]
 801a4a8:	3b01      	subs	r3, #1
 801a4aa:	837b      	strh	r3, [r7, #26]
    hmsc->bot_data[len] = pPage[len];
 801a4ac:	8b7b      	ldrh	r3, [r7, #26]
 801a4ae:	69fa      	ldr	r2, [r7, #28]
 801a4b0:	441a      	add	r2, r3
 801a4b2:	8b7b      	ldrh	r3, [r7, #26]
 801a4b4:	7811      	ldrb	r1, [r2, #0]
 801a4b6:	697a      	ldr	r2, [r7, #20]
 801a4b8:	4413      	add	r3, r2
 801a4ba:	460a      	mov	r2, r1
 801a4bc:	731a      	strb	r2, [r3, #12]
  while (len) 
 801a4be:	8b7b      	ldrh	r3, [r7, #26]
 801a4c0:	2b00      	cmp	r3, #0
 801a4c2:	d1f0      	bne.n	801a4a6 <SCSI_Inquiry+0x6e>
  }
  return 0;
 801a4c4:	2300      	movs	r3, #0
}
 801a4c6:	4618      	mov	r0, r3
 801a4c8:	3724      	adds	r7, #36	; 0x24
 801a4ca:	46bd      	mov	sp, r7
 801a4cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a4d0:	4770      	bx	lr
 801a4d2:	bf00      	nop
 801a4d4:	0801e1fc 	.word	0x0801e1fc

0801a4d8 <SCSI_ReadCapacity10>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadCapacity10(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a4d8:	b590      	push	{r4, r7, lr}
 801a4da:	b087      	sub	sp, #28
 801a4dc:	af00      	add	r7, sp, #0
 801a4de:	60f8      	str	r0, [r7, #12]
 801a4e0:	460b      	mov	r3, r1
 801a4e2:	607a      	str	r2, [r7, #4]
 801a4e4:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a4e6:	68fb      	ldr	r3, [r7, #12]
 801a4e8:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a4ec:	617b      	str	r3, [r7, #20]
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &hmsc->scsi_blk_nbr, &hmsc->scsi_blk_size) != 0)
 801a4ee:	68fb      	ldr	r3, [r7, #12]
 801a4f0:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801a4f4:	685c      	ldr	r4, [r3, #4]
 801a4f6:	697b      	ldr	r3, [r7, #20]
 801a4f8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a4fc:	3360      	adds	r3, #96	; 0x60
 801a4fe:	697a      	ldr	r2, [r7, #20]
 801a500:	f502 4280 	add.w	r2, r2, #16384	; 0x4000
 801a504:	325e      	adds	r2, #94	; 0x5e
 801a506:	7af8      	ldrb	r0, [r7, #11]
 801a508:	4619      	mov	r1, r3
 801a50a:	47a0      	blx	r4
 801a50c:	4603      	mov	r3, r0
 801a50e:	2b00      	cmp	r3, #0
 801a510:	d008      	beq.n	801a524 <SCSI_ReadCapacity10+0x4c>
  {
    SCSI_SenseCode(pdev,
 801a512:	7af9      	ldrb	r1, [r7, #11]
 801a514:	233a      	movs	r3, #58	; 0x3a
 801a516:	2202      	movs	r2, #2
 801a518:	68f8      	ldr	r0, [r7, #12]
 801a51a:	f000 f98b 	bl	801a834 <SCSI_SenseCode>
                   lun,
                   NOT_READY, 
                   MEDIUM_NOT_PRESENT);
    return -1;
 801a51e:	f04f 33ff 	mov.w	r3, #4294967295
 801a522:	e04f      	b.n	801a5c4 <SCSI_ReadCapacity10+0xec>
  } 
  else
  {
    
    hmsc->bot_data[0] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 24);
 801a524:	697b      	ldr	r3, [r7, #20]
 801a526:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a52a:	3360      	adds	r3, #96	; 0x60
 801a52c:	681b      	ldr	r3, [r3, #0]
 801a52e:	3b01      	subs	r3, #1
 801a530:	0e1b      	lsrs	r3, r3, #24
 801a532:	b2da      	uxtb	r2, r3
 801a534:	697b      	ldr	r3, [r7, #20]
 801a536:	731a      	strb	r2, [r3, #12]
    hmsc->bot_data[1] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >> 16);
 801a538:	697b      	ldr	r3, [r7, #20]
 801a53a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a53e:	3360      	adds	r3, #96	; 0x60
 801a540:	681b      	ldr	r3, [r3, #0]
 801a542:	3b01      	subs	r3, #1
 801a544:	0c1b      	lsrs	r3, r3, #16
 801a546:	b2da      	uxtb	r2, r3
 801a548:	697b      	ldr	r3, [r7, #20]
 801a54a:	735a      	strb	r2, [r3, #13]
    hmsc->bot_data[2] = (uint8_t)((hmsc->scsi_blk_nbr - 1) >>  8);
 801a54c:	697b      	ldr	r3, [r7, #20]
 801a54e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a552:	3360      	adds	r3, #96	; 0x60
 801a554:	681b      	ldr	r3, [r3, #0]
 801a556:	3b01      	subs	r3, #1
 801a558:	0a1b      	lsrs	r3, r3, #8
 801a55a:	b2da      	uxtb	r2, r3
 801a55c:	697b      	ldr	r3, [r7, #20]
 801a55e:	739a      	strb	r2, [r3, #14]
    hmsc->bot_data[3] = (uint8_t)(hmsc->scsi_blk_nbr - 1);
 801a560:	697b      	ldr	r3, [r7, #20]
 801a562:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a566:	3360      	adds	r3, #96	; 0x60
 801a568:	681b      	ldr	r3, [r3, #0]
 801a56a:	b2db      	uxtb	r3, r3
 801a56c:	3b01      	subs	r3, #1
 801a56e:	b2da      	uxtb	r2, r3
 801a570:	697b      	ldr	r3, [r7, #20]
 801a572:	73da      	strb	r2, [r3, #15]
    
    hmsc->bot_data[4] = (uint8_t)(hmsc->scsi_blk_size >>  24);
 801a574:	697b      	ldr	r3, [r7, #20]
 801a576:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a57a:	335e      	adds	r3, #94	; 0x5e
 801a57c:	881b      	ldrh	r3, [r3, #0]
 801a57e:	161b      	asrs	r3, r3, #24
 801a580:	b2da      	uxtb	r2, r3
 801a582:	697b      	ldr	r3, [r7, #20]
 801a584:	741a      	strb	r2, [r3, #16]
    hmsc->bot_data[5] = (uint8_t)(hmsc->scsi_blk_size >>  16);
 801a586:	697b      	ldr	r3, [r7, #20]
 801a588:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a58c:	335e      	adds	r3, #94	; 0x5e
 801a58e:	881b      	ldrh	r3, [r3, #0]
 801a590:	141b      	asrs	r3, r3, #16
 801a592:	b2da      	uxtb	r2, r3
 801a594:	697b      	ldr	r3, [r7, #20]
 801a596:	745a      	strb	r2, [r3, #17]
    hmsc->bot_data[6] = (uint8_t)(hmsc->scsi_blk_size >>  8);
 801a598:	697b      	ldr	r3, [r7, #20]
 801a59a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a59e:	335e      	adds	r3, #94	; 0x5e
 801a5a0:	881b      	ldrh	r3, [r3, #0]
 801a5a2:	0a1b      	lsrs	r3, r3, #8
 801a5a4:	b29b      	uxth	r3, r3
 801a5a6:	b2da      	uxtb	r2, r3
 801a5a8:	697b      	ldr	r3, [r7, #20]
 801a5aa:	749a      	strb	r2, [r3, #18]
    hmsc->bot_data[7] = (uint8_t)(hmsc->scsi_blk_size);
 801a5ac:	697b      	ldr	r3, [r7, #20]
 801a5ae:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a5b2:	335e      	adds	r3, #94	; 0x5e
 801a5b4:	881b      	ldrh	r3, [r3, #0]
 801a5b6:	b2da      	uxtb	r2, r3
 801a5b8:	697b      	ldr	r3, [r7, #20]
 801a5ba:	74da      	strb	r2, [r3, #19]
    
    hmsc->bot_data_length = 8;
 801a5bc:	697b      	ldr	r3, [r7, #20]
 801a5be:	2208      	movs	r2, #8
 801a5c0:	815a      	strh	r2, [r3, #10]
    return 0;
 801a5c2:	2300      	movs	r3, #0
  }
}
 801a5c4:	4618      	mov	r0, r3
 801a5c6:	371c      	adds	r7, #28
 801a5c8:	46bd      	mov	sp, r7
 801a5ca:	bd90      	pop	{r4, r7, pc}

0801a5cc <SCSI_ReadFormatCapacity>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ReadFormatCapacity(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a5cc:	b580      	push	{r7, lr}
 801a5ce:	b088      	sub	sp, #32
 801a5d0:	af00      	add	r7, sp, #0
 801a5d2:	60f8      	str	r0, [r7, #12]
 801a5d4:	460b      	mov	r3, r1
 801a5d6:	607a      	str	r2, [r7, #4]
 801a5d8:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a5da:	68fb      	ldr	r3, [r7, #12]
 801a5dc:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a5e0:	61bb      	str	r3, [r7, #24]
  
  uint16_t blk_size;
  uint32_t blk_nbr;
  uint16_t i;
  
  for(i=0 ; i < 12 ; i++) 
 801a5e2:	2300      	movs	r3, #0
 801a5e4:	83fb      	strh	r3, [r7, #30]
 801a5e6:	e007      	b.n	801a5f8 <SCSI_ReadFormatCapacity+0x2c>
  {
    hmsc->bot_data[i] = 0;
 801a5e8:	8bfb      	ldrh	r3, [r7, #30]
 801a5ea:	69ba      	ldr	r2, [r7, #24]
 801a5ec:	4413      	add	r3, r2
 801a5ee:	2200      	movs	r2, #0
 801a5f0:	731a      	strb	r2, [r3, #12]
  for(i=0 ; i < 12 ; i++) 
 801a5f2:	8bfb      	ldrh	r3, [r7, #30]
 801a5f4:	3301      	adds	r3, #1
 801a5f6:	83fb      	strh	r3, [r7, #30]
 801a5f8:	8bfb      	ldrh	r3, [r7, #30]
 801a5fa:	2b0b      	cmp	r3, #11
 801a5fc:	d9f4      	bls.n	801a5e8 <SCSI_ReadFormatCapacity+0x1c>
  }
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->GetCapacity(lun, &blk_nbr, &blk_size) != 0)
 801a5fe:	68fb      	ldr	r3, [r7, #12]
 801a600:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801a604:	685b      	ldr	r3, [r3, #4]
 801a606:	f107 0216 	add.w	r2, r7, #22
 801a60a:	f107 0110 	add.w	r1, r7, #16
 801a60e:	7af8      	ldrb	r0, [r7, #11]
 801a610:	4798      	blx	r3
 801a612:	4603      	mov	r3, r0
 801a614:	2b00      	cmp	r3, #0
 801a616:	d008      	beq.n	801a62a <SCSI_ReadFormatCapacity+0x5e>
  {
    SCSI_SenseCode(pdev,
 801a618:	7af9      	ldrb	r1, [r7, #11]
 801a61a:	233a      	movs	r3, #58	; 0x3a
 801a61c:	2202      	movs	r2, #2
 801a61e:	68f8      	ldr	r0, [r7, #12]
 801a620:	f000 f908 	bl	801a834 <SCSI_SenseCode>
                   lun,
                   NOT_READY, 
                   MEDIUM_NOT_PRESENT);
    return -1;
 801a624:	f04f 33ff 	mov.w	r3, #4294967295
 801a628:	e030      	b.n	801a68c <SCSI_ReadFormatCapacity+0xc0>
  } 
  else
  {
    hmsc->bot_data[3] = 0x08;
 801a62a:	69bb      	ldr	r3, [r7, #24]
 801a62c:	2208      	movs	r2, #8
 801a62e:	73da      	strb	r2, [r3, #15]
    hmsc->bot_data[4] = (uint8_t)((blk_nbr - 1) >> 24);
 801a630:	693b      	ldr	r3, [r7, #16]
 801a632:	3b01      	subs	r3, #1
 801a634:	0e1b      	lsrs	r3, r3, #24
 801a636:	b2da      	uxtb	r2, r3
 801a638:	69bb      	ldr	r3, [r7, #24]
 801a63a:	741a      	strb	r2, [r3, #16]
    hmsc->bot_data[5] = (uint8_t)((blk_nbr - 1) >> 16);
 801a63c:	693b      	ldr	r3, [r7, #16]
 801a63e:	3b01      	subs	r3, #1
 801a640:	0c1b      	lsrs	r3, r3, #16
 801a642:	b2da      	uxtb	r2, r3
 801a644:	69bb      	ldr	r3, [r7, #24]
 801a646:	745a      	strb	r2, [r3, #17]
    hmsc->bot_data[6] = (uint8_t)((blk_nbr - 1) >>  8);
 801a648:	693b      	ldr	r3, [r7, #16]
 801a64a:	3b01      	subs	r3, #1
 801a64c:	0a1b      	lsrs	r3, r3, #8
 801a64e:	b2da      	uxtb	r2, r3
 801a650:	69bb      	ldr	r3, [r7, #24]
 801a652:	749a      	strb	r2, [r3, #18]
    hmsc->bot_data[7] = (uint8_t)(blk_nbr - 1);
 801a654:	693b      	ldr	r3, [r7, #16]
 801a656:	b2db      	uxtb	r3, r3
 801a658:	3b01      	subs	r3, #1
 801a65a:	b2da      	uxtb	r2, r3
 801a65c:	69bb      	ldr	r3, [r7, #24]
 801a65e:	74da      	strb	r2, [r3, #19]
    
    hmsc->bot_data[8] = 0x02;
 801a660:	69bb      	ldr	r3, [r7, #24]
 801a662:	2202      	movs	r2, #2
 801a664:	751a      	strb	r2, [r3, #20]
    hmsc->bot_data[9] = (uint8_t)(blk_size >>  16);
 801a666:	8afb      	ldrh	r3, [r7, #22]
 801a668:	141b      	asrs	r3, r3, #16
 801a66a:	b2da      	uxtb	r2, r3
 801a66c:	69bb      	ldr	r3, [r7, #24]
 801a66e:	755a      	strb	r2, [r3, #21]
    hmsc->bot_data[10] = (uint8_t)(blk_size >>  8);
 801a670:	8afb      	ldrh	r3, [r7, #22]
 801a672:	0a1b      	lsrs	r3, r3, #8
 801a674:	b29b      	uxth	r3, r3
 801a676:	b2da      	uxtb	r2, r3
 801a678:	69bb      	ldr	r3, [r7, #24]
 801a67a:	759a      	strb	r2, [r3, #22]
    hmsc->bot_data[11] = (uint8_t)(blk_size);
 801a67c:	8afb      	ldrh	r3, [r7, #22]
 801a67e:	b2da      	uxtb	r2, r3
 801a680:	69bb      	ldr	r3, [r7, #24]
 801a682:	75da      	strb	r2, [r3, #23]
    
    hmsc->bot_data_length = 12;
 801a684:	69bb      	ldr	r3, [r7, #24]
 801a686:	220c      	movs	r2, #12
 801a688:	815a      	strh	r2, [r3, #10]
    return 0;
 801a68a:	2300      	movs	r3, #0
  }
}
 801a68c:	4618      	mov	r0, r3
 801a68e:	3720      	adds	r7, #32
 801a690:	46bd      	mov	sp, r7
 801a692:	bd80      	pop	{r7, pc}

0801a694 <SCSI_ModeSense6>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ModeSense6 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a694:	b480      	push	{r7}
 801a696:	b087      	sub	sp, #28
 801a698:	af00      	add	r7, sp, #0
 801a69a:	60f8      	str	r0, [r7, #12]
 801a69c:	460b      	mov	r3, r1
 801a69e:	607a      	str	r2, [r7, #4]
 801a6a0:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a6a2:	68fb      	ldr	r3, [r7, #12]
 801a6a4:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a6a8:	613b      	str	r3, [r7, #16]
  uint16_t len = 8 ;
 801a6aa:	2308      	movs	r3, #8
 801a6ac:	82fb      	strh	r3, [r7, #22]
  hmsc->bot_data_length = len;
 801a6ae:	693b      	ldr	r3, [r7, #16]
 801a6b0:	8afa      	ldrh	r2, [r7, #22]
 801a6b2:	815a      	strh	r2, [r3, #10]
  
  while (len) 
 801a6b4:	e00a      	b.n	801a6cc <SCSI_ModeSense6+0x38>
  {
    len--;
 801a6b6:	8afb      	ldrh	r3, [r7, #22]
 801a6b8:	3b01      	subs	r3, #1
 801a6ba:	82fb      	strh	r3, [r7, #22]
    hmsc->bot_data[len] = MSC_Mode_Sense6_data[len];
 801a6bc:	8afa      	ldrh	r2, [r7, #22]
 801a6be:	8afb      	ldrh	r3, [r7, #22]
 801a6c0:	4907      	ldr	r1, [pc, #28]	; (801a6e0 <SCSI_ModeSense6+0x4c>)
 801a6c2:	5c89      	ldrb	r1, [r1, r2]
 801a6c4:	693a      	ldr	r2, [r7, #16]
 801a6c6:	4413      	add	r3, r2
 801a6c8:	460a      	mov	r2, r1
 801a6ca:	731a      	strb	r2, [r3, #12]
  while (len) 
 801a6cc:	8afb      	ldrh	r3, [r7, #22]
 801a6ce:	2b00      	cmp	r3, #0
 801a6d0:	d1f1      	bne.n	801a6b6 <SCSI_ModeSense6+0x22>
  }
  return 0;
 801a6d2:	2300      	movs	r3, #0
}
 801a6d4:	4618      	mov	r0, r3
 801a6d6:	371c      	adds	r7, #28
 801a6d8:	46bd      	mov	sp, r7
 801a6da:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a6de:	4770      	bx	lr
 801a6e0:	0801e204 	.word	0x0801e204

0801a6e4 <SCSI_ModeSense10>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_ModeSense10 (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a6e4:	b480      	push	{r7}
 801a6e6:	b087      	sub	sp, #28
 801a6e8:	af00      	add	r7, sp, #0
 801a6ea:	60f8      	str	r0, [r7, #12]
 801a6ec:	460b      	mov	r3, r1
 801a6ee:	607a      	str	r2, [r7, #4]
 801a6f0:	72fb      	strb	r3, [r7, #11]
  uint16_t len = 8;
 801a6f2:	2308      	movs	r3, #8
 801a6f4:	82fb      	strh	r3, [r7, #22]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a6f6:	68fb      	ldr	r3, [r7, #12]
 801a6f8:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a6fc:	613b      	str	r3, [r7, #16]
  
  hmsc->bot_data_length = len;
 801a6fe:	693b      	ldr	r3, [r7, #16]
 801a700:	8afa      	ldrh	r2, [r7, #22]
 801a702:	815a      	strh	r2, [r3, #10]

  while (len) 
 801a704:	e00a      	b.n	801a71c <SCSI_ModeSense10+0x38>
  {
    len--;
 801a706:	8afb      	ldrh	r3, [r7, #22]
 801a708:	3b01      	subs	r3, #1
 801a70a:	82fb      	strh	r3, [r7, #22]
    hmsc->bot_data[len] = MSC_Mode_Sense10_data[len];
 801a70c:	8afa      	ldrh	r2, [r7, #22]
 801a70e:	8afb      	ldrh	r3, [r7, #22]
 801a710:	4907      	ldr	r1, [pc, #28]	; (801a730 <SCSI_ModeSense10+0x4c>)
 801a712:	5c89      	ldrb	r1, [r1, r2]
 801a714:	693a      	ldr	r2, [r7, #16]
 801a716:	4413      	add	r3, r2
 801a718:	460a      	mov	r2, r1
 801a71a:	731a      	strb	r2, [r3, #12]
  while (len) 
 801a71c:	8afb      	ldrh	r3, [r7, #22]
 801a71e:	2b00      	cmp	r3, #0
 801a720:	d1f1      	bne.n	801a706 <SCSI_ModeSense10+0x22>
  }
  return 0;
 801a722:	2300      	movs	r3, #0
}
 801a724:	4618      	mov	r0, r3
 801a726:	371c      	adds	r7, #28
 801a728:	46bd      	mov	sp, r7
 801a72a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a72e:	4770      	bx	lr
 801a730:	0801e20c 	.word	0x0801e20c

0801a734 <SCSI_RequestSense>:
* @param  params: Command parameters
* @retval status
*/

static int8_t SCSI_RequestSense (USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a734:	b480      	push	{r7}
 801a736:	b087      	sub	sp, #28
 801a738:	af00      	add	r7, sp, #0
 801a73a:	60f8      	str	r0, [r7, #12]
 801a73c:	460b      	mov	r3, r1
 801a73e:	607a      	str	r2, [r7, #4]
 801a740:	72fb      	strb	r3, [r7, #11]
  uint8_t i;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a742:	68fb      	ldr	r3, [r7, #12]
 801a744:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a748:	613b      	str	r3, [r7, #16]
  
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
 801a74a:	2300      	movs	r3, #0
 801a74c:	75fb      	strb	r3, [r7, #23]
 801a74e:	e007      	b.n	801a760 <SCSI_RequestSense+0x2c>
  {
    hmsc->bot_data[i] = 0;
 801a750:	7dfb      	ldrb	r3, [r7, #23]
 801a752:	693a      	ldr	r2, [r7, #16]
 801a754:	4413      	add	r3, r2
 801a756:	2200      	movs	r2, #0
 801a758:	731a      	strb	r2, [r3, #12]
  for(i=0 ; i < REQUEST_SENSE_DATA_LEN ; i++) 
 801a75a:	7dfb      	ldrb	r3, [r7, #23]
 801a75c:	3301      	adds	r3, #1
 801a75e:	75fb      	strb	r3, [r7, #23]
 801a760:	7dfb      	ldrb	r3, [r7, #23]
 801a762:	2b11      	cmp	r3, #17
 801a764:	d9f4      	bls.n	801a750 <SCSI_RequestSense+0x1c>
  }
  
  hmsc->bot_data[0]	= 0x70;		
 801a766:	693b      	ldr	r3, [r7, #16]
 801a768:	2270      	movs	r2, #112	; 0x70
 801a76a:	731a      	strb	r2, [r3, #12]
  hmsc->bot_data[7]	= REQUEST_SENSE_DATA_LEN - 6;	
 801a76c:	693b      	ldr	r3, [r7, #16]
 801a76e:	220c      	movs	r2, #12
 801a770:	74da      	strb	r2, [r3, #19]
  
  if((hmsc->scsi_sense_head != hmsc->scsi_sense_tail)) {
 801a772:	693b      	ldr	r3, [r7, #16]
 801a774:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a778:	335c      	adds	r3, #92	; 0x5c
 801a77a:	781a      	ldrb	r2, [r3, #0]
 801a77c:	693b      	ldr	r3, [r7, #16]
 801a77e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a782:	335d      	adds	r3, #93	; 0x5d
 801a784:	781b      	ldrb	r3, [r3, #0]
 801a786:	429a      	cmp	r2, r3
 801a788:	d03f      	beq.n	801a80a <SCSI_RequestSense+0xd6>
    
    hmsc->bot_data[2]     = hmsc->scsi_sense[hmsc->scsi_sense_head].Skey;		
 801a78a:	693b      	ldr	r3, [r7, #16]
 801a78c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a790:	335c      	adds	r3, #92	; 0x5c
 801a792:	781b      	ldrb	r3, [r3, #0]
 801a794:	693a      	ldr	r2, [r7, #16]
 801a796:	f603 0307 	addw	r3, r3, #2055	; 0x807
 801a79a:	00db      	lsls	r3, r3, #3
 801a79c:	4413      	add	r3, r2
 801a79e:	791a      	ldrb	r2, [r3, #4]
 801a7a0:	693b      	ldr	r3, [r7, #16]
 801a7a2:	739a      	strb	r2, [r3, #14]
    hmsc->bot_data[12]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASCQ;	
 801a7a4:	693b      	ldr	r3, [r7, #16]
 801a7a6:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a7aa:	335c      	adds	r3, #92	; 0x5c
 801a7ac:	781b      	ldrb	r3, [r3, #0]
 801a7ae:	693a      	ldr	r2, [r7, #16]
 801a7b0:	f603 0307 	addw	r3, r3, #2055	; 0x807
 801a7b4:	00db      	lsls	r3, r3, #3
 801a7b6:	4413      	add	r3, r2
 801a7b8:	7a5a      	ldrb	r2, [r3, #9]
 801a7ba:	693b      	ldr	r3, [r7, #16]
 801a7bc:	761a      	strb	r2, [r3, #24]
    hmsc->bot_data[13]    = hmsc->scsi_sense[hmsc->scsi_sense_head].w.b.ASC;	
 801a7be:	693b      	ldr	r3, [r7, #16]
 801a7c0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a7c4:	335c      	adds	r3, #92	; 0x5c
 801a7c6:	781b      	ldrb	r3, [r3, #0]
 801a7c8:	693a      	ldr	r2, [r7, #16]
 801a7ca:	f603 0307 	addw	r3, r3, #2055	; 0x807
 801a7ce:	00db      	lsls	r3, r3, #3
 801a7d0:	4413      	add	r3, r2
 801a7d2:	7a1a      	ldrb	r2, [r3, #8]
 801a7d4:	693b      	ldr	r3, [r7, #16]
 801a7d6:	765a      	strb	r2, [r3, #25]
    hmsc->scsi_sense_head++;
 801a7d8:	693b      	ldr	r3, [r7, #16]
 801a7da:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a7de:	335c      	adds	r3, #92	; 0x5c
 801a7e0:	781b      	ldrb	r3, [r3, #0]
 801a7e2:	3301      	adds	r3, #1
 801a7e4:	b2da      	uxtb	r2, r3
 801a7e6:	693b      	ldr	r3, [r7, #16]
 801a7e8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a7ec:	335c      	adds	r3, #92	; 0x5c
 801a7ee:	701a      	strb	r2, [r3, #0]
    
    if (hmsc->scsi_sense_head == SENSE_LIST_DEEPTH)
 801a7f0:	693b      	ldr	r3, [r7, #16]
 801a7f2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a7f6:	335c      	adds	r3, #92	; 0x5c
 801a7f8:	781b      	ldrb	r3, [r3, #0]
 801a7fa:	2b04      	cmp	r3, #4
 801a7fc:	d105      	bne.n	801a80a <SCSI_RequestSense+0xd6>
    {
      hmsc->scsi_sense_head = 0;
 801a7fe:	693b      	ldr	r3, [r7, #16]
 801a800:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a804:	335c      	adds	r3, #92	; 0x5c
 801a806:	2200      	movs	r2, #0
 801a808:	701a      	strb	r2, [r3, #0]
    }
  }
  hmsc->bot_data_length = REQUEST_SENSE_DATA_LEN;  
 801a80a:	693b      	ldr	r3, [r7, #16]
 801a80c:	2212      	movs	r2, #18
 801a80e:	815a      	strh	r2, [r3, #10]
  
  if (params[4] <= REQUEST_SENSE_DATA_LEN)
 801a810:	687b      	ldr	r3, [r7, #4]
 801a812:	3304      	adds	r3, #4
 801a814:	781b      	ldrb	r3, [r3, #0]
 801a816:	2b12      	cmp	r3, #18
 801a818:	d805      	bhi.n	801a826 <SCSI_RequestSense+0xf2>
  {
    hmsc->bot_data_length = params[4];
 801a81a:	687b      	ldr	r3, [r7, #4]
 801a81c:	3304      	adds	r3, #4
 801a81e:	781b      	ldrb	r3, [r3, #0]
 801a820:	b29a      	uxth	r2, r3
 801a822:	693b      	ldr	r3, [r7, #16]
 801a824:	815a      	strh	r2, [r3, #10]
  }
  return 0;
 801a826:	2300      	movs	r3, #0
}
 801a828:	4618      	mov	r0, r3
 801a82a:	371c      	adds	r7, #28
 801a82c:	46bd      	mov	sp, r7
 801a82e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a832:	4770      	bx	lr

0801a834 <SCSI_SenseCode>:
* @param  ASC: Additional Sense Key
* @retval none

*/
void SCSI_SenseCode(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t sKey, uint8_t ASC)
{
 801a834:	b480      	push	{r7}
 801a836:	b085      	sub	sp, #20
 801a838:	af00      	add	r7, sp, #0
 801a83a:	6078      	str	r0, [r7, #4]
 801a83c:	4608      	mov	r0, r1
 801a83e:	4611      	mov	r1, r2
 801a840:	461a      	mov	r2, r3
 801a842:	4603      	mov	r3, r0
 801a844:	70fb      	strb	r3, [r7, #3]
 801a846:	460b      	mov	r3, r1
 801a848:	70bb      	strb	r3, [r7, #2]
 801a84a:	4613      	mov	r3, r2
 801a84c:	707b      	strb	r3, [r7, #1]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData; 
 801a84e:	687b      	ldr	r3, [r7, #4]
 801a850:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a854:	60fb      	str	r3, [r7, #12]
  
  hmsc->scsi_sense[hmsc->scsi_sense_tail].Skey  = sKey;
 801a856:	68fb      	ldr	r3, [r7, #12]
 801a858:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a85c:	335d      	adds	r3, #93	; 0x5d
 801a85e:	781b      	ldrb	r3, [r3, #0]
 801a860:	68fa      	ldr	r2, [r7, #12]
 801a862:	f603 0307 	addw	r3, r3, #2055	; 0x807
 801a866:	00db      	lsls	r3, r3, #3
 801a868:	4413      	add	r3, r2
 801a86a:	78ba      	ldrb	r2, [r7, #2]
 801a86c:	711a      	strb	r2, [r3, #4]
  hmsc->scsi_sense[hmsc->scsi_sense_tail].w.ASC = ASC << 8;
 801a86e:	787b      	ldrb	r3, [r7, #1]
 801a870:	021a      	lsls	r2, r3, #8
 801a872:	68fb      	ldr	r3, [r7, #12]
 801a874:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a878:	335d      	adds	r3, #93	; 0x5d
 801a87a:	781b      	ldrb	r3, [r3, #0]
 801a87c:	4611      	mov	r1, r2
 801a87e:	68fa      	ldr	r2, [r7, #12]
 801a880:	f603 0307 	addw	r3, r3, #2055	; 0x807
 801a884:	00db      	lsls	r3, r3, #3
 801a886:	4413      	add	r3, r2
 801a888:	6099      	str	r1, [r3, #8]
  hmsc->scsi_sense_tail++;
 801a88a:	68fb      	ldr	r3, [r7, #12]
 801a88c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a890:	335d      	adds	r3, #93	; 0x5d
 801a892:	781b      	ldrb	r3, [r3, #0]
 801a894:	3301      	adds	r3, #1
 801a896:	b2da      	uxtb	r2, r3
 801a898:	68fb      	ldr	r3, [r7, #12]
 801a89a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a89e:	335d      	adds	r3, #93	; 0x5d
 801a8a0:	701a      	strb	r2, [r3, #0]
  if (hmsc->scsi_sense_tail == SENSE_LIST_DEEPTH)
 801a8a2:	68fb      	ldr	r3, [r7, #12]
 801a8a4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a8a8:	335d      	adds	r3, #93	; 0x5d
 801a8aa:	781b      	ldrb	r3, [r3, #0]
 801a8ac:	2b04      	cmp	r3, #4
 801a8ae:	d105      	bne.n	801a8bc <SCSI_SenseCode+0x88>
  {
    hmsc->scsi_sense_tail = 0;
 801a8b0:	68fb      	ldr	r3, [r7, #12]
 801a8b2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a8b6:	335d      	adds	r3, #93	; 0x5d
 801a8b8:	2200      	movs	r2, #0
 801a8ba:	701a      	strb	r2, [r3, #0]
  }
}
 801a8bc:	bf00      	nop
 801a8be:	3714      	adds	r7, #20
 801a8c0:	46bd      	mov	sp, r7
 801a8c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a8c6:	4770      	bx	lr

0801a8c8 <SCSI_StartStopUnit>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_StartStopUnit(USBD_HandleTypeDef  *pdev, uint8_t lun, uint8_t *params)
{
 801a8c8:	b480      	push	{r7}
 801a8ca:	b087      	sub	sp, #28
 801a8cc:	af00      	add	r7, sp, #0
 801a8ce:	60f8      	str	r0, [r7, #12]
 801a8d0:	460b      	mov	r3, r1
 801a8d2:	607a      	str	r2, [r7, #4]
 801a8d4:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData;   
 801a8d6:	68fb      	ldr	r3, [r7, #12]
 801a8d8:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a8dc:	617b      	str	r3, [r7, #20]
  hmsc->bot_data_length = 0;
 801a8de:	697b      	ldr	r3, [r7, #20]
 801a8e0:	2200      	movs	r2, #0
 801a8e2:	815a      	strh	r2, [r3, #10]
  return 0;
 801a8e4:	2300      	movs	r3, #0
}
 801a8e6:	4618      	mov	r0, r3
 801a8e8:	371c      	adds	r7, #28
 801a8ea:	46bd      	mov	sp, r7
 801a8ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a8f0:	4770      	bx	lr

0801a8f2 <SCSI_Read10>:
* @param  lun: Logical unit number
* @param  params: Command parameters
* @retval status
*/
static int8_t SCSI_Read10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
 801a8f2:	b580      	push	{r7, lr}
 801a8f4:	b086      	sub	sp, #24
 801a8f6:	af00      	add	r7, sp, #0
 801a8f8:	60f8      	str	r0, [r7, #12]
 801a8fa:	460b      	mov	r3, r1
 801a8fc:	607a      	str	r2, [r7, #4]
 801a8fe:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 801a900:	68fb      	ldr	r3, [r7, #12]
 801a902:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801a906:	617b      	str	r3, [r7, #20]
  
  if(hmsc->bot_state == USBD_BOT_IDLE)  /* Idle */
 801a908:	697b      	ldr	r3, [r7, #20]
 801a90a:	7a1b      	ldrb	r3, [r3, #8]
 801a90c:	2b00      	cmp	r3, #0
 801a90e:	f040 80a1 	bne.w	801aa54 <SCSI_Read10+0x162>
  {
    
    /* case 10 : Ho <> Di */
    
    if ((hmsc->cbw.bmFlags & 0x80) != 0x80)
 801a912:	697b      	ldr	r3, [r7, #20]
 801a914:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a918:	3318      	adds	r3, #24
 801a91a:	781b      	ldrb	r3, [r3, #0]
 801a91c:	b25b      	sxtb	r3, r3
 801a91e:	2b00      	cmp	r3, #0
 801a920:	db0c      	blt.n	801a93c <SCSI_Read10+0x4a>
    {
      SCSI_SenseCode(pdev,
 801a922:	697b      	ldr	r3, [r7, #20]
 801a924:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a928:	3319      	adds	r3, #25
 801a92a:	7819      	ldrb	r1, [r3, #0]
 801a92c:	2320      	movs	r3, #32
 801a92e:	2205      	movs	r2, #5
 801a930:	68f8      	ldr	r0, [r7, #12]
 801a932:	f7ff ff7f 	bl	801a834 <SCSI_SenseCode>
                     hmsc->cbw.bLUN, 
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
 801a936:	f04f 33ff 	mov.w	r3, #4294967295
 801a93a:	e095      	b.n	801aa68 <SCSI_Read10+0x176>
    }    
    
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 801a93c:	68fb      	ldr	r3, [r7, #12]
 801a93e:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801a942:	689b      	ldr	r3, [r3, #8]
 801a944:	7afa      	ldrb	r2, [r7, #11]
 801a946:	4610      	mov	r0, r2
 801a948:	4798      	blx	r3
 801a94a:	4603      	mov	r3, r0
 801a94c:	2b00      	cmp	r3, #0
 801a94e:	d008      	beq.n	801a962 <SCSI_Read10+0x70>
    {
      SCSI_SenseCode(pdev,
 801a950:	7af9      	ldrb	r1, [r7, #11]
 801a952:	233a      	movs	r3, #58	; 0x3a
 801a954:	2202      	movs	r2, #2
 801a956:	68f8      	ldr	r0, [r7, #12]
 801a958:	f7ff ff6c 	bl	801a834 <SCSI_SenseCode>
                     lun,
                     NOT_READY, 
                     MEDIUM_NOT_PRESENT);
      return -1;
 801a95c:	f04f 33ff 	mov.w	r3, #4294967295
 801a960:	e082      	b.n	801aa68 <SCSI_Read10+0x176>
    } 
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801a962:	687b      	ldr	r3, [r7, #4]
 801a964:	3302      	adds	r3, #2
 801a966:	781b      	ldrb	r3, [r3, #0]
 801a968:	061a      	lsls	r2, r3, #24
      (params[3] << 16) | \
 801a96a:	687b      	ldr	r3, [r7, #4]
 801a96c:	3303      	adds	r3, #3
 801a96e:	781b      	ldrb	r3, [r3, #0]
 801a970:	041b      	lsls	r3, r3, #16
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801a972:	431a      	orrs	r2, r3
        (params[4] <<  8) | \
 801a974:	687b      	ldr	r3, [r7, #4]
 801a976:	3304      	adds	r3, #4
 801a978:	781b      	ldrb	r3, [r3, #0]
 801a97a:	021b      	lsls	r3, r3, #8
      (params[3] << 16) | \
 801a97c:	4313      	orrs	r3, r2
          params[5];
 801a97e:	687a      	ldr	r2, [r7, #4]
 801a980:	3205      	adds	r2, #5
 801a982:	7812      	ldrb	r2, [r2, #0]
        (params[4] <<  8) | \
 801a984:	4313      	orrs	r3, r2
 801a986:	461a      	mov	r2, r3
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801a988:	697b      	ldr	r3, [r7, #20]
 801a98a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a98e:	3364      	adds	r3, #100	; 0x64
 801a990:	601a      	str	r2, [r3, #0]
    
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 801a992:	687b      	ldr	r3, [r7, #4]
 801a994:	3307      	adds	r3, #7
 801a996:	781b      	ldrb	r3, [r3, #0]
 801a998:	021b      	lsls	r3, r3, #8
      params[8];  
 801a99a:	687a      	ldr	r2, [r7, #4]
 801a99c:	3208      	adds	r2, #8
 801a99e:	7812      	ldrb	r2, [r2, #0]
    hmsc->scsi_blk_len =  (params[7] <<  8) | \
 801a9a0:	4313      	orrs	r3, r2
 801a9a2:	461a      	mov	r2, r3
 801a9a4:	697b      	ldr	r3, [r7, #20]
 801a9a6:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9aa:	3368      	adds	r3, #104	; 0x68
 801a9ac:	601a      	str	r2, [r3, #0]
    
    
    
    if( SCSI_CheckAddressRange(pdev, lun, hmsc->scsi_blk_addr, hmsc->scsi_blk_len) < 0)
 801a9ae:	697b      	ldr	r3, [r7, #20]
 801a9b0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9b4:	3364      	adds	r3, #100	; 0x64
 801a9b6:	681a      	ldr	r2, [r3, #0]
 801a9b8:	697b      	ldr	r3, [r7, #20]
 801a9ba:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9be:	3368      	adds	r3, #104	; 0x68
 801a9c0:	681b      	ldr	r3, [r3, #0]
 801a9c2:	b29b      	uxth	r3, r3
 801a9c4:	7af9      	ldrb	r1, [r7, #11]
 801a9c6:	68f8      	ldr	r0, [r7, #12]
 801a9c8:	f000 f96c 	bl	801aca4 <SCSI_CheckAddressRange>
 801a9cc:	4603      	mov	r3, r0
 801a9ce:	2b00      	cmp	r3, #0
 801a9d0:	da02      	bge.n	801a9d8 <SCSI_Read10+0xe6>
    {
      return -1; /* error */
 801a9d2:	f04f 33ff 	mov.w	r3, #4294967295
 801a9d6:	e047      	b.n	801aa68 <SCSI_Read10+0x176>
    }
    
    hmsc->bot_state = USBD_BOT_DATA_IN;
 801a9d8:	697b      	ldr	r3, [r7, #20]
 801a9da:	2202      	movs	r2, #2
 801a9dc:	721a      	strb	r2, [r3, #8]
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 801a9de:	697b      	ldr	r3, [r7, #20]
 801a9e0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9e4:	3364      	adds	r3, #100	; 0x64
 801a9e6:	681a      	ldr	r2, [r3, #0]
 801a9e8:	697b      	ldr	r3, [r7, #20]
 801a9ea:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9ee:	335e      	adds	r3, #94	; 0x5e
 801a9f0:	881b      	ldrh	r3, [r3, #0]
 801a9f2:	fb03 f202 	mul.w	r2, r3, r2
 801a9f6:	697b      	ldr	r3, [r7, #20]
 801a9f8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801a9fc:	3364      	adds	r3, #100	; 0x64
 801a9fe:	601a      	str	r2, [r3, #0]
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 801aa00:	697b      	ldr	r3, [r7, #20]
 801aa02:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa06:	3368      	adds	r3, #104	; 0x68
 801aa08:	681a      	ldr	r2, [r3, #0]
 801aa0a:	697b      	ldr	r3, [r7, #20]
 801aa0c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa10:	335e      	adds	r3, #94	; 0x5e
 801aa12:	881b      	ldrh	r3, [r3, #0]
 801aa14:	fb03 f202 	mul.w	r2, r3, r2
 801aa18:	697b      	ldr	r3, [r7, #20]
 801aa1a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa1e:	3368      	adds	r3, #104	; 0x68
 801aa20:	601a      	str	r2, [r3, #0]
    
    /* cases 4,5 : Hi <> Dn */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 801aa22:	697b      	ldr	r3, [r7, #20]
 801aa24:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa28:	3314      	adds	r3, #20
 801aa2a:	681a      	ldr	r2, [r3, #0]
 801aa2c:	697b      	ldr	r3, [r7, #20]
 801aa2e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa32:	3368      	adds	r3, #104	; 0x68
 801aa34:	681b      	ldr	r3, [r3, #0]
 801aa36:	429a      	cmp	r2, r3
 801aa38:	d00c      	beq.n	801aa54 <SCSI_Read10+0x162>
    {
      SCSI_SenseCode(pdev,
 801aa3a:	697b      	ldr	r3, [r7, #20]
 801aa3c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa40:	3319      	adds	r3, #25
 801aa42:	7819      	ldrb	r1, [r3, #0]
 801aa44:	2320      	movs	r3, #32
 801aa46:	2205      	movs	r2, #5
 801aa48:	68f8      	ldr	r0, [r7, #12]
 801aa4a:	f7ff fef3 	bl	801a834 <SCSI_SenseCode>
                     hmsc->cbw.bLUN, 
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
 801aa4e:	f04f 33ff 	mov.w	r3, #4294967295
 801aa52:	e009      	b.n	801aa68 <SCSI_Read10+0x176>
    }
  }
  hmsc->bot_data_length = MSC_MEDIA_PACKET;  
 801aa54:	697b      	ldr	r3, [r7, #20]
 801aa56:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 801aa5a:	815a      	strh	r2, [r3, #10]
  
  return SCSI_ProcessRead(pdev, lun);
 801aa5c:	7afb      	ldrb	r3, [r7, #11]
 801aa5e:	4619      	mov	r1, r3
 801aa60:	68f8      	ldr	r0, [r7, #12]
 801aa62:	f000 f945 	bl	801acf0 <SCSI_ProcessRead>
 801aa66:	4603      	mov	r3, r0
}
 801aa68:	4618      	mov	r0, r3
 801aa6a:	3718      	adds	r7, #24
 801aa6c:	46bd      	mov	sp, r7
 801aa6e:	bd80      	pop	{r7, pc}

0801aa70 <SCSI_Write10>:
* @param  params: Command parameters
* @retval status
*/

static int8_t SCSI_Write10 (USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
 801aa70:	b580      	push	{r7, lr}
 801aa72:	b086      	sub	sp, #24
 801aa74:	af00      	add	r7, sp, #0
 801aa76:	60f8      	str	r0, [r7, #12]
 801aa78:	460b      	mov	r3, r1
 801aa7a:	607a      	str	r2, [r7, #4]
 801aa7c:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 801aa7e:	68fb      	ldr	r3, [r7, #12]
 801aa80:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801aa84:	617b      	str	r3, [r7, #20]
  
  if (hmsc->bot_state == USBD_BOT_IDLE) /* Idle */
 801aa86:	697b      	ldr	r3, [r7, #20]
 801aa88:	7a1b      	ldrb	r3, [r3, #8]
 801aa8a:	2b00      	cmp	r3, #0
 801aa8c:	f040 80c8 	bne.w	801ac20 <SCSI_Write10+0x1b0>
  {
    
    /* case 8 : Hi <> Do */
    
    if ((hmsc->cbw.bmFlags & 0x80) == 0x80)
 801aa90:	697b      	ldr	r3, [r7, #20]
 801aa92:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aa96:	3318      	adds	r3, #24
 801aa98:	781b      	ldrb	r3, [r3, #0]
 801aa9a:	b25b      	sxtb	r3, r3
 801aa9c:	2b00      	cmp	r3, #0
 801aa9e:	da0c      	bge.n	801aaba <SCSI_Write10+0x4a>
    {
      SCSI_SenseCode(pdev,
 801aaa0:	697b      	ldr	r3, [r7, #20]
 801aaa2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aaa6:	3319      	adds	r3, #25
 801aaa8:	7819      	ldrb	r1, [r3, #0]
 801aaaa:	2320      	movs	r3, #32
 801aaac:	2205      	movs	r2, #5
 801aaae:	68f8      	ldr	r0, [r7, #12]
 801aab0:	f7ff fec0 	bl	801a834 <SCSI_SenseCode>
                     hmsc->cbw.bLUN, 
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
 801aab4:	f04f 33ff 	mov.w	r3, #4294967295
 801aab8:	e0b8      	b.n	801ac2c <SCSI_Write10+0x1bc>
    }
    
    /* Check whether Media is ready */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsReady(lun) !=0 )
 801aaba:	68fb      	ldr	r3, [r7, #12]
 801aabc:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801aac0:	689b      	ldr	r3, [r3, #8]
 801aac2:	7afa      	ldrb	r2, [r7, #11]
 801aac4:	4610      	mov	r0, r2
 801aac6:	4798      	blx	r3
 801aac8:	4603      	mov	r3, r0
 801aaca:	2b00      	cmp	r3, #0
 801aacc:	d008      	beq.n	801aae0 <SCSI_Write10+0x70>
    {
      SCSI_SenseCode(pdev,
 801aace:	7af9      	ldrb	r1, [r7, #11]
 801aad0:	233a      	movs	r3, #58	; 0x3a
 801aad2:	2202      	movs	r2, #2
 801aad4:	68f8      	ldr	r0, [r7, #12]
 801aad6:	f7ff fead 	bl	801a834 <SCSI_SenseCode>
                     lun,
                     NOT_READY, 
                     MEDIUM_NOT_PRESENT);
      return -1;
 801aada:	f04f 33ff 	mov.w	r3, #4294967295
 801aade:	e0a5      	b.n	801ac2c <SCSI_Write10+0x1bc>
    } 
    
    /* Check If media is write-protected */
    if(((USBD_StorageTypeDef *)pdev->pUserData)->IsWriteProtected(lun) !=0 )
 801aae0:	68fb      	ldr	r3, [r7, #12]
 801aae2:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801aae6:	68db      	ldr	r3, [r3, #12]
 801aae8:	7afa      	ldrb	r2, [r7, #11]
 801aaea:	4610      	mov	r0, r2
 801aaec:	4798      	blx	r3
 801aaee:	4603      	mov	r3, r0
 801aaf0:	2b00      	cmp	r3, #0
 801aaf2:	d008      	beq.n	801ab06 <SCSI_Write10+0x96>
    {
      SCSI_SenseCode(pdev,
 801aaf4:	7af9      	ldrb	r1, [r7, #11]
 801aaf6:	2327      	movs	r3, #39	; 0x27
 801aaf8:	2202      	movs	r2, #2
 801aafa:	68f8      	ldr	r0, [r7, #12]
 801aafc:	f7ff fe9a 	bl	801a834 <SCSI_SenseCode>
                     lun,
                     NOT_READY, 
                     WRITE_PROTECTED);
      return -1;
 801ab00:	f04f 33ff 	mov.w	r3, #4294967295
 801ab04:	e092      	b.n	801ac2c <SCSI_Write10+0x1bc>
    } 
    
    
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801ab06:	687b      	ldr	r3, [r7, #4]
 801ab08:	3302      	adds	r3, #2
 801ab0a:	781b      	ldrb	r3, [r3, #0]
 801ab0c:	061a      	lsls	r2, r3, #24
      (params[3] << 16) | \
 801ab0e:	687b      	ldr	r3, [r7, #4]
 801ab10:	3303      	adds	r3, #3
 801ab12:	781b      	ldrb	r3, [r3, #0]
 801ab14:	041b      	lsls	r3, r3, #16
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801ab16:	431a      	orrs	r2, r3
        (params[4] <<  8) | \
 801ab18:	687b      	ldr	r3, [r7, #4]
 801ab1a:	3304      	adds	r3, #4
 801ab1c:	781b      	ldrb	r3, [r3, #0]
 801ab1e:	021b      	lsls	r3, r3, #8
      (params[3] << 16) | \
 801ab20:	4313      	orrs	r3, r2
          params[5];
 801ab22:	687a      	ldr	r2, [r7, #4]
 801ab24:	3205      	adds	r2, #5
 801ab26:	7812      	ldrb	r2, [r2, #0]
        (params[4] <<  8) | \
 801ab28:	4313      	orrs	r3, r2
 801ab2a:	461a      	mov	r2, r3
    hmsc->scsi_blk_addr = (params[2] << 24) | \
 801ab2c:	697b      	ldr	r3, [r7, #20]
 801ab2e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab32:	3364      	adds	r3, #100	; 0x64
 801ab34:	601a      	str	r2, [r3, #0]
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 801ab36:	687b      	ldr	r3, [r7, #4]
 801ab38:	3307      	adds	r3, #7
 801ab3a:	781b      	ldrb	r3, [r3, #0]
 801ab3c:	021b      	lsls	r3, r3, #8
      params[8];  
 801ab3e:	687a      	ldr	r2, [r7, #4]
 801ab40:	3208      	adds	r2, #8
 801ab42:	7812      	ldrb	r2, [r2, #0]
    hmsc->scsi_blk_len = (params[7] <<  8) | \
 801ab44:	4313      	orrs	r3, r2
 801ab46:	461a      	mov	r2, r3
 801ab48:	697b      	ldr	r3, [r7, #20]
 801ab4a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab4e:	3368      	adds	r3, #104	; 0x68
 801ab50:	601a      	str	r2, [r3, #0]
    
    /* check if LBA address is in the right range */
    if(SCSI_CheckAddressRange(pdev,
 801ab52:	697b      	ldr	r3, [r7, #20]
 801ab54:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab58:	3364      	adds	r3, #100	; 0x64
 801ab5a:	681a      	ldr	r2, [r3, #0]
                              lun,
                              hmsc->scsi_blk_addr,
                              hmsc->scsi_blk_len) < 0)
 801ab5c:	697b      	ldr	r3, [r7, #20]
 801ab5e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab62:	3368      	adds	r3, #104	; 0x68
 801ab64:	681b      	ldr	r3, [r3, #0]
    if(SCSI_CheckAddressRange(pdev,
 801ab66:	b29b      	uxth	r3, r3
 801ab68:	7af9      	ldrb	r1, [r7, #11]
 801ab6a:	68f8      	ldr	r0, [r7, #12]
 801ab6c:	f000 f89a 	bl	801aca4 <SCSI_CheckAddressRange>
 801ab70:	4603      	mov	r3, r0
 801ab72:	2b00      	cmp	r3, #0
 801ab74:	da02      	bge.n	801ab7c <SCSI_Write10+0x10c>
    {
      return -1; /* error */      
 801ab76:	f04f 33ff 	mov.w	r3, #4294967295
 801ab7a:	e057      	b.n	801ac2c <SCSI_Write10+0x1bc>
    }
    
    hmsc->scsi_blk_addr *= hmsc->scsi_blk_size;
 801ab7c:	697b      	ldr	r3, [r7, #20]
 801ab7e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab82:	3364      	adds	r3, #100	; 0x64
 801ab84:	681a      	ldr	r2, [r3, #0]
 801ab86:	697b      	ldr	r3, [r7, #20]
 801ab88:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab8c:	335e      	adds	r3, #94	; 0x5e
 801ab8e:	881b      	ldrh	r3, [r3, #0]
 801ab90:	fb03 f202 	mul.w	r2, r3, r2
 801ab94:	697b      	ldr	r3, [r7, #20]
 801ab96:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ab9a:	3364      	adds	r3, #100	; 0x64
 801ab9c:	601a      	str	r2, [r3, #0]
    hmsc->scsi_blk_len  *= hmsc->scsi_blk_size;
 801ab9e:	697b      	ldr	r3, [r7, #20]
 801aba0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aba4:	3368      	adds	r3, #104	; 0x68
 801aba6:	681a      	ldr	r2, [r3, #0]
 801aba8:	697b      	ldr	r3, [r7, #20]
 801abaa:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801abae:	335e      	adds	r3, #94	; 0x5e
 801abb0:	881b      	ldrh	r3, [r3, #0]
 801abb2:	fb03 f202 	mul.w	r2, r3, r2
 801abb6:	697b      	ldr	r3, [r7, #20]
 801abb8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801abbc:	3368      	adds	r3, #104	; 0x68
 801abbe:	601a      	str	r2, [r3, #0]
    
    /* cases 3,11,13 : Hn,Ho <> D0 */
    if (hmsc->cbw.dDataLength != hmsc->scsi_blk_len)
 801abc0:	697b      	ldr	r3, [r7, #20]
 801abc2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801abc6:	3314      	adds	r3, #20
 801abc8:	681a      	ldr	r2, [r3, #0]
 801abca:	697b      	ldr	r3, [r7, #20]
 801abcc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801abd0:	3368      	adds	r3, #104	; 0x68
 801abd2:	681b      	ldr	r3, [r3, #0]
 801abd4:	429a      	cmp	r2, r3
 801abd6:	d00c      	beq.n	801abf2 <SCSI_Write10+0x182>
    {
      SCSI_SenseCode(pdev,
 801abd8:	697b      	ldr	r3, [r7, #20]
 801abda:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801abde:	3319      	adds	r3, #25
 801abe0:	7819      	ldrb	r1, [r3, #0]
 801abe2:	2320      	movs	r3, #32
 801abe4:	2205      	movs	r2, #5
 801abe6:	68f8      	ldr	r0, [r7, #12]
 801abe8:	f7ff fe24 	bl	801a834 <SCSI_SenseCode>
                     hmsc->cbw.bLUN, 
                     ILLEGAL_REQUEST, 
                     INVALID_CDB);
      return -1;
 801abec:	f04f 33ff 	mov.w	r3, #4294967295
 801abf0:	e01c      	b.n	801ac2c <SCSI_Write10+0x1bc>
    }
    
    /* Prepare EP to receive first data packet */
    hmsc->bot_state = USBD_BOT_DATA_OUT;  
 801abf2:	697b      	ldr	r3, [r7, #20]
 801abf4:	2201      	movs	r2, #1
 801abf6:	721a      	strb	r2, [r3, #8]
    USBD_LL_PrepareReceive (pdev,
                      MSC_EPOUT_ADDR,
                      hmsc->bot_data, 
 801abf8:	697b      	ldr	r3, [r7, #20]
 801abfa:	f103 020c 	add.w	r2, r3, #12
                      MIN (hmsc->scsi_blk_len, MSC_MEDIA_PACKET));  
 801abfe:	697b      	ldr	r3, [r7, #20]
 801ac00:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ac04:	3368      	adds	r3, #104	; 0x68
 801ac06:	681b      	ldr	r3, [r3, #0]
 801ac08:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801ac0c:	bf28      	it	cs
 801ac0e:	f44f 4380 	movcs.w	r3, #16384	; 0x4000
    USBD_LL_PrepareReceive (pdev,
 801ac12:	b29b      	uxth	r3, r3
 801ac14:	2101      	movs	r1, #1
 801ac16:	68f8      	ldr	r0, [r7, #12]
 801ac18:	f7f6 faa3 	bl	8011162 <USBD_LL_PrepareReceive>
  }
  else /* Write Process ongoing */
  {
    return SCSI_ProcessWrite(pdev, lun);
  }
  return 0;
 801ac1c:	2300      	movs	r3, #0
 801ac1e:	e005      	b.n	801ac2c <SCSI_Write10+0x1bc>
    return SCSI_ProcessWrite(pdev, lun);
 801ac20:	7afb      	ldrb	r3, [r7, #11]
 801ac22:	4619      	mov	r1, r3
 801ac24:	68f8      	ldr	r0, [r7, #12]
 801ac26:	f000 f8df 	bl	801ade8 <SCSI_ProcessWrite>
 801ac2a:	4603      	mov	r3, r0
}
 801ac2c:	4618      	mov	r0, r3
 801ac2e:	3718      	adds	r7, #24
 801ac30:	46bd      	mov	sp, r7
 801ac32:	bd80      	pop	{r7, pc}

0801ac34 <SCSI_Verify10>:
* @param  params: Command parameters
* @retval status
*/

static int8_t SCSI_Verify10(USBD_HandleTypeDef  *pdev, uint8_t lun , uint8_t *params)
{
 801ac34:	b580      	push	{r7, lr}
 801ac36:	b086      	sub	sp, #24
 801ac38:	af00      	add	r7, sp, #0
 801ac3a:	60f8      	str	r0, [r7, #12]
 801ac3c:	460b      	mov	r3, r1
 801ac3e:	607a      	str	r2, [r7, #4]
 801ac40:	72fb      	strb	r3, [r7, #11]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 801ac42:	68fb      	ldr	r3, [r7, #12]
 801ac44:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801ac48:	617b      	str	r3, [r7, #20]
  
  if ((params[1]& 0x02) == 0x02) 
 801ac4a:	687b      	ldr	r3, [r7, #4]
 801ac4c:	3301      	adds	r3, #1
 801ac4e:	781b      	ldrb	r3, [r3, #0]
 801ac50:	f003 0302 	and.w	r3, r3, #2
 801ac54:	2b00      	cmp	r3, #0
 801ac56:	d008      	beq.n	801ac6a <SCSI_Verify10+0x36>
  {
    SCSI_SenseCode (pdev,
 801ac58:	7af9      	ldrb	r1, [r7, #11]
 801ac5a:	2324      	movs	r3, #36	; 0x24
 801ac5c:	2205      	movs	r2, #5
 801ac5e:	68f8      	ldr	r0, [r7, #12]
 801ac60:	f7ff fde8 	bl	801a834 <SCSI_SenseCode>
                    lun, 
                    ILLEGAL_REQUEST, 
                    INVALID_FIELED_IN_COMMAND);
    return -1; /* Error, Verify Mode Not supported*/
 801ac64:	f04f 33ff 	mov.w	r3, #4294967295
 801ac68:	e018      	b.n	801ac9c <SCSI_Verify10+0x68>
  }
  
  if(SCSI_CheckAddressRange(pdev,
 801ac6a:	697b      	ldr	r3, [r7, #20]
 801ac6c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ac70:	3364      	adds	r3, #100	; 0x64
 801ac72:	681a      	ldr	r2, [r3, #0]
                            lun, 
                            hmsc->scsi_blk_addr, 
                            hmsc->scsi_blk_len) < 0)
 801ac74:	697b      	ldr	r3, [r7, #20]
 801ac76:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ac7a:	3368      	adds	r3, #104	; 0x68
 801ac7c:	681b      	ldr	r3, [r3, #0]
  if(SCSI_CheckAddressRange(pdev,
 801ac7e:	b29b      	uxth	r3, r3
 801ac80:	7af9      	ldrb	r1, [r7, #11]
 801ac82:	68f8      	ldr	r0, [r7, #12]
 801ac84:	f000 f80e 	bl	801aca4 <SCSI_CheckAddressRange>
 801ac88:	4603      	mov	r3, r0
 801ac8a:	2b00      	cmp	r3, #0
 801ac8c:	da02      	bge.n	801ac94 <SCSI_Verify10+0x60>
  {
    return -1; /* error */      
 801ac8e:	f04f 33ff 	mov.w	r3, #4294967295
 801ac92:	e003      	b.n	801ac9c <SCSI_Verify10+0x68>
  }
  hmsc->bot_data_length = 0;
 801ac94:	697b      	ldr	r3, [r7, #20]
 801ac96:	2200      	movs	r2, #0
 801ac98:	815a      	strh	r2, [r3, #10]
  return 0;
 801ac9a:	2300      	movs	r3, #0
}
 801ac9c:	4618      	mov	r0, r3
 801ac9e:	3718      	adds	r7, #24
 801aca0:	46bd      	mov	sp, r7
 801aca2:	bd80      	pop	{r7, pc}

0801aca4 <SCSI_CheckAddressRange>:
* @param  blk_offset: first block address
* @param  blk_nbr: number of block to be processed
* @retval status
*/
static int8_t SCSI_CheckAddressRange (USBD_HandleTypeDef  *pdev, uint8_t lun , uint32_t blk_offset , uint16_t blk_nbr)
{
 801aca4:	b580      	push	{r7, lr}
 801aca6:	b086      	sub	sp, #24
 801aca8:	af00      	add	r7, sp, #0
 801acaa:	60f8      	str	r0, [r7, #12]
 801acac:	607a      	str	r2, [r7, #4]
 801acae:	461a      	mov	r2, r3
 801acb0:	460b      	mov	r3, r1
 801acb2:	72fb      	strb	r3, [r7, #11]
 801acb4:	4613      	mov	r3, r2
 801acb6:	813b      	strh	r3, [r7, #8]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 801acb8:	68fb      	ldr	r3, [r7, #12]
 801acba:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801acbe:	617b      	str	r3, [r7, #20]
  
  if ((blk_offset + blk_nbr) > hmsc->scsi_blk_nbr )
 801acc0:	893a      	ldrh	r2, [r7, #8]
 801acc2:	687b      	ldr	r3, [r7, #4]
 801acc4:	441a      	add	r2, r3
 801acc6:	697b      	ldr	r3, [r7, #20]
 801acc8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801accc:	3360      	adds	r3, #96	; 0x60
 801acce:	681b      	ldr	r3, [r3, #0]
 801acd0:	429a      	cmp	r2, r3
 801acd2:	d908      	bls.n	801ace6 <SCSI_CheckAddressRange+0x42>
  {
    SCSI_SenseCode(pdev,
 801acd4:	7af9      	ldrb	r1, [r7, #11]
 801acd6:	2321      	movs	r3, #33	; 0x21
 801acd8:	2205      	movs	r2, #5
 801acda:	68f8      	ldr	r0, [r7, #12]
 801acdc:	f7ff fdaa 	bl	801a834 <SCSI_SenseCode>
                   lun, 
                   ILLEGAL_REQUEST, 
                   ADDRESS_OUT_OF_RANGE);
    return -1;
 801ace0:	f04f 33ff 	mov.w	r3, #4294967295
 801ace4:	e000      	b.n	801ace8 <SCSI_CheckAddressRange+0x44>
  }
  return 0;
 801ace6:	2300      	movs	r3, #0
}
 801ace8:	4618      	mov	r0, r3
 801acea:	3718      	adds	r7, #24
 801acec:	46bd      	mov	sp, r7
 801acee:	bd80      	pop	{r7, pc}

0801acf0 <SCSI_ProcessRead>:
*         Handle Read Process
* @param  lun: Logical unit number
* @retval status
*/
static int8_t SCSI_ProcessRead (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
 801acf0:	b590      	push	{r4, r7, lr}
 801acf2:	b085      	sub	sp, #20
 801acf4:	af00      	add	r7, sp, #0
 801acf6:	6078      	str	r0, [r7, #4]
 801acf8:	460b      	mov	r3, r1
 801acfa:	70fb      	strb	r3, [r7, #3]
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*)pdev->pClassData;   
 801acfc:	687b      	ldr	r3, [r7, #4]
 801acfe:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801ad02:	60fb      	str	r3, [r7, #12]
  uint32_t len;
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 801ad04:	68fb      	ldr	r3, [r7, #12]
 801ad06:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad0a:	3368      	adds	r3, #104	; 0x68
 801ad0c:	681b      	ldr	r3, [r3, #0]
 801ad0e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801ad12:	bf28      	it	cs
 801ad14:	f44f 4380 	movcs.w	r3, #16384	; 0x4000
 801ad18:	60bb      	str	r3, [r7, #8]
  
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 801ad1a:	687b      	ldr	r3, [r7, #4]
 801ad1c:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801ad20:	691c      	ldr	r4, [r3, #16]
                              hmsc->bot_data, 
 801ad22:	68fb      	ldr	r3, [r7, #12]
 801ad24:	f103 010c 	add.w	r1, r3, #12
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
 801ad28:	68fb      	ldr	r3, [r7, #12]
 801ad2a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad2e:	3364      	adds	r3, #100	; 0x64
 801ad30:	681a      	ldr	r2, [r3, #0]
 801ad32:	68fb      	ldr	r3, [r7, #12]
 801ad34:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad38:	335e      	adds	r3, #94	; 0x5e
 801ad3a:	881b      	ldrh	r3, [r3, #0]
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 801ad3c:	fbb2 f2f3 	udiv	r2, r2, r3
                              len / hmsc->scsi_blk_size) < 0)
 801ad40:	68fb      	ldr	r3, [r7, #12]
 801ad42:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad46:	335e      	adds	r3, #94	; 0x5e
 801ad48:	881b      	ldrh	r3, [r3, #0]
 801ad4a:	4618      	mov	r0, r3
 801ad4c:	68bb      	ldr	r3, [r7, #8]
 801ad4e:	fbb3 f3f0 	udiv	r3, r3, r0
  if( ((USBD_StorageTypeDef *)pdev->pUserData)->Read(lun ,
 801ad52:	b29b      	uxth	r3, r3
 801ad54:	78f8      	ldrb	r0, [r7, #3]
 801ad56:	47a0      	blx	r4
 801ad58:	4603      	mov	r3, r0
 801ad5a:	2b00      	cmp	r3, #0
 801ad5c:	da08      	bge.n	801ad70 <SCSI_ProcessRead+0x80>
  {
    
    SCSI_SenseCode(pdev,
 801ad5e:	78f9      	ldrb	r1, [r7, #3]
 801ad60:	2311      	movs	r3, #17
 801ad62:	2204      	movs	r2, #4
 801ad64:	6878      	ldr	r0, [r7, #4]
 801ad66:	f7ff fd65 	bl	801a834 <SCSI_SenseCode>
                   lun, 
                   HARDWARE_ERROR, 
                   UNRECOVERED_READ_ERROR);
    return -1; 
 801ad6a:	f04f 33ff 	mov.w	r3, #4294967295
 801ad6e:	e037      	b.n	801ade0 <SCSI_ProcessRead+0xf0>
  }
  
  
  USBD_LL_Transmit (pdev, 
             MSC_EPIN_ADDR,
             hmsc->bot_data,
 801ad70:	68fb      	ldr	r3, [r7, #12]
 801ad72:	f103 020c 	add.w	r2, r3, #12
  USBD_LL_Transmit (pdev, 
 801ad76:	68bb      	ldr	r3, [r7, #8]
 801ad78:	b29b      	uxth	r3, r3
 801ad7a:	2181      	movs	r1, #129	; 0x81
 801ad7c:	6878      	ldr	r0, [r7, #4]
 801ad7e:	f7f6 f9d9 	bl	8011134 <USBD_LL_Transmit>
             len);
  
  
  hmsc->scsi_blk_addr   += len; 
 801ad82:	68fb      	ldr	r3, [r7, #12]
 801ad84:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad88:	3364      	adds	r3, #100	; 0x64
 801ad8a:	681a      	ldr	r2, [r3, #0]
 801ad8c:	68bb      	ldr	r3, [r7, #8]
 801ad8e:	441a      	add	r2, r3
 801ad90:	68fb      	ldr	r3, [r7, #12]
 801ad92:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ad96:	3364      	adds	r3, #100	; 0x64
 801ad98:	601a      	str	r2, [r3, #0]
  hmsc->scsi_blk_len    -= len;  
 801ad9a:	68fb      	ldr	r3, [r7, #12]
 801ad9c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ada0:	3368      	adds	r3, #104	; 0x68
 801ada2:	681a      	ldr	r2, [r3, #0]
 801ada4:	68bb      	ldr	r3, [r7, #8]
 801ada6:	1ad2      	subs	r2, r2, r3
 801ada8:	68fb      	ldr	r3, [r7, #12]
 801adaa:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801adae:	3368      	adds	r3, #104	; 0x68
 801adb0:	601a      	str	r2, [r3, #0]
  
  /* case 6 : Hi = Di */
  hmsc->csw.dDataResidue -= len;
 801adb2:	68fb      	ldr	r3, [r7, #12]
 801adb4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801adb8:	3334      	adds	r3, #52	; 0x34
 801adba:	681a      	ldr	r2, [r3, #0]
 801adbc:	68bb      	ldr	r3, [r7, #8]
 801adbe:	1ad2      	subs	r2, r2, r3
 801adc0:	68fb      	ldr	r3, [r7, #12]
 801adc2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801adc6:	3334      	adds	r3, #52	; 0x34
 801adc8:	601a      	str	r2, [r3, #0]
  
  if (hmsc->scsi_blk_len == 0)
 801adca:	68fb      	ldr	r3, [r7, #12]
 801adcc:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801add0:	3368      	adds	r3, #104	; 0x68
 801add2:	681b      	ldr	r3, [r3, #0]
 801add4:	2b00      	cmp	r3, #0
 801add6:	d102      	bne.n	801adde <SCSI_ProcessRead+0xee>
  {
    hmsc->bot_state = USBD_BOT_LAST_DATA_IN;
 801add8:	68fb      	ldr	r3, [r7, #12]
 801adda:	2203      	movs	r2, #3
 801addc:	721a      	strb	r2, [r3, #8]
  }
  return 0;
 801adde:	2300      	movs	r3, #0
}
 801ade0:	4618      	mov	r0, r3
 801ade2:	3714      	adds	r7, #20
 801ade4:	46bd      	mov	sp, r7
 801ade6:	bd90      	pop	{r4, r7, pc}

0801ade8 <SCSI_ProcessWrite>:
* @param  lun: Logical unit number
* @retval status
*/

static int8_t SCSI_ProcessWrite (USBD_HandleTypeDef  *pdev, uint8_t lun)
{
 801ade8:	b590      	push	{r4, r7, lr}
 801adea:	b085      	sub	sp, #20
 801adec:	af00      	add	r7, sp, #0
 801adee:	6078      	str	r0, [r7, #4]
 801adf0:	460b      	mov	r3, r1
 801adf2:	70fb      	strb	r3, [r7, #3]
  uint32_t len;
  USBD_MSC_BOT_HandleTypeDef  *hmsc = (USBD_MSC_BOT_HandleTypeDef*) pdev->pClassData; 
 801adf4:	687b      	ldr	r3, [r7, #4]
 801adf6:	f8d3 3218 	ldr.w	r3, [r3, #536]	; 0x218
 801adfa:	60fb      	str	r3, [r7, #12]
  
  len = MIN(hmsc->scsi_blk_len , MSC_MEDIA_PACKET); 
 801adfc:	68fb      	ldr	r3, [r7, #12]
 801adfe:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae02:	3368      	adds	r3, #104	; 0x68
 801ae04:	681b      	ldr	r3, [r3, #0]
 801ae06:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801ae0a:	bf28      	it	cs
 801ae0c:	f44f 4380 	movcs.w	r3, #16384	; 0x4000
 801ae10:	60bb      	str	r3, [r7, #8]
  
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 801ae12:	687b      	ldr	r3, [r7, #4]
 801ae14:	f8d3 321c 	ldr.w	r3, [r3, #540]	; 0x21c
 801ae18:	695c      	ldr	r4, [r3, #20]
                              hmsc->bot_data, 
 801ae1a:	68fb      	ldr	r3, [r7, #12]
 801ae1c:	f103 010c 	add.w	r1, r3, #12
                              hmsc->scsi_blk_addr / hmsc->scsi_blk_size, 
 801ae20:	68fb      	ldr	r3, [r7, #12]
 801ae22:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae26:	3364      	adds	r3, #100	; 0x64
 801ae28:	681a      	ldr	r2, [r3, #0]
 801ae2a:	68fb      	ldr	r3, [r7, #12]
 801ae2c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae30:	335e      	adds	r3, #94	; 0x5e
 801ae32:	881b      	ldrh	r3, [r3, #0]
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 801ae34:	fbb2 f2f3 	udiv	r2, r2, r3
                              len / hmsc->scsi_blk_size) < 0)
 801ae38:	68fb      	ldr	r3, [r7, #12]
 801ae3a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae3e:	335e      	adds	r3, #94	; 0x5e
 801ae40:	881b      	ldrh	r3, [r3, #0]
 801ae42:	4618      	mov	r0, r3
 801ae44:	68bb      	ldr	r3, [r7, #8]
 801ae46:	fbb3 f3f0 	udiv	r3, r3, r0
  if(((USBD_StorageTypeDef *)pdev->pUserData)->Write(lun ,
 801ae4a:	b29b      	uxth	r3, r3
 801ae4c:	78f8      	ldrb	r0, [r7, #3]
 801ae4e:	47a0      	blx	r4
 801ae50:	4603      	mov	r3, r0
 801ae52:	2b00      	cmp	r3, #0
 801ae54:	da08      	bge.n	801ae68 <SCSI_ProcessWrite+0x80>
  {
    SCSI_SenseCode(pdev,
 801ae56:	78f9      	ldrb	r1, [r7, #3]
 801ae58:	2303      	movs	r3, #3
 801ae5a:	2204      	movs	r2, #4
 801ae5c:	6878      	ldr	r0, [r7, #4]
 801ae5e:	f7ff fce9 	bl	801a834 <SCSI_SenseCode>
                   lun, 
                   HARDWARE_ERROR, 
                   WRITE_FAULT);     
    return -1; 
 801ae62:	f04f 33ff 	mov.w	r3, #4294967295
 801ae66:	e042      	b.n	801aeee <SCSI_ProcessWrite+0x106>
  }
  
  
  hmsc->scsi_blk_addr  += len; 
 801ae68:	68fb      	ldr	r3, [r7, #12]
 801ae6a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae6e:	3364      	adds	r3, #100	; 0x64
 801ae70:	681a      	ldr	r2, [r3, #0]
 801ae72:	68bb      	ldr	r3, [r7, #8]
 801ae74:	441a      	add	r2, r3
 801ae76:	68fb      	ldr	r3, [r7, #12]
 801ae78:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae7c:	3364      	adds	r3, #100	; 0x64
 801ae7e:	601a      	str	r2, [r3, #0]
  hmsc->scsi_blk_len   -= len; 
 801ae80:	68fb      	ldr	r3, [r7, #12]
 801ae82:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae86:	3368      	adds	r3, #104	; 0x68
 801ae88:	681a      	ldr	r2, [r3, #0]
 801ae8a:	68bb      	ldr	r3, [r7, #8]
 801ae8c:	1ad2      	subs	r2, r2, r3
 801ae8e:	68fb      	ldr	r3, [r7, #12]
 801ae90:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae94:	3368      	adds	r3, #104	; 0x68
 801ae96:	601a      	str	r2, [r3, #0]
  
  /* case 12 : Ho = Do */
  hmsc->csw.dDataResidue -= len;
 801ae98:	68fb      	ldr	r3, [r7, #12]
 801ae9a:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801ae9e:	3334      	adds	r3, #52	; 0x34
 801aea0:	681a      	ldr	r2, [r3, #0]
 801aea2:	68bb      	ldr	r3, [r7, #8]
 801aea4:	1ad2      	subs	r2, r2, r3
 801aea6:	68fb      	ldr	r3, [r7, #12]
 801aea8:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aeac:	3334      	adds	r3, #52	; 0x34
 801aeae:	601a      	str	r2, [r3, #0]
  
  if (hmsc->scsi_blk_len == 0)
 801aeb0:	68fb      	ldr	r3, [r7, #12]
 801aeb2:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aeb6:	3368      	adds	r3, #104	; 0x68
 801aeb8:	681b      	ldr	r3, [r3, #0]
 801aeba:	2b00      	cmp	r3, #0
 801aebc:	d104      	bne.n	801aec8 <SCSI_ProcessWrite+0xe0>
  {
    MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED);
 801aebe:	2100      	movs	r1, #0
 801aec0:	6878      	ldr	r0, [r7, #4]
 801aec2:	f7ff f8bd 	bl	801a040 <MSC_BOT_SendCSW>
 801aec6:	e011      	b.n	801aeec <SCSI_ProcessWrite+0x104>
  else
  {
    /* Prepare EP to Receive next packet */
    USBD_LL_PrepareReceive (pdev,
                            MSC_EPOUT_ADDR,
                            hmsc->bot_data, 
 801aec8:	68fb      	ldr	r3, [r7, #12]
 801aeca:	f103 020c 	add.w	r2, r3, #12
                            MIN (hmsc->scsi_blk_len, MSC_MEDIA_PACKET)); 
 801aece:	68fb      	ldr	r3, [r7, #12]
 801aed0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
 801aed4:	3368      	adds	r3, #104	; 0x68
 801aed6:	681b      	ldr	r3, [r3, #0]
 801aed8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 801aedc:	bf28      	it	cs
 801aede:	f44f 4380 	movcs.w	r3, #16384	; 0x4000
    USBD_LL_PrepareReceive (pdev,
 801aee2:	b29b      	uxth	r3, r3
 801aee4:	2101      	movs	r1, #1
 801aee6:	6878      	ldr	r0, [r7, #4]
 801aee8:	f7f6 f93b 	bl	8011162 <USBD_LL_PrepareReceive>
  }
  
  return 0;
 801aeec:	2300      	movs	r3, #0
}
 801aeee:	4618      	mov	r0, r3
 801aef0:	3714      	adds	r7, #20
 801aef2:	46bd      	mov	sp, r7
 801aef4:	bd90      	pop	{r4, r7, pc}
	...

0801aef8 <exit>:
 801aef8:	b508      	push	{r3, lr}
 801aefa:	4b07      	ldr	r3, [pc, #28]	; (801af18 <exit+0x20>)
 801aefc:	4604      	mov	r4, r0
 801aefe:	b113      	cbz	r3, 801af06 <exit+0xe>
 801af00:	2100      	movs	r1, #0
 801af02:	f3af 8000 	nop.w
 801af06:	4b05      	ldr	r3, [pc, #20]	; (801af1c <exit+0x24>)
 801af08:	6818      	ldr	r0, [r3, #0]
 801af0a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 801af0c:	b103      	cbz	r3, 801af10 <exit+0x18>
 801af0e:	4798      	blx	r3
 801af10:	4620      	mov	r0, r4
 801af12:	f000 fc65 	bl	801b7e0 <_exit>
 801af16:	bf00      	nop
 801af18:	00000000 	.word	0x00000000
 801af1c:	0801e214 	.word	0x0801e214

0801af20 <__libc_init_array>:
 801af20:	b570      	push	{r4, r5, r6, lr}
 801af22:	4e0d      	ldr	r6, [pc, #52]	; (801af58 <__libc_init_array+0x38>)
 801af24:	4c0d      	ldr	r4, [pc, #52]	; (801af5c <__libc_init_array+0x3c>)
 801af26:	1ba4      	subs	r4, r4, r6
 801af28:	10a4      	asrs	r4, r4, #2
 801af2a:	2500      	movs	r5, #0
 801af2c:	42a5      	cmp	r5, r4
 801af2e:	d109      	bne.n	801af44 <__libc_init_array+0x24>
 801af30:	4e0b      	ldr	r6, [pc, #44]	; (801af60 <__libc_init_array+0x40>)
 801af32:	4c0c      	ldr	r4, [pc, #48]	; (801af64 <__libc_init_array+0x44>)
 801af34:	f000 fc56 	bl	801b7e4 <_init>
 801af38:	1ba4      	subs	r4, r4, r6
 801af3a:	10a4      	asrs	r4, r4, #2
 801af3c:	2500      	movs	r5, #0
 801af3e:	42a5      	cmp	r5, r4
 801af40:	d105      	bne.n	801af4e <__libc_init_array+0x2e>
 801af42:	bd70      	pop	{r4, r5, r6, pc}
 801af44:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801af48:	4798      	blx	r3
 801af4a:	3501      	adds	r5, #1
 801af4c:	e7ee      	b.n	801af2c <__libc_init_array+0xc>
 801af4e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801af52:	4798      	blx	r3
 801af54:	3501      	adds	r5, #1
 801af56:	e7f2      	b.n	801af3e <__libc_init_array+0x1e>
 801af58:	0801e24c 	.word	0x0801e24c
 801af5c:	0801e24c 	.word	0x0801e24c
 801af60:	0801e24c 	.word	0x0801e24c
 801af64:	0801e250 	.word	0x0801e250

0801af68 <malloc>:
 801af68:	4b02      	ldr	r3, [pc, #8]	; (801af74 <malloc+0xc>)
 801af6a:	4601      	mov	r1, r0
 801af6c:	6818      	ldr	r0, [r3, #0]
 801af6e:	f000 b895 	b.w	801b09c <_malloc_r>
 801af72:	bf00      	nop
 801af74:	20000400 	.word	0x20000400

0801af78 <free>:
 801af78:	4b02      	ldr	r3, [pc, #8]	; (801af84 <free+0xc>)
 801af7a:	4601      	mov	r1, r0
 801af7c:	6818      	ldr	r0, [r3, #0]
 801af7e:	f000 b83f 	b.w	801b000 <_free_r>
 801af82:	bf00      	nop
 801af84:	20000400 	.word	0x20000400

0801af88 <memcmp>:
 801af88:	b530      	push	{r4, r5, lr}
 801af8a:	2400      	movs	r4, #0
 801af8c:	42a2      	cmp	r2, r4
 801af8e:	d101      	bne.n	801af94 <memcmp+0xc>
 801af90:	2000      	movs	r0, #0
 801af92:	e007      	b.n	801afa4 <memcmp+0x1c>
 801af94:	5d03      	ldrb	r3, [r0, r4]
 801af96:	3401      	adds	r4, #1
 801af98:	190d      	adds	r5, r1, r4
 801af9a:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 801af9e:	42ab      	cmp	r3, r5
 801afa0:	d0f4      	beq.n	801af8c <memcmp+0x4>
 801afa2:	1b58      	subs	r0, r3, r5
 801afa4:	bd30      	pop	{r4, r5, pc}

0801afa6 <memcpy>:
 801afa6:	b510      	push	{r4, lr}
 801afa8:	1e43      	subs	r3, r0, #1
 801afaa:	440a      	add	r2, r1
 801afac:	4291      	cmp	r1, r2
 801afae:	d100      	bne.n	801afb2 <memcpy+0xc>
 801afb0:	bd10      	pop	{r4, pc}
 801afb2:	f811 4b01 	ldrb.w	r4, [r1], #1
 801afb6:	f803 4f01 	strb.w	r4, [r3, #1]!
 801afba:	e7f7      	b.n	801afac <memcpy+0x6>

0801afbc <memmove>:
 801afbc:	4288      	cmp	r0, r1
 801afbe:	b510      	push	{r4, lr}
 801afc0:	eb01 0302 	add.w	r3, r1, r2
 801afc4:	d807      	bhi.n	801afd6 <memmove+0x1a>
 801afc6:	1e42      	subs	r2, r0, #1
 801afc8:	4299      	cmp	r1, r3
 801afca:	d00a      	beq.n	801afe2 <memmove+0x26>
 801afcc:	f811 4b01 	ldrb.w	r4, [r1], #1
 801afd0:	f802 4f01 	strb.w	r4, [r2, #1]!
 801afd4:	e7f8      	b.n	801afc8 <memmove+0xc>
 801afd6:	4283      	cmp	r3, r0
 801afd8:	d9f5      	bls.n	801afc6 <memmove+0xa>
 801afda:	1881      	adds	r1, r0, r2
 801afdc:	1ad2      	subs	r2, r2, r3
 801afde:	42d3      	cmn	r3, r2
 801afe0:	d100      	bne.n	801afe4 <memmove+0x28>
 801afe2:	bd10      	pop	{r4, pc}
 801afe4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 801afe8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 801afec:	e7f7      	b.n	801afde <memmove+0x22>

0801afee <memset>:
 801afee:	4402      	add	r2, r0
 801aff0:	4603      	mov	r3, r0
 801aff2:	4293      	cmp	r3, r2
 801aff4:	d100      	bne.n	801aff8 <memset+0xa>
 801aff6:	4770      	bx	lr
 801aff8:	f803 1b01 	strb.w	r1, [r3], #1
 801affc:	e7f9      	b.n	801aff2 <memset+0x4>
	...

0801b000 <_free_r>:
 801b000:	b538      	push	{r3, r4, r5, lr}
 801b002:	4605      	mov	r5, r0
 801b004:	2900      	cmp	r1, #0
 801b006:	d045      	beq.n	801b094 <_free_r+0x94>
 801b008:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801b00c:	1f0c      	subs	r4, r1, #4
 801b00e:	2b00      	cmp	r3, #0
 801b010:	bfb8      	it	lt
 801b012:	18e4      	addlt	r4, r4, r3
 801b014:	f000 f8cc 	bl	801b1b0 <__malloc_lock>
 801b018:	4a1f      	ldr	r2, [pc, #124]	; (801b098 <_free_r+0x98>)
 801b01a:	6813      	ldr	r3, [r2, #0]
 801b01c:	4610      	mov	r0, r2
 801b01e:	b933      	cbnz	r3, 801b02e <_free_r+0x2e>
 801b020:	6063      	str	r3, [r4, #4]
 801b022:	6014      	str	r4, [r2, #0]
 801b024:	4628      	mov	r0, r5
 801b026:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801b02a:	f000 b8c2 	b.w	801b1b2 <__malloc_unlock>
 801b02e:	42a3      	cmp	r3, r4
 801b030:	d90c      	bls.n	801b04c <_free_r+0x4c>
 801b032:	6821      	ldr	r1, [r4, #0]
 801b034:	1862      	adds	r2, r4, r1
 801b036:	4293      	cmp	r3, r2
 801b038:	bf04      	itt	eq
 801b03a:	681a      	ldreq	r2, [r3, #0]
 801b03c:	685b      	ldreq	r3, [r3, #4]
 801b03e:	6063      	str	r3, [r4, #4]
 801b040:	bf04      	itt	eq
 801b042:	1852      	addeq	r2, r2, r1
 801b044:	6022      	streq	r2, [r4, #0]
 801b046:	6004      	str	r4, [r0, #0]
 801b048:	e7ec      	b.n	801b024 <_free_r+0x24>
 801b04a:	4613      	mov	r3, r2
 801b04c:	685a      	ldr	r2, [r3, #4]
 801b04e:	b10a      	cbz	r2, 801b054 <_free_r+0x54>
 801b050:	42a2      	cmp	r2, r4
 801b052:	d9fa      	bls.n	801b04a <_free_r+0x4a>
 801b054:	6819      	ldr	r1, [r3, #0]
 801b056:	1858      	adds	r0, r3, r1
 801b058:	42a0      	cmp	r0, r4
 801b05a:	d10b      	bne.n	801b074 <_free_r+0x74>
 801b05c:	6820      	ldr	r0, [r4, #0]
 801b05e:	4401      	add	r1, r0
 801b060:	1858      	adds	r0, r3, r1
 801b062:	4282      	cmp	r2, r0
 801b064:	6019      	str	r1, [r3, #0]
 801b066:	d1dd      	bne.n	801b024 <_free_r+0x24>
 801b068:	6810      	ldr	r0, [r2, #0]
 801b06a:	6852      	ldr	r2, [r2, #4]
 801b06c:	605a      	str	r2, [r3, #4]
 801b06e:	4401      	add	r1, r0
 801b070:	6019      	str	r1, [r3, #0]
 801b072:	e7d7      	b.n	801b024 <_free_r+0x24>
 801b074:	d902      	bls.n	801b07c <_free_r+0x7c>
 801b076:	230c      	movs	r3, #12
 801b078:	602b      	str	r3, [r5, #0]
 801b07a:	e7d3      	b.n	801b024 <_free_r+0x24>
 801b07c:	6820      	ldr	r0, [r4, #0]
 801b07e:	1821      	adds	r1, r4, r0
 801b080:	428a      	cmp	r2, r1
 801b082:	bf04      	itt	eq
 801b084:	6811      	ldreq	r1, [r2, #0]
 801b086:	6852      	ldreq	r2, [r2, #4]
 801b088:	6062      	str	r2, [r4, #4]
 801b08a:	bf04      	itt	eq
 801b08c:	1809      	addeq	r1, r1, r0
 801b08e:	6021      	streq	r1, [r4, #0]
 801b090:	605c      	str	r4, [r3, #4]
 801b092:	e7c7      	b.n	801b024 <_free_r+0x24>
 801b094:	bd38      	pop	{r3, r4, r5, pc}
 801b096:	bf00      	nop
 801b098:	20000494 	.word	0x20000494

0801b09c <_malloc_r>:
 801b09c:	b570      	push	{r4, r5, r6, lr}
 801b09e:	1ccd      	adds	r5, r1, #3
 801b0a0:	f025 0503 	bic.w	r5, r5, #3
 801b0a4:	3508      	adds	r5, #8
 801b0a6:	2d0c      	cmp	r5, #12
 801b0a8:	bf38      	it	cc
 801b0aa:	250c      	movcc	r5, #12
 801b0ac:	2d00      	cmp	r5, #0
 801b0ae:	4606      	mov	r6, r0
 801b0b0:	db01      	blt.n	801b0b6 <_malloc_r+0x1a>
 801b0b2:	42a9      	cmp	r1, r5
 801b0b4:	d903      	bls.n	801b0be <_malloc_r+0x22>
 801b0b6:	230c      	movs	r3, #12
 801b0b8:	6033      	str	r3, [r6, #0]
 801b0ba:	2000      	movs	r0, #0
 801b0bc:	bd70      	pop	{r4, r5, r6, pc}
 801b0be:	f000 f877 	bl	801b1b0 <__malloc_lock>
 801b0c2:	4a21      	ldr	r2, [pc, #132]	; (801b148 <_malloc_r+0xac>)
 801b0c4:	6814      	ldr	r4, [r2, #0]
 801b0c6:	4621      	mov	r1, r4
 801b0c8:	b991      	cbnz	r1, 801b0f0 <_malloc_r+0x54>
 801b0ca:	4c20      	ldr	r4, [pc, #128]	; (801b14c <_malloc_r+0xb0>)
 801b0cc:	6823      	ldr	r3, [r4, #0]
 801b0ce:	b91b      	cbnz	r3, 801b0d8 <_malloc_r+0x3c>
 801b0d0:	4630      	mov	r0, r6
 801b0d2:	f000 f83d 	bl	801b150 <_sbrk_r>
 801b0d6:	6020      	str	r0, [r4, #0]
 801b0d8:	4629      	mov	r1, r5
 801b0da:	4630      	mov	r0, r6
 801b0dc:	f000 f838 	bl	801b150 <_sbrk_r>
 801b0e0:	1c43      	adds	r3, r0, #1
 801b0e2:	d124      	bne.n	801b12e <_malloc_r+0x92>
 801b0e4:	230c      	movs	r3, #12
 801b0e6:	6033      	str	r3, [r6, #0]
 801b0e8:	4630      	mov	r0, r6
 801b0ea:	f000 f862 	bl	801b1b2 <__malloc_unlock>
 801b0ee:	e7e4      	b.n	801b0ba <_malloc_r+0x1e>
 801b0f0:	680b      	ldr	r3, [r1, #0]
 801b0f2:	1b5b      	subs	r3, r3, r5
 801b0f4:	d418      	bmi.n	801b128 <_malloc_r+0x8c>
 801b0f6:	2b0b      	cmp	r3, #11
 801b0f8:	d90f      	bls.n	801b11a <_malloc_r+0x7e>
 801b0fa:	600b      	str	r3, [r1, #0]
 801b0fc:	50cd      	str	r5, [r1, r3]
 801b0fe:	18cc      	adds	r4, r1, r3
 801b100:	4630      	mov	r0, r6
 801b102:	f000 f856 	bl	801b1b2 <__malloc_unlock>
 801b106:	f104 000b 	add.w	r0, r4, #11
 801b10a:	1d23      	adds	r3, r4, #4
 801b10c:	f020 0007 	bic.w	r0, r0, #7
 801b110:	1ac3      	subs	r3, r0, r3
 801b112:	d0d3      	beq.n	801b0bc <_malloc_r+0x20>
 801b114:	425a      	negs	r2, r3
 801b116:	50e2      	str	r2, [r4, r3]
 801b118:	e7d0      	b.n	801b0bc <_malloc_r+0x20>
 801b11a:	428c      	cmp	r4, r1
 801b11c:	684b      	ldr	r3, [r1, #4]
 801b11e:	bf16      	itet	ne
 801b120:	6063      	strne	r3, [r4, #4]
 801b122:	6013      	streq	r3, [r2, #0]
 801b124:	460c      	movne	r4, r1
 801b126:	e7eb      	b.n	801b100 <_malloc_r+0x64>
 801b128:	460c      	mov	r4, r1
 801b12a:	6849      	ldr	r1, [r1, #4]
 801b12c:	e7cc      	b.n	801b0c8 <_malloc_r+0x2c>
 801b12e:	1cc4      	adds	r4, r0, #3
 801b130:	f024 0403 	bic.w	r4, r4, #3
 801b134:	42a0      	cmp	r0, r4
 801b136:	d005      	beq.n	801b144 <_malloc_r+0xa8>
 801b138:	1a21      	subs	r1, r4, r0
 801b13a:	4630      	mov	r0, r6
 801b13c:	f000 f808 	bl	801b150 <_sbrk_r>
 801b140:	3001      	adds	r0, #1
 801b142:	d0cf      	beq.n	801b0e4 <_malloc_r+0x48>
 801b144:	6025      	str	r5, [r4, #0]
 801b146:	e7db      	b.n	801b100 <_malloc_r+0x64>
 801b148:	20000494 	.word	0x20000494
 801b14c:	20000498 	.word	0x20000498

0801b150 <_sbrk_r>:
 801b150:	b538      	push	{r3, r4, r5, lr}
 801b152:	4c06      	ldr	r4, [pc, #24]	; (801b16c <_sbrk_r+0x1c>)
 801b154:	2300      	movs	r3, #0
 801b156:	4605      	mov	r5, r0
 801b158:	4608      	mov	r0, r1
 801b15a:	6023      	str	r3, [r4, #0]
 801b15c:	f000 fb32 	bl	801b7c4 <_sbrk>
 801b160:	1c43      	adds	r3, r0, #1
 801b162:	d102      	bne.n	801b16a <_sbrk_r+0x1a>
 801b164:	6823      	ldr	r3, [r4, #0]
 801b166:	b103      	cbz	r3, 801b16a <_sbrk_r+0x1a>
 801b168:	602b      	str	r3, [r5, #0]
 801b16a:	bd38      	pop	{r3, r4, r5, pc}
 801b16c:	2000da5c 	.word	0x2000da5c

0801b170 <siprintf>:
 801b170:	b40e      	push	{r1, r2, r3}
 801b172:	b500      	push	{lr}
 801b174:	b09c      	sub	sp, #112	; 0x70
 801b176:	ab1d      	add	r3, sp, #116	; 0x74
 801b178:	9002      	str	r0, [sp, #8]
 801b17a:	9006      	str	r0, [sp, #24]
 801b17c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 801b180:	4809      	ldr	r0, [pc, #36]	; (801b1a8 <siprintf+0x38>)
 801b182:	9107      	str	r1, [sp, #28]
 801b184:	9104      	str	r1, [sp, #16]
 801b186:	4909      	ldr	r1, [pc, #36]	; (801b1ac <siprintf+0x3c>)
 801b188:	f853 2b04 	ldr.w	r2, [r3], #4
 801b18c:	9105      	str	r1, [sp, #20]
 801b18e:	6800      	ldr	r0, [r0, #0]
 801b190:	9301      	str	r3, [sp, #4]
 801b192:	a902      	add	r1, sp, #8
 801b194:	f000 f868 	bl	801b268 <_svfiprintf_r>
 801b198:	9b02      	ldr	r3, [sp, #8]
 801b19a:	2200      	movs	r2, #0
 801b19c:	701a      	strb	r2, [r3, #0]
 801b19e:	b01c      	add	sp, #112	; 0x70
 801b1a0:	f85d eb04 	ldr.w	lr, [sp], #4
 801b1a4:	b003      	add	sp, #12
 801b1a6:	4770      	bx	lr
 801b1a8:	20000400 	.word	0x20000400
 801b1ac:	ffff0208 	.word	0xffff0208

0801b1b0 <__malloc_lock>:
 801b1b0:	4770      	bx	lr

0801b1b2 <__malloc_unlock>:
 801b1b2:	4770      	bx	lr

0801b1b4 <__ssputs_r>:
 801b1b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801b1b8:	688e      	ldr	r6, [r1, #8]
 801b1ba:	429e      	cmp	r6, r3
 801b1bc:	4682      	mov	sl, r0
 801b1be:	460c      	mov	r4, r1
 801b1c0:	4690      	mov	r8, r2
 801b1c2:	4699      	mov	r9, r3
 801b1c4:	d837      	bhi.n	801b236 <__ssputs_r+0x82>
 801b1c6:	898a      	ldrh	r2, [r1, #12]
 801b1c8:	f412 6f90 	tst.w	r2, #1152	; 0x480
 801b1cc:	d031      	beq.n	801b232 <__ssputs_r+0x7e>
 801b1ce:	6825      	ldr	r5, [r4, #0]
 801b1d0:	6909      	ldr	r1, [r1, #16]
 801b1d2:	1a6f      	subs	r7, r5, r1
 801b1d4:	6965      	ldr	r5, [r4, #20]
 801b1d6:	2302      	movs	r3, #2
 801b1d8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 801b1dc:	fb95 f5f3 	sdiv	r5, r5, r3
 801b1e0:	f109 0301 	add.w	r3, r9, #1
 801b1e4:	443b      	add	r3, r7
 801b1e6:	429d      	cmp	r5, r3
 801b1e8:	bf38      	it	cc
 801b1ea:	461d      	movcc	r5, r3
 801b1ec:	0553      	lsls	r3, r2, #21
 801b1ee:	d530      	bpl.n	801b252 <__ssputs_r+0x9e>
 801b1f0:	4629      	mov	r1, r5
 801b1f2:	f7ff ff53 	bl	801b09c <_malloc_r>
 801b1f6:	4606      	mov	r6, r0
 801b1f8:	b950      	cbnz	r0, 801b210 <__ssputs_r+0x5c>
 801b1fa:	230c      	movs	r3, #12
 801b1fc:	f8ca 3000 	str.w	r3, [sl]
 801b200:	89a3      	ldrh	r3, [r4, #12]
 801b202:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801b206:	81a3      	strh	r3, [r4, #12]
 801b208:	f04f 30ff 	mov.w	r0, #4294967295
 801b20c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801b210:	463a      	mov	r2, r7
 801b212:	6921      	ldr	r1, [r4, #16]
 801b214:	f7ff fec7 	bl	801afa6 <memcpy>
 801b218:	89a3      	ldrh	r3, [r4, #12]
 801b21a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801b21e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801b222:	81a3      	strh	r3, [r4, #12]
 801b224:	6126      	str	r6, [r4, #16]
 801b226:	6165      	str	r5, [r4, #20]
 801b228:	443e      	add	r6, r7
 801b22a:	1bed      	subs	r5, r5, r7
 801b22c:	6026      	str	r6, [r4, #0]
 801b22e:	60a5      	str	r5, [r4, #8]
 801b230:	464e      	mov	r6, r9
 801b232:	454e      	cmp	r6, r9
 801b234:	d900      	bls.n	801b238 <__ssputs_r+0x84>
 801b236:	464e      	mov	r6, r9
 801b238:	4632      	mov	r2, r6
 801b23a:	4641      	mov	r1, r8
 801b23c:	6820      	ldr	r0, [r4, #0]
 801b23e:	f7ff febd 	bl	801afbc <memmove>
 801b242:	68a3      	ldr	r3, [r4, #8]
 801b244:	1b9b      	subs	r3, r3, r6
 801b246:	60a3      	str	r3, [r4, #8]
 801b248:	6823      	ldr	r3, [r4, #0]
 801b24a:	441e      	add	r6, r3
 801b24c:	6026      	str	r6, [r4, #0]
 801b24e:	2000      	movs	r0, #0
 801b250:	e7dc      	b.n	801b20c <__ssputs_r+0x58>
 801b252:	462a      	mov	r2, r5
 801b254:	f000 fa88 	bl	801b768 <_realloc_r>
 801b258:	4606      	mov	r6, r0
 801b25a:	2800      	cmp	r0, #0
 801b25c:	d1e2      	bne.n	801b224 <__ssputs_r+0x70>
 801b25e:	6921      	ldr	r1, [r4, #16]
 801b260:	4650      	mov	r0, sl
 801b262:	f7ff fecd 	bl	801b000 <_free_r>
 801b266:	e7c8      	b.n	801b1fa <__ssputs_r+0x46>

0801b268 <_svfiprintf_r>:
 801b268:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b26c:	461d      	mov	r5, r3
 801b26e:	898b      	ldrh	r3, [r1, #12]
 801b270:	061f      	lsls	r7, r3, #24
 801b272:	b09d      	sub	sp, #116	; 0x74
 801b274:	4680      	mov	r8, r0
 801b276:	460c      	mov	r4, r1
 801b278:	4616      	mov	r6, r2
 801b27a:	d50f      	bpl.n	801b29c <_svfiprintf_r+0x34>
 801b27c:	690b      	ldr	r3, [r1, #16]
 801b27e:	b96b      	cbnz	r3, 801b29c <_svfiprintf_r+0x34>
 801b280:	2140      	movs	r1, #64	; 0x40
 801b282:	f7ff ff0b 	bl	801b09c <_malloc_r>
 801b286:	6020      	str	r0, [r4, #0]
 801b288:	6120      	str	r0, [r4, #16]
 801b28a:	b928      	cbnz	r0, 801b298 <_svfiprintf_r+0x30>
 801b28c:	230c      	movs	r3, #12
 801b28e:	f8c8 3000 	str.w	r3, [r8]
 801b292:	f04f 30ff 	mov.w	r0, #4294967295
 801b296:	e0c8      	b.n	801b42a <_svfiprintf_r+0x1c2>
 801b298:	2340      	movs	r3, #64	; 0x40
 801b29a:	6163      	str	r3, [r4, #20]
 801b29c:	2300      	movs	r3, #0
 801b29e:	9309      	str	r3, [sp, #36]	; 0x24
 801b2a0:	2320      	movs	r3, #32
 801b2a2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801b2a6:	2330      	movs	r3, #48	; 0x30
 801b2a8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 801b2ac:	9503      	str	r5, [sp, #12]
 801b2ae:	f04f 0b01 	mov.w	fp, #1
 801b2b2:	4637      	mov	r7, r6
 801b2b4:	463d      	mov	r5, r7
 801b2b6:	f815 3b01 	ldrb.w	r3, [r5], #1
 801b2ba:	b10b      	cbz	r3, 801b2c0 <_svfiprintf_r+0x58>
 801b2bc:	2b25      	cmp	r3, #37	; 0x25
 801b2be:	d13e      	bne.n	801b33e <_svfiprintf_r+0xd6>
 801b2c0:	ebb7 0a06 	subs.w	sl, r7, r6
 801b2c4:	d00b      	beq.n	801b2de <_svfiprintf_r+0x76>
 801b2c6:	4653      	mov	r3, sl
 801b2c8:	4632      	mov	r2, r6
 801b2ca:	4621      	mov	r1, r4
 801b2cc:	4640      	mov	r0, r8
 801b2ce:	f7ff ff71 	bl	801b1b4 <__ssputs_r>
 801b2d2:	3001      	adds	r0, #1
 801b2d4:	f000 80a4 	beq.w	801b420 <_svfiprintf_r+0x1b8>
 801b2d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b2da:	4453      	add	r3, sl
 801b2dc:	9309      	str	r3, [sp, #36]	; 0x24
 801b2de:	783b      	ldrb	r3, [r7, #0]
 801b2e0:	2b00      	cmp	r3, #0
 801b2e2:	f000 809d 	beq.w	801b420 <_svfiprintf_r+0x1b8>
 801b2e6:	2300      	movs	r3, #0
 801b2e8:	f04f 32ff 	mov.w	r2, #4294967295
 801b2ec:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801b2f0:	9304      	str	r3, [sp, #16]
 801b2f2:	9307      	str	r3, [sp, #28]
 801b2f4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801b2f8:	931a      	str	r3, [sp, #104]	; 0x68
 801b2fa:	462f      	mov	r7, r5
 801b2fc:	2205      	movs	r2, #5
 801b2fe:	f817 1b01 	ldrb.w	r1, [r7], #1
 801b302:	4850      	ldr	r0, [pc, #320]	; (801b444 <_svfiprintf_r+0x1dc>)
 801b304:	f7e4 ff7c 	bl	8000200 <memchr>
 801b308:	9b04      	ldr	r3, [sp, #16]
 801b30a:	b9d0      	cbnz	r0, 801b342 <_svfiprintf_r+0xda>
 801b30c:	06d9      	lsls	r1, r3, #27
 801b30e:	bf44      	itt	mi
 801b310:	2220      	movmi	r2, #32
 801b312:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 801b316:	071a      	lsls	r2, r3, #28
 801b318:	bf44      	itt	mi
 801b31a:	222b      	movmi	r2, #43	; 0x2b
 801b31c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 801b320:	782a      	ldrb	r2, [r5, #0]
 801b322:	2a2a      	cmp	r2, #42	; 0x2a
 801b324:	d015      	beq.n	801b352 <_svfiprintf_r+0xea>
 801b326:	9a07      	ldr	r2, [sp, #28]
 801b328:	462f      	mov	r7, r5
 801b32a:	2000      	movs	r0, #0
 801b32c:	250a      	movs	r5, #10
 801b32e:	4639      	mov	r1, r7
 801b330:	f811 3b01 	ldrb.w	r3, [r1], #1
 801b334:	3b30      	subs	r3, #48	; 0x30
 801b336:	2b09      	cmp	r3, #9
 801b338:	d94d      	bls.n	801b3d6 <_svfiprintf_r+0x16e>
 801b33a:	b1b8      	cbz	r0, 801b36c <_svfiprintf_r+0x104>
 801b33c:	e00f      	b.n	801b35e <_svfiprintf_r+0xf6>
 801b33e:	462f      	mov	r7, r5
 801b340:	e7b8      	b.n	801b2b4 <_svfiprintf_r+0x4c>
 801b342:	4a40      	ldr	r2, [pc, #256]	; (801b444 <_svfiprintf_r+0x1dc>)
 801b344:	1a80      	subs	r0, r0, r2
 801b346:	fa0b f000 	lsl.w	r0, fp, r0
 801b34a:	4318      	orrs	r0, r3
 801b34c:	9004      	str	r0, [sp, #16]
 801b34e:	463d      	mov	r5, r7
 801b350:	e7d3      	b.n	801b2fa <_svfiprintf_r+0x92>
 801b352:	9a03      	ldr	r2, [sp, #12]
 801b354:	1d11      	adds	r1, r2, #4
 801b356:	6812      	ldr	r2, [r2, #0]
 801b358:	9103      	str	r1, [sp, #12]
 801b35a:	2a00      	cmp	r2, #0
 801b35c:	db01      	blt.n	801b362 <_svfiprintf_r+0xfa>
 801b35e:	9207      	str	r2, [sp, #28]
 801b360:	e004      	b.n	801b36c <_svfiprintf_r+0x104>
 801b362:	4252      	negs	r2, r2
 801b364:	f043 0302 	orr.w	r3, r3, #2
 801b368:	9207      	str	r2, [sp, #28]
 801b36a:	9304      	str	r3, [sp, #16]
 801b36c:	783b      	ldrb	r3, [r7, #0]
 801b36e:	2b2e      	cmp	r3, #46	; 0x2e
 801b370:	d10c      	bne.n	801b38c <_svfiprintf_r+0x124>
 801b372:	787b      	ldrb	r3, [r7, #1]
 801b374:	2b2a      	cmp	r3, #42	; 0x2a
 801b376:	d133      	bne.n	801b3e0 <_svfiprintf_r+0x178>
 801b378:	9b03      	ldr	r3, [sp, #12]
 801b37a:	1d1a      	adds	r2, r3, #4
 801b37c:	681b      	ldr	r3, [r3, #0]
 801b37e:	9203      	str	r2, [sp, #12]
 801b380:	2b00      	cmp	r3, #0
 801b382:	bfb8      	it	lt
 801b384:	f04f 33ff 	movlt.w	r3, #4294967295
 801b388:	3702      	adds	r7, #2
 801b38a:	9305      	str	r3, [sp, #20]
 801b38c:	4d2e      	ldr	r5, [pc, #184]	; (801b448 <_svfiprintf_r+0x1e0>)
 801b38e:	7839      	ldrb	r1, [r7, #0]
 801b390:	2203      	movs	r2, #3
 801b392:	4628      	mov	r0, r5
 801b394:	f7e4 ff34 	bl	8000200 <memchr>
 801b398:	b138      	cbz	r0, 801b3aa <_svfiprintf_r+0x142>
 801b39a:	2340      	movs	r3, #64	; 0x40
 801b39c:	1b40      	subs	r0, r0, r5
 801b39e:	fa03 f000 	lsl.w	r0, r3, r0
 801b3a2:	9b04      	ldr	r3, [sp, #16]
 801b3a4:	4303      	orrs	r3, r0
 801b3a6:	3701      	adds	r7, #1
 801b3a8:	9304      	str	r3, [sp, #16]
 801b3aa:	7839      	ldrb	r1, [r7, #0]
 801b3ac:	4827      	ldr	r0, [pc, #156]	; (801b44c <_svfiprintf_r+0x1e4>)
 801b3ae:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801b3b2:	2206      	movs	r2, #6
 801b3b4:	1c7e      	adds	r6, r7, #1
 801b3b6:	f7e4 ff23 	bl	8000200 <memchr>
 801b3ba:	2800      	cmp	r0, #0
 801b3bc:	d038      	beq.n	801b430 <_svfiprintf_r+0x1c8>
 801b3be:	4b24      	ldr	r3, [pc, #144]	; (801b450 <_svfiprintf_r+0x1e8>)
 801b3c0:	bb13      	cbnz	r3, 801b408 <_svfiprintf_r+0x1a0>
 801b3c2:	9b03      	ldr	r3, [sp, #12]
 801b3c4:	3307      	adds	r3, #7
 801b3c6:	f023 0307 	bic.w	r3, r3, #7
 801b3ca:	3308      	adds	r3, #8
 801b3cc:	9303      	str	r3, [sp, #12]
 801b3ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b3d0:	444b      	add	r3, r9
 801b3d2:	9309      	str	r3, [sp, #36]	; 0x24
 801b3d4:	e76d      	b.n	801b2b2 <_svfiprintf_r+0x4a>
 801b3d6:	fb05 3202 	mla	r2, r5, r2, r3
 801b3da:	2001      	movs	r0, #1
 801b3dc:	460f      	mov	r7, r1
 801b3de:	e7a6      	b.n	801b32e <_svfiprintf_r+0xc6>
 801b3e0:	2300      	movs	r3, #0
 801b3e2:	3701      	adds	r7, #1
 801b3e4:	9305      	str	r3, [sp, #20]
 801b3e6:	4619      	mov	r1, r3
 801b3e8:	250a      	movs	r5, #10
 801b3ea:	4638      	mov	r0, r7
 801b3ec:	f810 2b01 	ldrb.w	r2, [r0], #1
 801b3f0:	3a30      	subs	r2, #48	; 0x30
 801b3f2:	2a09      	cmp	r2, #9
 801b3f4:	d903      	bls.n	801b3fe <_svfiprintf_r+0x196>
 801b3f6:	2b00      	cmp	r3, #0
 801b3f8:	d0c8      	beq.n	801b38c <_svfiprintf_r+0x124>
 801b3fa:	9105      	str	r1, [sp, #20]
 801b3fc:	e7c6      	b.n	801b38c <_svfiprintf_r+0x124>
 801b3fe:	fb05 2101 	mla	r1, r5, r1, r2
 801b402:	2301      	movs	r3, #1
 801b404:	4607      	mov	r7, r0
 801b406:	e7f0      	b.n	801b3ea <_svfiprintf_r+0x182>
 801b408:	ab03      	add	r3, sp, #12
 801b40a:	9300      	str	r3, [sp, #0]
 801b40c:	4622      	mov	r2, r4
 801b40e:	4b11      	ldr	r3, [pc, #68]	; (801b454 <_svfiprintf_r+0x1ec>)
 801b410:	a904      	add	r1, sp, #16
 801b412:	4640      	mov	r0, r8
 801b414:	f3af 8000 	nop.w
 801b418:	f1b0 3fff 	cmp.w	r0, #4294967295
 801b41c:	4681      	mov	r9, r0
 801b41e:	d1d6      	bne.n	801b3ce <_svfiprintf_r+0x166>
 801b420:	89a3      	ldrh	r3, [r4, #12]
 801b422:	065b      	lsls	r3, r3, #25
 801b424:	f53f af35 	bmi.w	801b292 <_svfiprintf_r+0x2a>
 801b428:	9809      	ldr	r0, [sp, #36]	; 0x24
 801b42a:	b01d      	add	sp, #116	; 0x74
 801b42c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801b430:	ab03      	add	r3, sp, #12
 801b432:	9300      	str	r3, [sp, #0]
 801b434:	4622      	mov	r2, r4
 801b436:	4b07      	ldr	r3, [pc, #28]	; (801b454 <_svfiprintf_r+0x1ec>)
 801b438:	a904      	add	r1, sp, #16
 801b43a:	4640      	mov	r0, r8
 801b43c:	f000 f882 	bl	801b544 <_printf_i>
 801b440:	e7ea      	b.n	801b418 <_svfiprintf_r+0x1b0>
 801b442:	bf00      	nop
 801b444:	0801e218 	.word	0x0801e218
 801b448:	0801e21e 	.word	0x0801e21e
 801b44c:	0801e222 	.word	0x0801e222
 801b450:	00000000 	.word	0x00000000
 801b454:	0801b1b5 	.word	0x0801b1b5

0801b458 <_printf_common>:
 801b458:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801b45c:	4691      	mov	r9, r2
 801b45e:	461f      	mov	r7, r3
 801b460:	688a      	ldr	r2, [r1, #8]
 801b462:	690b      	ldr	r3, [r1, #16]
 801b464:	f8dd 8020 	ldr.w	r8, [sp, #32]
 801b468:	4293      	cmp	r3, r2
 801b46a:	bfb8      	it	lt
 801b46c:	4613      	movlt	r3, r2
 801b46e:	f8c9 3000 	str.w	r3, [r9]
 801b472:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 801b476:	4606      	mov	r6, r0
 801b478:	460c      	mov	r4, r1
 801b47a:	b112      	cbz	r2, 801b482 <_printf_common+0x2a>
 801b47c:	3301      	adds	r3, #1
 801b47e:	f8c9 3000 	str.w	r3, [r9]
 801b482:	6823      	ldr	r3, [r4, #0]
 801b484:	0699      	lsls	r1, r3, #26
 801b486:	bf42      	ittt	mi
 801b488:	f8d9 3000 	ldrmi.w	r3, [r9]
 801b48c:	3302      	addmi	r3, #2
 801b48e:	f8c9 3000 	strmi.w	r3, [r9]
 801b492:	6825      	ldr	r5, [r4, #0]
 801b494:	f015 0506 	ands.w	r5, r5, #6
 801b498:	d107      	bne.n	801b4aa <_printf_common+0x52>
 801b49a:	f104 0a19 	add.w	sl, r4, #25
 801b49e:	68e3      	ldr	r3, [r4, #12]
 801b4a0:	f8d9 2000 	ldr.w	r2, [r9]
 801b4a4:	1a9b      	subs	r3, r3, r2
 801b4a6:	42ab      	cmp	r3, r5
 801b4a8:	dc28      	bgt.n	801b4fc <_printf_common+0xa4>
 801b4aa:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 801b4ae:	6822      	ldr	r2, [r4, #0]
 801b4b0:	3300      	adds	r3, #0
 801b4b2:	bf18      	it	ne
 801b4b4:	2301      	movne	r3, #1
 801b4b6:	0692      	lsls	r2, r2, #26
 801b4b8:	d42d      	bmi.n	801b516 <_printf_common+0xbe>
 801b4ba:	f104 0243 	add.w	r2, r4, #67	; 0x43
 801b4be:	4639      	mov	r1, r7
 801b4c0:	4630      	mov	r0, r6
 801b4c2:	47c0      	blx	r8
 801b4c4:	3001      	adds	r0, #1
 801b4c6:	d020      	beq.n	801b50a <_printf_common+0xb2>
 801b4c8:	6823      	ldr	r3, [r4, #0]
 801b4ca:	68e5      	ldr	r5, [r4, #12]
 801b4cc:	f8d9 2000 	ldr.w	r2, [r9]
 801b4d0:	f003 0306 	and.w	r3, r3, #6
 801b4d4:	2b04      	cmp	r3, #4
 801b4d6:	bf08      	it	eq
 801b4d8:	1aad      	subeq	r5, r5, r2
 801b4da:	68a3      	ldr	r3, [r4, #8]
 801b4dc:	6922      	ldr	r2, [r4, #16]
 801b4de:	bf0c      	ite	eq
 801b4e0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801b4e4:	2500      	movne	r5, #0
 801b4e6:	4293      	cmp	r3, r2
 801b4e8:	bfc4      	itt	gt
 801b4ea:	1a9b      	subgt	r3, r3, r2
 801b4ec:	18ed      	addgt	r5, r5, r3
 801b4ee:	f04f 0900 	mov.w	r9, #0
 801b4f2:	341a      	adds	r4, #26
 801b4f4:	454d      	cmp	r5, r9
 801b4f6:	d11a      	bne.n	801b52e <_printf_common+0xd6>
 801b4f8:	2000      	movs	r0, #0
 801b4fa:	e008      	b.n	801b50e <_printf_common+0xb6>
 801b4fc:	2301      	movs	r3, #1
 801b4fe:	4652      	mov	r2, sl
 801b500:	4639      	mov	r1, r7
 801b502:	4630      	mov	r0, r6
 801b504:	47c0      	blx	r8
 801b506:	3001      	adds	r0, #1
 801b508:	d103      	bne.n	801b512 <_printf_common+0xba>
 801b50a:	f04f 30ff 	mov.w	r0, #4294967295
 801b50e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801b512:	3501      	adds	r5, #1
 801b514:	e7c3      	b.n	801b49e <_printf_common+0x46>
 801b516:	18e1      	adds	r1, r4, r3
 801b518:	1c5a      	adds	r2, r3, #1
 801b51a:	2030      	movs	r0, #48	; 0x30
 801b51c:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801b520:	4422      	add	r2, r4
 801b522:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 801b526:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 801b52a:	3302      	adds	r3, #2
 801b52c:	e7c5      	b.n	801b4ba <_printf_common+0x62>
 801b52e:	2301      	movs	r3, #1
 801b530:	4622      	mov	r2, r4
 801b532:	4639      	mov	r1, r7
 801b534:	4630      	mov	r0, r6
 801b536:	47c0      	blx	r8
 801b538:	3001      	adds	r0, #1
 801b53a:	d0e6      	beq.n	801b50a <_printf_common+0xb2>
 801b53c:	f109 0901 	add.w	r9, r9, #1
 801b540:	e7d8      	b.n	801b4f4 <_printf_common+0x9c>
	...

0801b544 <_printf_i>:
 801b544:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801b548:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 801b54c:	460c      	mov	r4, r1
 801b54e:	7e09      	ldrb	r1, [r1, #24]
 801b550:	b085      	sub	sp, #20
 801b552:	296e      	cmp	r1, #110	; 0x6e
 801b554:	4617      	mov	r7, r2
 801b556:	4606      	mov	r6, r0
 801b558:	4698      	mov	r8, r3
 801b55a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801b55c:	f000 80b3 	beq.w	801b6c6 <_printf_i+0x182>
 801b560:	d822      	bhi.n	801b5a8 <_printf_i+0x64>
 801b562:	2963      	cmp	r1, #99	; 0x63
 801b564:	d036      	beq.n	801b5d4 <_printf_i+0x90>
 801b566:	d80a      	bhi.n	801b57e <_printf_i+0x3a>
 801b568:	2900      	cmp	r1, #0
 801b56a:	f000 80b9 	beq.w	801b6e0 <_printf_i+0x19c>
 801b56e:	2958      	cmp	r1, #88	; 0x58
 801b570:	f000 8083 	beq.w	801b67a <_printf_i+0x136>
 801b574:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801b578:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 801b57c:	e032      	b.n	801b5e4 <_printf_i+0xa0>
 801b57e:	2964      	cmp	r1, #100	; 0x64
 801b580:	d001      	beq.n	801b586 <_printf_i+0x42>
 801b582:	2969      	cmp	r1, #105	; 0x69
 801b584:	d1f6      	bne.n	801b574 <_printf_i+0x30>
 801b586:	6820      	ldr	r0, [r4, #0]
 801b588:	6813      	ldr	r3, [r2, #0]
 801b58a:	0605      	lsls	r5, r0, #24
 801b58c:	f103 0104 	add.w	r1, r3, #4
 801b590:	d52a      	bpl.n	801b5e8 <_printf_i+0xa4>
 801b592:	681b      	ldr	r3, [r3, #0]
 801b594:	6011      	str	r1, [r2, #0]
 801b596:	2b00      	cmp	r3, #0
 801b598:	da03      	bge.n	801b5a2 <_printf_i+0x5e>
 801b59a:	222d      	movs	r2, #45	; 0x2d
 801b59c:	425b      	negs	r3, r3
 801b59e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 801b5a2:	486f      	ldr	r0, [pc, #444]	; (801b760 <_printf_i+0x21c>)
 801b5a4:	220a      	movs	r2, #10
 801b5a6:	e039      	b.n	801b61c <_printf_i+0xd8>
 801b5a8:	2973      	cmp	r1, #115	; 0x73
 801b5aa:	f000 809d 	beq.w	801b6e8 <_printf_i+0x1a4>
 801b5ae:	d808      	bhi.n	801b5c2 <_printf_i+0x7e>
 801b5b0:	296f      	cmp	r1, #111	; 0x6f
 801b5b2:	d020      	beq.n	801b5f6 <_printf_i+0xb2>
 801b5b4:	2970      	cmp	r1, #112	; 0x70
 801b5b6:	d1dd      	bne.n	801b574 <_printf_i+0x30>
 801b5b8:	6823      	ldr	r3, [r4, #0]
 801b5ba:	f043 0320 	orr.w	r3, r3, #32
 801b5be:	6023      	str	r3, [r4, #0]
 801b5c0:	e003      	b.n	801b5ca <_printf_i+0x86>
 801b5c2:	2975      	cmp	r1, #117	; 0x75
 801b5c4:	d017      	beq.n	801b5f6 <_printf_i+0xb2>
 801b5c6:	2978      	cmp	r1, #120	; 0x78
 801b5c8:	d1d4      	bne.n	801b574 <_printf_i+0x30>
 801b5ca:	2378      	movs	r3, #120	; 0x78
 801b5cc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801b5d0:	4864      	ldr	r0, [pc, #400]	; (801b764 <_printf_i+0x220>)
 801b5d2:	e055      	b.n	801b680 <_printf_i+0x13c>
 801b5d4:	6813      	ldr	r3, [r2, #0]
 801b5d6:	1d19      	adds	r1, r3, #4
 801b5d8:	681b      	ldr	r3, [r3, #0]
 801b5da:	6011      	str	r1, [r2, #0]
 801b5dc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801b5e0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801b5e4:	2301      	movs	r3, #1
 801b5e6:	e08c      	b.n	801b702 <_printf_i+0x1be>
 801b5e8:	681b      	ldr	r3, [r3, #0]
 801b5ea:	6011      	str	r1, [r2, #0]
 801b5ec:	f010 0f40 	tst.w	r0, #64	; 0x40
 801b5f0:	bf18      	it	ne
 801b5f2:	b21b      	sxthne	r3, r3
 801b5f4:	e7cf      	b.n	801b596 <_printf_i+0x52>
 801b5f6:	6813      	ldr	r3, [r2, #0]
 801b5f8:	6825      	ldr	r5, [r4, #0]
 801b5fa:	1d18      	adds	r0, r3, #4
 801b5fc:	6010      	str	r0, [r2, #0]
 801b5fe:	0628      	lsls	r0, r5, #24
 801b600:	d501      	bpl.n	801b606 <_printf_i+0xc2>
 801b602:	681b      	ldr	r3, [r3, #0]
 801b604:	e002      	b.n	801b60c <_printf_i+0xc8>
 801b606:	0668      	lsls	r0, r5, #25
 801b608:	d5fb      	bpl.n	801b602 <_printf_i+0xbe>
 801b60a:	881b      	ldrh	r3, [r3, #0]
 801b60c:	4854      	ldr	r0, [pc, #336]	; (801b760 <_printf_i+0x21c>)
 801b60e:	296f      	cmp	r1, #111	; 0x6f
 801b610:	bf14      	ite	ne
 801b612:	220a      	movne	r2, #10
 801b614:	2208      	moveq	r2, #8
 801b616:	2100      	movs	r1, #0
 801b618:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801b61c:	6865      	ldr	r5, [r4, #4]
 801b61e:	60a5      	str	r5, [r4, #8]
 801b620:	2d00      	cmp	r5, #0
 801b622:	f2c0 8095 	blt.w	801b750 <_printf_i+0x20c>
 801b626:	6821      	ldr	r1, [r4, #0]
 801b628:	f021 0104 	bic.w	r1, r1, #4
 801b62c:	6021      	str	r1, [r4, #0]
 801b62e:	2b00      	cmp	r3, #0
 801b630:	d13d      	bne.n	801b6ae <_printf_i+0x16a>
 801b632:	2d00      	cmp	r5, #0
 801b634:	f040 808e 	bne.w	801b754 <_printf_i+0x210>
 801b638:	4665      	mov	r5, ip
 801b63a:	2a08      	cmp	r2, #8
 801b63c:	d10b      	bne.n	801b656 <_printf_i+0x112>
 801b63e:	6823      	ldr	r3, [r4, #0]
 801b640:	07db      	lsls	r3, r3, #31
 801b642:	d508      	bpl.n	801b656 <_printf_i+0x112>
 801b644:	6923      	ldr	r3, [r4, #16]
 801b646:	6862      	ldr	r2, [r4, #4]
 801b648:	429a      	cmp	r2, r3
 801b64a:	bfde      	ittt	le
 801b64c:	2330      	movle	r3, #48	; 0x30
 801b64e:	f805 3c01 	strble.w	r3, [r5, #-1]
 801b652:	f105 35ff 	addle.w	r5, r5, #4294967295
 801b656:	ebac 0305 	sub.w	r3, ip, r5
 801b65a:	6123      	str	r3, [r4, #16]
 801b65c:	f8cd 8000 	str.w	r8, [sp]
 801b660:	463b      	mov	r3, r7
 801b662:	aa03      	add	r2, sp, #12
 801b664:	4621      	mov	r1, r4
 801b666:	4630      	mov	r0, r6
 801b668:	f7ff fef6 	bl	801b458 <_printf_common>
 801b66c:	3001      	adds	r0, #1
 801b66e:	d14d      	bne.n	801b70c <_printf_i+0x1c8>
 801b670:	f04f 30ff 	mov.w	r0, #4294967295
 801b674:	b005      	add	sp, #20
 801b676:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801b67a:	4839      	ldr	r0, [pc, #228]	; (801b760 <_printf_i+0x21c>)
 801b67c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 801b680:	6813      	ldr	r3, [r2, #0]
 801b682:	6821      	ldr	r1, [r4, #0]
 801b684:	1d1d      	adds	r5, r3, #4
 801b686:	681b      	ldr	r3, [r3, #0]
 801b688:	6015      	str	r5, [r2, #0]
 801b68a:	060a      	lsls	r2, r1, #24
 801b68c:	d50b      	bpl.n	801b6a6 <_printf_i+0x162>
 801b68e:	07ca      	lsls	r2, r1, #31
 801b690:	bf44      	itt	mi
 801b692:	f041 0120 	orrmi.w	r1, r1, #32
 801b696:	6021      	strmi	r1, [r4, #0]
 801b698:	b91b      	cbnz	r3, 801b6a2 <_printf_i+0x15e>
 801b69a:	6822      	ldr	r2, [r4, #0]
 801b69c:	f022 0220 	bic.w	r2, r2, #32
 801b6a0:	6022      	str	r2, [r4, #0]
 801b6a2:	2210      	movs	r2, #16
 801b6a4:	e7b7      	b.n	801b616 <_printf_i+0xd2>
 801b6a6:	064d      	lsls	r5, r1, #25
 801b6a8:	bf48      	it	mi
 801b6aa:	b29b      	uxthmi	r3, r3
 801b6ac:	e7ef      	b.n	801b68e <_printf_i+0x14a>
 801b6ae:	4665      	mov	r5, ip
 801b6b0:	fbb3 f1f2 	udiv	r1, r3, r2
 801b6b4:	fb02 3311 	mls	r3, r2, r1, r3
 801b6b8:	5cc3      	ldrb	r3, [r0, r3]
 801b6ba:	f805 3d01 	strb.w	r3, [r5, #-1]!
 801b6be:	460b      	mov	r3, r1
 801b6c0:	2900      	cmp	r1, #0
 801b6c2:	d1f5      	bne.n	801b6b0 <_printf_i+0x16c>
 801b6c4:	e7b9      	b.n	801b63a <_printf_i+0xf6>
 801b6c6:	6813      	ldr	r3, [r2, #0]
 801b6c8:	6825      	ldr	r5, [r4, #0]
 801b6ca:	6961      	ldr	r1, [r4, #20]
 801b6cc:	1d18      	adds	r0, r3, #4
 801b6ce:	6010      	str	r0, [r2, #0]
 801b6d0:	0628      	lsls	r0, r5, #24
 801b6d2:	681b      	ldr	r3, [r3, #0]
 801b6d4:	d501      	bpl.n	801b6da <_printf_i+0x196>
 801b6d6:	6019      	str	r1, [r3, #0]
 801b6d8:	e002      	b.n	801b6e0 <_printf_i+0x19c>
 801b6da:	066a      	lsls	r2, r5, #25
 801b6dc:	d5fb      	bpl.n	801b6d6 <_printf_i+0x192>
 801b6de:	8019      	strh	r1, [r3, #0]
 801b6e0:	2300      	movs	r3, #0
 801b6e2:	6123      	str	r3, [r4, #16]
 801b6e4:	4665      	mov	r5, ip
 801b6e6:	e7b9      	b.n	801b65c <_printf_i+0x118>
 801b6e8:	6813      	ldr	r3, [r2, #0]
 801b6ea:	1d19      	adds	r1, r3, #4
 801b6ec:	6011      	str	r1, [r2, #0]
 801b6ee:	681d      	ldr	r5, [r3, #0]
 801b6f0:	6862      	ldr	r2, [r4, #4]
 801b6f2:	2100      	movs	r1, #0
 801b6f4:	4628      	mov	r0, r5
 801b6f6:	f7e4 fd83 	bl	8000200 <memchr>
 801b6fa:	b108      	cbz	r0, 801b700 <_printf_i+0x1bc>
 801b6fc:	1b40      	subs	r0, r0, r5
 801b6fe:	6060      	str	r0, [r4, #4]
 801b700:	6863      	ldr	r3, [r4, #4]
 801b702:	6123      	str	r3, [r4, #16]
 801b704:	2300      	movs	r3, #0
 801b706:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801b70a:	e7a7      	b.n	801b65c <_printf_i+0x118>
 801b70c:	6923      	ldr	r3, [r4, #16]
 801b70e:	462a      	mov	r2, r5
 801b710:	4639      	mov	r1, r7
 801b712:	4630      	mov	r0, r6
 801b714:	47c0      	blx	r8
 801b716:	3001      	adds	r0, #1
 801b718:	d0aa      	beq.n	801b670 <_printf_i+0x12c>
 801b71a:	6823      	ldr	r3, [r4, #0]
 801b71c:	079b      	lsls	r3, r3, #30
 801b71e:	d413      	bmi.n	801b748 <_printf_i+0x204>
 801b720:	68e0      	ldr	r0, [r4, #12]
 801b722:	9b03      	ldr	r3, [sp, #12]
 801b724:	4298      	cmp	r0, r3
 801b726:	bfb8      	it	lt
 801b728:	4618      	movlt	r0, r3
 801b72a:	e7a3      	b.n	801b674 <_printf_i+0x130>
 801b72c:	2301      	movs	r3, #1
 801b72e:	464a      	mov	r2, r9
 801b730:	4639      	mov	r1, r7
 801b732:	4630      	mov	r0, r6
 801b734:	47c0      	blx	r8
 801b736:	3001      	adds	r0, #1
 801b738:	d09a      	beq.n	801b670 <_printf_i+0x12c>
 801b73a:	3501      	adds	r5, #1
 801b73c:	68e3      	ldr	r3, [r4, #12]
 801b73e:	9a03      	ldr	r2, [sp, #12]
 801b740:	1a9b      	subs	r3, r3, r2
 801b742:	42ab      	cmp	r3, r5
 801b744:	dcf2      	bgt.n	801b72c <_printf_i+0x1e8>
 801b746:	e7eb      	b.n	801b720 <_printf_i+0x1dc>
 801b748:	2500      	movs	r5, #0
 801b74a:	f104 0919 	add.w	r9, r4, #25
 801b74e:	e7f5      	b.n	801b73c <_printf_i+0x1f8>
 801b750:	2b00      	cmp	r3, #0
 801b752:	d1ac      	bne.n	801b6ae <_printf_i+0x16a>
 801b754:	7803      	ldrb	r3, [r0, #0]
 801b756:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 801b75a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801b75e:	e76c      	b.n	801b63a <_printf_i+0xf6>
 801b760:	0801e229 	.word	0x0801e229
 801b764:	0801e23a 	.word	0x0801e23a

0801b768 <_realloc_r>:
 801b768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b76a:	4607      	mov	r7, r0
 801b76c:	4614      	mov	r4, r2
 801b76e:	460e      	mov	r6, r1
 801b770:	b921      	cbnz	r1, 801b77c <_realloc_r+0x14>
 801b772:	4611      	mov	r1, r2
 801b774:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 801b778:	f7ff bc90 	b.w	801b09c <_malloc_r>
 801b77c:	b922      	cbnz	r2, 801b788 <_realloc_r+0x20>
 801b77e:	f7ff fc3f 	bl	801b000 <_free_r>
 801b782:	4625      	mov	r5, r4
 801b784:	4628      	mov	r0, r5
 801b786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801b788:	f000 f814 	bl	801b7b4 <_malloc_usable_size_r>
 801b78c:	42a0      	cmp	r0, r4
 801b78e:	d20f      	bcs.n	801b7b0 <_realloc_r+0x48>
 801b790:	4621      	mov	r1, r4
 801b792:	4638      	mov	r0, r7
 801b794:	f7ff fc82 	bl	801b09c <_malloc_r>
 801b798:	4605      	mov	r5, r0
 801b79a:	2800      	cmp	r0, #0
 801b79c:	d0f2      	beq.n	801b784 <_realloc_r+0x1c>
 801b79e:	4631      	mov	r1, r6
 801b7a0:	4622      	mov	r2, r4
 801b7a2:	f7ff fc00 	bl	801afa6 <memcpy>
 801b7a6:	4631      	mov	r1, r6
 801b7a8:	4638      	mov	r0, r7
 801b7aa:	f7ff fc29 	bl	801b000 <_free_r>
 801b7ae:	e7e9      	b.n	801b784 <_realloc_r+0x1c>
 801b7b0:	4635      	mov	r5, r6
 801b7b2:	e7e7      	b.n	801b784 <_realloc_r+0x1c>

0801b7b4 <_malloc_usable_size_r>:
 801b7b4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801b7b8:	1f18      	subs	r0, r3, #4
 801b7ba:	2b00      	cmp	r3, #0
 801b7bc:	bfbc      	itt	lt
 801b7be:	580b      	ldrlt	r3, [r1, r0]
 801b7c0:	18c0      	addlt	r0, r0, r3
 801b7c2:	4770      	bx	lr

0801b7c4 <_sbrk>:
 801b7c4:	4b04      	ldr	r3, [pc, #16]	; (801b7d8 <_sbrk+0x14>)
 801b7c6:	6819      	ldr	r1, [r3, #0]
 801b7c8:	4602      	mov	r2, r0
 801b7ca:	b909      	cbnz	r1, 801b7d0 <_sbrk+0xc>
 801b7cc:	4903      	ldr	r1, [pc, #12]	; (801b7dc <_sbrk+0x18>)
 801b7ce:	6019      	str	r1, [r3, #0]
 801b7d0:	6818      	ldr	r0, [r3, #0]
 801b7d2:	4402      	add	r2, r0
 801b7d4:	601a      	str	r2, [r3, #0]
 801b7d6:	4770      	bx	lr
 801b7d8:	2000049c 	.word	0x2000049c
 801b7dc:	2000da60 	.word	0x2000da60

0801b7e0 <_exit>:
 801b7e0:	e7fe      	b.n	801b7e0 <_exit>
	...

0801b7e4 <_init>:
 801b7e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b7e6:	bf00      	nop
 801b7e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801b7ea:	bc08      	pop	{r3}
 801b7ec:	469e      	mov	lr, r3
 801b7ee:	4770      	bx	lr

0801b7f0 <_fini>:
 801b7f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b7f2:	bf00      	nop
 801b7f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801b7f6:	bc08      	pop	{r3}
 801b7f8:	469e      	mov	lr, r3
 801b7fa:	4770      	bx	lr
